[2024-01-09 17:17:30 INFO] **[Preprocessing]**

**ChatDev Starts** (20240901171730)

**Timestamp**: 20240901171730

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './../interfaces/IJBController.sol';
import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol';
import './../libraries/JBConstants.sol';
import './../libraries/JBCurrencies.sol';
import './../libraries/JBFixedPointNumber.sol';
import './../libraries/JBFundingCycleMetadataResolver.sol';
import './../libraries/JBOperations.sol';
import './../libraries/JBSplitsGroups.sol';
import './../libraries/JBTokens.sol';
import './../structs/JBTokenAmount.sol';
import './JBOperatable.sol';
import './JBSingleTokenPaymentTerminal.sol';

/**
  @notice
  Generic terminal managing all inflows and outflows of funds into the protocol ecosystem.

  @dev
  A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time.

  @dev
  Adheres to -
  IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.
  JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
abstract contract JBPayoutRedemptionPaymentTerminal is
  IJBPayoutRedemptionPaymentTerminal,
  JBSingleTokenPaymentTerminal,
  JBOperatable,
  Ownable,
  ReentrancyGuard
{
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error FEE_TOO_HIGH();
  error INADEQUATE_DISTRIBUTION_AMOUNT();
  error INADEQUATE_RECLAIM_AMOUNT();
  error INADEQUATE_TOKEN_COUNT();
  error NO_MSG_VALUE_ALLOWED();
  error PAY_TO_ZERO_ADDRESS();
  error PROJECT_TERMINAL_MISMATCH();
  error REDEEM_TO_ZERO_ADDRESS();
  error TERMINAL_IN_SPLIT_ZERO_ADDRESS();
  error TERMINAL_TOKENS_INCOMPATIBLE();

  //*********************************************************************//
  // ---------------------------- modifiers ---------------------------- //
  //*********************************************************************//

  /** 
    @notice 
    A modifier that verifies this terminal is a terminal of provided project ID.
  */
  modifier isTerminalOf(uint256 _projectId) {
    if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();
    _;
  }

  //*********************************************************************//
  // --------------------- internal stored constants ------------------- //
  //*********************************************************************//

  /**
    @notice
    Maximum fee that can be set for a funding cycle configuration.

    @dev
    Out of MAX_FEE (50_000_000 / 1_000_000_000).
  */
  uint256 internal constant _FEE_CAP = 50_000_000;

  /**
    @notice
    The protocol project ID is 1, as it should be the first project launched during the deployment process.
  */
  uint256 internal constant _PROTOCOL_PROJECT_ID = 1;

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    Fees that are being held to be processed later.

    _projectId The ID of the project for which fees are being held.
  */
  mapping(uint256 => JBFee[]) internal _heldFeesOf;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership and transfers.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  /**
    @notice
    The contract that stores and manages the terminal's data.
  */
  IJBSingleTokenPaymentTerminalStore public immutable override store;

  /**
    @notice
    The currency to base token issuance on.

    @dev
    If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.
  */
  uint256 public immutable override baseWeightCurrency;

  /**
    @notice
    The group that payout splits coming from this terminal are identified by.
  */
  uint256 public immutable override payoutSplitsGroup;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The platform fee percent.

    @dev
    Out of MAX_FEE (25_000_000 / 1_000_000_000)
  */
  uint256 public override fee = 25_000_000; // 2.5%

  /**
    @notice
    The data source that returns a discount to apply to a project's fee.
  */
  IJBFeeGauge public override feeGauge;

  /**
    @notice
    Addresses that can be paid towards from this terminal without incurring a fee.

    _address The address that can be paid toward.
  */
  mapping(address => bool) public override isFeelessAddress;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.

    @dev
    The current overflow is represented as a fixed point number with 18 decimals.

    @param _projectId The ID of the project to get overflow for.

    @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.
  */
  function currentEthOverflowOf(uint256 _projectId)
    external
    view
    virtual
    override
    returns (uint256)
  {
    // Get this terminal's current overflow.
    uint256 _overflow = store.currentOverflowOf(this, _projectId);

    // Adjust the decimals of the fixed point number if needed to have 18 decimals.
    uint256 _adjustedOverflow = (decimals == 18)
      ? _overflow
      : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);

    // Return the amount converted to ETH.
    return
      (currency == JBCurrencies.ETH)
        ? _adjustedOverflow
        : PRBMath.mulDiv(
          _adjustedOverflow,
          10**decimals,
          prices.priceFor(currency, JBCurrencies.ETH, decimals)
        );
  }

  /**
    @notice
    The fees that are currently being held to be processed later for each project.

    @param _projectId The ID of the project for which fees are being held.

    @return An array of fees that are being held.
  */
  function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {
    return _heldFeesOf[_projectId];
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(JBSingleTokenPaymentTerminal, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||
      _interfaceId == type(IJBPayoutTerminal).interfaceId ||
      _interfaceId == type(IJBAllowanceTerminal).interfaceId ||
      _interfaceId == type(IJBRedemptionTerminal).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _token The token that this terminal manages.
    @param _decimals The number of decimals the token fixed point amounts are expected to have.
    @param _currency The currency that this terminal's token adheres to for price feeds.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _splitsStore A contract that stores splits for each project.
    @param _prices A contract that exposes price feeds.
    @param _store A contract that stores the terminal's data.
    @param _owner The address that will own this contract.
  */
  constructor(
    // payable constructor save the gas used to check msg.value==0
    address _token,
    uint256 _decimals,
    uint256 _currency,
    uint256 _baseWeightCurrency,
    uint256 _payoutSplitsGroup,
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBSplitsStore _splitsStore,
    IJBPrices _prices,
    IJBSingleTokenPaymentTerminalStore _store,
    address _owner
  )
    payable
    JBSingleTokenPaymentTerminal(_token, _decimals, _currency)
    JBOperatable(_operatorStore)
  {
    baseWeightCurrency = _baseWeightCurrency;
    payoutSplitsGroup = _payoutSplitsGroup;
    projects = _projects;
    directory = _directory;
    splitsStore = _splitsStore;
    prices = _prices;
    store = _store;

    transferOwnership(_owner);
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Contribute tokens to a project.

    @param _projectId The ID of the project being paid.
    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _token The token being paid. This terminal ignores this property since it only manages one token. 
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function pay(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {
    _token; // Prevents unused var compiler and natspec complaints.

    // ETH shouldn't be sent if this terminal's token isn't ETH.
    if (token != JBTokens.ETH) {
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If this terminal's token is ETH, override _amount with msg.value.
    else _amount = msg.value;

    return
      _pay(
        _amount,
        msg.sender,
        _projectId,
        _beneficiary,
        _minReturnedTokens,
        _preferClaimedTokens,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _token The token being reclaimed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  )
    external
    virtual
    override
    requirePermission(_holder, _projectId, JBOperations.REDEEM)
    returns (uint256 reclaimAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return
      _redeemTokensOf(
        _holder,
        _projectId,
        _tokenCount,
        _minReturnedTokens,
        _beneficiary,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) external virtual override returns (uint256 netLeftoverDistributionAmount) {
    _token; // Prevents unused var compiler and natspec complaints.

    return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)
    returns (uint256 netDistributedAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);
  }

  /**
    @notice
    Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project being migrated.
    @param _to The terminal contract that will gain the project's funds.

    @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.
  */
  function migrate(uint256 _projectId, IJBPaymentTerminal _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)
    returns (uint256 balance)
  {
    // The terminal being migrated to must accept the same token as this terminal.
    if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE();

    // Record the migration in the store.
    balance = store.recordMigration(_projectId);

    // Transfer the balance if needed.
    if (balance > 0) {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_to), balance);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? balance : 0;

      // Withdraw the balance to transfer to the new terminal;
      _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes(''));
    }

    emit Migrate(_projectId, _to, balance, msg.sender);
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _token The token being paid. This terminal ignores this property since it only manages one currency. 
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) {
    _token; // Prevents unused var compiler and natspec complaints.

    // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender.
    if (token != JBTokens.ETH) {
      // Amount must be greater than 0.
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If the terminal's token is ETH, override `_amount` with msg.value.
    else _amount = msg.value;

    // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal.
    _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);
  }

  /**
    @notice
    Process any fees that are being held for the project.

    @dev
    Only a project owner, an operator, or the contract's owner can process held fees.

    @param _projectId The ID of the project whos held fees should be processed.
  */
  function processFees(uint256 _projectId)
    external
    virtual
    override
    requirePermissionAllowingOverride(
      projects.ownerOf(_projectId),
      _projectId,
      JBOperations.PROCESS_FEES,
      msg.sender == owner()
    )
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the held fees.
    delete _heldFeesOf[_projectId];

    // Push array length in stack
    uint256 _heldFeeLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeeLength; ) {
      // Get the fee amount.
      uint256 _amount = _feeAmount(
        _heldFees[_i].amount,
        _heldFees[_i].fee,
        _heldFees[_i].feeDiscount
      );

      // Process the fee.
      _processFee(_amount, _heldFees[_i].beneficiary);

      emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Allows the fee to be updated.

    @dev
    Only the owner of this contract can change the fee.

    @param _fee The new fee, out of MAX_FEE.
  */
  function setFee(uint256 _fee) external virtual override onlyOwner {
    // The provided fee must be within the max.
    if (_fee > _FEE_CAP) revert FEE_TOO_HIGH();

    // Store the new fee.
    fee = _fee;

    emit SetFee(_fee, msg.sender);
  }

  /**
    @notice
    Allows the fee gauge to be updated.

    @dev
    Only the owner of this contract can change the fee gauge.

    @dev
    If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.

    @param _feeGauge The new fee gauge.
  */
  function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {
    // Store the new fee gauge.
    feeGauge = _feeGauge;

    emit SetFeeGauge(_feeGauge, msg.sender);
  }

  /**
    @notice
    Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.

    @dev
    Only the owner of this contract can set addresses as feeless.

    @param _address The address that can be paid towards while still bypassing fees.
    @param _flag A flag indicating whether the terminal should be feeless or not.
  */
  function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {
    // Set the flag value.
    isFeelessAddress[_address] = _flag;

    emit SetFeelessAddress(_address, _flag, msg.sender);
  }

  //*********************************************************************//
  // ---------------------- internal transactions ---------------------- //
  //*********************************************************************//

  /** 
    @notice
    Transfers tokens.

    @param _from The address from which the transfer should originate.
    @param _to The address to which the transfer should go.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _transferFrom(
    address _from,
    address payable _to,
    uint256 _amount
  ) internal virtual;

  /** 
    @notice
    Logic to be triggered before transferring tokens from this terminal.

    @param _to The address to which the transfer is going.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _beforeTransferTo(address _to, uint256 _amount) internal virtual;

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function _redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 reclaimAmount) {
    // Can't send reclaimed funds to the zero address.
    if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the redemption is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` only used within scope.
    {
      IJBRedemptionDelegate _delegate;

      // Record the redemption.
      (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(
        _holder,
        _projectId,
        _tokenCount,
        _memo,
        _metadata
      );

      // The amount being reclaimed must be at least as much as was expected.
      if (reclaimAmount < _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();

      // Burn the project tokens.
      if (_tokenCount > 0)
        IJBController(directory.controllerOf(_projectId)).burnTokensOf(
          _holder,
          _projectId,
          _tokenCount,
          '',
          false
        );

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBRedemptionDelegate(address(0))) {
        JBDidRedeemData memory _data = JBDidRedeemData(
          _holder,
          _projectId,
          _fundingCycle.configuration,
          _tokenCount,
          JBTokenAmount(token, reclaimAmount, decimals, currency),
          _beneficiary,
          _memo,
          _metadata
        );
        _delegate.didRedeem(_data);
        emit DelegateDidRedeem(_delegate, _data, msg.sender);
      }
    }

    // Send the reclaimed funds to the beneficiary.
    if (reclaimAmount > 0) _transferFrom(address(this), _beneficiary, reclaimAmount);

    emit RedeemTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _holder,
      _beneficiary,
      _tokenCount,
      reclaimAmount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) internal returns (uint256 netLeftoverDistributionAmount) {
    // Record the distribution.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(
      _projectId,
      _amount,
      _currency
    );

    // The amount being distributed must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Get a reference to the project owner, which will receive tokens from paying the platform fee
    // and receive any extra distributable funds not allocated to payout splits.
    address payable _projectOwner = payable(projects.ownerOf(_projectId));

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the fee amount that was paid.
    uint256 _fee;

    // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope.
    {
      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // The amount distributed that is eligible for incurring fees.
      uint256 _feeEligibleDistributionAmount;

      // The amount leftover after distributing to the splits.
      uint256 _leftoverDistributionAmount;

      // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.
      // Also get a reference to the amount that was distributed to splits from which fees should be taken.
      (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        payoutSplitsGroup,
        _distributedAmount,
        _feeDiscount
      );

      // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.
      unchecked {
        _feeEligibleDistributionAmount += _leftoverDistributionAmount;
      }

      // Take the fee.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0
        ? 0
        : _takeFeeFrom(
          _projectId,
          _fundingCycle,
          _feeEligibleDistributionAmount,
          _projectOwner,
          _feeDiscount
        );

      // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.

      unchecked {
        netLeftoverDistributionAmount = _leftoverDistributionAmount == 0
          ? 0
          : _leftoverDistributionAmount -
            _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);
      }

      // Transfer any remaining balance to the project owner.
      if (netLeftoverDistributionAmount > 0)
        _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount);
    }

    emit DistributePayouts(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _projectOwner,
      _amount,
      _distributedAmount,
      _fee,
      netLeftoverDistributionAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function _useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  ) internal returns (uint256 netDistributedAmount) {
    // Record the use of the allowance.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(
      _projectId,
      _amount,
      _currency
    );

    // The amount being withdrawn must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope.
    {
      // Keep a reference to the fee amount that was paid.
      uint256 _fee;

      // Get a reference to the project owner, which will receive tokens from paying the platform fee.
      address _projectOwner = projects.ownerOf(_projectId);

      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // Take a fee from the `_distributedAmount`, if needed.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
        ? 0
        : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);

      unchecked {
        // The net amount is the withdrawn amount without the fee.
        netDistributedAmount = _distributedAmount - _fee;
      }

      // Transfer any remaining balance to the beneficiary.
      if (netDistributedAmount > 0)
        _transferFrom(address(this), _beneficiary, netDistributedAmount);
    }

    emit UseAllowance(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _beneficiary,
      _amount,
      _distributedAmount,
      netDistributedAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Pays out splits for a project's funding cycle configuration.

    @param _projectId The ID of the project for which payout splits are being distributed.
    @param _domain The domain of the splits to distribute the payout between.
    @param _group The group of the splits to distribute the payout between.
    @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return leftoverAmount If the leftover amount if the splits don't add up to 100%.
    @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.
  */
  function _distributeToPayoutSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount,
    uint256 _feeDiscount
  ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's payout splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    // Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; ) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _payoutAmount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // The payout amount substracting any applicable incurred fees.
      uint256 _netPayoutAmount;

      if (_payoutAmount > 0) {
        // Transfer tokens to the split.
        // If there's an allocator set, transfer to its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0))) {
          // If the split allocator is set as feeless, this distribution is not eligible for a fee.
          if (isFeelessAddress[address(_split.allocator)])
            _netPayoutAmount = _payoutAmount;
            // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.
          else {
            unchecked {
              _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                ? _payoutAmount
                : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
            }

            // This distribution is eligible for a fee since the funds are leaving the ecosystem.
            feeEligibleDistributionAmount += _payoutAmount;
          }

          // Trigger any inherited pre-transfer logic.
          _beforeTransferTo(address(_split.allocator), _netPayoutAmount);

          // If this terminal's token is ETH, send it in msg.value.
          uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

          // Create the data to send to the allocator.
          JBSplitAllocationData memory _data = JBSplitAllocationData(
            token,
            _netPayoutAmount,
            decimals,
            _projectId,
            _group,
            _split
          );

          // Trigger the allocator's `allocate` function.
          _split.allocator.allocate{value: _payableValue}(_data);

          // Otherwise, if a project is specified, make a payment to it.
        } else if (_split.projectId != 0) {
          // Get a reference to the Juicebox terminal being used.
          IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);

          // The project must have a terminal to send funds to.
          if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();

          // Save gas if this contract is being used as the terminal.
          if (_terminal == this) {
            // This distribution does not incur a fee.
            _netPayoutAmount = _payoutAmount;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);
            else
              _pay(
                _netPayoutAmount,
                address(this),
                _split.projectId,
                (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          } else {
            // If the terminal is set as feeless, this distribution is not eligible for a fee.
            if (isFeelessAddress[address(_terminal)])
              _netPayoutAmount = _payoutAmount;
              // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.
            else {
              unchecked {
                _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                  ? _payoutAmount
                  : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
              }

              feeEligibleDistributionAmount += _payoutAmount;
            }

            // Trigger any inherited pre-transfer logic.
            _beforeTransferTo(address(_terminal), _netPayoutAmount);

            // If this terminal's token is ETH, send it in msg.value.
            uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _terminal.addToBalanceOf{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                '',
                _projectMetadata
              );
            else
              _terminal.pay{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          }
        } else {
          unchecked {
            _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
              ? _payoutAmount
              : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
          }

          // This distribution is eligible for a fee since the funds are leaving the ecosystem.
          feeEligibleDistributionAmount += _payoutAmount;

          // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.
          _transferFrom(
            address(this),
            _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),
            _netPayoutAmount
          );
        }

        // Subtract from the amount to be sent to the beneficiary.
        unchecked {
          leftoverAmount = leftoverAmount - _payoutAmount;
        }
      }

      emit DistributeToPayoutSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _netPayoutAmount,
        msg.sender
      );

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID.

    @param _projectId The ID of the project having fees taken from.
    @param _fundingCycle The funding cycle during which the fee is being taken.
    @param _amount The amount of the fee to take, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platforms tokens for.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return feeAmount The amount of the fee taken.
  */
  function _takeFeeFrom(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _amount,
    address _beneficiary,
    uint256 _feeDiscount
  ) internal returns (uint256 feeAmount) {
    feeAmount = _feeAmount(_amount, fee, _feeDiscount);

    if (_fundingCycle.shouldHoldFees()) {
      // Store the held fee.
      _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));

      emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender);
    } else {
      // Process the fee.
      _processFee(feeAmount, _beneficiary); // Take the fee.

      emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender);
    }
  }

  /**
    @notice
    Process a fee of the specified amount.

    @param _amount The fee amount, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platform's tokens for.
  */
  function _processFee(uint256 _amount, address _beneficiary) internal {
    // Get the terminal for the protocol project.
    IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token);

    // When processing the admin fee, save gas if the admin is using this contract as its terminal.
    if (_terminal == this)
      _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call.
    else {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_terminal), _amount);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;

      // Send the payment.
      _terminal.pay{value: _payableValue}(
        _PROTOCOL_PROJECT_ID,
        _amount,
        token,
        _beneficiary,
        0,
        false,
        '',
        bytes('')
      ); // Use the external pay call of the correct terminal.
    }
  }

  /**
    @notice
    Contribute tokens to a project.

    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _payer The address making the payment.
    @param _projectId The ID of the project being paid.
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function _pay(
    uint256 _amount,
    address _payer,
    uint256 _projectId,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 beneficiaryTokenCount) {
    // Cant send tokens to the zero address.
    if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the payment is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope.
    {
      IJBPayDelegate _delegate;
      uint256 _tokenCount;

      // Bundle the amount info into a JBTokenAmount struct.
      JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);

      // Record the payment.
      (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(
        _payer,
        _bundledAmount,
        _projectId,
        baseWeightCurrency,
        _beneficiary,
        _memo,
        _metadata
      );

      // Mint the tokens if needed.
      if (_tokenCount > 0)
        // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.
        beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(
          _projectId,
          _tokenCount,
          _beneficiary,
          '',
          _preferClaimedTokens,
          true
        );

      // The token count for the beneficiary must be greater than or equal to the minimum expected.
      if (beneficiaryTokenCount < _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBPayDelegate(address(0))) {
        JBDidPayData memory _data = JBDidPayData(
          _payer,
          _projectId,
          _fundingCycle.configuration,
          _bundledAmount,
          beneficiaryTokenCount,
          _beneficiary,
          _preferClaimedTokens,
          _memo,
          _metadata
        );

        _delegate.didPay(_data);
        emit DelegateDidPay(_delegate, _data, msg.sender);
      }
    }

    emit Pay(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _payer,
      _beneficiary,
      _amount,
      beneficiaryTokenCount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function _addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    bool _shouldRefundHeldFees,
    string memory _memo,
    bytes memory _metadata
  ) internal {
    // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.
    uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0;

    // Record the added funds with any refunded fees.
    store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);

    emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);
  }

  /**
    @notice
    Refund fees based on the specified amount.

    @param _projectId The project for which fees are being refunded.
    @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.

    @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal
  */
  function _refundHeldFees(uint256 _projectId, uint256 _amount)
    internal
    returns (uint256 refundedFees)
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the current held fees.
    delete _heldFeesOf[_projectId];

    // Get a reference to the leftover amount once all fees have been settled.
    uint256 leftoverAmount = _amount;

    // Push length in stack
    uint256 _heldFeesLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeesLength; ) {
      if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);
      else if (leftoverAmount >= _heldFees[_i].amount) {
        unchecked {
          leftoverAmount = leftoverAmount - _heldFees[_i].amount;
          refundedFees += _feeAmount(
            _heldFees[_i].amount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount
          );
        }
      } else {
        _heldFeesOf[_projectId].push(
          JBFee(
            _heldFees[_i].amount - leftoverAmount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount,
            _heldFees[_i].beneficiary
          )
        );
        unchecked {
          refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);
        }
        leftoverAmount = 0;
      }

      unchecked {
        ++_i;
      }
    }

    emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);
  }

  /** 
    @notice 
    Returns the fee amount based on the provided amount for the specified project.

    @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal.
    @param _fee The percentage of the fee, out of MAX_FEE. 
    @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.

    @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _feeAmount(
    uint256 _amount,
    uint256 _fee,
    uint256 _feeDiscount
  ) internal pure returns (uint256) {
    // Calculate the discounted fee.
    uint256 _discountedFee = _fee -
      PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT);

    // The amount of tokens from the `_amount` to pay as a fee.
    return
      _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);
  }

  /** 
    @notice
    Get the fee discount from the fee gauge for the specified project.

    @param _projectId The ID of the project to get a fee discount for.
    
    @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.
  */
  function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {
    // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.
    if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))
      return JBConstants.MAX_FEE_DISCOUNT;

    // Get the fee discount.
    if (feeGauge == IJBFeeGauge(address(0)))
      feeDiscount = 0;
      // If the guage reverts, set the discount to 0.
    else
      try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {
        feeDiscount = discount;
      } catch {
        feeDiscount = 0;
      }

    // If the fee discount is greater than the max, nullify the discount.
    if (feeDiscount > JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;
  }
}


**project_name**: RealWorld_BA_143_JBPayoutRedemptionPaymentTerminal

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_143_JBPayoutRedemptionPaymentTerminal_RealWord_20240901171730.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-01-09 17:17:30 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/security/ReentrancyGuard.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './../interfaces/IJBController.sol'; import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol'; import './../libraries/JBConstants.sol'; import './../libraries/JBCurrencies.sol'; import './../libraries/JBFixedPointNumber.sol'; import './../libraries/JBFundingCycleMetadataResolver.sol'; import './../libraries/JBOperations.sol'; import './../libraries/JBSplitsGroups.sol'; import './../libraries/JBTokens.sol'; import './../structs/JBTokenAmount.sol'; import './JBOperatable.sol'; import './JBSingleTokenPaymentTerminal.sol'; /**   @notice   Generic terminal managing all inflows and outflows of funds into the protocol ecosystem. @dev   A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time. @dev   Adheres to -   IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules. @dev   Inherits from -   JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.   JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.   Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.   ReentrancyGuard: Contract module that helps prevent reentrant calls to a function. */ abstract contract JBPayoutRedemptionPaymentTerminal is   IJBPayoutRedemptionPaymentTerminal,   JBSingleTokenPaymentTerminal,   JBOperatable,   Ownable,   ReentrancyGuard {   // A library that parses the packed funding cycle metadata into a friendlier format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error FEE_TOO_HIGH();   error INADEQUATE_DISTRIBUTION_AMOUNT();   error INADEQUATE_RECLAIM_AMOUNT();   error INADEQUATE_TOKEN_COUNT();   error NO_MSG_VALUE_ALLOWED();   error PAY_TO_ZERO_ADDRESS();   error PROJECT_TERMINAL_MISMATCH();   error REDEEM_TO_ZERO_ADDRESS();   error TERMINAL_IN_SPLIT_ZERO_ADDRESS();   error TERMINAL_TOKENS_INCOMPATIBLE(); //***********//   // ---------------------------- modifiers ---------------------------- //   //*************// /*      @notice      A modifier that verifies this terminal is a terminal of provided project ID.   /   modifier isTerminalOf(uint256 projectId) {     if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();     ;   } //***********//   // --------------------- internal stored constants ------------------- //   //*************// /**     @notice     Maximum fee that can be set for a funding cycle configuration. @dev Out of MAX_FEE (50_000_000 / 1_000_000_000).  */   uint256 internal constant _FEE_CAP = 50_000_000; /*     @notice     The protocol project ID is 1, as it should be the first project launched during the deployment process.   /   uint256 internal constant _PROTOCOL_PROJECT_ID = 1; //***********//   // --------------------- internal stored properties ------------------ //   //*************// /**     @notice     Fees that are being held to be processed later. _projectId The ID of the project for which fees are being held.  */   mapping(uint256 =&gt; JBFee[]) internal _heldFeesOf; //***********//   // ---------------- public immutable stored properties --------------- //   //*************// /*     @notice     Mints ERC-721's that represent project ownership and transfers.   /   IJBProjects public immutable override projects; /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; /*     @notice     The contract that stores splits for each project.   /   IJBSplitsStore public immutable override splitsStore; /*     @notice     The contract that exposes price feeds.   /   IJBPrices public immutable override prices; /*     @notice     The contract that stores and manages the terminal's data.   /   IJBSingleTokenPaymentTerminalStore public immutable override store; /**     @notice     The currency to base token issuance on. @dev If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.  */   uint256 public immutable override baseWeightCurrency; /*     @notice     The group that payout splits coming from this terminal are identified by.   /   uint256 public immutable override payoutSplitsGroup; //***********//   // --------------------- public stored properties -------------------- //   //*************// /**     @notice     The platform fee percent. @dev Out of MAX_FEE (25_000_000 / 1_000_000_000)  */   uint256 public override fee = 25_000_000; // 2.5% /*     @notice     The data source that returns a discount to apply to a project's fee.   /   IJBFeeGauge public override feeGauge; /**     @notice     Addresses that can be paid towards from this terminal without incurring a fee. _address The address that can be paid toward.  */   mapping(address =&gt; bool) public override isFeelessAddress; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     Gets the current overflowed amount in this terminal for a specified project, in terms of ETH. @dev The current overflow is represented as a fixed point number with 18 decimals.  @param _projectId The ID of the project to get overflow for.  @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.  */   function currentEthOverflowOf(uint256 _projectId)     external     view     virtual     override     returns (uint256)   {     // Get this terminal's current overflow.     uint256 _overflow = store.currentOverflowOf(this, _projectId); // Adjust the decimals of the fixed point number if needed to have 18 decimals. uint256 _adjustedOverflow = (decimals == 18)   ? _overflow   : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);  // Return the amount converted to ETH. return   (currency == JBCurrencies.ETH)     ? _adjustedOverflow     : PRBMath.mulDiv(       _adjustedOverflow,       10**decimals,       prices.priceFor(currency, JBCurrencies.ETH, decimals)     );  } /**     @notice     The fees that are currently being held to be processed later for each project. @param _projectId The ID of the project for which fees are being held.  @return An array of fees that are being held.  */   function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {     return _heldFeesOf[_projectId];   } //***********//   // -------------------------- public views --------------------------- //   //*************// /**     @notice     Indicates if this contract adheres to the specified interface. @dev  See {IERC165-supportsInterface}.  @param _interfaceId The ID of the interface to check for adherance to.  */   function supportsInterface(bytes4 _interfaceId)     public     view     virtual     override(JBSingleTokenPaymentTerminal, IERC165)     returns (bool)   {     return       _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||       _interfaceId == type(IJBPayoutTerminal).interfaceId ||       _interfaceId == type(IJBAllowanceTerminal).interfaceId ||       _interfaceId == type(IJBRedemptionTerminal).interfaceId ||       _interfaceId == type(IJBOperatable).interfaceId ||       super.supportsInterface(_interfaceId);   } //***********//   // -------------------------- constructor ---------------------------- //   //*************// /*     @param _token The token that this terminal manages.     @param _decimals The number of decimals the token fixed point amounts are expected to have.     @param _currency The currency that this terminal's token adheres to for price feeds.     @param _baseWeightCurrency The currency to base token issuance on.     @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.     @param _operatorStore A contract storing operator assignments.     @param _projects A contract which mints ERC-721's that represent project ownership and transfers.     @param _directory A contract storing directories of terminals and controllers for each project.     @param _splitsStore A contract that stores splits for each project.     @param _prices A contract that exposes price feeds.     @param _store A contract that stores the terminal's data.     @param _owner The address that will own this contract.   /   constructor(     // payable constructor save the gas used to check msg.value==0     address _token,     uint256 _decimals,     uint256 _currency,     uint256 _baseWeightCurrency,     uint256 _payoutSplitsGroup,     IJBOperatorStore _operatorStore,     IJBProjects _projects,     IJBDirectory _directory,     IJBSplitsStore _splitsStore,     IJBPrices _prices,     IJBSingleTokenPaymentTerminalStore _store,     address _owner   )     payable     JBSingleTokenPaymentTerminal(_token, _decimals, _currency)     JBOperatable(_operatorStore)   {     baseWeightCurrency = _baseWeightCurrency;     payoutSplitsGroup = _payoutSplitsGroup;     projects = _projects;     directory = _directory;     splitsStore = _splitsStore;     prices = _prices;     store = _store; transferOwnership(_owner);  } //***********//   // ---------------------- external transactions ---------------------- //   //*************// /**     @notice     Contribute tokens to a project. @param _projectId The ID of the project being paid. @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place. @param _token The token being paid. This terminal ignores this property since it only manages one token.  @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate. @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal. @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas. @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.  */   function pay(     uint256 _projectId,     uint256 _amount,     address _token,     address _beneficiary,     uint256 _minReturnedTokens,     bool _preferClaimedTokens,     string calldata _memo,     bytes calldata _metadata   ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {     _token; // Prevents unused var compiler and natspec complaints. // ETH shouldn't be sent if this terminal's token isn't ETH. if (token != JBTokens.ETH) {   if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();    // Transfer tokens to this terminal from the msg sender.   _transferFrom(msg.sender, payable(address(this)), _amount); } // If this terminal's token is ETH, override _amount with msg.value. else _amount = msg.value;  return   _pay(     _amount,     msg.sender,     _projectId,     _beneficiary,     _minReturnedTokens,     _preferClaimedTokens,     _memo,     _metadata   );  } /**     @notice     Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source. @dev Only a token holder or a designated operator can redeem its tokens.  @param _holder The account to redeem tokens for. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _token The token being reclaimed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal. @param _beneficiary The address to send the terminal tokens to. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.  */   function redeemTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     address _token,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo,     bytes memory _metadata   )     external     virtual     override     requirePermission(_holder, _projectId, JBOperations.REDEEM)     returns (uint256 reclaimAmount)   {     _token; // Prevents unused var compiler and natspec complaints. return   _redeemTokensOf(     _holder,     _projectId,     _tokenCount,     _minReturnedTokens,     _beneficiary,     _memo,     _metadata   );  } /**     @notice     Distributes payouts for a project with the distribution limit of its current funding cycle. @dev Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.  @dev Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.  @dev All funds distributed outside of this contract or any feeless terminals incure the protocol fee.  @param _projectId The ID of the project having its payouts distributed. @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency. @param _token The token being distributed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal. @param _memo A memo to pass along to the emitted event.  @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.  */   function distributePayoutsOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     address _token,     uint256 _minReturnedTokens,     string calldata _memo   ) external virtual override returns (uint256 netLeftoverDistributionAmount) {     _token; // Prevents unused var compiler and natspec complaints. return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);  } /**     @notice     Allows a project to send funds from its overflow up to the preconfigured allowance. @dev Only a project's owner or a designated operator can use its allowance.  @dev Incurs the protocol fee.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency. @param _token The token being distributed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals. @param _beneficiary The address to send the funds to. @param _memo A memo to pass along to the emitted event.  @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.  */   function useAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     address _token,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)     returns (uint256 netDistributedAmount)   {     _token; // Prevents unused var compiler and natspec complaints. return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);  } /**     @notice     Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type. @dev Only a project's owner or a designated operator can migrate it.  @param _projectId The ID of the project being migrated. @param _to The terminal contract that will gain the project's funds.  @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.  */   function migrate(uint256 _projectId, IJBPaymentTerminal _to)     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)     returns (uint256 balance)   {     // The terminal being migrated to must accept the same token as this terminal.     if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE(); // Record the migration in the store. balance = store.recordMigration(_projectId);  // Transfer the balance if needed. if (balance &gt; 0) {   // Trigger any inherited pre-transfer logic.   _beforeTransferTo(address(_to), balance);    // If this terminal's token is ETH, send it in msg.value.   uint256 _payableValue = token == JBTokens.ETH ? balance : 0;    // Withdraw the balance to transfer to the new terminal;   _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes('')); }  emit Migrate(_projectId, _to, balance, msg.sender);  } /**     @notice     Receives funds belonging to the specified project. @param _projectId The ID of the project to which the funds received belong. @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead. @param _token The token being paid. This terminal ignores this property since it only manages one currency.  @param _memo A memo to pass along to the emitted event. @param _metadata Extra data to pass along to the emitted event.  */   function addToBalanceOf(     uint256 _projectId,     uint256 _amount,     address _token,     string calldata _memo,     bytes calldata _metadata   ) external payable virtual override isTerminalOf(_projectId) {     _token; // Prevents unused var compiler and natspec complaints. // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender. if (token != JBTokens.ETH) {   // Amount must be greater than 0.   if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();    // Transfer tokens to this terminal from the msg sender.   _transferFrom(msg.sender, payable(address(this)), _amount); } // If the terminal's token is ETH, override `_amount` with msg.value. else _amount = msg.value;  // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal. _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);  } /**     @notice     Process any fees that are being held for the project. @dev Only a project owner, an operator, or the contract's owner can process held fees.  @param _projectId The ID of the project whos held fees should be processed.  */   function processFees(uint256 _projectId)     external     virtual     override     requirePermissionAllowingOverride(       projects.ownerOf(_projectId),       _projectId,       JBOperations.PROCESS_FEES,       msg.sender == owner()     )   {     // Get a reference to the project's held fees.     JBFee[] memory _heldFees = _heldFeesOf[_projectId]; // Delete the held fees. delete _heldFeesOf[_projectId];  // Push array length in stack uint256 _heldFeeLength = _heldFees.length;  // Process each fee. for (uint256 _i = 0; _i &lt; _heldFeeLength; ) {   // Get the fee amount.   uint256 _amount = _feeAmount(     _heldFees[_i].amount,     _heldFees[_i].fee,     _heldFees[_i].feeDiscount   );    // Process the fee.   _processFee(_amount, _heldFees[_i].beneficiary);    emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);    unchecked {     ++_i;   } }  } /**     @notice     Allows the fee to be updated. @dev Only the owner of this contract can change the fee.  @param _fee The new fee, out of MAX_FEE.  */   function setFee(uint256 _fee) external virtual override onlyOwner {     // The provided fee must be within the max.     if (_fee &gt; _FEE_CAP) revert FEE_TOO_HIGH(); // Store the new fee. fee = _fee;  emit SetFee(_fee, msg.sender);  } /**     @notice     Allows the fee gauge to be updated. @dev Only the owner of this contract can change the fee gauge.  @dev If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.  @param _feeGauge The new fee gauge.  */   function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {     // Store the new fee gauge.     feeGauge = _feeGauge; emit SetFeeGauge(_feeGauge, msg.sender);  } /**     @notice     Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee. @dev Only the owner of this contract can set addresses as feeless.  @param _address The address that can be paid towards while still bypassing fees. @param _flag A flag indicating whether the terminal should be feeless or not.  */   function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {     // Set the flag value.     isFeelessAddress[_address] = _flag; emit SetFeelessAddress(_address, _flag, msg.sender);  } //***********//   // ---------------------- internal transactions ---------------------- //   //*************// /**      @notice     Transfers tokens. @param _from The address from which the transfer should originate. @param _to The address to which the transfer should go. @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.  */   function _transferFrom(     address _from,     address payable _to,     uint256 _amount   ) internal virtual; /**      @notice     Logic to be triggered before transferring tokens from this terminal. @param _to The address to which the transfer is going. @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.  */   function _beforeTransferTo(address _to, uint256 _amount) internal virtual; /**     @notice     Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source. @dev Only a token holder or a designated operator can redeem its tokens.  @param _holder The account to redeem tokens for. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal. @param _beneficiary The address to send the terminal tokens to. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.  */   function _redeemTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo,     bytes memory _metadata   ) internal returns (uint256 reclaimAmount) {     // Can't send reclaimed funds to the zero address.     if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS(); // Define variables that will be needed outside the scoped section below. // Keep a reference to the funding cycle during which the redemption is being made. JBFundingCycle memory _fundingCycle;  // Scoped section prevents stack too deep. `_delegate` only used within scope. {   IJBRedemptionDelegate _delegate;    // Record the redemption.   (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(     _holder,     _projectId,     _tokenCount,     _memo,     _metadata   );    // The amount being reclaimed must be at least as much as was expected.   if (reclaimAmount &lt; _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();    // Burn the project tokens.   if (_tokenCount &gt; 0)     IJBController(directory.controllerOf(_projectId)).burnTokensOf(       _holder,       _projectId,       _tokenCount,       '',       false     );    // If a delegate was returned by the data source, issue a callback to it.   if (_delegate != IJBRedemptionDelegate(address(0))) {     JBDidRedeemData memory _data = JBDidRedeemData(       _holder,       _projectId,       _fundingCycle.configuration,       _tokenCount,       JBTokenAmount(token, reclaimAmount, decimals, currency),       _beneficiary,       _memo,       _metadata     );     _delegate.didRedeem(_data);     emit DelegateDidRedeem(_delegate, _data, msg.sender);   } }  // Send the reclaimed funds to the beneficiary. if (reclaimAmount &gt; 0) _transferFrom(address(this), _beneficiary, reclaimAmount);  emit RedeemTokens(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _holder,   _beneficiary,   _tokenCount,   reclaimAmount,   _memo,   _metadata,   msg.sender );  } /**     @notice     Distributes payouts for a project with the distribution limit of its current funding cycle. @dev Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.  @dev Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.  @dev All funds distributed outside of this contract or any feeless terminals incure the protocol fee.  @param _projectId The ID of the project having its payouts distributed. @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency. @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal. @param _memo A memo to pass along to the emitted event.  @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.  */   function _distributePayoutsOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     uint256 _minReturnedTokens,     string calldata _memo   ) internal returns (uint256 netLeftoverDistributionAmount) {     // Record the distribution.     (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(       _projectId,       _amount,       _currency     ); // The amount being distributed must be at least as much as was expected. if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();  // Get a reference to the project owner, which will receive tokens from paying the platform fee // and receive any extra distributable funds not allocated to payout splits. address payable _projectOwner = payable(projects.ownerOf(_projectId));  // Define variables that will be needed outside the scoped section below. // Keep a reference to the fee amount that was paid. uint256 _fee;  // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope. {   // Get the amount of discount that should be applied to any fees taken.   // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.   uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]     ? JBConstants.MAX_FEE_DISCOUNT     : _currentFeeDiscount(_projectId);    // The amount distributed that is eligible for incurring fees.   uint256 _feeEligibleDistributionAmount;    // The amount leftover after distributing to the splits.   uint256 _leftoverDistributionAmount;    // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.   // Also get a reference to the amount that was distributed to splits from which fees should be taken.   (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(     _projectId,     _fundingCycle.configuration,     payoutSplitsGroup,     _distributedAmount,     _feeDiscount   );    // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.   unchecked {     _feeEligibleDistributionAmount += _leftoverDistributionAmount;   }    // Take the fee.   _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0     ? 0     : _takeFeeFrom(       _projectId,       _fundingCycle,       _feeEligibleDistributionAmount,       _projectOwner,       _feeDiscount     );    // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.    unchecked {     netLeftoverDistributionAmount = _leftoverDistributionAmount == 0       ? 0       : _leftoverDistributionAmount -         _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);   }    // Transfer any remaining balance to the project owner.   if (netLeftoverDistributionAmount &gt; 0)     _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount); }  emit DistributePayouts(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _projectOwner,   _amount,   _distributedAmount,   _fee,   netLeftoverDistributionAmount,   _memo,   msg.sender );  } /**     @notice     Allows a project to send funds from its overflow up to the preconfigured allowance. @dev Only a project's owner or a designated operator can use its allowance.  @dev Incurs the protocol fee.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency. @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals. @param _beneficiary The address to send the funds to. @param _memo A memo to pass along to the emitted event.  @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.  */   function _useAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo   ) internal returns (uint256 netDistributedAmount) {     // Record the use of the allowance.     (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(       _projectId,       _amount,       _currency     ); // The amount being withdrawn must be at least as much as was expected. if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();  // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope. {   // Keep a reference to the fee amount that was paid.   uint256 _fee;    // Get a reference to the project owner, which will receive tokens from paying the platform fee.   address _projectOwner = projects.ownerOf(_projectId);    // Get the amount of discount that should be applied to any fees taken.   // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.   uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]     ? JBConstants.MAX_FEE_DISCOUNT     : _currentFeeDiscount(_projectId);    // Take a fee from the `_distributedAmount`, if needed.   _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT     ? 0     : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);    unchecked {     // The net amount is the withdrawn amount without the fee.     netDistributedAmount = _distributedAmount - _fee;   }    // Transfer any remaining balance to the beneficiary.   if (netDistributedAmount &gt; 0)     _transferFrom(address(this), _beneficiary, netDistributedAmount); }  emit UseAllowance(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _beneficiary,   _amount,   _distributedAmount,   netDistributedAmount,   _memo,   msg.sender );  } /**     @notice     Pays out splits for a project's funding cycle configuration. @param _projectId The ID of the project for which payout splits are being distributed. @param _domain The domain of the splits to distribute the payout between. @param _group The group of the splits to distribute the payout between. @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal. @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.  @return leftoverAmount If the leftover amount if the splits don't add up to 100%. @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.  */   function _distributeToPayoutSplitsOf(     uint256 _projectId,     uint256 _domain,     uint256 _group,     uint256 _amount,     uint256 _feeDiscount   ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {     // Set the leftover amount to the initial amount.     leftoverAmount = _amount; // Get a reference to the project's payout splits. JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);  // Transfer between all splits. for (uint256 _i = 0; _i &lt; _splits.length; ) {   // Get a reference to the split being iterated on.   JBSplit memory _split = _splits[_i];    // The amount to send towards the split.   uint256 _payoutAmount = PRBMath.mulDiv(     _amount,     _split.percent,     JBConstants.SPLITS_TOTAL_PERCENT   );    // The payout amount substracting any applicable incurred fees.   uint256 _netPayoutAmount;    if (_payoutAmount &gt; 0) {     // Transfer tokens to the split.     // If there's an allocator set, transfer to its `allocate` function.     if (_split.allocator != IJBSplitAllocator(address(0))) {       // If the split allocator is set as feeless, this distribution is not eligible for a fee.       if (isFeelessAddress[address(_split.allocator)])         _netPayoutAmount = _payoutAmount;         // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.       else {         unchecked {           _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT             ? _payoutAmount             : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);         }          // This distribution is eligible for a fee since the funds are leaving the ecosystem.         feeEligibleDistributionAmount += _payoutAmount;       }        // Trigger any inherited pre-transfer logic.       _beforeTransferTo(address(_split.allocator), _netPayoutAmount);        // If this terminal's token is ETH, send it in msg.value.       uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;        // Create the data to send to the allocator.       JBSplitAllocationData memory _data = JBSplitAllocationData(         token,         _netPayoutAmount,         decimals,         _projectId,         _group,         _split       );        // Trigger the allocator's `allocate` function.       _split.allocator.allocate{value: _payableValue}(_data);        // Otherwise, if a project is specified, make a payment to it.     } else if (_split.projectId != 0) {       // Get a reference to the Juicebox terminal being used.       IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);        // The project must have a terminal to send funds to.       if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();        // Save gas if this contract is being used as the terminal.       if (_terminal == this) {         // This distribution does not incur a fee.         _netPayoutAmount = _payoutAmount;          // Send the projectId in the metadata.         bytes memory _projectMetadata = new bytes(32);         _projectMetadata = bytes(abi.encodePacked(_projectId));          // Add to balance if prefered.         if (_split.preferAddToBalance)           _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);         else           _pay(             _netPayoutAmount,             address(this),             _split.projectId,             (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,             0,             _split.preferClaimed,             '',             _projectMetadata           );       } else {         // If the terminal is set as feeless, this distribution is not eligible for a fee.         if (isFeelessAddress[address(_terminal)])           _netPayoutAmount = _payoutAmount;           // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.         else {           unchecked {             _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT               ? _payoutAmount               : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);           }            feeEligibleDistributionAmount += _payoutAmount;         }          // Trigger any inherited pre-transfer logic.         _beforeTransferTo(address(_terminal), _netPayoutAmount);          // If this terminal's token is ETH, send it in msg.value.         uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;          // Send the projectId in the metadata.         bytes memory _projectMetadata = new bytes(32);         _projectMetadata = bytes(abi.encodePacked(_projectId));          // Add to balance if prefered.         if (_split.preferAddToBalance)           _terminal.addToBalanceOf{value: _payableValue}(             _split.projectId,             _netPayoutAmount,             token,             '',             _projectMetadata           );         else           _terminal.pay{value: _payableValue}(             _split.projectId,             _netPayoutAmount,             token,             _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,             0,             _split.preferClaimed,             '',             _projectMetadata           );       }     } else {       unchecked {         _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT           ? _payoutAmount           : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);       }        // This distribution is eligible for a fee since the funds are leaving the ecosystem.       feeEligibleDistributionAmount += _payoutAmount;        // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.       _transferFrom(         address(this),         _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),         _netPayoutAmount       );     }      // Subtract from the amount to be sent to the beneficiary.     unchecked {       leftoverAmount = leftoverAmount - _payoutAmount;     }   }    emit DistributeToPayoutSplit(     _projectId,     _domain,     _group,     _split,     _netPayoutAmount,     msg.sender   );    unchecked {     ++_i;   } }  } /**     @notice     Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID. @param _projectId The ID of the project having fees taken from. @param _fundingCycle The funding cycle during which the fee is being taken. @param _amount The amount of the fee to take, as a floating point number with 18 decimals. @param _beneficiary The address to mint the platforms tokens for. @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.  @return feeAmount The amount of the fee taken.  */   function _takeFeeFrom(     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _amount,     address _beneficiary,     uint256 _feeDiscount   ) internal returns (uint256 feeAmount) {     feeAmount = _feeAmount(_amount, fee, _feeDiscount); if (_fundingCycle.shouldHoldFees()) {   // Store the held fee.   _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));    emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender); } else {   // Process the fee.   _processFee(feeAmount, _beneficiary); // Take the fee.    emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender); }  } /**     @notice     Process a fee of the specified amount. @param _amount The fee amount, as a floating point number with 18 decimals. @param _beneficiary The address to mint the platform's tokens for.  */   function _processFee(uint256 _amount, address _beneficiary) internal {     // Get the terminal for the protocol project.     IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token); // When processing the admin fee, save gas if the admin is using this contract as its terminal. if (_terminal == this)   _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call. else {   // Trigger any inherited pre-transfer logic.   _beforeTransferTo(address(_terminal), _amount);    // If this terminal's token is ETH, send it in msg.value.   uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;    // Send the payment.   _terminal.pay{value: _payableValue}(     _PROTOCOL_PROJECT_ID,     _amount,     token,     _beneficiary,     0,     false,     '',     bytes('')   ); // Use the external pay call of the correct terminal. }  } /**     @notice     Contribute tokens to a project. @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place. @param _payer The address making the payment. @param _projectId The ID of the project being paid. @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate. @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal. @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas. @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.  */   function _pay(     uint256 _amount,     address _payer,     uint256 _projectId,     address _beneficiary,     uint256 _minReturnedTokens,     bool _preferClaimedTokens,     string memory _memo,     bytes memory _metadata   ) internal returns (uint256 beneficiaryTokenCount) {     // Cant send tokens to the zero address.     if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS(); // Define variables that will be needed outside the scoped section below. // Keep a reference to the funding cycle during which the payment is being made. JBFundingCycle memory _fundingCycle;  // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope. {   IJBPayDelegate _delegate;   uint256 _tokenCount;    // Bundle the amount info into a JBTokenAmount struct.   JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);    // Record the payment.   (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(     _payer,     _bundledAmount,     _projectId,     baseWeightCurrency,     _beneficiary,     _memo,     _metadata   );    // Mint the tokens if needed.   if (_tokenCount &gt; 0)     // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.     beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(       _projectId,       _tokenCount,       _beneficiary,       '',       _preferClaimedTokens,       true     );    // The token count for the beneficiary must be greater than or equal to the minimum expected.   if (beneficiaryTokenCount &lt; _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();    // If a delegate was returned by the data source, issue a callback to it.   if (_delegate != IJBPayDelegate(address(0))) {     JBDidPayData memory _data = JBDidPayData(       _payer,       _projectId,       _fundingCycle.configuration,       _bundledAmount,       beneficiaryTokenCount,       _beneficiary,       _preferClaimedTokens,       _memo,       _metadata     );      _delegate.didPay(_data);     emit DelegateDidPay(_delegate, _data, msg.sender);   } }  emit Pay(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _payer,   _beneficiary,   _amount,   beneficiaryTokenCount,   _memo,   _metadata,   msg.sender );  } /**     @notice     Receives funds belonging to the specified project. @param _projectId The ID of the project to which the funds received belong. @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead. @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added. @param _memo A memo to pass along to the emitted event. @param _metadata Extra data to pass along to the emitted event.  */   function _addToBalanceOf(     uint256 _projectId,     uint256 _amount,     bool _shouldRefundHeldFees,     string memory _memo,     bytes memory _metadata   ) internal {     // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.     uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0; // Record the added funds with any refunded fees. store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);  emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);  } /**     @notice     Refund fees based on the specified amount. @param _projectId The project for which fees are being refunded. @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.  @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal  */   function _refundHeldFees(uint256 _projectId, uint256 _amount)     internal     returns (uint256 refundedFees)   {     // Get a reference to the project's held fees.     JBFee[] memory _heldFees = _heldFeesOf[_projectId]; // Delete the current held fees. delete _heldFeesOf[_projectId];  // Get a reference to the leftover amount once all fees have been settled. uint256 leftoverAmount = _amount;  // Push length in stack uint256 _heldFeesLength = _heldFees.length;  // Process each fee. for (uint256 _i = 0; _i &lt; _heldFeesLength; ) {   if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);   else if (leftoverAmount &gt;= _heldFees[_i].amount) {     unchecked {       leftoverAmount = leftoverAmount - _heldFees[_i].amount;       refundedFees += _feeAmount(         _heldFees[_i].amount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount       );     }   } else {     _heldFeesOf[_projectId].push(       JBFee(         _heldFees[_i].amount - leftoverAmount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount,         _heldFees[_i].beneficiary       )     );     unchecked {       refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);     }     leftoverAmount = 0;   }    unchecked {     ++_i;   } }  emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);  } /**      @notice      Returns the fee amount based on the provided amount for the specified project. @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal. @param _fee The percentage of the fee, out of MAX_FEE.  @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.  @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.  */   function _feeAmount(     uint256 _amount,     uint256 _fee,     uint256 _feeDiscount   ) internal pure returns (uint256) {     // Calculate the discounted fee.     uint256 _discountedFee = _fee -       PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT); // The amount of tokens from the `_amount` to pay as a fee. return   _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);  } /**      @notice     Get the fee discount from the fee gauge for the specified project. @param _projectId The ID of the project to get a fee discount for.  @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.  */   function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {     // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.     if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))       return JBConstants.MAX_FEE_DISCOUNT; // Get the fee discount. if (feeGauge == IJBFeeGauge(address(0)))   feeDiscount = 0;   // If the guage reverts, set the discount to 0. else   try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {     feeDiscount = discount;   } catch {     feeDiscount = 0;   }  // If the fee discount is greater than the max, nullify the discount. if (feeDiscount &gt; JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;  } } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@paulrberg/contracts/math/PRBMath.sol';\nimport './../interfaces/IJBController.sol';\nimport './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol';\nimport './../libraries/JBConstants.sol';\nimport './../libraries/JBCurrencies.sol';\nimport './../libraries/JBFixedPointNumber.sol';\nimport './../libraries/JBFundingCycleMetadataResolver.sol';\nimport './../libraries/JBOperations.sol';\nimport './../libraries/JBSplitsGroups.sol';\nimport './../libraries/JBTokens.sol';\nimport './../structs/JBTokenAmount.sol';\nimport './JBOperatable.sol';\nimport './JBSingleTokenPaymentTerminal.sol';\n\n/\n  @notice\n  Generic terminal managing all inflows and outflows of funds into the protocol ecosystem.\n\n  @dev\n  A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time.\n\n  @dev\n  Adheres to -\n  IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.\n\n  @dev\n  Inherits from -\n  JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.\n  JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.\n  Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.\n  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.\n/\nabstract contract JBPayoutRedemptionPaymentTerminal is\n  IJBPayoutRedemptionPaymentTerminal,\n  JBSingleTokenPaymentTerminal,\n  JBOperatable,\n  Ownable,\n  ReentrancyGuard\n{\n  // A library that parses the packed funding cycle metadata into a friendlier format.\n  using JBFundingCycleMetadataResolver for JBFundingCycle;\n\n  //*********//\n  // --------------------------- custom errors ------------------------- //\n  //*********//\n  error FEE_TOO_HIGH();\n  error INADEQUATE_DISTRIBUTION_AMOUNT();\n  error INADEQUATE_RECLAIM_AMOUNT();\n  error INADEQUATE_TOKEN_COUNT();\n  error NO_MSG_VALUE_ALLOWED();\n  error PAY_TO_ZERO_ADDRESS();\n  error PROJECT_TERMINAL_MISMATCH();\n  error REDEEM_TO_ZERO_ADDRESS();\n  error TERMINAL_IN_SPLIT_ZERO_ADDRESS();\n  error TERMINAL_TOKENS_INCOMPATIBLE();\n\n  //*********//\n  // ---------------------------- modifiers ---------------------------- //\n  //*********//\n\n  / \n    @notice \n    A modifier that verifies this terminal is a terminal of provided project ID.\n  /\n  modifier isTerminalOf(uint256 projectId) {\n    if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();\n    ;\n  }\n\n  //**********//\n  // --------------------- internal stored constants ------------------- //\n  //*********//\n\n  /\n    @notice\n    Maximum fee that can be set for a funding cycle configuration.\n\n    @dev\n    Out of MAX_FEE (50_000_000 / 1_000_000_000).\n  /\n  uint256 internal constant _FEE_CAP = 50_000_000;\n\n  /\n    @notice\n    The protocol project ID is 1, as it should be the first project launched during the deployment process.\n  /\n  uint256 internal constant _PROTOCOL_PROJECT_ID = 1;\n\n  //**********//\n  // --------------------- internal stored properties ------------------ //\n  //**********//\n\n  /\n    @notice\n    Fees that are being held to be processed later.\n\n    _projectId The ID of the project for which fees are being held.\n  /\n  mapping(uint256 =&gt; JBFee[]) internal _heldFeesOf;\n\n  //**********//\n  // ---------------- public immutable stored properties --------------- //\n  //*********//\n\n  /\n    @notice\n    Mints ERC-721's that represent project ownership and transfers.\n  /\n  IJBProjects public immutable override projects;\n\n  /\n    @notice\n    The directory of terminals and controllers for projects.\n  /\n  IJBDirectory public immutable override directory;\n\n  /\n    @notice\n    The contract that stores splits for each project.\n  /\n  IJBSplitsStore public immutable override splitsStore;\n\n  /\n    @notice\n    The contract that exposes price feeds.\n  /\n  IJBPrices public immutable override prices;\n\n  /\n    @notice\n    The contract that stores and manages the terminal's data.\n  */\n  IJBSingleTokenPaymentTerminalStore public immutable override store;\n\n  /\n    @notice\n    The currency to base token issuance on.\n\n    @dev\n    If this differs from currency, there must be a price feed available to convert currency to baseWeightCurrency.\n  /\n  uint256 public immutable override baseWeightCurrency;\n\n  /\n    @notice\n    The group that payout splits coming from this terminal are identified by.\n  /\n  uint256 public immutable override payoutSplitsGroup;\n\n  //*********//\n  // --------------------- public stored properties -------------------- //\n  //*********//\n\n  /\n    @notice\n    The platform fee percent.\n\n    @dev\n    Out of MAX_FEE (25_000_000 / 1_000_000_000)\n  /\n  uint256 public override fee = 25_000_000; // 2.5%\n\n  /\n    @notice\n    The data source that returns a discount to apply to a project's fee.\n  /\n  IJBFeeGauge public override feeGauge;\n\n  /\n    @notice\n    Addresses that can be paid towards from this terminal without incurring a fee.\n\n    _address The address that can be paid toward.\n  /\n  mapping(address =&gt; bool) public override isFeelessAddress;\n\n  //***********//\n  // ------------------------- external views -------------------------- //\n  //**********//\n\n  /\n    @notice\n    Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.\n\n    @dev\n    The current overflow is represented as a fixed point number with 18 decimals.\n\n    @param _projectId The ID of the project to get overflow for.\n\n    @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.\n  /\n  function currentEthOverflowOf(uint256 _projectId)\n    external\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    // Get this terminal's current overflow.\n    uint256 _overflow = store.currentOverflowOf(this, _projectId);\n\n    // Adjust the decimals of the fixed point number if needed to have 18 decimals.\n    uint256 _adjustedOverflow = (decimals == 18)\n      ? _overflow\n      : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);\n\n    // Return the amount converted to ETH.\n    return\n      (currency == JBCurrencies.ETH)\n        ? _adjustedOverflow\n        : PRBMath.mulDiv(\n          _adjustedOverflow,\n          10decimals,\n          prices.priceFor(currency, JBCurrencies.ETH, decimals)\n        );\n  }\n\n  /\n    @notice\n    The fees that are currently being held to be processed later for each project.\n\n    @param _projectId The ID of the project for which fees are being held.\n\n    @return An array of fees that are being held.\n  /\n  function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {\n    return _heldFeesOf[_projectId];\n  }\n\n  //*********//\n  // -------------------------- public views --------------------------- //\n  //*********//\n\n  /\n    @notice\n    Indicates if this contract adheres to the specified interface.\n\n    @dev \n    See {IERC165-supportsInterface}.\n\n    @param _interfaceId The ID of the interface to check for adherance to.\n  /\n  function supportsInterface(bytes4 _interfaceId)\n    public\n    view\n    virtual\n    override(JBSingleTokenPaymentTerminal, IERC165)\n    returns (bool)\n  {\n    return\n      _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||\n      _interfaceId == type(IJBPayoutTerminal).interfaceId ||\n      _interfaceId == type(IJBAllowanceTerminal).interfaceId ||\n      _interfaceId == type(IJBRedemptionTerminal).interfaceId ||\n      _interfaceId == type(IJBOperatable).interfaceId ||\n      super.supportsInterface(_interfaceId);\n  }\n\n  //**********//\n  // -------------------------- constructor ---------------------------- //\n  //*********//\n\n  /\n    @param _token The token that this terminal manages.\n    @param _decimals The number of decimals the token fixed point amounts are expected to have.\n    @param _currency The currency that this terminal's token adheres to for price feeds.\n    @param _baseWeightCurrency The currency to base token issuance on.\n    @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.\n    @param _operatorStore A contract storing operator assignments.\n    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.\n    @param _directory A contract storing directories of terminals and controllers for each project.\n    @param _splitsStore A contract that stores splits for each project.\n    @param _prices A contract that exposes price feeds.\n    @param _store A contract that stores the terminal's data.\n    @param _owner The address that will own this contract.\n  /\n  constructor(\n    // payable constructor save the gas used to check msg.value==0\n    address _token,\n    uint256 _decimals,\n    uint256 _currency,\n    uint256 _baseWeightCurrency,\n    uint256 _payoutSplitsGroup,\n    IJBOperatorStore _operatorStore,\n    IJBProjects _projects,\n    IJBDirectory _directory,\n    IJBSplitsStore _splitsStore,\n    IJBPrices _prices,\n    IJBSingleTokenPaymentTerminalStore _store,\n    address _owner\n  )\n    payable\n    JBSingleTokenPaymentTerminal(_token, _decimals, _currency)\n    JBOperatable(_operatorStore)\n  {\n    baseWeightCurrency = _baseWeightCurrency;\n    payoutSplitsGroup = _payoutSplitsGroup;\n    projects = _projects;\n    directory = _directory;\n    splitsStore = _splitsStore;\n    prices = _prices;\n    store = _store;\n\n    transferOwnership(_owner);\n  }\n\n  //**********//\n  // ---------------------- external transactions ---------------------- //\n  //*********//\n\n  /\n    @notice\n    Contribute tokens to a project.\n\n    @param _projectId The ID of the project being paid.\n    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.\n    @param _token The token being paid. This terminal ignores this property since it only manages one token. \n    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.\n    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.\n    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.\n    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.\n    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.\n\n    @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.\n  /\n  function pay(\n    uint256 _projectId,\n    uint256 _amount,\n    address _token,\n    address _beneficiary,\n    uint256 _minReturnedTokens,\n    bool _preferClaimedTokens,\n    string calldata _memo,\n    bytes calldata _metadata\n  ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {\n    _token; // Prevents unused var compiler and natspec complaints.\n\n    // ETH shouldn't be sent if this terminal's token isn't ETH.\n    if (token != JBTokens.ETH) {\n      if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();\n\n      // Transfer tokens to this terminal from the msg sender.\n      _transferFrom(msg.sender, payable(address(this)), _amount);\n    }\n    // If this terminal's token is ETH, override _amount with msg.value.\n    else _amount = msg.value;\n\n    return\n      _pay(\n        _amount,\n        msg.sender,\n        _projectId,\n        _beneficiary,\n        _minReturnedTokens,\n        _preferClaimedTokens,\n        _memo,\n        _metadata\n      );\n  }\n\n  /\n    @notice\n    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.\n\n    @dev\n    Only a token holder or a designated operator can redeem its tokens.\n\n    @param _holder The account to redeem tokens for.\n    @param _projectId The ID of the project to which the tokens being redeemed belong.\n    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.\n    @param _token The token being reclaimed. This terminal ignores this property since it only manages one token. \n    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.\n    @param _beneficiary The address to send the terminal tokens to.\n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.\n\n    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.\n  /\n  function redeemTokensOf(\n    address _holder,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    address _token,\n    uint256 _minReturnedTokens,\n    address payable _beneficiary,\n    string memory _memo,\n    bytes memory _metadata\n  )\n    external\n    virtual\n    override\n    requirePermission(_holder, _projectId, JBOperations.REDEEM)\n    returns (uint256 reclaimAmount)\n  {\n    _token; // Prevents unused var compiler and natspec complaints.\n\n    return\n      _redeemTokensOf(\n        _holder,\n        _projectId,\n        _tokenCount,\n        _minReturnedTokens,\n        _beneficiary,\n        _memo,\n        _metadata\n      );\n  }\n\n  /\n    @notice\n    Distributes payouts for a project with the distribution limit of its current funding cycle.\n\n    @dev\n    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.\n\n    @dev\n    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.\n\n    @dev\n    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.\n\n    @param _projectId The ID of the project having its payouts distributed.\n    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.\n    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.\n    @param _token The token being distributed. This terminal ignores this property since it only manages one token. \n    @param _minReturnedTokens The minimum number of terminal tokens that the _amount should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.\n  /\n  function distributePayoutsOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency,\n    address _token,\n    uint256 _minReturnedTokens,\n    string calldata _memo\n  ) external virtual override returns (uint256 netLeftoverDistributionAmount) {\n    _token; // Prevents unused var compiler and natspec complaints.\n\n    return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);\n  }\n\n  /\n    @notice\n    Allows a project to send funds from its overflow up to the preconfigured allowance.\n\n    @dev\n    Only a project's owner or a designated operator can use its allowance.\n\n    @dev\n    Incurs the protocol fee.\n\n    @param _projectId The ID of the project to use the allowance of.\n    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.\n    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.\n    @param _token The token being distributed. This terminal ignores this property since it only manages one token. \n    @param _minReturnedTokens The minimum number of tokens that the _amount should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.\n    @param _beneficiary The address to send the funds to.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.\n  /\n  function useAllowanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency,\n    address _token,\n    uint256 _minReturnedTokens,\n    address payable _beneficiary,\n    string memory _memo\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)\n    returns (uint256 netDistributedAmount)\n  {\n    _token; // Prevents unused var compiler and natspec complaints.\n\n    return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);\n  }\n\n  /\n    @notice\n    Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.\n\n    @dev\n    Only a project's owner or a designated operator can migrate it.\n\n    @param _projectId The ID of the project being migrated.\n    @param _to The terminal contract that will gain the project's funds.\n\n    @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.\n  */\n  function migrate(uint256 _projectId, IJBPaymentTerminal _to)\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)\n    returns (uint256 balance)\n  {\n    // The terminal being migrated to must accept the same token as this terminal.\n    if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE();\n\n    // Record the migration in the store.\n    balance = store.recordMigration(_projectId);\n\n    // Transfer the balance if needed.\n    if (balance &gt; 0) {\n      // Trigger any inherited pre-transfer logic.\n      _beforeTransferTo(address(_to), balance);\n\n      // If this terminal's token is ETH, send it in msg.value.\n      uint256 _payableValue = token == JBTokens.ETH ? balance : 0;\n\n      // Withdraw the balance to transfer to the new terminal;\n      _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes(''));\n    }\n\n    emit Migrate(_projectId, _to, balance, msg.sender);\n  }\n\n  /\n    @notice\n    Receives funds belonging to the specified project.\n\n    @param _projectId The ID of the project to which the funds received belong.\n    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.\n    @param _token The token being paid. This terminal ignores this property since it only manages one currency. \n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Extra data to pass along to the emitted event.\n  /\n  function addToBalanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    address _token,\n    string calldata _memo,\n    bytes calldata _metadata\n  ) external payable virtual override isTerminalOf(_projectId) {\n    _token; // Prevents unused var compiler and natspec complaints.\n\n    // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender.\n    if (token != JBTokens.ETH) {\n      // Amount must be greater than 0.\n      if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();\n\n      // Transfer tokens to this terminal from the msg sender.\n      _transferFrom(msg.sender, payable(address(this)), _amount);\n    }\n    // If the terminal's token is ETH, override _amount with msg.value.\n    else _amount = msg.value;\n\n    // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal.\n    _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);\n  }\n\n  /\n    @notice\n    Process any fees that are being held for the project.\n\n    @dev\n    Only a project owner, an operator, or the contract's owner can process held fees.\n\n    @param _projectId The ID of the project whos held fees should be processed.\n  /\n  function processFees(uint256 _projectId)\n    external\n    virtual\n    override\n    requirePermissionAllowingOverride(\n      projects.ownerOf(_projectId),\n      _projectId,\n      JBOperations.PROCESS_FEES,\n      msg.sender == owner()\n    )\n  {\n    // Get a reference to the project's held fees.\n    JBFee[] memory _heldFees = _heldFeesOf[_projectId];\n\n    // Delete the held fees.\n    delete _heldFeesOf[_projectId];\n\n    // Push array length in stack\n    uint256 _heldFeeLength = _heldFees.length;\n\n    // Process each fee.\n    for (uint256 _i = 0; _i &lt; _heldFeeLength; ) {\n      // Get the fee amount.\n      uint256 _amount = _feeAmount(\n        _heldFees[_i].amount,\n        _heldFees[_i].fee,\n        _heldFees[_i].feeDiscount\n      );\n\n      // Process the fee.\n      _processFee(_amount, _heldFees[_i].beneficiary);\n\n      emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /\n    @notice\n    Allows the fee to be updated.\n\n    @dev\n    Only the owner of this contract can change the fee.\n\n    @param _fee The new fee, out of MAX_FEE.\n  */\n  function setFee(uint256 _fee) external virtual override onlyOwner {\n    // The provided fee must be within the max.\n    if (_fee &gt; _FEE_CAP) revert FEE_TOO_HIGH();\n\n    // Store the new fee.\n    fee = _fee;\n\n    emit SetFee(_fee, msg.sender);\n  }\n\n  /\n    @notice\n    Allows the fee gauge to be updated.\n\n    @dev\n    Only the owner of this contract can change the fee gauge.\n\n    @dev\n    If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.\n\n    @param _feeGauge The new fee gauge.\n  /\n  function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {\n    // Store the new fee gauge.\n    feeGauge = _feeGauge;\n\n    emit SetFeeGauge(_feeGauge, msg.sender);\n  }\n\n  /\n    @notice\n    Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.\n\n    @dev\n    Only the owner of this contract can set addresses as feeless.\n\n    @param _address The address that can be paid towards while still bypassing fees.\n    @param _flag A flag indicating whether the terminal should be feeless or not.\n  /\n  function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {\n    // Set the flag value.\n    isFeelessAddress[_address] = _flag;\n\n    emit SetFeelessAddress(_address, _flag, msg.sender);\n  }\n\n  //*********//\n  // ---------------------- internal transactions ---------------------- //\n  //*********//\n\n  / \n    @notice\n    Transfers tokens.\n\n    @param _from The address from which the transfer should originate.\n    @param _to The address to which the transfer should go.\n    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.\n  /\n  function _transferFrom(\n    address _from,\n    address payable _to,\n    uint256 _amount\n  ) internal virtual;\n\n  / \n    @notice\n    Logic to be triggered before transferring tokens from this terminal.\n\n    @param _to The address to which the transfer is going.\n    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.\n  /\n  function _beforeTransferTo(address _to, uint256 _amount) internal virtual;\n\n  /\n    @notice\n    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.\n\n    @dev\n    Only a token holder or a designated operator can redeem its tokens.\n\n    @param _holder The account to redeem tokens for.\n    @param _projectId The ID of the project to which the tokens being redeemed belong.\n    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.\n    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.\n    @param _beneficiary The address to send the terminal tokens to.\n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.\n\n    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.\n  /\n  function _redeemTokensOf(\n    address _holder,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    uint256 _minReturnedTokens,\n    address payable _beneficiary,\n    string memory _memo,\n    bytes memory _metadata\n  ) internal returns (uint256 reclaimAmount) {\n    // Can't send reclaimed funds to the zero address.\n    if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS();\n\n    // Define variables that will be needed outside the scoped section below.\n    // Keep a reference to the funding cycle during which the redemption is being made.\n    JBFundingCycle memory _fundingCycle;\n\n    // Scoped section prevents stack too deep. _delegate only used within scope.\n    {\n      IJBRedemptionDelegate _delegate;\n\n      // Record the redemption.\n      (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(\n        _holder,\n        _projectId,\n        _tokenCount,\n        _memo,\n        _metadata\n      );\n\n      // The amount being reclaimed must be at least as much as was expected.\n      if (reclaimAmount &lt; _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();\n\n      // Burn the project tokens.\n      if (_tokenCount &gt; 0)\n        IJBController(directory.controllerOf(_projectId)).burnTokensOf(\n          _holder,\n          _projectId,\n          _tokenCount,\n          '',\n          false\n        );\n\n      // If a delegate was returned by the data source, issue a callback to it.\n      if (_delegate != IJBRedemptionDelegate(address(0))) {\n        JBDidRedeemData memory _data = JBDidRedeemData(\n          _holder,\n          _projectId,\n          _fundingCycle.configuration,\n          _tokenCount,\n          JBTokenAmount(token, reclaimAmount, decimals, currency),\n          _beneficiary,\n          _memo,\n          _metadata\n        );\n        _delegate.didRedeem(_data);\n        emit DelegateDidRedeem(_delegate, _data, msg.sender);\n      }\n    }\n\n    // Send the reclaimed funds to the beneficiary.\n    if (reclaimAmount &gt; 0) _transferFrom(address(this), _beneficiary, reclaimAmount);\n\n    emit RedeemTokens(\n      _fundingCycle.configuration,\n      _fundingCycle.number,\n      _projectId,\n      _holder,\n      _beneficiary,\n      _tokenCount,\n      reclaimAmount,\n      _memo,\n      _metadata,\n      msg.sender\n    );\n  }\n\n  /\n    @notice\n    Distributes payouts for a project with the distribution limit of its current funding cycle.\n\n    @dev\n    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.\n\n    @dev\n    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.\n\n    @dev\n    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.\n\n    @param _projectId The ID of the project having its payouts distributed.\n    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.\n    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.\n    @param _minReturnedTokens The minimum number of terminal tokens that the _amount should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.\n  */\n  function _distributePayoutsOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency,\n    uint256 _minReturnedTokens,\n    string calldata _memo\n  ) internal returns (uint256 netLeftoverDistributionAmount) {\n    // Record the distribution.\n    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(\n      _projectId,\n      _amount,\n      _currency\n    );\n\n    // The amount being distributed must be at least as much as was expected.\n    if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();\n\n    // Get a reference to the project owner, which will receive tokens from paying the platform fee\n    // and receive any extra distributable funds not allocated to payout splits.\n    address payable _projectOwner = payable(projects.ownerOf(_projectId));\n\n    // Define variables that will be needed outside the scoped section below.\n    // Keep a reference to the fee amount that was paid.\n    uint256 _fee;\n\n    // Scoped section prevents stack too deep. _feeDiscount, _feeEligibleDistributionAmount, and _leftoverDistributionAmount only used within scope.\n    {\n      // Get the amount of discount that should be applied to any fees taken.\n      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.\n      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]\n        ? JBConstants.MAX_FEE_DISCOUNT\n        : _currentFeeDiscount(_projectId);\n\n      // The amount distributed that is eligible for incurring fees.\n      uint256 _feeEligibleDistributionAmount;\n\n      // The amount leftover after distributing to the splits.\n      uint256 _leftoverDistributionAmount;\n\n      // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.\n      // Also get a reference to the amount that was distributed to splits from which fees should be taken.\n      (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(\n        _projectId,\n        _fundingCycle.configuration,\n        payoutSplitsGroup,\n        _distributedAmount,\n        _feeDiscount\n      );\n\n      // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.\n      unchecked {\n        _feeEligibleDistributionAmount += _leftoverDistributionAmount;\n      }\n\n      // Take the fee.\n      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0\n        ? 0\n        : _takeFeeFrom(\n          _projectId,\n          _fundingCycle,\n          _feeEligibleDistributionAmount,\n          _projectOwner,\n          _feeDiscount\n        );\n\n      // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.\n\n      unchecked {\n        netLeftoverDistributionAmount = _leftoverDistributionAmount == 0\n          ? 0\n          : _leftoverDistributionAmount -\n            _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);\n      }\n\n      // Transfer any remaining balance to the project owner.\n      if (netLeftoverDistributionAmount &gt; 0)\n        _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount);\n    }\n\n    emit DistributePayouts(\n      _fundingCycle.configuration,\n      _fundingCycle.number,\n      _projectId,\n      _projectOwner,\n      _amount,\n      _distributedAmount,\n      _fee,\n      netLeftoverDistributionAmount,\n      _memo,\n      msg.sender\n    );\n  }\n\n  /\n    @notice\n    Allows a project to send funds from its overflow up to the preconfigured allowance.\n\n    @dev\n    Only a project's owner or a designated operator can use its allowance.\n\n    @dev\n    Incurs the protocol fee.\n\n    @param _projectId The ID of the project to use the allowance of.\n    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.\n    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.\n    @param _minReturnedTokens The minimum number of tokens that the _amount should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.\n    @param _beneficiary The address to send the funds to.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.\n  /\n  function _useAllowanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency,\n    uint256 _minReturnedTokens,\n    address payable _beneficiary,\n    string memory _memo\n  ) internal returns (uint256 netDistributedAmount) {\n    // Record the use of the allowance.\n    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(\n      _projectId,\n      _amount,\n      _currency\n    );\n\n    // The amount being withdrawn must be at least as much as was expected.\n    if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();\n\n    // Scoped section prevents stack too deep. _fee, _projectOwner, _feeDiscount, and _netAmount only used within scope.\n    {\n      // Keep a reference to the fee amount that was paid.\n      uint256 _fee;\n\n      // Get a reference to the project owner, which will receive tokens from paying the platform fee.\n      address _projectOwner = projects.ownerOf(_projectId);\n\n      // Get the amount of discount that should be applied to any fees taken.\n      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.\n      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]\n        ? JBConstants.MAX_FEE_DISCOUNT\n        : _currentFeeDiscount(_projectId);\n\n      // Take a fee from the _distributedAmount, if needed.\n      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT\n        ? 0\n        : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);\n\n      unchecked {\n        // The net amount is the withdrawn amount without the fee.\n        netDistributedAmount = _distributedAmount - _fee;\n      }\n\n      // Transfer any remaining balance to the beneficiary.\n      if (netDistributedAmount &gt; 0)\n        _transferFrom(address(this), _beneficiary, netDistributedAmount);\n    }\n\n    emit UseAllowance(\n      _fundingCycle.configuration,\n      _fundingCycle.number,\n      _projectId,\n      _beneficiary,\n      _amount,\n      _distributedAmount,\n      netDistributedAmount,\n      _memo,\n      msg.sender\n    );\n  }\n\n  /\n    @notice\n    Pays out splits for a project's funding cycle configuration.\n\n    @param _projectId The ID of the project for which payout splits are being distributed.\n    @param _domain The domain of the splits to distribute the payout between.\n    @param _group The group of the splits to distribute the payout between.\n    @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal.\n    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.\n\n    @return leftoverAmount If the leftover amount if the splits don't add up to 100%.\n    @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.\n  /\n  function _distributeToPayoutSplitsOf(\n    uint256 _projectId,\n    uint256 _domain,\n    uint256 _group,\n    uint256 _amount,\n    uint256 _feeDiscount\n  ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {\n    // Set the leftover amount to the initial amount.\n    leftoverAmount = _amount;\n\n    // Get a reference to the project's payout splits.\n    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);\n\n    // Transfer between all splits.\n    for (uint256 _i = 0; _i &lt; _splits.length; ) {\n      // Get a reference to the split being iterated on.\n      JBSplit memory _split = _splits[_i];\n\n      // The amount to send towards the split.\n      uint256 _payoutAmount = PRBMath.mulDiv(\n        _amount,\n        _split.percent,\n        JBConstants.SPLITS_TOTAL_PERCENT\n      );\n\n      // The payout amount substracting any applicable incurred fees.\n      uint256 _netPayoutAmount;\n\n      if (_payoutAmount &gt; 0) {\n        // Transfer tokens to the split.\n        // If there's an allocator set, transfer to its allocate function.\n        if (_split.allocator != IJBSplitAllocator(address(0))) {\n          // If the split allocator is set as feeless, this distribution is not eligible for a fee.\n          if (isFeelessAddress[address(_split.allocator)])\n            _netPayoutAmount = _payoutAmount;\n            // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.\n          else {\n            unchecked {\n              _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT\n                ? _payoutAmount\n                : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);\n            }\n\n            // This distribution is eligible for a fee since the funds are leaving the ecosystem.\n            feeEligibleDistributionAmount += _payoutAmount;\n          }\n\n          // Trigger any inherited pre-transfer logic.\n          _beforeTransferTo(address(_split.allocator), _netPayoutAmount);\n\n          // If this terminal's token is ETH, send it in msg.value.\n          uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;\n\n          // Create the data to send to the allocator.\n          JBSplitAllocationData memory _data = JBSplitAllocationData(\n            token,\n            _netPayoutAmount,\n            decimals,\n            _projectId,\n            _group,\n            _split\n          );\n\n          // Trigger the allocator's allocate function.\n          _split.allocator.allocate{value: _payableValue}(_data);\n\n          // Otherwise, if a project is specified, make a payment to it.\n        } else if (_split.projectId != 0) {\n          // Get a reference to the Juicebox terminal being used.\n          IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);\n\n          // The project must have a terminal to send funds to.\n          if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();\n\n          // Save gas if this contract is being used as the terminal.\n          if (_terminal == this) {\n            // This distribution does not incur a fee.\n            _netPayoutAmount = _payoutAmount;\n\n            // Send the projectId in the metadata.\n            bytes memory _projectMetadata = new bytes(32);\n            _projectMetadata = bytes(abi.encodePacked(_projectId));\n\n            // Add to balance if prefered.\n            if (_split.preferAddToBalance)\n              _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);\n            else\n              _pay(\n                _netPayoutAmount,\n                address(this),\n                _split.projectId,\n                (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,\n                0,\n                _split.preferClaimed,\n                '',\n                _projectMetadata\n              );\n          } else {\n            // If the terminal is set as feeless, this distribution is not eligible for a fee.\n            if (isFeelessAddress[address(_terminal)])\n              _netPayoutAmount = _payoutAmount;\n              // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.\n            else {\n              unchecked {\n                _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT\n                  ? _payoutAmount\n                  : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);\n              }\n\n              feeEligibleDistributionAmount += _payoutAmount;\n            }\n\n            // Trigger any inherited pre-transfer logic.\n            _beforeTransferTo(address(_terminal), _netPayoutAmount);\n\n            // If this terminal's token is ETH, send it in msg.value.\n            uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;\n\n            // Send the projectId in the metadata.\n            bytes memory _projectMetadata = new bytes(32);\n            _projectMetadata = bytes(abi.encodePacked(_projectId));\n\n            // Add to balance if prefered.\n            if (_split.preferAddToBalance)\n              _terminal.addToBalanceOf{value: _payableValue}(\n                _split.projectId,\n                _netPayoutAmount,\n                token,\n                '',\n                _projectMetadata\n              );\n            else\n              _terminal.pay{value: _payableValue}(\n                _split.projectId,\n                _netPayoutAmount,\n                token,\n                _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,\n                0,\n                _split.preferClaimed,\n                '',\n                _projectMetadata\n              );\n          }\n        } else {\n          unchecked {\n            _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT\n              ? _payoutAmount\n              : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);\n          }\n\n          // This distribution is eligible for a fee since the funds are leaving the ecosystem.\n          feeEligibleDistributionAmount += _payoutAmount;\n\n          // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.\n          _transferFrom(\n            address(this),\n            _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),\n            _netPayoutAmount\n          );\n        }\n\n        // Subtract from the amount to be sent to the beneficiary.\n        unchecked {\n          leftoverAmount = leftoverAmount - _payoutAmount;\n        }\n      }\n\n      emit DistributeToPayoutSplit(\n        _projectId,\n        _domain,\n        _group,\n        _split,\n        _netPayoutAmount,\n        msg.sender\n      );\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /\n    @notice\n    Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID.\n\n    @param _projectId The ID of the project having fees taken from.\n    @param _fundingCycle The funding cycle during which the fee is being taken.\n    @param _amount The amount of the fee to take, as a floating point number with 18 decimals.\n    @param _beneficiary The address to mint the platforms tokens for.\n    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.\n\n    @return feeAmount The amount of the fee taken.\n  */\n  function _takeFeeFrom(\n    uint256 _projectId,\n    JBFundingCycle memory _fundingCycle,\n    uint256 _amount,\n    address _beneficiary,\n    uint256 _feeDiscount\n  ) internal returns (uint256 feeAmount) {\n    feeAmount = _feeAmount(_amount, fee, _feeDiscount);\n\n    if (_fundingCycle.shouldHoldFees()) {\n      // Store the held fee.\n      _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));\n\n      emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender);\n    } else {\n      // Process the fee.\n      _processFee(feeAmount, _beneficiary); // Take the fee.\n\n      emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender);\n    }\n  }\n\n  /\n    @notice\n    Process a fee of the specified amount.\n\n    @param _amount The fee amount, as a floating point number with 18 decimals.\n    @param _beneficiary The address to mint the platform's tokens for.\n  /\n  function _processFee(uint256 _amount, address _beneficiary) internal {\n    // Get the terminal for the protocol project.\n    IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token);\n\n    // When processing the admin fee, save gas if the admin is using this contract as its terminal.\n    if (_terminal == this)\n      _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call.\n    else {\n      // Trigger any inherited pre-transfer logic.\n      _beforeTransferTo(address(_terminal), _amount);\n\n      // If this terminal's token is ETH, send it in msg.value.\n      uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;\n\n      // Send the payment.\n      _terminal.pay{value: _payableValue}(\n        _PROTOCOL_PROJECT_ID,\n        _amount,\n        token,\n        _beneficiary,\n        0,\n        false,\n        '',\n        bytes('')\n      ); // Use the external pay call of the correct terminal.\n    }\n  }\n\n  /\n    @notice\n    Contribute tokens to a project.\n\n    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.\n    @param _payer The address making the payment.\n    @param _projectId The ID of the project being paid.\n    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.\n    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.\n    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.\n    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.\n    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.\n\n    @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.\n  /\n  function _pay(\n    uint256 _amount,\n    address _payer,\n    uint256 _projectId,\n    address _beneficiary,\n    uint256 _minReturnedTokens,\n    bool _preferClaimedTokens,\n    string memory _memo,\n    bytes memory _metadata\n  ) internal returns (uint256 beneficiaryTokenCount) {\n    // Cant send tokens to the zero address.\n    if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS();\n\n    // Define variables that will be needed outside the scoped section below.\n    // Keep a reference to the funding cycle during which the payment is being made.\n    JBFundingCycle memory _fundingCycle;\n\n    // Scoped section prevents stack too deep. _delegate and _tokenCount only used within scope.\n    {\n      IJBPayDelegate _delegate;\n      uint256 _tokenCount;\n\n      // Bundle the amount info into a JBTokenAmount struct.\n      JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);\n\n      // Record the payment.\n      (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(\n        _payer,\n        _bundledAmount,\n        _projectId,\n        baseWeightCurrency,\n        _beneficiary,\n        _memo,\n        _metadata\n      );\n\n      // Mint the tokens if needed.\n      if (_tokenCount &gt; 0)\n        // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.\n        beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(\n          _projectId,\n          _tokenCount,\n          _beneficiary,\n          '',\n          _preferClaimedTokens,\n          true\n        );\n\n      // The token count for the beneficiary must be greater than or equal to the minimum expected.\n      if (beneficiaryTokenCount &lt; _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();\n\n      // If a delegate was returned by the data source, issue a callback to it.\n      if (_delegate != IJBPayDelegate(address(0))) {\n        JBDidPayData memory _data = JBDidPayData(\n          _payer,\n          _projectId,\n          _fundingCycle.configuration,\n          _bundledAmount,\n          beneficiaryTokenCount,\n          _beneficiary,\n          _preferClaimedTokens,\n          _memo,\n          _metadata\n        );\n\n        _delegate.didPay(_data);\n        emit DelegateDidPay(_delegate, _data, msg.sender);\n      }\n    }\n\n    emit Pay(\n      _fundingCycle.configuration,\n      _fundingCycle.number,\n      _projectId,\n      _payer,\n      _beneficiary,\n      _amount,\n      beneficiaryTokenCount,\n      _memo,\n      _metadata,\n      msg.sender\n    );\n  }\n\n  /\n    @notice\n    Receives funds belonging to the specified project.\n\n    @param _projectId The ID of the project to which the funds received belong.\n    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.\n    @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added.\n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Extra data to pass along to the emitted event.\n  */\n  function _addToBalanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    bool _shouldRefundHeldFees,\n    string memory _memo,\n    bytes memory _metadata\n  ) internal {\n    // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.\n    uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0;\n\n    // Record the added funds with any refunded fees.\n    store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);\n\n    emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);\n  }\n\n  /\n    @notice\n    Refund fees based on the specified amount.\n\n    @param _projectId The project for which fees are being refunded.\n    @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.\n\n    @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal\n  /\n  function _refundHeldFees(uint256 _projectId, uint256 _amount)\n    internal\n    returns (uint256 refundedFees)\n  {\n    // Get a reference to the project's held fees.\n    JBFee[] memory _heldFees = _heldFeesOf[_projectId];\n\n    // Delete the current held fees.\n    delete _heldFeesOf[_projectId];\n\n    // Get a reference to the leftover amount once all fees have been settled.\n    uint256 leftoverAmount = _amount;\n\n    // Push length in stack\n    uint256 _heldFeesLength = _heldFees.length;\n\n    // Process each fee.\n    for (uint256 _i = 0; _i &lt; _heldFeesLength; ) {\n      if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);\n      else if (leftoverAmount &gt;= _heldFees[_i].amount) {\n        unchecked {\n          leftoverAmount = leftoverAmount - _heldFees[_i].amount;\n          refundedFees += _feeAmount(\n            _heldFees[_i].amount,\n            _heldFees[_i].fee,\n            _heldFees[_i].feeDiscount\n          );\n        }\n      } else {\n        _heldFeesOf[_projectId].push(\n          JBFee(\n            _heldFees[_i].amount - leftoverAmount,\n            _heldFees[_i].fee,\n            _heldFees[_i].feeDiscount,\n            _heldFees[_i].beneficiary\n          )\n        );\n        unchecked {\n          refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);\n        }\n        leftoverAmount = 0;\n      }\n\n      unchecked {\n        ++_i;\n      }\n    }\n\n    emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);\n  }\n\n  / \n    @notice \n    Returns the fee amount based on the provided amount for the specified project.\n\n    @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal.\n    @param _fee The percentage of the fee, out of MAX_FEE. \n    @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.\n\n    @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.\n  /\n  function _feeAmount(\n    uint256 _amount,\n    uint256 _fee,\n    uint256 _feeDiscount\n  ) internal pure returns (uint256) {\n    // Calculate the discounted fee.\n    uint256 _discountedFee = _fee -\n      PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT);\n\n    // The amount of tokens from the _amount to pay as a fee.\n    return\n      _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);\n  }\n\n  /* \n    @notice\n    Get the fee discount from the fee gauge for the specified project.\n\n    @param _projectId The ID of the project to get a fee discount for.\n    \n    @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.\n  /\n  function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {\n    // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.\n    if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))\n      return JBConstants.MAX_FEE_DISCOUNT;\n\n    // Get the fee discount.\n    if (feeGauge == IJBFeeGauge(address(0)))\n      feeDiscount = 0;\n      // If the guage reverts, set the discount to 0.\n    else\n      try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {\n        feeDiscount = discount;\n      } catch {\n        feeDiscount = 0;\n      }\n\n    // If the fee discount is greater than the max, nullify the discount.\n    if (feeDiscount &gt; JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;\n  }\n}\n"} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 17:17:30 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/security/ReentrancyGuard.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './../interfaces/IJBController.sol'; import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol'; import './../libraries/JBConstants.sol'; import './../libraries/JBCurrencies.sol'; import './../libraries/JBFixedPointNumber.sol'; import './../libraries/JBFundingCycleMetadataResolver.sol'; import './../libraries/JBOperations.sol'; import './../libraries/JBSplitsGroups.sol'; import './../libraries/JBTokens.sol'; import './../structs/JBTokenAmount.sol'; import './JBOperatable.sol'; import './JBSingleTokenPaymentTerminal.sol'; /**   @notice   Generic terminal managing all inflows and outflows of funds into the protocol ecosystem. @dev   A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time. @dev   Adheres to -   IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules. @dev   Inherits from -   JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.   JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.   Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.   ReentrancyGuard: Contract module that helps prevent reentrant calls to a function. */ abstract contract JBPayoutRedemptionPaymentTerminal is   IJBPayoutRedemptionPaymentTerminal,   JBSingleTokenPaymentTerminal,   JBOperatable,   Ownable,   ReentrancyGuard {   // A library that parses the packed funding cycle metadata into a friendlier format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error FEE_TOO_HIGH();   error INADEQUATE_DISTRIBUTION_AMOUNT();   error INADEQUATE_RECLAIM_AMOUNT();   error INADEQUATE_TOKEN_COUNT();   error NO_MSG_VALUE_ALLOWED();   error PAY_TO_ZERO_ADDRESS();   error PROJECT_TERMINAL_MISMATCH();   error REDEEM_TO_ZERO_ADDRESS();   error TERMINAL_IN_SPLIT_ZERO_ADDRESS();   error TERMINAL_TOKENS_INCOMPATIBLE(); //***********//   // ---------------------------- modifiers ---------------------------- //   //*************// /*      @notice      A modifier that verifies this terminal is a terminal of provided project ID.   /   modifier isTerminalOf(uint256 projectId) {     if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();     ;   } //***********//   // --------------------- internal stored constants ------------------- //   //*************// /**     @notice     Maximum fee that can be set for a funding cycle configuration. @dev Out of MAX_FEE (50_000_000 / 1_000_000_000).  */   uint256 internal constant _FEE_CAP = 50_000_000; /*     @notice     The protocol project ID is 1, as it should be the first project launched during the deployment process.   /   uint256 internal constant _PROTOCOL_PROJECT_ID = 1; //***********//   // --------------------- internal stored properties ------------------ //   //*************// /**     @notice     Fees that are being held to be processed later. _projectId The ID of the project for which fees are being held.  */   mapping(uint256 =&gt; JBFee[]) internal _heldFeesOf; //***********//   // ---------------- public immutable stored properties --------------- //   //*************// /*     @notice     Mints ERC-721's that represent project ownership and transfers.   /   IJBProjects public immutable override projects; /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; /*     @notice     The contract that stores splits for each project.   /   IJBSplitsStore public immutable override splitsStore; /*     @notice     The contract that exposes price feeds.   /   IJBPrices public immutable override prices; /*     @notice     The contract that stores and manages the terminal's data.   /   IJBSingleTokenPaymentTerminalStore public immutable override store; /**     @notice     The currency to base token issuance on. @dev If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.  */   uint256 public immutable override baseWeightCurrency; /*     @notice     The group that payout splits coming from this terminal are identified by.   /   uint256 public immutable override payoutSplitsGroup; //***********//   // --------------------- public stored properties -------------------- //   //*************// /**     @notice     The platform fee percent. @dev Out of MAX_FEE (25_000_000 / 1_000_000_000)  */   uint256 public override fee = 25_000_000; // 2.5% /*     @notice     The data source that returns a discount to apply to a project's fee.   /   IJBFeeGauge public override feeGauge; /**     @notice     Addresses that can be paid towards from this terminal without incurring a fee. _address The address that can be paid toward.  */   mapping(address =&gt; bool) public override isFeelessAddress; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     Gets the current overflowed amount in this terminal for a specified project, in terms of ETH. @dev The current overflow is represented as a fixed point number with 18 decimals.  @param _projectId The ID of the project to get overflow for.  @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.  */   function currentEthOverflowOf(uint256 _projectId)     external     view     virtual     override     returns (uint256)   {     // Get this terminal's current overflow.     uint256 _overflow = store.currentOverflowOf(this, _projectId); // Adjust the decimals of the fixed point number if needed to have 18 decimals. uint256 _adjustedOverflow = (decimals == 18)   ? _overflow   : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);  // Return the amount converted to ETH. return   (currency == JBCurrencies.ETH)     ? _adjustedOverflow     : PRBMath.mulDiv(       _adjustedOverflow,       10**decimals,       prices.priceFor(currency, JBCurrencies.ETH, decimals)     );  } /**     @notice     The fees that are currently being held to be processed later for each project. @param _projectId The ID of the project for which fees are being held.  @return An array of fees that are being held.  */   function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {     return _heldFeesOf[_projectId];   } //***********//   // -------------------------- public views --------------------------- //   //*************// /**     @notice     Indicates if this contract adheres to the specified interface. @dev  See {IERC165-supportsInterface}.  @param _interfaceId The ID of the interface to check for adherance to.  */   function supportsInterface(bytes4 _interfaceId)     public     view     virtual     override(JBSingleTokenPaymentTerminal, IERC165)     returns (bool)   {     return       _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||       _interfaceId == type(IJBPayoutTerminal).interfaceId ||       _interfaceId == type(IJBAllowanceTerminal).interfaceId ||       _interfaceId == type(IJBRedemptionTerminal).interfaceId ||       _interfaceId == type(IJBOperatable).interfaceId ||       super.supportsInterface(_interfaceId);   } //***********//   // -------------------------- constructor ---------------------------- //   //*************// /*     @param _token The token that this terminal manages.     @param _decimals The number of decimals the token fixed point amounts are expected to have.     @param _currency The currency that this terminal's token adheres to for price feeds.     @param _baseWeightCurrency The currency to base token issuance on.     @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.     @param _operatorStore A contract storing operator assignments.     @param _projects A contract which mints ERC-721's that represent project ownership and transfers.     @param _directory A contract storing directories of terminals and controllers for each project.     @param _splitsStore A contract that stores splits for each project.     @param _prices A contract that exposes price feeds.     @param _store A contract that stores the terminal's data.     @param _owner The address that will own this contract.   /   constructor(     // payable constructor save the gas used to check msg.value==0     address _token,     uint256 _decimals,     uint256 _currency,     uint256 _baseWeightCurrency,     uint256 _payoutSplitsGroup,     IJBOperatorStore _operatorStore,     IJBProjects _projects,     IJBDirectory _directory,     IJBSplitsStore _splitsStore,     IJBPrices _prices,     IJBSingleTokenPaymentTerminalStore _store,     address _owner   )     payable     JBSingleTokenPaymentTerminal(_token, _decimals, _currency)     JBOperatable(_operatorStore)   {     baseWeightCurrency = _baseWeightCurrency;     payoutSplitsGroup = _payoutSplitsGroup;     projects = _projects;     directory = _directory;     splitsStore = _splitsStore;     prices = _prices;     store = _store; transferOwnership(_owner);  } //***********//   // ---------------------- external transactions ---------------------- //   //*************// /**     @notice     Contribute tokens to a project. @param _projectId The ID of the project being paid. @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place. @param _token The token being paid. This terminal ignores this property since it only manages one token.  @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate. @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal. @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas. @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.  */   function pay(     uint256 _projectId,     uint256 _amount,     address _token,     address _beneficiary,     uint256 _minReturnedTokens,     bool _preferClaimedTokens,     string calldata _memo,     bytes calldata _metadata   ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {     _token; // Prevents unused var compiler and natspec complaints. // ETH shouldn't be sent if this terminal's token isn't ETH. if (token != JBTokens.ETH) {   if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();    // Transfer tokens to this terminal from the msg sender.   _transferFrom(msg.sender, payable(address(this)), _amount); } // If this terminal's token is ETH, override _amount with msg.value. else _amount = msg.value;  return   _pay(     _amount,     msg.sender,     _projectId,     _beneficiary,     _minReturnedTokens,     _preferClaimedTokens,     _memo,     _metadata   );  } /**     @notice     Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source. @dev Only a token holder or a designated operator can redeem its tokens.  @param _holder The account to redeem tokens for. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _token The token being reclaimed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal. @param _beneficiary The address to send the terminal tokens to. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.  */   function redeemTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     address _token,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo,     bytes memory _metadata   )     external     virtual     override     requirePermission(_holder, _projectId, JBOperations.REDEEM)     returns (uint256 reclaimAmount)   {     _token; // Prevents unused var compiler and natspec complaints. return   _redeemTokensOf(     _holder,     _projectId,     _tokenCount,     _minReturnedTokens,     _beneficiary,     _memo,     _metadata   );  } /**     @notice     Distributes payouts for a project with the distribution limit of its current funding cycle. @dev Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.  @dev Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.  @dev All funds distributed outside of this contract or any feeless terminals incure the protocol fee.  @param _projectId The ID of the project having its payouts distributed. @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency. @param _token The token being distributed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal. @param _memo A memo to pass along to the emitted event.  @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.  */   function distributePayoutsOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     address _token,     uint256 _minReturnedTokens,     string calldata _memo   ) external virtual override returns (uint256 netLeftoverDistributionAmount) {     _token; // Prevents unused var compiler and natspec complaints. return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);  } /**     @notice     Allows a project to send funds from its overflow up to the preconfigured allowance. @dev Only a project's owner or a designated operator can use its allowance.  @dev Incurs the protocol fee.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency. @param _token The token being distributed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals. @param _beneficiary The address to send the funds to. @param _memo A memo to pass along to the emitted event.  @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.  */   function useAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     address _token,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)     returns (uint256 netDistributedAmount)   {     _token; // Prevents unused var compiler and natspec complaints. return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);  } /**     @notice     Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type. @dev Only a project's owner or a designated operator can migrate it.  @param _projectId The ID of the project being migrated. @param _to The terminal contract that will gain the project's funds.  @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.  */   function migrate(uint256 _projectId, IJBPaymentTerminal _to)     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)     returns (uint256 balance)   {     // The terminal being migrated to must accept the same token as this terminal.     if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE(); // Record the migration in the store. balance = store.recordMigration(_projectId);  // Transfer the balance if needed. if (balance &gt; 0) {   // Trigger any inherited pre-transfer logic.   _beforeTransferTo(address(_to), balance);    // If this terminal's token is ETH, send it in msg.value.   uint256 _payableValue = token == JBTokens.ETH ? balance : 0;    // Withdraw the balance to transfer to the new terminal;   _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes('')); }  emit Migrate(_projectId, _to, balance, msg.sender);  } /**     @notice     Receives funds belonging to the specified project. @param _projectId The ID of the project to which the funds received belong. @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead. @param _token The token being paid. This terminal ignores this property since it only manages one currency.  @param _memo A memo to pass along to the emitted event. @param _metadata Extra data to pass along to the emitted event.  */   function addToBalanceOf(     uint256 _projectId,     uint256 _amount,     address _token,     string calldata _memo,     bytes calldata _metadata   ) external payable virtual override isTerminalOf(_projectId) {     _token; // Prevents unused var compiler and natspec complaints. // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender. if (token != JBTokens.ETH) {   // Amount must be greater than 0.   if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();    // Transfer tokens to this terminal from the msg sender.   _transferFrom(msg.sender, payable(address(this)), _amount); } // If the terminal's token is ETH, override `_amount` with msg.value. else _amount = msg.value;  // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal. _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);  } /**     @notice     Process any fees that are being held for the project. @dev Only a project owner, an operator, or the contract's owner can process held fees.  @param _projectId The ID of the project whos held fees should be processed.  */   function processFees(uint256 _projectId)     external     virtual     override     requirePermissionAllowingOverride(       projects.ownerOf(_projectId),       _projectId,       JBOperations.PROCESS_FEES,       msg.sender == owner()     )   {     // Get a reference to the project's held fees.     JBFee[] memory _heldFees = _heldFeesOf[_projectId]; // Delete the held fees. delete _heldFeesOf[_projectId];  // Push array length in stack uint256 _heldFeeLength = _heldFees.length;  // Process each fee. for (uint256 _i = 0; _i &lt; _heldFeeLength; ) {   // Get the fee amount.   uint256 _amount = _feeAmount(     _heldFees[_i].amount,     _heldFees[_i].fee,     _heldFees[_i].feeDiscount   );    // Process the fee.   _processFee(_amount, _heldFees[_i].beneficiary);    emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);    unchecked {     ++_i;   } }  } /**     @notice     Allows the fee to be updated. @dev Only the owner of this contract can change the fee.  @param _fee The new fee, out of MAX_FEE.  */   function setFee(uint256 _fee) external virtual override onlyOwner {     // The provided fee must be within the max.     if (_fee &gt; _FEE_CAP) revert FEE_TOO_HIGH(); // Store the new fee. fee = _fee;  emit SetFee(_fee, msg.sender);  } /**     @notice     Allows the fee gauge to be updated. @dev Only the owner of this contract can change the fee gauge.  @dev If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.  @param _feeGauge The new fee gauge.  */   function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {     // Store the new fee gauge.     feeGauge = _feeGauge; emit SetFeeGauge(_feeGauge, msg.sender);  } /**     @notice     Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee. @dev Only the owner of this contract can set addresses as feeless.  @param _address The address that can be paid towards while still bypassing fees. @param _flag A flag indicating whether the terminal should be feeless or not.  */   function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {     // Set the flag value.     isFeelessAddress[_address] = _flag; emit SetFeelessAddress(_address, _flag, msg.sender);  } //***********//   // ---------------------- internal transactions ---------------------- //   //*************// /**      @notice     Transfers tokens. @param _from The address from which the transfer should originate. @param _to The address to which the transfer should go. @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.  */   function _transferFrom(     address _from,     address payable _to,     uint256 _amount   ) internal virtual; /**      @notice     Logic to be triggered before transferring tokens from this terminal. @param _to The address to which the transfer is going. @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.  */   function _beforeTransferTo(address _to, uint256 _amount) internal virtual; /**     @notice     Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source. @dev Only a token holder or a designated operator can redeem its tokens.  @param _holder The account to redeem tokens for. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal. @param _beneficiary The address to send the terminal tokens to. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.  */   function _redeemTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo,     bytes memory _metadata   ) internal returns (uint256 reclaimAmount) {     // Can't send reclaimed funds to the zero address.     if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS(); // Define variables that will be needed outside the scoped section below. // Keep a reference to the funding cycle during which the redemption is being made. JBFundingCycle memory _fundingCycle;  // Scoped section prevents stack too deep. `_delegate` only used within scope. {   IJBRedemptionDelegate _delegate;    // Record the redemption.   (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(     _holder,     _projectId,     _tokenCount,     _memo,     _metadata   );    // The amount being reclaimed must be at least as much as was expected.   if (reclaimAmount &lt; _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();    // Burn the project tokens.   if (_tokenCount &gt; 0)     IJBController(directory.controllerOf(_projectId)).burnTokensOf(       _holder,       _projectId,       _tokenCount,       '',       false     );    // If a delegate was returned by the data source, issue a callback to it.   if (_delegate != IJBRedemptionDelegate(address(0))) {     JBDidRedeemData memory _data = JBDidRedeemData(       _holder,       _projectId,       _fundingCycle.configuration,       _tokenCount,       JBTokenAmount(token, reclaimAmount, decimals, currency),       _beneficiary,       _memo,       _metadata     );     _delegate.didRedeem(_data);     emit DelegateDidRedeem(_delegate, _data, msg.sender);   } }  // Send the reclaimed funds to the beneficiary. if (reclaimAmount &gt; 0) _transferFrom(address(this), _beneficiary, reclaimAmount);  emit RedeemTokens(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _holder,   _beneficiary,   _tokenCount,   reclaimAmount,   _memo,   _metadata,   msg.sender );  } /**     @notice     Distributes payouts for a project with the distribution limit of its current funding cycle. @dev Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.  @dev Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.  @dev All funds distributed outside of this contract or any feeless terminals incure the protocol fee.  @param _projectId The ID of the project having its payouts distributed. @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency. @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal. @param _memo A memo to pass along to the emitted event.  @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.  */   function _distributePayoutsOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     uint256 _minReturnedTokens,     string calldata _memo   ) internal returns (uint256 netLeftoverDistributionAmount) {     // Record the distribution.     (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(       _projectId,       _amount,       _currency     ); // The amount being distributed must be at least as much as was expected. if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();  // Get a reference to the project owner, which will receive tokens from paying the platform fee // and receive any extra distributable funds not allocated to payout splits. address payable _projectOwner = payable(projects.ownerOf(_projectId));  // Define variables that will be needed outside the scoped section below. // Keep a reference to the fee amount that was paid. uint256 _fee;  // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope. {   // Get the amount of discount that should be applied to any fees taken.   // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.   uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]     ? JBConstants.MAX_FEE_DISCOUNT     : _currentFeeDiscount(_projectId);    // The amount distributed that is eligible for incurring fees.   uint256 _feeEligibleDistributionAmount;    // The amount leftover after distributing to the splits.   uint256 _leftoverDistributionAmount;    // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.   // Also get a reference to the amount that was distributed to splits from which fees should be taken.   (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(     _projectId,     _fundingCycle.configuration,     payoutSplitsGroup,     _distributedAmount,     _feeDiscount   );    // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.   unchecked {     _feeEligibleDistributionAmount += _leftoverDistributionAmount;   }    // Take the fee.   _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0     ? 0     : _takeFeeFrom(       _projectId,       _fundingCycle,       _feeEligibleDistributionAmount,       _projectOwner,       _feeDiscount     );    // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.    unchecked {     netLeftoverDistributionAmount = _leftoverDistributionAmount == 0       ? 0       : _leftoverDistributionAmount -         _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);   }    // Transfer any remaining balance to the project owner.   if (netLeftoverDistributionAmount &gt; 0)     _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount); }  emit DistributePayouts(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _projectOwner,   _amount,   _distributedAmount,   _fee,   netLeftoverDistributionAmount,   _memo,   msg.sender );  } /**     @notice     Allows a project to send funds from its overflow up to the preconfigured allowance. @dev Only a project's owner or a designated operator can use its allowance.  @dev Incurs the protocol fee.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency. @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals. @param _beneficiary The address to send the funds to. @param _memo A memo to pass along to the emitted event.  @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.  */   function _useAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo   ) internal returns (uint256 netDistributedAmount) {     // Record the use of the allowance.     (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(       _projectId,       _amount,       _currency     ); // The amount being withdrawn must be at least as much as was expected. if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();  // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope. {   // Keep a reference to the fee amount that was paid.   uint256 _fee;    // Get a reference to the project owner, which will receive tokens from paying the platform fee.   address _projectOwner = projects.ownerOf(_projectId);    // Get the amount of discount that should be applied to any fees taken.   // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.   uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]     ? JBConstants.MAX_FEE_DISCOUNT     : _currentFeeDiscount(_projectId);    // Take a fee from the `_distributedAmount`, if needed.   _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT     ? 0     : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);    unchecked {     // The net amount is the withdrawn amount without the fee.     netDistributedAmount = _distributedAmount - _fee;   }    // Transfer any remaining balance to the beneficiary.   if (netDistributedAmount &gt; 0)     _transferFrom(address(this), _beneficiary, netDistributedAmount); }  emit UseAllowance(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _beneficiary,   _amount,   _distributedAmount,   netDistributedAmount,   _memo,   msg.sender );  } /**     @notice     Pays out splits for a project's funding cycle configuration. @param _projectId The ID of the project for which payout splits are being distributed. @param _domain The domain of the splits to distribute the payout between. @param _group The group of the splits to distribute the payout between. @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal. @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.  @return leftoverAmount If the leftover amount if the splits don't add up to 100%. @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.  */   function _distributeToPayoutSplitsOf(     uint256 _projectId,     uint256 _domain,     uint256 _group,     uint256 _amount,     uint256 _feeDiscount   ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {     // Set the leftover amount to the initial amount.     leftoverAmount = _amount; // Get a reference to the project's payout splits. JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);  // Transfer between all splits. for (uint256 _i = 0; _i &lt; _splits.length; ) {   // Get a reference to the split being iterated on.   JBSplit memory _split = _splits[_i];    // The amount to send towards the split.   uint256 _payoutAmount = PRBMath.mulDiv(     _amount,     _split.percent,     JBConstants.SPLITS_TOTAL_PERCENT   );    // The payout amount substracting any applicable incurred fees.   uint256 _netPayoutAmount;    if (_payoutAmount &gt; 0) {     // Transfer tokens to the split.     // If there's an allocator set, transfer to its `allocate` function.     if (_split.allocator != IJBSplitAllocator(address(0))) {       // If the split allocator is set as feeless, this distribution is not eligible for a fee.       if (isFeelessAddress[address(_split.allocator)])         _netPayoutAmount = _payoutAmount;         // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.       else {         unchecked {           _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT             ? _payoutAmount             : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);         }          // This distribution is eligible for a fee since the funds are leaving the ecosystem.         feeEligibleDistributionAmount += _payoutAmount;       }        // Trigger any inherited pre-transfer logic.       _beforeTransferTo(address(_split.allocator), _netPayoutAmount);        // If this terminal's token is ETH, send it in msg.value.       uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;        // Create the data to send to the allocator.       JBSplitAllocationData memory _data = JBSplitAllocationData(         token,         _netPayoutAmount,         decimals,         _projectId,         _group,         _split       );        // Trigger the allocator's `allocate` function.       _split.allocator.allocate{value: _payableValue}(_data);        // Otherwise, if a project is specified, make a payment to it.     } else if (_split.projectId != 0) {       // Get a reference to the Juicebox terminal being used.       IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);        // The project must have a terminal to send funds to.       if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();        // Save gas if this contract is being used as the terminal.       if (_terminal == this) {         // This distribution does not incur a fee.         _netPayoutAmount = _payoutAmount;          // Send the projectId in the metadata.         bytes memory _projectMetadata = new bytes(32);         _projectMetadata = bytes(abi.encodePacked(_projectId));          // Add to balance if prefered.         if (_split.preferAddToBalance)           _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);         else           _pay(             _netPayoutAmount,             address(this),             _split.projectId,             (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,             0,             _split.preferClaimed,             '',             _projectMetadata           );       } else {         // If the terminal is set as feeless, this distribution is not eligible for a fee.         if (isFeelessAddress[address(_terminal)])           _netPayoutAmount = _payoutAmount;           // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.         else {           unchecked {             _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT               ? _payoutAmount               : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);           }            feeEligibleDistributionAmount += _payoutAmount;         }          // Trigger any inherited pre-transfer logic.         _beforeTransferTo(address(_terminal), _netPayoutAmount);          // If this terminal's token is ETH, send it in msg.value.         uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;          // Send the projectId in the metadata.         bytes memory _projectMetadata = new bytes(32);         _projectMetadata = bytes(abi.encodePacked(_projectId));          // Add to balance if prefered.         if (_split.preferAddToBalance)           _terminal.addToBalanceOf{value: _payableValue}(             _split.projectId,             _netPayoutAmount,             token,             '',             _projectMetadata           );         else           _terminal.pay{value: _payableValue}(             _split.projectId,             _netPayoutAmount,             token,             _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,             0,             _split.preferClaimed,             '',             _projectMetadata           );       }     } else {       unchecked {         _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT           ? _payoutAmount           : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);       }        // This distribution is eligible for a fee since the funds are leaving the ecosystem.       feeEligibleDistributionAmount += _payoutAmount;        // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.       _transferFrom(         address(this),         _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),         _netPayoutAmount       );     }      // Subtract from the amount to be sent to the beneficiary.     unchecked {       leftoverAmount = leftoverAmount - _payoutAmount;     }   }    emit DistributeToPayoutSplit(     _projectId,     _domain,     _group,     _split,     _netPayoutAmount,     msg.sender   );    unchecked {     ++_i;   } }  } /**     @notice     Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID. @param _projectId The ID of the project having fees taken from. @param _fundingCycle The funding cycle during which the fee is being taken. @param _amount The amount of the fee to take, as a floating point number with 18 decimals. @param _beneficiary The address to mint the platforms tokens for. @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.  @return feeAmount The amount of the fee taken.  */   function _takeFeeFrom(     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _amount,     address _beneficiary,     uint256 _feeDiscount   ) internal returns (uint256 feeAmount) {     feeAmount = _feeAmount(_amount, fee, _feeDiscount); if (_fundingCycle.shouldHoldFees()) {   // Store the held fee.   _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));    emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender); } else {   // Process the fee.   _processFee(feeAmount, _beneficiary); // Take the fee.    emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender); }  } /**     @notice     Process a fee of the specified amount. @param _amount The fee amount, as a floating point number with 18 decimals. @param _beneficiary The address to mint the platform's tokens for.  */   function _processFee(uint256 _amount, address _beneficiary) internal {     // Get the terminal for the protocol project.     IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token); // When processing the admin fee, save gas if the admin is using this contract as its terminal. if (_terminal == this)   _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call. else {   // Trigger any inherited pre-transfer logic.   _beforeTransferTo(address(_terminal), _amount);    // If this terminal's token is ETH, send it in msg.value.   uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;    // Send the payment.   _terminal.pay{value: _payableValue}(     _PROTOCOL_PROJECT_ID,     _amount,     token,     _beneficiary,     0,     false,     '',     bytes('')   ); // Use the external pay call of the correct terminal. }  } /**     @notice     Contribute tokens to a project. @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place. @param _payer The address making the payment. @param _projectId The ID of the project being paid. @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate. @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal. @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas. @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.  */   function _pay(     uint256 _amount,     address _payer,     uint256 _projectId,     address _beneficiary,     uint256 _minReturnedTokens,     bool _preferClaimedTokens,     string memory _memo,     bytes memory _metadata   ) internal returns (uint256 beneficiaryTokenCount) {     // Cant send tokens to the zero address.     if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS(); // Define variables that will be needed outside the scoped section below. // Keep a reference to the funding cycle during which the payment is being made. JBFundingCycle memory _fundingCycle;  // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope. {   IJBPayDelegate _delegate;   uint256 _tokenCount;    // Bundle the amount info into a JBTokenAmount struct.   JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);    // Record the payment.   (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(     _payer,     _bundledAmount,     _projectId,     baseWeightCurrency,     _beneficiary,     _memo,     _metadata   );    // Mint the tokens if needed.   if (_tokenCount &gt; 0)     // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.     beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(       _projectId,       _tokenCount,       _beneficiary,       '',       _preferClaimedTokens,       true     );    // The token count for the beneficiary must be greater than or equal to the minimum expected.   if (beneficiaryTokenCount &lt; _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();    // If a delegate was returned by the data source, issue a callback to it.   if (_delegate != IJBPayDelegate(address(0))) {     JBDidPayData memory _data = JBDidPayData(       _payer,       _projectId,       _fundingCycle.configuration,       _bundledAmount,       beneficiaryTokenCount,       _beneficiary,       _preferClaimedTokens,       _memo,       _metadata     );      _delegate.didPay(_data);     emit DelegateDidPay(_delegate, _data, msg.sender);   } }  emit Pay(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _payer,   _beneficiary,   _amount,   beneficiaryTokenCount,   _memo,   _metadata,   msg.sender );  } /**     @notice     Receives funds belonging to the specified project. @param _projectId The ID of the project to which the funds received belong. @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead. @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added. @param _memo A memo to pass along to the emitted event. @param _metadata Extra data to pass along to the emitted event.  */   function _addToBalanceOf(     uint256 _projectId,     uint256 _amount,     bool _shouldRefundHeldFees,     string memory _memo,     bytes memory _metadata   ) internal {     // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.     uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0; // Record the added funds with any refunded fees. store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);  emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);  } /**     @notice     Refund fees based on the specified amount. @param _projectId The project for which fees are being refunded. @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.  @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal  */   function _refundHeldFees(uint256 _projectId, uint256 _amount)     internal     returns (uint256 refundedFees)   {     // Get a reference to the project's held fees.     JBFee[] memory _heldFees = _heldFeesOf[_projectId]; // Delete the current held fees. delete _heldFeesOf[_projectId];  // Get a reference to the leftover amount once all fees have been settled. uint256 leftoverAmount = _amount;  // Push length in stack uint256 _heldFeesLength = _heldFees.length;  // Process each fee. for (uint256 _i = 0; _i &lt; _heldFeesLength; ) {   if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);   else if (leftoverAmount &gt;= _heldFees[_i].amount) {     unchecked {       leftoverAmount = leftoverAmount - _heldFees[_i].amount;       refundedFees += _feeAmount(         _heldFees[_i].amount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount       );     }   } else {     _heldFeesOf[_projectId].push(       JBFee(         _heldFees[_i].amount - leftoverAmount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount,         _heldFees[_i].beneficiary       )     );     unchecked {       refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);     }     leftoverAmount = 0;   }    unchecked {     ++_i;   } }  emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);  } /**      @notice      Returns the fee amount based on the provided amount for the specified project. @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal. @param _fee The percentage of the fee, out of MAX_FEE.  @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.  @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.  */   function _feeAmount(     uint256 _amount,     uint256 _fee,     uint256 _feeDiscount   ) internal pure returns (uint256) {     // Calculate the discounted fee.     uint256 _discountedFee = _fee -       PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT); // The amount of tokens from the `_amount` to pay as a fee. return   _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);  } /**      @notice     Get the fee discount from the fee gauge for the specified project. @param _projectId The ID of the project to get a fee discount for.  @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.  */   function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {     // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.     if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))       return JBConstants.MAX_FEE_DISCOUNT; // Get the fee discount. if (feeGauge == IJBFeeGauge(address(0)))   feeDiscount = 0;   // If the guage reverts, set the discount to 0. else   try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {     feeDiscount = discount;   } catch {     feeDiscount = 0;   }  // If the fee discount is greater than the max, nullify the discount. if (feeDiscount &gt; JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 17:17:30 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './../interfaces/IJBController.sol';
import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol';
import './../libraries/JBConstants.sol';
import './../libraries/JBCurrencies.sol';
import './../libraries/JBFixedPointNumber.sol';
import './../libraries/JBFundingCycleMetadataResolver.sol';
import './../libraries/JBOperations.sol';
import './../libraries/JBSplitsGroups.sol';
import './../libraries/JBTokens.sol';
import './../structs/JBTokenAmount.sol';
import './JBOperatable.sol';
import './JBSingleTokenPaymentTerminal.sol';

/**
  @notice
  Generic terminal managing all inflows and outflows of funds into the protocol ecosystem.

  @dev
  A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time.

  @dev
  Adheres to -
  IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.
  JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
abstract contract JBPayoutRedemptionPaymentTerminal is
  IJBPayoutRedemptionPaymentTerminal,
  JBSingleTokenPaymentTerminal,
  JBOperatable,
  Ownable,
  ReentrancyGuard
{
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error FEE_TOO_HIGH();
  error INADEQUATE_DISTRIBUTION_AMOUNT();
  error INADEQUATE_RECLAIM_AMOUNT();
  error INADEQUATE_TOKEN_COUNT();
  error NO_MSG_VALUE_ALLOWED();
  error PAY_TO_ZERO_ADDRESS();
  error PROJECT_TERMINAL_MISMATCH();
  error REDEEM_TO_ZERO_ADDRESS();
  error TERMINAL_IN_SPLIT_ZERO_ADDRESS();
  error TERMINAL_TOKENS_INCOMPATIBLE();

  //*********************************************************************//
  // ---------------------------- modifiers ---------------------------- //
  //*********************************************************************//

  /** 
    @notice 
    A modifier that verifies this terminal is a terminal of provided project ID.
  */
  modifier isTerminalOf(uint256 _projectId) {
    if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();
    _;
  }

  //*********************************************************************//
  // --------------------- internal stored constants ------------------- //
  //*********************************************************************//

  /**
    @notice
    Maximum fee that can be set for a funding cycle configuration.

    @dev
    Out of MAX_FEE (50_000_000 / 1_000_000_000).
  */
  uint256 internal constant _FEE_CAP = 50_000_000;

  /**
    @notice
    The protocol project ID is 1, as it should be the first project launched during the deployment process.
  */
  uint256 internal constant _PROTOCOL_PROJECT_ID = 1;

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    Fees that are being held to be processed later.

    _projectId The ID of the project for which fees are being held.
  */
  mapping(uint256 => JBFee[]) internal _heldFeesOf;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership and transfers.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  /**
    @notice
    The contract that stores and manages the terminal's data.
  */
  IJBSingleTokenPaymentTerminalStore public immutable override store;

  /**
    @notice
    The currency to base token issuance on.

    @dev
    If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.
  */
  uint256 public immutable override baseWeightCurrency;

  /**
    @notice
    The group that payout splits coming from this terminal are identified by.
  */
  uint256 public immutable override payoutSplitsGroup;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The platform fee percent.

    @dev
    Out of MAX_FEE (25_000_000 / 1_000_000_000)
  */
  uint256 public override fee = 25_000_000; // 2.5%

  /**
    @notice
    The data source that returns a discount to apply to a project's fee.
  */
  IJBFeeGauge public override feeGauge;

  /**
    @notice
    Addresses that can be paid towards from this terminal without incurring a fee.

    _address The address that can be paid toward.
  */
  mapping(address => bool) public override isFeelessAddress;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.

    @dev
    The current overflow is represented as a fixed point number with 18 decimals.

    @param _projectId The ID of the project to get overflow for.

    @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.
  */
  function currentEthOverflowOf(uint256 _projectId)
    external
    view
    virtual
    override
    returns (uint256)
  {
    // Get this terminal's current overflow.
    uint256 _overflow = store.currentOverflowOf(this, _projectId);

    // Adjust the decimals of the fixed point number if needed to have 18 decimals.
    uint256 _adjustedOverflow = (decimals == 18)
      ? _overflow
      : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);

    // Return the amount converted to ETH.
    return
      (currency == JBCurrencies.ETH)
        ? _adjustedOverflow
        : PRBMath.mulDiv(
          _adjustedOverflow,
          10**decimals,
          prices.priceFor(currency, JBCurrencies.ETH, decimals)
        );
  }

  /**
    @notice
    The fees that are currently being held to be processed later for each project.

    @param _projectId The ID of the project for which fees are being held.

    @return An array of fees that are being held.
  */
  function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {
    return _heldFeesOf[_projectId];
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(JBSingleTokenPaymentTerminal, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||
      _interfaceId == type(IJBPayoutTerminal).interfaceId ||
      _interfaceId == type(IJBAllowanceTerminal).interfaceId ||
      _interfaceId == type(IJBRedemptionTerminal).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _token The token that this terminal manages.
    @param _decimals The number of decimals the token fixed point amounts are expected to have.
    @param _currency The currency that this terminal's token adheres to for price feeds.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _splitsStore A contract that stores splits for each project.
    @param _prices A contract that exposes price feeds.
    @param _store A contract that stores the terminal's data.
    @param _owner The address that will own this contract.
  */
  constructor(
    // payable constructor save the gas used to check msg.value==0
    address _token,
    uint256 _decimals,
    uint256 _currency,
    uint256 _baseWeightCurrency,
    uint256 _payoutSplitsGroup,
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBSplitsStore _splitsStore,
    IJBPrices _prices,
    IJBSingleTokenPaymentTerminalStore _store,
    address _owner
  )
    payable
    JBSingleTokenPaymentTerminal(_token, _decimals, _currency)
    JBOperatable(_operatorStore)
  {
    baseWeightCurrency = _baseWeightCurrency;
    payoutSplitsGroup = _payoutSplitsGroup;
    projects = _projects;
    directory = _directory;
    splitsStore = _splitsStore;
    prices = _prices;
    store = _store;

    transferOwnership(_owner);
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Contribute tokens to a project.

    @param _projectId The ID of the project being paid.
    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _token The token being paid. This terminal ignores this property since it only manages one token. 
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function pay(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {
    _token; // Prevents unused var compiler and natspec complaints.

    // ETH shouldn't be sent if this terminal's token isn't ETH.
    if (token != JBTokens.ETH) {
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If this terminal's token is ETH, override _amount with msg.value.
    else _amount = msg.value;

    return
      _pay(
        _amount,
        msg.sender,
        _projectId,
        _beneficiary,
        _minReturnedTokens,
        _preferClaimedTokens,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _token The token being reclaimed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  )
    external
    virtual
    override
    requirePermission(_holder, _projectId, JBOperations.REDEEM)
    returns (uint256 reclaimAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return
      _redeemTokensOf(
        _holder,
        _projectId,
        _tokenCount,
        _minReturnedTokens,
        _beneficiary,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) external virtual override returns (uint256 netLeftoverDistributionAmount) {
    _token; // Prevents unused var compiler and natspec complaints.

    return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)
    returns (uint256 netDistributedAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);
  }

  /**
    @notice
    Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project being migrated.
    @param _to The terminal contract that will gain the project's funds.

    @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.
  */
  function migrate(uint256 _projectId, IJBPaymentTerminal _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)
    returns (uint256 balance)
  {
    // The terminal being migrated to must accept the same token as this terminal.
    if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE();

    // Record the migration in the store.
    balance = store.recordMigration(_projectId);

    // Transfer the balance if needed.
    if (balance > 0) {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_to), balance);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? balance : 0;

      // Withdraw the balance to transfer to the new terminal;
      _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes(''));
    }

    emit Migrate(_projectId, _to, balance, msg.sender);
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _token The token being paid. This terminal ignores this property since it only manages one currency. 
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) {
    _token; // Prevents unused var compiler and natspec complaints.

    // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender.
    if (token != JBTokens.ETH) {
      // Amount must be greater than 0.
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If the terminal's token is ETH, override `_amount` with msg.value.
    else _amount = msg.value;

    // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal.
    _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);
  }

  /**
    @notice
    Process any fees that are being held for the project.

    @dev
    Only a project owner, an operator, or the contract's owner can process held fees.

    @param _projectId The ID of the project whos held fees should be processed.
  */
  function processFees(uint256 _projectId)
    external
    virtual
    override
    requirePermissionAllowingOverride(
      projects.ownerOf(_projectId),
      _projectId,
      JBOperations.PROCESS_FEES,
      msg.sender == owner()
    )
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the held fees.
    delete _heldFeesOf[_projectId];

    // Push array length in stack
    uint256 _heldFeeLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeeLength; ) {
      // Get the fee amount.
      uint256 _amount = _feeAmount(
        _heldFees[_i].amount,
        _heldFees[_i].fee,
        _heldFees[_i].feeDiscount
      );

      // Process the fee.
      _processFee(_amount, _heldFees[_i].beneficiary);

      emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Allows the fee to be updated.

    @dev
    Only the owner of this contract can change the fee.

    @param _fee The new fee, out of MAX_FEE.
  */
  function setFee(uint256 _fee) external virtual override onlyOwner {
    // The provided fee must be within the max.
    if (_fee > _FEE_CAP) revert FEE_TOO_HIGH();

    // Store the new fee.
    fee = _fee;

    emit SetFee(_fee, msg.sender);
  }

  /**
    @notice
    Allows the fee gauge to be updated.

    @dev
    Only the owner of this contract can change the fee gauge.

    @dev
    If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.

    @param _feeGauge The new fee gauge.
  */
  function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {
    // Store the new fee gauge.
    feeGauge = _feeGauge;

    emit SetFeeGauge(_feeGauge, msg.sender);
  }

  /**
    @notice
    Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.

    @dev
    Only the owner of this contract can set addresses as feeless.

    @param _address The address that can be paid towards while still bypassing fees.
    @param _flag A flag indicating whether the terminal should be feeless or not.
  */
  function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {
    // Set the flag value.
    isFeelessAddress[_address] = _flag;

    emit SetFeelessAddress(_address, _flag, msg.sender);
  }

  //*********************************************************************//
  // ---------------------- internal transactions ---------------------- //
  //*********************************************************************//

  /** 
    @notice
    Transfers tokens.

    @param _from The address from which the transfer should originate.
    @param _to The address to which the transfer should go.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _transferFrom(
    address _from,
    address payable _to,
    uint256 _amount
  ) internal virtual;

  /** 
    @notice
    Logic to be triggered before transferring tokens from this terminal.

    @param _to The address to which the transfer is going.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _beforeTransferTo(address _to, uint256 _amount) internal virtual;

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function _redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 reclaimAmount) {
    // Can't send reclaimed funds to the zero address.
    if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the redemption is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` only used within scope.
    {
      IJBRedemptionDelegate _delegate;

      // Record the redemption.
      (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(
        _holder,
        _projectId,
        _tokenCount,
        _memo,
        _metadata
      );

      // The amount being reclaimed must be at least as much as was expected.
      if (reclaimAmount < _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();

      // Burn the project tokens.
      if (_tokenCount > 0)
        IJBController(directory.controllerOf(_projectId)).burnTokensOf(
          _holder,
          _projectId,
          _tokenCount,
          '',
          false
        );

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBRedemptionDelegate(address(0))) {
        JBDidRedeemData memory _data = JBDidRedeemData(
          _holder,
          _projectId,
          _fundingCycle.configuration,
          _tokenCount,
          JBTokenAmount(token, reclaimAmount, decimals, currency),
          _beneficiary,
          _memo,
          _metadata
        );
        _delegate.didRedeem(_data);
        emit DelegateDidRedeem(_delegate, _data, msg.sender);
      }
    }

    // Send the reclaimed funds to the beneficiary.
    if (reclaimAmount > 0) _transferFrom(address(this), _beneficiary, reclaimAmount);

    emit RedeemTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _holder,
      _beneficiary,
      _tokenCount,
      reclaimAmount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) internal returns (uint256 netLeftoverDistributionAmount) {
    // Record the distribution.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(
      _projectId,
      _amount,
      _currency
    );

    // The amount being distributed must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Get a reference to the project owner, which will receive tokens from paying the platform fee
    // and receive any extra distributable funds not allocated to payout splits.
    address payable _projectOwner = payable(projects.ownerOf(_projectId));

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the fee amount that was paid.
    uint256 _fee;

    // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope.
    {
      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // The amount distributed that is eligible for incurring fees.
      uint256 _feeEligibleDistributionAmount;

      // The amount leftover after distributing to the splits.
      uint256 _leftoverDistributionAmount;

      // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.
      // Also get a reference to the amount that was distributed to splits from which fees should be taken.
      (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        payoutSplitsGroup,
        _distributedAmount,
        _feeDiscount
      );

      // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.
      unchecked {
        _feeEligibleDistributionAmount += _leftoverDistributionAmount;
      }

      // Take the fee.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0
        ? 0
        : _takeFeeFrom(
          _projectId,
          _fundingCycle,
          _feeEligibleDistributionAmount,
          _projectOwner,
          _feeDiscount
        );

      // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.

      unchecked {
        netLeftoverDistributionAmount = _leftoverDistributionAmount == 0
          ? 0
          : _leftoverDistributionAmount -
            _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);
      }

      // Transfer any remaining balance to the project owner.
      if (netLeftoverDistributionAmount > 0)
        _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount);
    }

    emit DistributePayouts(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _projectOwner,
      _amount,
      _distributedAmount,
      _fee,
      netLeftoverDistributionAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function _useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  ) internal returns (uint256 netDistributedAmount) {
    // Record the use of the allowance.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(
      _projectId,
      _amount,
      _currency
    );

    // The amount being withdrawn must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope.
    {
      // Keep a reference to the fee amount that was paid.
      uint256 _fee;

      // Get a reference to the project owner, which will receive tokens from paying the platform fee.
      address _projectOwner = projects.ownerOf(_projectId);

      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // Take a fee from the `_distributedAmount`, if needed.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
        ? 0
        : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);

      unchecked {
        // The net amount is the withdrawn amount without the fee.
        netDistributedAmount = _distributedAmount - _fee;
      }

      // Transfer any remaining balance to the beneficiary.
      if (netDistributedAmount > 0)
        _transferFrom(address(this), _beneficiary, netDistributedAmount);
    }

    emit UseAllowance(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _beneficiary,
      _amount,
      _distributedAmount,
      netDistributedAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Pays out splits for a project's funding cycle configuration.

    @param _projectId The ID of the project for which payout splits are being distributed.
    @param _domain The domain of the splits to distribute the payout between.
    @param _group The group of the splits to distribute the payout between.
    @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return leftoverAmount If the leftover amount if the splits don't add up to 100%.
    @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.
  */
  function _distributeToPayoutSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount,
    uint256 _feeDiscount
  ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's payout splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    // Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; ) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _payoutAmount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // The payout amount substracting any applicable incurred fees.
      uint256 _netPayoutAmount;

      if (_payoutAmount > 0) {
        // Transfer tokens to the split.
        // If there's an allocator set, transfer to its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0))) {
          // If the split allocator is set as feeless, this distribution is not eligible for a fee.
          if (isFeelessAddress[address(_split.allocator)])
            _netPayoutAmount = _payoutAmount;
            // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.
          else {
            unchecked {
              _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                ? _payoutAmount
                : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
            }

            // This distribution is eligible for a fee since the funds are leaving the ecosystem.
            feeEligibleDistributionAmount += _payoutAmount;
          }

          // Trigger any inherited pre-transfer logic.
          _beforeTransferTo(address(_split.allocator), _netPayoutAmount);

          // If this terminal's token is ETH, send it in msg.value.
          uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

          // Create the data to send to the allocator.
          JBSplitAllocationData memory _data = JBSplitAllocationData(
            token,
            _netPayoutAmount,
            decimals,
            _projectId,
            _group,
            _split
          );

          // Trigger the allocator's `allocate` function.
          _split.allocator.allocate{value: _payableValue}(_data);

          // Otherwise, if a project is specified, make a payment to it.
        } else if (_split.projectId != 0) {
          // Get a reference to the Juicebox terminal being used.
          IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);

          // The project must have a terminal to send funds to.
          if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();

          // Save gas if this contract is being used as the terminal.
          if (_terminal == this) {
            // This distribution does not incur a fee.
            _netPayoutAmount = _payoutAmount;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);
            else
              _pay(
                _netPayoutAmount,
                address(this),
                _split.projectId,
                (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          } else {
            // If the terminal is set as feeless, this distribution is not eligible for a fee.
            if (isFeelessAddress[address(_terminal)])
              _netPayoutAmount = _payoutAmount;
              // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.
            else {
              unchecked {
                _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                  ? _payoutAmount
                  : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
              }

              feeEligibleDistributionAmount += _payoutAmount;
            }

            // Trigger any inherited pre-transfer logic.
            _beforeTransferTo(address(_terminal), _netPayoutAmount);

            // If this terminal's token is ETH, send it in msg.value.
            uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _terminal.addToBalanceOf{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                '',
                _projectMetadata
              );
            else
              _terminal.pay{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          }
        } else {
          unchecked {
            _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
              ? _payoutAmount
              : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
          }

          // This distribution is eligible for a fee since the funds are leaving the ecosystem.
          feeEligibleDistributionAmount += _payoutAmount;

          // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.
          _transferFrom(
            address(this),
            _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),
            _netPayoutAmount
          );
        }

        // Subtract from the amount to be sent to the beneficiary.
        unchecked {
          leftoverAmount = leftoverAmount - _payoutAmount;
        }
      }

      emit DistributeToPayoutSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _netPayoutAmount,
        msg.sender
      );

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID.

    @param _projectId The ID of the project having fees taken from.
    @param _fundingCycle The funding cycle during which the fee is being taken.
    @param _amount The amount of the fee to take, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platforms tokens for.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return feeAmount The amount of the fee taken.
  */
  function _takeFeeFrom(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _amount,
    address _beneficiary,
    uint256 _feeDiscount
  ) internal returns (uint256 feeAmount) {
    feeAmount = _feeAmount(_amount, fee, _feeDiscount);

    if (_fundingCycle.shouldHoldFees()) {
      // Store the held fee.
      _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));

      emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender);
    } else {
      // Process the fee.
      _processFee(feeAmount, _beneficiary); // Take the fee.

      emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender);
    }
  }

  /**
    @notice
    Process a fee of the specified amount.

    @param _amount The fee amount, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platform's tokens for.
  */
  function _processFee(uint256 _amount, address _beneficiary) internal {
    // Get the terminal for the protocol project.
    IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token);

    // When processing the admin fee, save gas if the admin is using this contract as its terminal.
    if (_terminal == this)
      _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call.
    else {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_terminal), _amount);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;

      // Send the payment.
      _terminal.pay{value: _payableValue}(
        _PROTOCOL_PROJECT_ID,
        _amount,
        token,
        _beneficiary,
        0,
        false,
        '',
        bytes('')
      ); // Use the external pay call of the correct terminal.
    }
  }

  /**
    @notice
    Contribute tokens to a project.

    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _payer The address making the payment.
    @param _projectId The ID of the project being paid.
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function _pay(
    uint256 _amount,
    address _payer,
    uint256 _projectId,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 beneficiaryTokenCount) {
    // Cant send tokens to the zero address.
    if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the payment is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope.
    {
      IJBPayDelegate _delegate;
      uint256 _tokenCount;

      // Bundle the amount info into a JBTokenAmount struct.
      JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);

      // Record the payment.
      (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(
        _payer,
        _bundledAmount,
        _projectId,
        baseWeightCurrency,
        _beneficiary,
        _memo,
        _metadata
      );

      // Mint the tokens if needed.
      if (_tokenCount > 0)
        // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.
        beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(
          _projectId,
          _tokenCount,
          _beneficiary,
          '',
          _preferClaimedTokens,
          true
        );

      // The token count for the beneficiary must be greater than or equal to the minimum expected.
      if (beneficiaryTokenCount < _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBPayDelegate(address(0))) {
        JBDidPayData memory _data = JBDidPayData(
          _payer,
          _projectId,
          _fundingCycle.configuration,
          _bundledAmount,
          beneficiaryTokenCount,
          _beneficiary,
          _preferClaimedTokens,
          _memo,
          _metadata
        );

        _delegate.didPay(_data);
        emit DelegateDidPay(_delegate, _data, msg.sender);
      }
    }

    emit Pay(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _payer,
      _beneficiary,
      _amount,
      beneficiaryTokenCount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function _addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    bool _shouldRefundHeldFees,
    string memory _memo,
    bytes memory _metadata
  ) internal {
    // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.
    uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0;

    // Record the added funds with any refunded fees.
    store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);

    emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);
  }

  /**
    @notice
    Refund fees based on the specified amount.

    @param _projectId The project for which fees are being refunded.
    @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.

    @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal
  */
  function _refundHeldFees(uint256 _projectId, uint256 _amount)
    internal
    returns (uint256 refundedFees)
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the current held fees.
    delete _heldFeesOf[_projectId];

    // Get a reference to the leftover amount once all fees have been settled.
    uint256 leftoverAmount = _amount;

    // Push length in stack
    uint256 _heldFeesLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeesLength; ) {
      if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);
      else if (leftoverAmount >= _heldFees[_i].amount) {
        unchecked {
          leftoverAmount = leftoverAmount - _heldFees[_i].amount;
          refundedFees += _feeAmount(
            _heldFees[_i].amount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount
          );
        }
      } else {
        _heldFeesOf[_projectId].push(
          JBFee(
            _heldFees[_i].amount - leftoverAmount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount,
            _heldFees[_i].beneficiary
          )
        );
        unchecked {
          refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);
        }
        leftoverAmount = 0;
      }

      unchecked {
        ++_i;
      }
    }

    emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);
  }

  /** 
    @notice 
    Returns the fee amount based on the provided amount for the specified project.

    @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal.
    @param _fee The percentage of the fee, out of MAX_FEE. 
    @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.

    @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _feeAmount(
    uint256 _amount,
    uint256 _fee,
    uint256 _feeDiscount
  ) internal pure returns (uint256) {
    // Calculate the discounted fee.
    uint256 _discountedFee = _fee -
      PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT);

    // The amount of tokens from the `_amount` to pay as a fee.
    return
      _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);
  }

  /** 
    @notice
    Get the fee discount from the fee gauge for the specified project.

    @param _projectId The ID of the project to get a fee discount for.
    
    @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.
  */
  function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {
    // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.
    if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))
      return JBConstants.MAX_FEE_DISCOUNT;

    // Get the fee discount.
    if (feeGauge == IJBFeeGauge(address(0)))
      feeDiscount = 0;
      // If the guage reverts, set the discount to 0.
    else
      try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {
        feeDiscount = discount;
      } catch {
        feeDiscount = 0;
      }

    // If the fee discount is greater than the max, nullify the discount.
    if (feeDiscount > JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;
  }
}
.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './../interfaces/IJBController.sol';
import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol';
import './../libraries/JBConstants.sol';
import './../libraries/JBCurrencies.sol';
import './../libraries/JBFixedPointNumber.sol';
import './../libraries/JBFundingCycleMetadataResolver.sol';
import './../libraries/JBOperations.sol';
import './../libraries/JBSplitsGroups.sol';
import './../libraries/JBTokens.sol';
import './../structs/JBTokenAmount.sol';
import './JBOperatable.sol';
import './JBSingleTokenPaymentTerminal.sol';

/**
  @notice
  Generic terminal managing all inflows and outflows of funds into the protocol ecosystem.

  @dev
  A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time.

  @dev
  Adheres to -
  IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.
  JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
abstract contract JBPayoutRedemptionPaymentTerminal is
  IJBPayoutRedemptionPaymentTerminal,
  JBSingleTokenPaymentTerminal,
  JBOperatable,
  Ownable,
  ReentrancyGuard
{
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error FEE_TOO_HIGH();
  error INADEQUATE_DISTRIBUTION_AMOUNT();
  error INADEQUATE_RECLAIM_AMOUNT();
  error INADEQUATE_TOKEN_COUNT();
  error NO_MSG_VALUE_ALLOWED();
  error PAY_TO_ZERO_ADDRESS();
  error PROJECT_TERMINAL_MISMATCH();
  error REDEEM_TO_ZERO_ADDRESS();
  error TERMINAL_IN_SPLIT_ZERO_ADDRESS();
  error TERMINAL_TOKENS_INCOMPATIBLE();

  //*********************************************************************//
  // ---------------------------- modifiers ---------------------------- //
  //*********************************************************************//

  /** 
    @notice 
    A modifier that verifies this terminal is a terminal of provided project ID.
  */
  modifier isTerminalOf(uint256 _projectId) {
    if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();
    _;
  }

  //*********************************************************************//
  // --------------------- internal stored constants ------------------- //
  //*********************************************************************//

  /**
    @notice
    Maximum fee that can be set for a funding cycle configuration.

    @dev
    Out of MAX_FEE (50_000_000 / 1_000_000_000).
  */
  uint256 internal constant _FEE_CAP = 50_000_000;

  /**
    @notice
    The protocol project ID is 1, as it should be the first project launched during the deployment process.
  */
  uint256 internal constant _PROTOCOL_PROJECT_ID = 1;

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    Fees that are being held to be processed later.

    _projectId The ID of the project for which fees are being held.
  */
  mapping(uint256 => JBFee[]) internal _heldFeesOf;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership and transfers.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  /**
    @notice
    The contract that stores and manages the terminal's data.
  */
  IJBSingleTokenPaymentTerminalStore public immutable override store;

  /**
    @notice
    The currency to base token issuance on.

    @dev
    If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.
  */
  uint256 public immutable override baseWeightCurrency;

  /**
    @notice
    The group that payout splits coming from this terminal are identified by.
  */
  uint256 public immutable override payoutSplitsGroup;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The platform fee percent.

    @dev
    Out of MAX_FEE (25_000_000 / 1_000_000_000)
  */
  uint256 public override fee = 25_000_000; // 2.5%

  /**
    @notice
    The data source that returns a discount to apply to a project's fee.
  */
  IJBFeeGauge public override feeGauge;

  /**
    @notice
    Addresses that can be paid towards from this terminal without incurring a fee.

    _address The address that can be paid toward.
  */
  mapping(address => bool) public override isFeelessAddress;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.

    @dev
    The current overflow is represented as a fixed point number with 18 decimals.

    @param _projectId The ID of the project to get overflow for.

    @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.
  */
  function currentEthOverflowOf(uint256 _projectId)
    external
    view
    virtual
    override
    returns (uint256)
  {
    // Get this terminal's current overflow.
    uint256 _overflow = store.currentOverflowOf(this, _projectId);

    // Adjust the decimals of the fixed point number if needed to have 18 decimals.
    uint256 _adjustedOverflow = (decimals == 18)
      ? _overflow
      : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);

    // Return the amount converted to ETH.
    return
      (currency == JBCurrencies.ETH)
        ? _adjustedOverflow
        : PRBMath.mulDiv(
          _adjustedOverflow,
          10**decimals,
          prices.priceFor(currency, JBCurrencies.ETH, decimals)
        );
  }

  /**
    @notice
    The fees that are currently being held to be processed later for each project.

    @param _projectId The ID of the project for which fees are being held.

    @return An array of fees that are being held.
  */
  function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {
    return _heldFeesOf[_projectId];
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(JBSingleTokenPaymentTerminal, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||
      _interfaceId == type(IJBPayoutTerminal).interfaceId ||
      _interfaceId == type(IJBAllowanceTerminal).interfaceId ||
      _interfaceId == type(IJBRedemptionTerminal).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _token The token that this terminal manages.
    @param _decimals The number of decimals the token fixed point amounts are expected to have.
    @param _currency The currency that this terminal's token adheres to for price feeds.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _splitsStore A contract that stores splits for each project.
    @param _prices A contract that exposes price feeds.
    @param _store A contract that stores the terminal's data.
    @param _owner The address that will own this contract.
  */
  constructor(
    // payable constructor save the gas used to check msg.value==0
    address _token,
    uint256 _decimals,
    uint256 _currency,
    uint256 _baseWeightCurrency,
    uint256 _payoutSplitsGroup,
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBSplitsStore _splitsStore,
    IJBPrices _prices,
    IJBSingleTokenPaymentTerminalStore _store,
    address _owner
  )
    payable
    JBSingleTokenPaymentTerminal(_token, _decimals, _currency)
    JBOperatable(_operatorStore)
  {
    baseWeightCurrency = _baseWeightCurrency;
    payoutSplitsGroup = _payoutSplitsGroup;
    projects = _projects;
    directory = _directory;
    splitsStore = _splitsStore;
    prices = _prices;
    store = _store;

    transferOwnership(_owner);
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Contribute tokens to a project.

    @param _projectId The ID of the project being paid.
    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _token The token being paid. This terminal ignores this property since it only manages one token. 
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function pay(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {
    _token; // Prevents unused var compiler and natspec complaints.

    // ETH shouldn't be sent if this terminal's token isn't ETH.
    if (token != JBTokens.ETH) {
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If this terminal's token is ETH, override _amount with msg.value.
    else _amount = msg.value;

    return
      _pay(
        _amount,
        msg.sender,
        _projectId,
        _beneficiary,
        _minReturnedTokens,
        _preferClaimedTokens,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _token The token being reclaimed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  )
    external
    virtual
    override
    requirePermission(_holder, _projectId, JBOperations.REDEEM)
    returns (uint256 reclaimAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return
      _redeemTokensOf(
        _holder,
        _projectId,
        _tokenCount,
        _minReturnedTokens,
        _beneficiary,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) external virtual override returns (uint256 netLeftoverDistributionAmount) {
    _token; // Prevents unused var compiler and natspec complaints.

    return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)
    returns (uint256 netDistributedAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);
  }

  /**
    @notice
    Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project being migrated.
    @param _to The terminal contract that will gain the project's funds.

    @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.
  */
  function migrate(uint256 _projectId, IJBPaymentTerminal _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)
    returns (uint256 balance)
  {
    // The terminal being migrated to must accept the same token as this terminal.
    if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE();

    // Record the migration in the store.
    balance = store.recordMigration(_projectId);

    // Transfer the balance if needed.
    if (balance > 0) {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_to), balance);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? balance : 0;

      // Withdraw the balance to transfer to the new terminal;
      _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes(''));
    }

    emit Migrate(_projectId, _to, balance, msg.sender);
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _token The token being paid. This terminal ignores this property since it only manages one currency. 
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) {
    _token; // Prevents unused var compiler and natspec complaints.

    // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender.
    if (token != JBTokens.ETH) {
      // Amount must be greater than 0.
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If the terminal's token is ETH, override `_amount` with msg.value.
    else _amount = msg.value;

    // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal.
    _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);
  }

  /**
    @notice
    Process any fees that are being held for the project.

    @dev
    Only a project owner, an operator, or the contract's owner can process held fees.

    @param _projectId The ID of the project whos held fees should be processed.
  */
  function processFees(uint256 _projectId)
    external
    virtual
    override
    requirePermissionAllowingOverride(
      projects.ownerOf(_projectId),
      _projectId,
      JBOperations.PROCESS_FEES,
      msg.sender == owner()
    )
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the held fees.
    delete _heldFeesOf[_projectId];

    // Push array length in stack
    uint256 _heldFeeLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeeLength; ) {
      // Get the fee amount.
      uint256 _amount = _feeAmount(
        _heldFees[_i].amount,
        _heldFees[_i].fee,
        _heldFees[_i].feeDiscount
      );

      // Process the fee.
      _processFee(_amount, _heldFees[_i].beneficiary);

      emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Allows the fee to be updated.

    @dev
    Only the owner of this contract can change the fee.

    @param _fee The new fee, out of MAX_FEE.
  */
  function setFee(uint256 _fee) external virtual override onlyOwner {
    // The provided fee must be within the max.
    if (_fee > _FEE_CAP) revert FEE_TOO_HIGH();

    // Store the new fee.
    fee = _fee;

    emit SetFee(_fee, msg.sender);
  }

  /**
    @notice
    Allows the fee gauge to be updated.

    @dev
    Only the owner of this contract can change the fee gauge.

    @dev
    If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.

    @param _feeGauge The new fee gauge.
  */
  function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {
    // Store the new fee gauge.
    feeGauge = _feeGauge;

    emit SetFeeGauge(_feeGauge, msg.sender);
  }

  /**
    @notice
    Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.

    @dev
    Only the owner of this contract can set addresses as feeless.

    @param _address The address that can be paid towards while still bypassing fees.
    @param _flag A flag indicating whether the terminal should be feeless or not.
  */
  function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {
    // Set the flag value.
    isFeelessAddress[_address] = _flag;

    emit SetFeelessAddress(_address, _flag, msg.sender);
  }

  //*********************************************************************//
  // ---------------------- internal transactions ---------------------- //
  //*********************************************************************//

  /** 
    @notice
    Transfers tokens.

    @param _from The address from which the transfer should originate.
    @param _to The address to which the transfer should go.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _transferFrom(
    address _from,
    address payable _to,
    uint256 _amount
  ) internal virtual;

  /** 
    @notice
    Logic to be triggered before transferring tokens from this terminal.

    @param _to The address to which the transfer is going.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _beforeTransferTo(address _to, uint256 _amount) internal virtual;

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function _redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 reclaimAmount) {
    // Can't send reclaimed funds to the zero address.
    if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the redemption is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` only used within scope.
    {
      IJBRedemptionDelegate _delegate;

      // Record the redemption.
      (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(
        _holder,
        _projectId,
        _tokenCount,
        _memo,
        _metadata
      );

      // The amount being reclaimed must be at least as much as was expected.
      if (reclaimAmount < _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();

      // Burn the project tokens.
      if (_tokenCount > 0)
        IJBController(directory.controllerOf(_projectId)).burnTokensOf(
          _holder,
          _projectId,
          _tokenCount,
          '',
          false
        );

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBRedemptionDelegate(address(0))) {
        JBDidRedeemData memory _data = JBDidRedeemData(
          _holder,
          _projectId,
          _fundingCycle.configuration,
          _tokenCount,
          JBTokenAmount(token, reclaimAmount, decimals, currency),
          _beneficiary,
          _memo,
          _metadata
        );
        _delegate.didRedeem(_data);
        emit DelegateDidRedeem(_delegate, _data, msg.sender);
      }
    }

    // Send the reclaimed funds to the beneficiary.
    if (reclaimAmount > 0) _transferFrom(address(this), _beneficiary, reclaimAmount);

    emit RedeemTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _holder,
      _beneficiary,
      _tokenCount,
      reclaimAmount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) internal returns (uint256 netLeftoverDistributionAmount) {
    // Record the distribution.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(
      _projectId,
      _amount,
      _currency
    );

    // The amount being distributed must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Get a reference to the project owner, which will receive tokens from paying the platform fee
    // and receive any extra distributable funds not allocated to payout splits.
    address payable _projectOwner = payable(projects.ownerOf(_projectId));

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the fee amount that was paid.
    uint256 _fee;

    // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope.
    {
      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // The amount distributed that is eligible for incurring fees.
      uint256 _feeEligibleDistributionAmount;

      // The amount leftover after distributing to the splits.
      uint256 _leftoverDistributionAmount;

      // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.
      // Also get a reference to the amount that was distributed to splits from which fees should be taken.
      (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        payoutSplitsGroup,
        _distributedAmount,
        _feeDiscount
      );

      // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.
      unchecked {
        _feeEligibleDistributionAmount += _leftoverDistributionAmount;
      }

      // Take the fee.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0
        ? 0
        : _takeFeeFrom(
          _projectId,
          _fundingCycle,
          _feeEligibleDistributionAmount,
          _projectOwner,
          _feeDiscount
        );

      // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.

      unchecked {
        netLeftoverDistributionAmount = _leftoverDistributionAmount == 0
          ? 0
          : _leftoverDistributionAmount -
            _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);
      }

      // Transfer any remaining balance to the project owner.
      if (netLeftoverDistributionAmount > 0)
        _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount);
    }

    emit DistributePayouts(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _projectOwner,
      _amount,
      _distributedAmount,
      _fee,
      netLeftoverDistributionAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function _useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  ) internal returns (uint256 netDistributedAmount) {
    // Record the use of the allowance.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(
      _projectId,
      _amount,
      _currency
    );

    // The amount being withdrawn must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope.
    {
      // Keep a reference to the fee amount that was paid.
      uint256 _fee;

      // Get a reference to the project owner, which will receive tokens from paying the platform fee.
      address _projectOwner = projects.ownerOf(_projectId);

      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // Take a fee from the `_distributedAmount`, if needed.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
        ? 0
        : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);

      unchecked {
        // The net amount is the withdrawn amount without the fee.
        netDistributedAmount = _distributedAmount - _fee;
      }

      // Transfer any remaining balance to the beneficiary.
      if (netDistributedAmount > 0)
        _transferFrom(address(this), _beneficiary, netDistributedAmount);
    }

    emit UseAllowance(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _beneficiary,
      _amount,
      _distributedAmount,
      netDistributedAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Pays out splits for a project's funding cycle configuration.

    @param _projectId The ID of the project for which payout splits are being distributed.
    @param _domain The domain of the splits to distribute the payout between.
    @param _group The group of the splits to distribute the payout between.
    @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return leftoverAmount If the leftover amount if the splits don't add up to 100%.
    @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.
  */
  function _distributeToPayoutSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount,
    uint256 _feeDiscount
  ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's payout splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    // Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; ) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _payoutAmount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // The payout amount substracting any applicable incurred fees.
      uint256 _netPayoutAmount;

      if (_payoutAmount > 0) {
        // Transfer tokens to the split.
        // If there's an allocator set, transfer to its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0))) {
          // If the split allocator is set as feeless, this distribution is not eligible for a fee.
          if (isFeelessAddress[address(_split.allocator)])
            _netPayoutAmount = _payoutAmount;
            // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.
          else {
            unchecked {
              _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                ? _payoutAmount
                : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
            }

            // This distribution is eligible for a fee since the funds are leaving the ecosystem.
            feeEligibleDistributionAmount += _payoutAmount;
          }

          // Trigger any inherited pre-transfer logic.
          _beforeTransferTo(address(_split.allocator), _netPayoutAmount);

          // If this terminal's token is ETH, send it in msg.value.
          uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

          // Create the data to send to the allocator.
          JBSplitAllocationData memory _data = JBSplitAllocationData(
            token,
            _netPayoutAmount,
            decimals,
            _projectId,
            _group,
            _split
          );

          // Trigger the allocator's `allocate` function.
          _split.allocator.allocate{value: _payableValue}(_data);

          // Otherwise, if a project is specified, make a payment to it.
        } else if (_split.projectId != 0) {
          // Get a reference to the Juicebox terminal being used.
          IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);

          // The project must have a terminal to send funds to.
          if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();

          // Save gas if this contract is being used as the terminal.
          if (_terminal == this) {
            // This distribution does not incur a fee.
            _netPayoutAmount = _payoutAmount;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);
            else
              _pay(
                _netPayoutAmount,
                address(this),
                _split.projectId,
                (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          } else {
            // If the terminal is set as feeless, this distribution is not eligible for a fee.
            if (isFeelessAddress[address(_terminal)])
              _netPayoutAmount = _payoutAmount;
              // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.
            else {
              unchecked {
                _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                  ? _payoutAmount
                  : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
              }

              feeEligibleDistributionAmount += _payoutAmount;
            }

            // Trigger any inherited pre-transfer logic.
            _beforeTransferTo(address(_terminal), _netPayoutAmount);

            // If this terminal's token is ETH, send it in msg.value.
            uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _terminal.addToBalanceOf{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                '',
                _projectMetadata
              );
            else
              _terminal.pay{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          }
        } else {
          unchecked {
            _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
              ? _payoutAmount
              : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
          }

          // This distribution is eligible for a fee since the funds are leaving the ecosystem.
          feeEligibleDistributionAmount += _payoutAmount;

          // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.
          _transferFrom(
            address(this),
            _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),
            _netPayoutAmount
          );
        }

        // Subtract from the amount to be sent to the beneficiary.
        unchecked {
          leftoverAmount = leftoverAmount - _payoutAmount;
        }
      }

      emit DistributeToPayoutSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _netPayoutAmount,
        msg.sender
      );

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID.

    @param _projectId The ID of the project having fees taken from.
    @param _fundingCycle The funding cycle during which the fee is being taken.
    @param _amount The amount of the fee to take, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platforms tokens for.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return feeAmount The amount of the fee taken.
  */
  function _takeFeeFrom(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _amount,
    address _beneficiary,
    uint256 _feeDiscount
  ) internal returns (uint256 feeAmount) {
    feeAmount = _feeAmount(_amount, fee, _feeDiscount);

    if (_fundingCycle.shouldHoldFees()) {
      // Store the held fee.
      _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));

      emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender);
    } else {
      // Process the fee.
      _processFee(feeAmount, _beneficiary); // Take the fee.

      emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender);
    }
  }

  /**
    @notice
    Process a fee of the specified amount.

    @param _amount The fee amount, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platform's tokens for.
  */
  function _processFee(uint256 _amount, address _beneficiary) internal {
    // Get the terminal for the protocol project.
    IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token);

    // When processing the admin fee, save gas if the admin is using this contract as its terminal.
    if (_terminal == this)
      _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call.
    else {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_terminal), _amount);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;

      // Send the payment.
      _terminal.pay{value: _payableValue}(
        _PROTOCOL_PROJECT_ID,
        _amount,
        token,
        _beneficiary,
        0,
        false,
        '',
        bytes('')
      ); // Use the external pay call of the correct terminal.
    }
  }

  /**
    @notice
    Contribute tokens to a project.

    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _payer The address making the payment.
    @param _projectId The ID of the project being paid.
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function _pay(
    uint256 _amount,
    address _payer,
    uint256 _projectId,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 beneficiaryTokenCount) {
    // Cant send tokens to the zero address.
    if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the payment is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope.
    {
      IJBPayDelegate _delegate;
      uint256 _tokenCount;

      // Bundle the amount info into a JBTokenAmount struct.
      JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);

      // Record the payment.
      (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(
        _payer,
        _bundledAmount,
        _projectId,
        baseWeightCurrency,
        _beneficiary,
        _memo,
        _metadata
      );

      // Mint the tokens if needed.
      if (_tokenCount > 0)
        // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.
        beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(
          _projectId,
          _tokenCount,
          _beneficiary,
          '',
          _preferClaimedTokens,
          true
        );

      // The token count for the beneficiary must be greater than or equal to the minimum expected.
      if (beneficiaryTokenCount < _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBPayDelegate(address(0))) {
        JBDidPayData memory _data = JBDidPayData(
          _payer,
          _projectId,
          _fundingCycle.configuration,
          _bundledAmount,
          beneficiaryTokenCount,
          _beneficiary,
          _preferClaimedTokens,
          _memo,
          _metadata
        );

        _delegate.didPay(_data);
        emit DelegateDidPay(_delegate, _data, msg.sender);
      }
    }

    emit Pay(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _payer,
      _beneficiary,
      _amount,
      beneficiaryTokenCount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function _addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    bool _shouldRefundHeldFees,
    string memory _memo,
    bytes memory _metadata
  ) internal {
    // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.
    uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0;

    // Record the added funds with any refunded fees.
    store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);

    emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);
  }

  /**
    @notice
    Refund fees based on the specified amount.

    @param _projectId The project for which fees are being refunded.
    @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.

    @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal
  */
  function _refundHeldFees(uint256 _projectId, uint256 _amount)
    internal
    returns (uint256 refundedFees)
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the current held fees.
    delete _heldFeesOf[_projectId];

    // Get a reference to the leftover amount once all fees have been settled.
    uint256 leftoverAmount = _amount;

    // Push length in stack
    uint256 _heldFeesLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeesLength; ) {
      if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);
      else if (leftoverAmount >= _heldFees[_i].amount) {
        unchecked {
          leftoverAmount = leftoverAmount - _heldFees[_i].amount;
          refundedFees += _feeAmount(
            _heldFees[_i].amount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount
          );
        }
      } else {
        _heldFeesOf[_projectId].push(
          JBFee(
            _heldFees[_i].amount - leftoverAmount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount,
            _heldFees[_i].beneficiary
          )
        );
        unchecked {
          refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);
        }
        leftoverAmount = 0;
      }

      unchecked {
        ++_i;
      }
    }

    emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);
  }

  /** 
    @notice 
    Returns the fee amount based on the provided amount for the specified project.

    @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal.
    @param _fee The percentage of the fee, out of MAX_FEE. 
    @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.

    @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _feeAmount(
    uint256 _amount,
    uint256 _fee,
    uint256 _feeDiscount
  ) internal pure returns (uint256) {
    // Calculate the discounted fee.
    uint256 _discountedFee = _fee -
      PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT);

    // The amount of tokens from the `_amount` to pay as a fee.
    return
      _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);
  }

  /** 
    @notice
    Get the fee discount from the fee gauge for the specified project.

    @param _projectId The ID of the project to get a fee discount for.
    
    @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.
  */
  function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {
    // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.
    if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))
      return JBConstants.MAX_FEE_DISCOUNT;

    // Get the fee discount.
    if (feeGauge == IJBFeeGauge(address(0)))
      feeDiscount = 0;
      // If the guage reverts, set the discount to 0.
    else
      try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {
        feeDiscount = discount;
      } catch {
        feeDiscount = 0;
      }

    // If the fee discount is greater than the max, nullify the discount.
    if (feeDiscount > JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;
  }
}
".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-01-09 17:17:34 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 17:17:34 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 25454
completion_tokens: 1
total_tokens: 25455
cost: $-1.000000


[2024-01-09 17:17:34 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './../interfaces/IJBController.sol';
import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol';
import './../libraries/JBConstants.sol';
import './../libraries/JBCurrencies.sol';
import './../libraries/JBFixedPointNumber.sol';
import './../libraries/JBFundingCycleMetadataResolver.sol';
import './../libraries/JBOperations.sol';
import './../libraries/JBSplitsGroups.sol';
import './../libraries/JBTokens.sol';
import './../structs/JBTokenAmount.sol';
import './JBOperatable.sol';
import './JBSingleTokenPaymentTerminal.sol';

/**
  @notice
  Generic terminal managing all inflows and outflows of funds into the protocol ecosystem.

  @dev
  A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time.

  @dev
  Adheres to -
  IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.
  JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
abstract contract JBPayoutRedemptionPaymentTerminal is
  IJBPayoutRedemptionPaymentTerminal,
  JBSingleTokenPaymentTerminal,
  JBOperatable,
  Ownable,
  ReentrancyGuard
{
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error FEE_TOO_HIGH();
  error INADEQUATE_DISTRIBUTION_AMOUNT();
  error INADEQUATE_RECLAIM_AMOUNT();
  error INADEQUATE_TOKEN_COUNT();
  error NO_MSG_VALUE_ALLOWED();
  error PAY_TO_ZERO_ADDRESS();
  error PROJECT_TERMINAL_MISMATCH();
  error REDEEM_TO_ZERO_ADDRESS();
  error TERMINAL_IN_SPLIT_ZERO_ADDRESS();
  error TERMINAL_TOKENS_INCOMPATIBLE();

  //*********************************************************************//
  // ---------------------------- modifiers ---------------------------- //
  //*********************************************************************//

  /** 
    @notice 
    A modifier that verifies this terminal is a terminal of provided project ID.
  */
  modifier isTerminalOf(uint256 _projectId) {
    if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();
    _;
  }

  //*********************************************************************//
  // --------------------- internal stored constants ------------------- //
  //*********************************************************************//

  /**
    @notice
    Maximum fee that can be set for a funding cycle configuration.

    @dev
    Out of MAX_FEE (50_000_000 / 1_000_000_000).
  */
  uint256 internal constant _FEE_CAP = 50_000_000;

  /**
    @notice
    The protocol project ID is 1, as it should be the first project launched during the deployment process.
  */
  uint256 internal constant _PROTOCOL_PROJECT_ID = 1;

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    Fees that are being held to be processed later.

    _projectId The ID of the project for which fees are being held.
  */
  mapping(uint256 => JBFee[]) internal _heldFeesOf;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership and transfers.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  /**
    @notice
    The contract that stores and manages the terminal's data.
  */
  IJBSingleTokenPaymentTerminalStore public immutable override store;

  /**
    @notice
    The currency to base token issuance on.

    @dev
    If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.
  */
  uint256 public immutable override baseWeightCurrency;

  /**
    @notice
    The group that payout splits coming from this terminal are identified by.
  */
  uint256 public immutable override payoutSplitsGroup;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The platform fee percent.

    @dev
    Out of MAX_FEE (25_000_000 / 1_000_000_000)
  */
  uint256 public override fee = 25_000_000; // 2.5%

  /**
    @notice
    The data source that returns a discount to apply to a project's fee.
  */
  IJBFeeGauge public override feeGauge;

  /**
    @notice
    Addresses that can be paid towards from this terminal without incurring a fee.

    _address The address that can be paid toward.
  */
  mapping(address => bool) public override isFeelessAddress;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.

    @dev
    The current overflow is represented as a fixed point number with 18 decimals.

    @param _projectId The ID of the project to get overflow for.

    @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.
  */
  function currentEthOverflowOf(uint256 _projectId)
    external
    view
    virtual
    override
    returns (uint256)
  {
    // Get this terminal's current overflow.
    uint256 _overflow = store.currentOverflowOf(this, _projectId);

    // Adjust the decimals of the fixed point number if needed to have 18 decimals.
    uint256 _adjustedOverflow = (decimals == 18)
      ? _overflow
      : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);

    // Return the amount converted to ETH.
    return
      (currency == JBCurrencies.ETH)
        ? _adjustedOverflow
        : PRBMath.mulDiv(
          _adjustedOverflow,
          10**decimals,
          prices.priceFor(currency, JBCurrencies.ETH, decimals)
        );
  }

  /**
    @notice
    The fees that are currently being held to be processed later for each project.

    @param _projectId The ID of the project for which fees are being held.

    @return An array of fees that are being held.
  */
  function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {
    return _heldFeesOf[_projectId];
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(JBSingleTokenPaymentTerminal, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||
      _interfaceId == type(IJBPayoutTerminal).interfaceId ||
      _interfaceId == type(IJBAllowanceTerminal).interfaceId ||
      _interfaceId == type(IJBRedemptionTerminal).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _token The token that this terminal manages.
    @param _decimals The number of decimals the token fixed point amounts are expected to have.
    @param _currency The currency that this terminal's token adheres to for price feeds.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _splitsStore A contract that stores splits for each project.
    @param _prices A contract that exposes price feeds.
    @param _store A contract that stores the terminal's data.
    @param _owner The address that will own this contract.
  */
  constructor(
    // payable constructor save the gas used to check msg.value==0
    address _token,
    uint256 _decimals,
    uint256 _currency,
    uint256 _baseWeightCurrency,
    uint256 _payoutSplitsGroup,
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBSplitsStore _splitsStore,
    IJBPrices _prices,
    IJBSingleTokenPaymentTerminalStore _store,
    address _owner
  )
    payable
    JBSingleTokenPaymentTerminal(_token, _decimals, _currency)
    JBOperatable(_operatorStore)
  {
    baseWeightCurrency = _baseWeightCurrency;
    payoutSplitsGroup = _payoutSplitsGroup;
    projects = _projects;
    directory = _directory;
    splitsStore = _splitsStore;
    prices = _prices;
    store = _store;

    transferOwnership(_owner);
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Contribute tokens to a project.

    @param _projectId The ID of the project being paid.
    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _token The token being paid. This terminal ignores this property since it only manages one token. 
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function pay(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {
    _token; // Prevents unused var compiler and natspec complaints.

    // ETH shouldn't be sent if this terminal's token isn't ETH.
    if (token != JBTokens.ETH) {
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If this terminal's token is ETH, override _amount with msg.value.
    else _amount = msg.value;

    return
      _pay(
        _amount,
        msg.sender,
        _projectId,
        _beneficiary,
        _minReturnedTokens,
        _preferClaimedTokens,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _token The token being reclaimed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  )
    external
    virtual
    override
    requirePermission(_holder, _projectId, JBOperations.REDEEM)
    returns (uint256 reclaimAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return
      _redeemTokensOf(
        _holder,
        _projectId,
        _tokenCount,
        _minReturnedTokens,
        _beneficiary,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) external virtual override returns (uint256 netLeftoverDistributionAmount) {
    _token; // Prevents unused var compiler and natspec complaints.

    return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)
    returns (uint256 netDistributedAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);
  }

  /**
    @notice
    Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project being migrated.
    @param _to The terminal contract that will gain the project's funds.

    @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.
  */
  function migrate(uint256 _projectId, IJBPaymentTerminal _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)
    returns (uint256 balance)
  {
    // The terminal being migrated to must accept the same token as this terminal.
    if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE();

    // Record the migration in the store.
    balance = store.recordMigration(_projectId);

    // Transfer the balance if needed.
    if (balance > 0) {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_to), balance);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? balance : 0;

      // Withdraw the balance to transfer to the new terminal;
      _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes(''));
    }

    emit Migrate(_projectId, _to, balance, msg.sender);
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _token The token being paid. This terminal ignores this property since it only manages one currency. 
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) {
    _token; // Prevents unused var compiler and natspec complaints.

    // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender.
    if (token != JBTokens.ETH) {
      // Amount must be greater than 0.
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If the terminal's token is ETH, override `_amount` with msg.value.
    else _amount = msg.value;

    // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal.
    _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);
  }

  /**
    @notice
    Process any fees that are being held for the project.

    @dev
    Only a project owner, an operator, or the contract's owner can process held fees.

    @param _projectId The ID of the project whos held fees should be processed.
  */
  function processFees(uint256 _projectId)
    external
    virtual
    override
    requirePermissionAllowingOverride(
      projects.ownerOf(_projectId),
      _projectId,
      JBOperations.PROCESS_FEES,
      msg.sender == owner()
    )
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the held fees.
    delete _heldFeesOf[_projectId];

    // Push array length in stack
    uint256 _heldFeeLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeeLength; ) {
      // Get the fee amount.
      uint256 _amount = _feeAmount(
        _heldFees[_i].amount,
        _heldFees[_i].fee,
        _heldFees[_i].feeDiscount
      );

      // Process the fee.
      _processFee(_amount, _heldFees[_i].beneficiary);

      emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Allows the fee to be updated.

    @dev
    Only the owner of this contract can change the fee.

    @param _fee The new fee, out of MAX_FEE.
  */
  function setFee(uint256 _fee) external virtual override onlyOwner {
    // The provided fee must be within the max.
    if (_fee > _FEE_CAP) revert FEE_TOO_HIGH();

    // Store the new fee.
    fee = _fee;

    emit SetFee(_fee, msg.sender);
  }

  /**
    @notice
    Allows the fee gauge to be updated.

    @dev
    Only the owner of this contract can change the fee gauge.

    @dev
    If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.

    @param _feeGauge The new fee gauge.
  */
  function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {
    // Store the new fee gauge.
    feeGauge = _feeGauge;

    emit SetFeeGauge(_feeGauge, msg.sender);
  }

  /**
    @notice
    Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.

    @dev
    Only the owner of this contract can set addresses as feeless.

    @param _address The address that can be paid towards while still bypassing fees.
    @param _flag A flag indicating whether the terminal should be feeless or not.
  */
  function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {
    // Set the flag value.
    isFeelessAddress[_address] = _flag;

    emit SetFeelessAddress(_address, _flag, msg.sender);
  }

  //*********************************************************************//
  // ---------------------- internal transactions ---------------------- //
  //*********************************************************************//

  /** 
    @notice
    Transfers tokens.

    @param _from The address from which the transfer should originate.
    @param _to The address to which the transfer should go.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _transferFrom(
    address _from,
    address payable _to,
    uint256 _amount
  ) internal virtual;

  /** 
    @notice
    Logic to be triggered before transferring tokens from this terminal.

    @param _to The address to which the transfer is going.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _beforeTransferTo(address _to, uint256 _amount) internal virtual;

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function _redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 reclaimAmount) {
    // Can't send reclaimed funds to the zero address.
    if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the redemption is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` only used within scope.
    {
      IJBRedemptionDelegate _delegate;

      // Record the redemption.
      (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(
        _holder,
        _projectId,
        _tokenCount,
        _memo,
        _metadata
      );

      // The amount being reclaimed must be at least as much as was expected.
      if (reclaimAmount < _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();

      // Burn the project tokens.
      if (_tokenCount > 0)
        IJBController(directory.controllerOf(_projectId)).burnTokensOf(
          _holder,
          _projectId,
          _tokenCount,
          '',
          false
        );

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBRedemptionDelegate(address(0))) {
        JBDidRedeemData memory _data = JBDidRedeemData(
          _holder,
          _projectId,
          _fundingCycle.configuration,
          _tokenCount,
          JBTokenAmount(token, reclaimAmount, decimals, currency),
          _beneficiary,
          _memo,
          _metadata
        );
        _delegate.didRedeem(_data);
        emit DelegateDidRedeem(_delegate, _data, msg.sender);
      }
    }

    // Send the reclaimed funds to the beneficiary.
    if (reclaimAmount > 0) _transferFrom(address(this), _beneficiary, reclaimAmount);

    emit RedeemTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _holder,
      _beneficiary,
      _tokenCount,
      reclaimAmount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) internal returns (uint256 netLeftoverDistributionAmount) {
    // Record the distribution.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(
      _projectId,
      _amount,
      _currency
    );

    // The amount being distributed must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Get a reference to the project owner, which will receive tokens from paying the platform fee
    // and receive any extra distributable funds not allocated to payout splits.
    address payable _projectOwner = payable(projects.ownerOf(_projectId));

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the fee amount that was paid.
    uint256 _fee;

    // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope.
    {
      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // The amount distributed that is eligible for incurring fees.
      uint256 _feeEligibleDistributionAmount;

      // The amount leftover after distributing to the splits.
      uint256 _leftoverDistributionAmount;

      // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.
      // Also get a reference to the amount that was distributed to splits from which fees should be taken.
      (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        payoutSplitsGroup,
        _distributedAmount,
        _feeDiscount
      );

      // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.
      unchecked {
        _feeEligibleDistributionAmount += _leftoverDistributionAmount;
      }

      // Take the fee.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0
        ? 0
        : _takeFeeFrom(
          _projectId,
          _fundingCycle,
          _feeEligibleDistributionAmount,
          _projectOwner,
          _feeDiscount
        );

      // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.

      unchecked {
        netLeftoverDistributionAmount = _leftoverDistributionAmount == 0
          ? 0
          : _leftoverDistributionAmount -
            _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);
      }

      // Transfer any remaining balance to the project owner.
      if (netLeftoverDistributionAmount > 0)
        _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount);
    }

    emit DistributePayouts(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _projectOwner,
      _amount,
      _distributedAmount,
      _fee,
      netLeftoverDistributionAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function _useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  ) internal returns (uint256 netDistributedAmount) {
    // Record the use of the allowance.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(
      _projectId,
      _amount,
      _currency
    );

    // The amount being withdrawn must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope.
    {
      // Keep a reference to the fee amount that was paid.
      uint256 _fee;

      // Get a reference to the project owner, which will receive tokens from paying the platform fee.
      address _projectOwner = projects.ownerOf(_projectId);

      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // Take a fee from the `_distributedAmount`, if needed.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
        ? 0
        : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);

      unchecked {
        // The net amount is the withdrawn amount without the fee.
        netDistributedAmount = _distributedAmount - _fee;
      }

      // Transfer any remaining balance to the beneficiary.
      if (netDistributedAmount > 0)
        _transferFrom(address(this), _beneficiary, netDistributedAmount);
    }

    emit UseAllowance(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _beneficiary,
      _amount,
      _distributedAmount,
      netDistributedAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Pays out splits for a project's funding cycle configuration.

    @param _projectId The ID of the project for which payout splits are being distributed.
    @param _domain The domain of the splits to distribute the payout between.
    @param _group The group of the splits to distribute the payout between.
    @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return leftoverAmount If the leftover amount if the splits don't add up to 100%.
    @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.
  */
  function _distributeToPayoutSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount,
    uint256 _feeDiscount
  ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's payout splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    // Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; ) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _payoutAmount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // The payout amount substracting any applicable incurred fees.
      uint256 _netPayoutAmount;

      if (_payoutAmount > 0) {
        // Transfer tokens to the split.
        // If there's an allocator set, transfer to its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0))) {
          // If the split allocator is set as feeless, this distribution is not eligible for a fee.
          if (isFeelessAddress[address(_split.allocator)])
            _netPayoutAmount = _payoutAmount;
            // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.
          else {
            unchecked {
              _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                ? _payoutAmount
                : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
            }

            // This distribution is eligible for a fee since the funds are leaving the ecosystem.
            feeEligibleDistributionAmount += _payoutAmount;
          }

          // Trigger any inherited pre-transfer logic.
          _beforeTransferTo(address(_split.allocator), _netPayoutAmount);

          // If this terminal's token is ETH, send it in msg.value.
          uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

          // Create the data to send to the allocator.
          JBSplitAllocationData memory _data = JBSplitAllocationData(
            token,
            _netPayoutAmount,
            decimals,
            _projectId,
            _group,
            _split
          );

          // Trigger the allocator's `allocate` function.
          _split.allocator.allocate{value: _payableValue}(_data);

          // Otherwise, if a project is specified, make a payment to it.
        } else if (_split.projectId != 0) {
          // Get a reference to the Juicebox terminal being used.
          IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);

          // The project must have a terminal to send funds to.
          if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();

          // Save gas if this contract is being used as the terminal.
          if (_terminal == this) {
            // This distribution does not incur a fee.
            _netPayoutAmount = _payoutAmount;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);
            else
              _pay(
                _netPayoutAmount,
                address(this),
                _split.projectId,
                (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          } else {
            // If the terminal is set as feeless, this distribution is not eligible for a fee.
            if (isFeelessAddress[address(_terminal)])
              _netPayoutAmount = _payoutAmount;
              // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.
            else {
              unchecked {
                _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                  ? _payoutAmount
                  : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
              }

              feeEligibleDistributionAmount += _payoutAmount;
            }

            // Trigger any inherited pre-transfer logic.
            _beforeTransferTo(address(_terminal), _netPayoutAmount);

            // If this terminal's token is ETH, send it in msg.value.
            uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _terminal.addToBalanceOf{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                '',
                _projectMetadata
              );
            else
              _terminal.pay{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          }
        } else {
          unchecked {
            _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
              ? _payoutAmount
              : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
          }

          // This distribution is eligible for a fee since the funds are leaving the ecosystem.
          feeEligibleDistributionAmount += _payoutAmount;

          // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.
          _transferFrom(
            address(this),
            _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),
            _netPayoutAmount
          );
        }

        // Subtract from the amount to be sent to the beneficiary.
        unchecked {
          leftoverAmount = leftoverAmount - _payoutAmount;
        }
      }

      emit DistributeToPayoutSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _netPayoutAmount,
        msg.sender
      );

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID.

    @param _projectId The ID of the project having fees taken from.
    @param _fundingCycle The funding cycle during which the fee is being taken.
    @param _amount The amount of the fee to take, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platforms tokens for.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return feeAmount The amount of the fee taken.
  */
  function _takeFeeFrom(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _amount,
    address _beneficiary,
    uint256 _feeDiscount
  ) internal returns (uint256 feeAmount) {
    feeAmount = _feeAmount(_amount, fee, _feeDiscount);

    if (_fundingCycle.shouldHoldFees()) {
      // Store the held fee.
      _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));

      emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender);
    } else {
      // Process the fee.
      _processFee(feeAmount, _beneficiary); // Take the fee.

      emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender);
    }
  }

  /**
    @notice
    Process a fee of the specified amount.

    @param _amount The fee amount, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platform's tokens for.
  */
  function _processFee(uint256 _amount, address _beneficiary) internal {
    // Get the terminal for the protocol project.
    IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token);

    // When processing the admin fee, save gas if the admin is using this contract as its terminal.
    if (_terminal == this)
      _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call.
    else {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_terminal), _amount);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;

      // Send the payment.
      _terminal.pay{value: _payableValue}(
        _PROTOCOL_PROJECT_ID,
        _amount,
        token,
        _beneficiary,
        0,
        false,
        '',
        bytes('')
      ); // Use the external pay call of the correct terminal.
    }
  }

  /**
    @notice
    Contribute tokens to a project.

    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _payer The address making the payment.
    @param _projectId The ID of the project being paid.
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function _pay(
    uint256 _amount,
    address _payer,
    uint256 _projectId,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 beneficiaryTokenCount) {
    // Cant send tokens to the zero address.
    if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the payment is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope.
    {
      IJBPayDelegate _delegate;
      uint256 _tokenCount;

      // Bundle the amount info into a JBTokenAmount struct.
      JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);

      // Record the payment.
      (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(
        _payer,
        _bundledAmount,
        _projectId,
        baseWeightCurrency,
        _beneficiary,
        _memo,
        _metadata
      );

      // Mint the tokens if needed.
      if (_tokenCount > 0)
        // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.
        beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(
          _projectId,
          _tokenCount,
          _beneficiary,
          '',
          _preferClaimedTokens,
          true
        );

      // The token count for the beneficiary must be greater than or equal to the minimum expected.
      if (beneficiaryTokenCount < _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBPayDelegate(address(0))) {
        JBDidPayData memory _data = JBDidPayData(
          _payer,
          _projectId,
          _fundingCycle.configuration,
          _bundledAmount,
          beneficiaryTokenCount,
          _beneficiary,
          _preferClaimedTokens,
          _memo,
          _metadata
        );

        _delegate.didPay(_data);
        emit DelegateDidPay(_delegate, _data, msg.sender);
      }
    }

    emit Pay(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _payer,
      _beneficiary,
      _amount,
      beneficiaryTokenCount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function _addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    bool _shouldRefundHeldFees,
    string memory _memo,
    bytes memory _metadata
  ) internal {
    // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.
    uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0;

    // Record the added funds with any refunded fees.
    store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);

    emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);
  }

  /**
    @notice
    Refund fees based on the specified amount.

    @param _projectId The project for which fees are being refunded.
    @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.

    @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal
  */
  function _refundHeldFees(uint256 _projectId, uint256 _amount)
    internal
    returns (uint256 refundedFees)
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the current held fees.
    delete _heldFeesOf[_projectId];

    // Get a reference to the leftover amount once all fees have been settled.
    uint256 leftoverAmount = _amount;

    // Push length in stack
    uint256 _heldFeesLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeesLength; ) {
      if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);
      else if (leftoverAmount >= _heldFees[_i].amount) {
        unchecked {
          leftoverAmount = leftoverAmount - _heldFees[_i].amount;
          refundedFees += _feeAmount(
            _heldFees[_i].amount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount
          );
        }
      } else {
        _heldFeesOf[_projectId].push(
          JBFee(
            _heldFees[_i].amount - leftoverAmount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount,
            _heldFees[_i].beneficiary
          )
        );
        unchecked {
          refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);
        }
        leftoverAmount = 0;
      }

      unchecked {
        ++_i;
      }
    }

    emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);
  }

  /** 
    @notice 
    Returns the fee amount based on the provided amount for the specified project.

    @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal.
    @param _fee The percentage of the fee, out of MAX_FEE. 
    @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.

    @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _feeAmount(
    uint256 _amount,
    uint256 _fee,
    uint256 _feeDiscount
  ) internal pure returns (uint256) {
    // Calculate the discounted fee.
    uint256 _discountedFee = _fee -
      PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT);

    // The amount of tokens from the `_amount` to pay as a fee.
    return
      _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);
  }

  /** 
    @notice
    Get the fee discount from the fee gauge for the specified project.

    @param _projectId The ID of the project to get a fee discount for.
    
    @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.
  */
  function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {
    // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.
    if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))
      return JBConstants.MAX_FEE_DISCOUNT;

    // Get the fee discount.
    if (feeGauge == IJBFeeGauge(address(0)))
      feeDiscount = 0;
      // If the guage reverts, set the discount to 0.
    else
      try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {
        feeDiscount = discount;
      } catch {
        feeDiscount = 0;
      }

    // If the fee discount is greater than the max, nullify the discount.
    if (feeDiscount > JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;
  }
}
.]

Let's

[2024-01-09 17:17:35 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/security/ReentrancyGuard.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './../interfaces/IJBController.sol'; import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol'; import './../libraries/JBConstants.sol'; import './../libraries/JBCurrencies.sol'; import './../libraries/JBFixedPointNumber.sol'; import './../libraries/JBFundingCycleMetadataResolver.sol'; import './../libraries/JBOperations.sol'; import './../libraries/JBSplitsGroups.sol'; import './../libraries/JBTokens.sol'; import './../structs/JBTokenAmount.sol'; import './JBOperatable.sol'; import './JBSingleTokenPaymentTerminal.sol'; /**   @notice   Generic terminal managing all inflows and outflows of funds into the protocol ecosystem. @dev   A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time. @dev   Adheres to -   IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules. @dev   Inherits from -   JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.   JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.   Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.   ReentrancyGuard: Contract module that helps prevent reentrant calls to a function. */ abstract contract JBPayoutRedemptionPaymentTerminal is   IJBPayoutRedemptionPaymentTerminal,   JBSingleTokenPaymentTerminal,   JBOperatable,   Ownable,   ReentrancyGuard {   // A library that parses the packed funding cycle metadata into a friendlier format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error FEE_TOO_HIGH();   error INADEQUATE_DISTRIBUTION_AMOUNT();   error INADEQUATE_RECLAIM_AMOUNT();   error INADEQUATE_TOKEN_COUNT();   error NO_MSG_VALUE_ALLOWED();   error PAY_TO_ZERO_ADDRESS();   error PROJECT_TERMINAL_MISMATCH();   error REDEEM_TO_ZERO_ADDRESS();   error TERMINAL_IN_SPLIT_ZERO_ADDRESS();   error TERMINAL_TOKENS_INCOMPATIBLE(); //***********//   // ---------------------------- modifiers ---------------------------- //   //*************// /*      @notice      A modifier that verifies this terminal is a terminal of provided project ID.   /   modifier isTerminalOf(uint256 projectId) {     if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();     ;   } //***********//   // --------------------- internal stored constants ------------------- //   //*************// /**     @notice     Maximum fee that can be set for a funding cycle configuration. @dev Out of MAX_FEE (50_000_000 / 1_000_000_000).  */   uint256 internal constant _FEE_CAP = 50_000_000; /*     @notice     The protocol project ID is 1, as it should be the first project launched during the deployment process.   /   uint256 internal constant _PROTOCOL_PROJECT_ID = 1; //***********//   // --------------------- internal stored properties ------------------ //   //*************// /**     @notice     Fees that are being held to be processed later. _projectId The ID of the project for which fees are being held.  */   mapping(uint256 =&gt; JBFee[]) internal _heldFeesOf; //***********//   // ---------------- public immutable stored properties --------------- //   //*************// /*     @notice     Mints ERC-721's that represent project ownership and transfers.   /   IJBProjects public immutable override projects; /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; /*     @notice     The contract that stores splits for each project.   /   IJBSplitsStore public immutable override splitsStore; /*     @notice     The contract that exposes price feeds.   /   IJBPrices public immutable override prices; /*     @notice     The contract that stores and manages the terminal's data.   /   IJBSingleTokenPaymentTerminalStore public immutable override store; /**     @notice     The currency to base token issuance on. @dev If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.  */   uint256 public immutable override baseWeightCurrency; /*     @notice     The group that payout splits coming from this terminal are identified by.   /   uint256 public immutable override payoutSplitsGroup; //***********//   // --------------------- public stored properties -------------------- //   //*************// /**     @notice     The platform fee percent. @dev Out of MAX_FEE (25_000_000 / 1_000_000_000)  */   uint256 public override fee = 25_000_000; // 2.5% /*     @notice     The data source that returns a discount to apply to a project's fee.   /   IJBFeeGauge public override feeGauge; /**     @notice     Addresses that can be paid towards from this terminal without incurring a fee. _address The address that can be paid toward.  */   mapping(address =&gt; bool) public override isFeelessAddress; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     Gets the current overflowed amount in this terminal for a specified project, in terms of ETH. @dev The current overflow is represented as a fixed point number with 18 decimals.  @param _projectId The ID of the project to get overflow for.  @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.  */   function currentEthOverflowOf(uint256 _projectId)     external     view     virtual     override     returns (uint256)   {     // Get this terminal's current overflow.     uint256 _overflow = store.currentOverflowOf(this, _projectId); // Adjust the decimals of the fixed point number if needed to have 18 decimals. uint256 _adjustedOverflow = (decimals == 18)   ? _overflow   : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);  // Return the amount converted to ETH. return   (currency == JBCurrencies.ETH)     ? _adjustedOverflow     : PRBMath.mulDiv(       _adjustedOverflow,       10**decimals,       prices.priceFor(currency, JBCurrencies.ETH, decimals)     );  } /**     @notice     The fees that are currently being held to be processed later for each project. @param _projectId The ID of the project for which fees are being held.  @return An array of fees that are being held.  */   function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {     return _heldFeesOf[_projectId];   } //***********//   // -------------------------- public views --------------------------- //   //*************// /**     @notice     Indicates if this contract adheres to the specified interface. @dev  See {IERC165-supportsInterface}.  @param _interfaceId The ID of the interface to check for adherance to.  */   function supportsInterface(bytes4 _interfaceId)     public     view     virtual     override(JBSingleTokenPaymentTerminal, IERC165)     returns (bool)   {     return       _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||       _interfaceId == type(IJBPayoutTerminal).interfaceId ||       _interfaceId == type(IJBAllowanceTerminal).interfaceId ||       _interfaceId == type(IJBRedemptionTerminal).interfaceId ||       _interfaceId == type(IJBOperatable).interfaceId ||       super.supportsInterface(_interfaceId);   } //***********//   // -------------------------- constructor ---------------------------- //   //*************// /*     @param _token The token that this terminal manages.     @param _decimals The number of decimals the token fixed point amounts are expected to have.     @param _currency The currency that this terminal's token adheres to for price feeds.     @param _baseWeightCurrency The currency to base token issuance on.     @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.     @param _operatorStore A contract storing operator assignments.     @param _projects A contract which mints ERC-721's that represent project ownership and transfers.     @param _directory A contract storing directories of terminals and controllers for each project.     @param _splitsStore A contract that stores splits for each project.     @param _prices A contract that exposes price feeds.     @param _store A contract that stores the terminal's data.     @param _owner The address that will own this contract.   /   constructor(     // payable constructor save the gas used to check msg.value==0     address _token,     uint256 _decimals,     uint256 _currency,     uint256 _baseWeightCurrency,     uint256 _payoutSplitsGroup,     IJBOperatorStore _operatorStore,     IJBProjects _projects,     IJBDirectory _directory,     IJBSplitsStore _splitsStore,     IJBPrices _prices,     IJBSingleTokenPaymentTerminalStore _store,     address _owner   )     payable     JBSingleTokenPaymentTerminal(_token, _decimals, _currency)     JBOperatable(_operatorStore)   {     baseWeightCurrency = _baseWeightCurrency;     payoutSplitsGroup = _payoutSplitsGroup;     projects = _projects;     directory = _directory;     splitsStore = _splitsStore;     prices = _prices;     store = _store; transferOwnership(_owner);  } //***********//   // ---------------------- external transactions ---------------------- //   //*************// /**     @notice     Contribute tokens to a project. @param _projectId The ID of the project being paid. @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place. @param _token The token being paid. This terminal ignores this property since it only manages one token.  @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate. @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal. @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas. @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.  */   function pay(     uint256 _projectId,     uint256 _amount,     address _token,     address _beneficiary,     uint256 _minReturnedTokens,     bool _preferClaimedTokens,     string calldata _memo,     bytes calldata _metadata   ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {     _token; // Prevents unused var compiler and natspec complaints. // ETH shouldn't be sent if this terminal's token isn't ETH. if (token != JBTokens.ETH) {   if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();    // Transfer tokens to this terminal from the msg sender.   _transferFrom(msg.sender, payable(address(this)), _amount); } // If this terminal's token is ETH, override _amount with msg.value. else _amount = msg.value;  return   _pay(     _amount,     msg.sender,     _projectId,     _beneficiary,     _minReturnedTokens,     _preferClaimedTokens,     _memo,     _metadata   );  } /**     @notice     Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source. @dev Only a token holder or a designated operator can redeem its tokens.  @param _holder The account to redeem tokens for. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _token The token being reclaimed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal. @param _beneficiary The address to send the terminal tokens to. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.  */   function redeemTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     address _token,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo,     bytes memory _metadata   )     external     virtual     override     requirePermission(_holder, _projectId, JBOperations.REDEEM)     returns (uint256 reclaimAmount)   {     _token; // Prevents unused var compiler and natspec complaints. return   _redeemTokensOf(     _holder,     _projectId,     _tokenCount,     _minReturnedTokens,     _beneficiary,     _memo,     _metadata   );  } /**     @notice     Distributes payouts for a project with the distribution limit of its current funding cycle. @dev Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.  @dev Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.  @dev All funds distributed outside of this contract or any feeless terminals incure the protocol fee.  @param _projectId The ID of the project having its payouts distributed. @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency. @param _token The token being distributed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal. @param _memo A memo to pass along to the emitted event.  @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.  */   function distributePayoutsOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     address _token,     uint256 _minReturnedTokens,     string calldata _memo   ) external virtual override returns (uint256 netLeftoverDistributionAmount) {     _token; // Prevents unused var compiler and natspec complaints. return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);  } /**     @notice     Allows a project to send funds from its overflow up to the preconfigured allowance. @dev Only a project's owner or a designated operator can use its allowance.  @dev Incurs the protocol fee.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency. @param _token The token being distributed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals. @param _beneficiary The address to send the funds to. @param _memo A memo to pass along to the emitted event.  @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.  */   function useAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     address _token,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)     returns (uint256 netDistributedAmount)   {     _token; // Prevents unused var compiler and natspec complaints. return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);  } /**     @notice     Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type. @dev Only a project's owner or a designated operator can migrate it.  @param _projectId The ID of the project being migrated. @param _to The terminal contract that will gain the project's funds.  @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.  */   function migrate(uint256 _projectId, IJBPaymentTerminal _to)     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)     returns (uint256 balance)   {     // The terminal being migrated to must accept the same token as this terminal.     if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE(); // Record the migration in the store. balance = store.recordMigration(_projectId);  // Transfer the balance if needed. if (balance &gt; 0) {   // Trigger any inherited pre-transfer logic.   _beforeTransferTo(address(_to), balance);    // If this terminal's token is ETH, send it in msg.value.   uint256 _payableValue = token == JBTokens.ETH ? balance : 0;    // Withdraw the balance to transfer to the new terminal;   _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes('')); }  emit Migrate(_projectId, _to, balance, msg.sender);  } /**     @notice     Receives funds belonging to the specified project. @param _projectId The ID of the project to which the funds received belong. @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead. @param _token The token being paid. This terminal ignores this property since it only manages one currency.  @param _memo A memo to pass along to the emitted event. @param _metadata Extra data to pass along to the emitted event.  */   function addToBalanceOf(     uint256 _projectId,     uint256 _amount,     address _token,     string calldata _memo,     bytes calldata _metadata   ) external payable virtual override isTerminalOf(_projectId) {     _token; // Prevents unused var compiler and natspec complaints. // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender. if (token != JBTokens.ETH) {   // Amount must be greater than 0.   if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();    // Transfer tokens to this terminal from the msg sender.   _transferFrom(msg.sender, payable(address(this)), _amount); } // If the terminal's token is ETH, override `_amount` with msg.value. else _amount = msg.value;  // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal. _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);  } /**     @notice     Process any fees that are being held for the project. @dev Only a project owner, an operator, or the contract's owner can process held fees.  @param _projectId The ID of the project whos held fees should be processed.  */   function processFees(uint256 _projectId)     external     virtual     override     requirePermissionAllowingOverride(       projects.ownerOf(_projectId),       _projectId,       JBOperations.PROCESS_FEES,       msg.sender == owner()     )   {     // Get a reference to the project's held fees.     JBFee[] memory _heldFees = _heldFeesOf[_projectId]; // Delete the held fees. delete _heldFeesOf[_projectId];  // Push array length in stack uint256 _heldFeeLength = _heldFees.length;  // Process each fee. for (uint256 _i = 0; _i &lt; _heldFeeLength; ) {   // Get the fee amount.   uint256 _amount = _feeAmount(     _heldFees[_i].amount,     _heldFees[_i].fee,     _heldFees[_i].feeDiscount   );    // Process the fee.   _processFee(_amount, _heldFees[_i].beneficiary);    emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);    unchecked {     ++_i;   } }  } /**     @notice     Allows the fee to be updated. @dev Only the owner of this contract can change the fee.  @param _fee The new fee, out of MAX_FEE.  */   function setFee(uint256 _fee) external virtual override onlyOwner {     // The provided fee must be within the max.     if (_fee &gt; _FEE_CAP) revert FEE_TOO_HIGH(); // Store the new fee. fee = _fee;  emit SetFee(_fee, msg.sender);  } /**     @notice     Allows the fee gauge to be updated. @dev Only the owner of this contract can change the fee gauge.  @dev If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.  @param _feeGauge The new fee gauge.  */   function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {     // Store the new fee gauge.     feeGauge = _feeGauge; emit SetFeeGauge(_feeGauge, msg.sender);  } /**     @notice     Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee. @dev Only the owner of this contract can set addresses as feeless.  @param _address The address that can be paid towards while still bypassing fees. @param _flag A flag indicating whether the terminal should be feeless or not.  */   function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {     // Set the flag value.     isFeelessAddress[_address] = _flag; emit SetFeelessAddress(_address, _flag, msg.sender);  } //***********//   // ---------------------- internal transactions ---------------------- //   //*************// /**      @notice     Transfers tokens. @param _from The address from which the transfer should originate. @param _to The address to which the transfer should go. @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.  */   function _transferFrom(     address _from,     address payable _to,     uint256 _amount   ) internal virtual; /**      @notice     Logic to be triggered before transferring tokens from this terminal. @param _to The address to which the transfer is going. @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.  */   function _beforeTransferTo(address _to, uint256 _amount) internal virtual; /**     @notice     Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source. @dev Only a token holder or a designated operator can redeem its tokens.  @param _holder The account to redeem tokens for. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal. @param _beneficiary The address to send the terminal tokens to. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.  */   function _redeemTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo,     bytes memory _metadata   ) internal returns (uint256 reclaimAmount) {     // Can't send reclaimed funds to the zero address.     if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS(); // Define variables that will be needed outside the scoped section below. // Keep a reference to the funding cycle during which the redemption is being made. JBFundingCycle memory _fundingCycle;  // Scoped section prevents stack too deep. `_delegate` only used within scope. {   IJBRedemptionDelegate _delegate;    // Record the redemption.   (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(     _holder,     _projectId,     _tokenCount,     _memo,     _metadata   );    // The amount being reclaimed must be at least as much as was expected.   if (reclaimAmount &lt; _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();    // Burn the project tokens.   if (_tokenCount &gt; 0)     IJBController(directory.controllerOf(_projectId)).burnTokensOf(       _holder,       _projectId,       _tokenCount,       '',       false     );    // If a delegate was returned by the data source, issue a callback to it.   if (_delegate != IJBRedemptionDelegate(address(0))) {     JBDidRedeemData memory _data = JBDidRedeemData(       _holder,       _projectId,       _fundingCycle.configuration,       _tokenCount,       JBTokenAmount(token, reclaimAmount, decimals, currency),       _beneficiary,       _memo,       _metadata     );     _delegate.didRedeem(_data);     emit DelegateDidRedeem(_delegate, _data, msg.sender);   } }  // Send the reclaimed funds to the beneficiary. if (reclaimAmount &gt; 0) _transferFrom(address(this), _beneficiary, reclaimAmount);  emit RedeemTokens(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _holder,   _beneficiary,   _tokenCount,   reclaimAmount,   _memo,   _metadata,   msg.sender );  } /**     @notice     Distributes payouts for a project with the distribution limit of its current funding cycle. @dev Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.  @dev Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.  @dev All funds distributed outside of this contract or any feeless terminals incure the protocol fee.  @param _projectId The ID of the project having its payouts distributed. @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency. @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal. @param _memo A memo to pass along to the emitted event.  @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.  */   function _distributePayoutsOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     uint256 _minReturnedTokens,     string calldata _memo   ) internal returns (uint256 netLeftoverDistributionAmount) {     // Record the distribution.     (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(       _projectId,       _amount,       _currency     ); // The amount being distributed must be at least as much as was expected. if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();  // Get a reference to the project owner, which will receive tokens from paying the platform fee // and receive any extra distributable funds not allocated to payout splits. address payable _projectOwner = payable(projects.ownerOf(_projectId));  // Define variables that will be needed outside the scoped section below. // Keep a reference to the fee amount that was paid. uint256 _fee;  // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope. {   // Get the amount of discount that should be applied to any fees taken.   // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.   uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]     ? JBConstants.MAX_FEE_DISCOUNT     : _currentFeeDiscount(_projectId);    // The amount distributed that is eligible for incurring fees.   uint256 _feeEligibleDistributionAmount;    // The amount leftover after distributing to the splits.   uint256 _leftoverDistributionAmount;    // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.   // Also get a reference to the amount that was distributed to splits from which fees should be taken.   (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(     _projectId,     _fundingCycle.configuration,     payoutSplitsGroup,     _distributedAmount,     _feeDiscount   );    // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.   unchecked {     _feeEligibleDistributionAmount += _leftoverDistributionAmount;   }    // Take the fee.   _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0     ? 0     : _takeFeeFrom(       _projectId,       _fundingCycle,       _feeEligibleDistributionAmount,       _projectOwner,       _feeDiscount     );    // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.    unchecked {     netLeftoverDistributionAmount = _leftoverDistributionAmount == 0       ? 0       : _leftoverDistributionAmount -         _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);   }    // Transfer any remaining balance to the project owner.   if (netLeftoverDistributionAmount &gt; 0)     _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount); }  emit DistributePayouts(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _projectOwner,   _amount,   _distributedAmount,   _fee,   netLeftoverDistributionAmount,   _memo,   msg.sender );  } /**     @notice     Allows a project to send funds from its overflow up to the preconfigured allowance. @dev Only a project's owner or a designated operator can use its allowance.  @dev Incurs the protocol fee.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency. @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals. @param _beneficiary The address to send the funds to. @param _memo A memo to pass along to the emitted event.  @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.  */   function _useAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo   ) internal returns (uint256 netDistributedAmount) {     // Record the use of the allowance.     (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(       _projectId,       _amount,       _currency     ); // The amount being withdrawn must be at least as much as was expected. if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();  // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope. {   // Keep a reference to the fee amount that was paid.   uint256 _fee;    // Get a reference to the project owner, which will receive tokens from paying the platform fee.   address _projectOwner = projects.ownerOf(_projectId);    // Get the amount of discount that should be applied to any fees taken.   // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.   uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]     ? JBConstants.MAX_FEE_DISCOUNT     : _currentFeeDiscount(_projectId);    // Take a fee from the `_distributedAmount`, if needed.   _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT     ? 0     : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);    unchecked {     // The net amount is the withdrawn amount without the fee.     netDistributedAmount = _distributedAmount - _fee;   }    // Transfer any remaining balance to the beneficiary.   if (netDistributedAmount &gt; 0)     _transferFrom(address(this), _beneficiary, netDistributedAmount); }  emit UseAllowance(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _beneficiary,   _amount,   _distributedAmount,   netDistributedAmount,   _memo,   msg.sender );  } /**     @notice     Pays out splits for a project's funding cycle configuration. @param _projectId The ID of the project for which payout splits are being distributed. @param _domain The domain of the splits to distribute the payout between. @param _group The group of the splits to distribute the payout between. @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal. @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.  @return leftoverAmount If the leftover amount if the splits don't add up to 100%. @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.  */   function _distributeToPayoutSplitsOf(     uint256 _projectId,     uint256 _domain,     uint256 _group,     uint256 _amount,     uint256 _feeDiscount   ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {     // Set the leftover amount to the initial amount.     leftoverAmount = _amount; // Get a reference to the project's payout splits. JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);  // Transfer between all splits. for (uint256 _i = 0; _i &lt; _splits.length; ) {   // Get a reference to the split being iterated on.   JBSplit memory _split = _splits[_i];    // The amount to send towards the split.   uint256 _payoutAmount = PRBMath.mulDiv(     _amount,     _split.percent,     JBConstants.SPLITS_TOTAL_PERCENT   );    // The payout amount substracting any applicable incurred fees.   uint256 _netPayoutAmount;    if (_payoutAmount &gt; 0) {     // Transfer tokens to the split.     // If there's an allocator set, transfer to its `allocate` function.     if (_split.allocator != IJBSplitAllocator(address(0))) {       // If the split allocator is set as feeless, this distribution is not eligible for a fee.       if (isFeelessAddress[address(_split.allocator)])         _netPayoutAmount = _payoutAmount;         // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.       else {         unchecked {           _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT             ? _payoutAmount             : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);         }          // This distribution is eligible for a fee since the funds are leaving the ecosystem.         feeEligibleDistributionAmount += _payoutAmount;       }        // Trigger any inherited pre-transfer logic.       _beforeTransferTo(address(_split.allocator), _netPayoutAmount);        // If this terminal's token is ETH, send it in msg.value.       uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;        // Create the data to send to the allocator.       JBSplitAllocationData memory _data = JBSplitAllocationData(         token,         _netPayoutAmount,         decimals,         _projectId,         _group,         _split       );        // Trigger the allocator's `allocate` function.       _split.allocator.allocate{value: _payableValue}(_data);        // Otherwise, if a project is specified, make a payment to it.     } else if (_split.projectId != 0) {       // Get a reference to the Juicebox terminal being used.       IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);        // The project must have a terminal to send funds to.       if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();        // Save gas if this contract is being used as the terminal.       if (_terminal == this) {         // This distribution does not incur a fee.         _netPayoutAmount = _payoutAmount;          // Send the projectId in the metadata.         bytes memory _projectMetadata = new bytes(32);         _projectMetadata = bytes(abi.encodePacked(_projectId));          // Add to balance if prefered.         if (_split.preferAddToBalance)           _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);         else           _pay(             _netPayoutAmount,             address(this),             _split.projectId,             (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,             0,             _split.preferClaimed,             '',             _projectMetadata           );       } else {         // If the terminal is set as feeless, this distribution is not eligible for a fee.         if (isFeelessAddress[address(_terminal)])           _netPayoutAmount = _payoutAmount;           // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.         else {           unchecked {             _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT               ? _payoutAmount               : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);           }            feeEligibleDistributionAmount += _payoutAmount;         }          // Trigger any inherited pre-transfer logic.         _beforeTransferTo(address(_terminal), _netPayoutAmount);          // If this terminal's token is ETH, send it in msg.value.         uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;          // Send the projectId in the metadata.         bytes memory _projectMetadata = new bytes(32);         _projectMetadata = bytes(abi.encodePacked(_projectId));          // Add to balance if prefered.         if (_split.preferAddToBalance)           _terminal.addToBalanceOf{value: _payableValue}(             _split.projectId,             _netPayoutAmount,             token,             '',             _projectMetadata           );         else           _terminal.pay{value: _payableValue}(             _split.projectId,             _netPayoutAmount,             token,             _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,             0,             _split.preferClaimed,             '',             _projectMetadata           );       }     } else {       unchecked {         _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT           ? _payoutAmount           : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);       }        // This distribution is eligible for a fee since the funds are leaving the ecosystem.       feeEligibleDistributionAmount += _payoutAmount;        // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.       _transferFrom(         address(this),         _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),         _netPayoutAmount       );     }      // Subtract from the amount to be sent to the beneficiary.     unchecked {       leftoverAmount = leftoverAmount - _payoutAmount;     }   }    emit DistributeToPayoutSplit(     _projectId,     _domain,     _group,     _split,     _netPayoutAmount,     msg.sender   );    unchecked {     ++_i;   } }  } /**     @notice     Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID. @param _projectId The ID of the project having fees taken from. @param _fundingCycle The funding cycle during which the fee is being taken. @param _amount The amount of the fee to take, as a floating point number with 18 decimals. @param _beneficiary The address to mint the platforms tokens for. @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.  @return feeAmount The amount of the fee taken.  */   function _takeFeeFrom(     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _amount,     address _beneficiary,     uint256 _feeDiscount   ) internal returns (uint256 feeAmount) {     feeAmount = _feeAmount(_amount, fee, _feeDiscount); if (_fundingCycle.shouldHoldFees()) {   // Store the held fee.   _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));    emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender); } else {   // Process the fee.   _processFee(feeAmount, _beneficiary); // Take the fee.    emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender); }  } /**     @notice     Process a fee of the specified amount. @param _amount The fee amount, as a floating point number with 18 decimals. @param _beneficiary The address to mint the platform's tokens for.  */   function _processFee(uint256 _amount, address _beneficiary) internal {     // Get the terminal for the protocol project.     IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token); // When processing the admin fee, save gas if the admin is using this contract as its terminal. if (_terminal == this)   _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call. else {   // Trigger any inherited pre-transfer logic.   _beforeTransferTo(address(_terminal), _amount);    // If this terminal's token is ETH, send it in msg.value.   uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;    // Send the payment.   _terminal.pay{value: _payableValue}(     _PROTOCOL_PROJECT_ID,     _amount,     token,     _beneficiary,     0,     false,     '',     bytes('')   ); // Use the external pay call of the correct terminal. }  } /**     @notice     Contribute tokens to a project. @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place. @param _payer The address making the payment. @param _projectId The ID of the project being paid. @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate. @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal. @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas. @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.  */   function _pay(     uint256 _amount,     address _payer,     uint256 _projectId,     address _beneficiary,     uint256 _minReturnedTokens,     bool _preferClaimedTokens,     string memory _memo,     bytes memory _metadata   ) internal returns (uint256 beneficiaryTokenCount) {     // Cant send tokens to the zero address.     if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS(); // Define variables that will be needed outside the scoped section below. // Keep a reference to the funding cycle during which the payment is being made. JBFundingCycle memory _fundingCycle;  // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope. {   IJBPayDelegate _delegate;   uint256 _tokenCount;    // Bundle the amount info into a JBTokenAmount struct.   JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);    // Record the payment.   (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(     _payer,     _bundledAmount,     _projectId,     baseWeightCurrency,     _beneficiary,     _memo,     _metadata   );    // Mint the tokens if needed.   if (_tokenCount &gt; 0)     // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.     beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(       _projectId,       _tokenCount,       _beneficiary,       '',       _preferClaimedTokens,       true     );    // The token count for the beneficiary must be greater than or equal to the minimum expected.   if (beneficiaryTokenCount &lt; _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();    // If a delegate was returned by the data source, issue a callback to it.   if (_delegate != IJBPayDelegate(address(0))) {     JBDidPayData memory _data = JBDidPayData(       _payer,       _projectId,       _fundingCycle.configuration,       _bundledAmount,       beneficiaryTokenCount,       _beneficiary,       _preferClaimedTokens,       _memo,       _metadata     );      _delegate.didPay(_data);     emit DelegateDidPay(_delegate, _data, msg.sender);   } }  emit Pay(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _payer,   _beneficiary,   _amount,   beneficiaryTokenCount,   _memo,   _metadata,   msg.sender );  } /**     @notice     Receives funds belonging to the specified project. @param _projectId The ID of the project to which the funds received belong. @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead. @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added. @param _memo A memo to pass along to the emitted event. @param _metadata Extra data to pass along to the emitted event.  */   function _addToBalanceOf(     uint256 _projectId,     uint256 _amount,     bool _shouldRefundHeldFees,     string memory _memo,     bytes memory _metadata   ) internal {     // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.     uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0; // Record the added funds with any refunded fees. store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);  emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);  } /**     @notice     Refund fees based on the specified amount. @param _projectId The project for which fees are being refunded. @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.  @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal  */   function _refundHeldFees(uint256 _projectId, uint256 _amount)     internal     returns (uint256 refundedFees)   {     // Get a reference to the project's held fees.     JBFee[] memory _heldFees = _heldFeesOf[_projectId]; // Delete the current held fees. delete _heldFeesOf[_projectId];  // Get a reference to the leftover amount once all fees have been settled. uint256 leftoverAmount = _amount;  // Push length in stack uint256 _heldFeesLength = _heldFees.length;  // Process each fee. for (uint256 _i = 0; _i &lt; _heldFeesLength; ) {   if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);   else if (leftoverAmount &gt;= _heldFees[_i].amount) {     unchecked {       leftoverAmount = leftoverAmount - _heldFees[_i].amount;       refundedFees += _feeAmount(         _heldFees[_i].amount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount       );     }   } else {     _heldFeesOf[_projectId].push(       JBFee(         _heldFees[_i].amount - leftoverAmount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount,         _heldFees[_i].beneficiary       )     );     unchecked {       refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);     }     leftoverAmount = 0;   }    unchecked {     ++_i;   } }  emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);  } /**      @notice      Returns the fee amount based on the provided amount for the specified project. @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal. @param _fee The percentage of the fee, out of MAX_FEE.  @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.  @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.  */   function _feeAmount(     uint256 _amount,     uint256 _fee,     uint256 _feeDiscount   ) internal pure returns (uint256) {     // Calculate the discounted fee.     uint256 _discountedFee = _fee -       PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT); // The amount of tokens from the `_amount` to pay as a fee. return   _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);  } /**      @notice     Get the fee discount from the fee gauge for the specified project. @param _projectId The ID of the project to get a fee discount for.  @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.  */   function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {     // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.     if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))       return JBConstants.MAX_FEE_DISCOUNT; // Get the fee discount. if (feeGauge == IJBFeeGauge(address(0)))   feeDiscount = 0;   // If the guage reverts, set the discount to 0. else   try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {     feeDiscount = discount;   } catch {     feeDiscount = 0;   }  // If the fee discount is greater than the max, nullify the discount. if (feeDiscount &gt; JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;  } } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: // SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\nimport \'@openzeppelin/contracts/access/Ownable.sol\';\nimport \'@openzeppelin/contracts/security/ReentrancyGuard.sol\';\nimport \'@openzeppelin/contracts/token/ERC20/IERC20.sol\';\nimport \'@paulrberg/contracts/math/PRBMath.sol\';\nimport \'./../interfaces/IJBController.sol\';\nimport \'./../interfaces/IJBPayoutRedemptionPaymentTerminal.sol\';\nimport \'./../libraries/JBConstants.sol\';\nimport \'./../libraries/JBCurrencies.sol\';\nimport \'./../libraries/JBFixedPointNumber.sol\';\nimport \'./../libraries/JBFundingCycleMetadataResolver.sol\';\nimport \'./../libraries/JBOperations.sol\';\nimport \'./../libraries/JBSplitsGroups.sol\';\nimport \'./../libraries/JBTokens.sol\';\nimport \'./../structs/JBTokenAmount.sol\';\nimport \'./JBOperatable.sol\';\nimport \'./JBSingleTokenPaymentTerminal.sol\';\n/\n  @notice\n  Generic terminal managing all inflows and outflows of funds into the protocol ecosystem.\n  @dev\n  A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time.\n  @dev\n  Adheres to -\n  IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain\'s state according to the protocol\'s rules.\n  @dev\n  Inherits from -\n  JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.\n  JBOperatable: Includes convenience functionality for checking a message sender\'s permissions before executing certain transactions.\n  Ownable: Includes convenience functionality for checking a message sender\'s permissions before executing certain transactions.\n  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.\n/\nabstract contract JBPayoutRedemptionPaymentTerminal is\n  IJBPayoutRedemptionPaymentTerminal,\n  JBSingleTokenPaymentTerminal,\n  JBOperatable,\n  Ownable,\n  ReentrancyGuard\n{\n  // A library that parses the packed funding cycle metadata into a friendlier format.\n  using JBFundingCycleMetadataResolver for JBFundingCycle;\n  //*********//\n  // --------------------------- custom errors ------------------------- //\n  //*********//\n  error FEE_TOO_HIGH();\n  error INADEQUATE_DISTRIBUTION_AMOUNT();\n  error INADEQUATE_RECLAIM_AMOUNT();\n  error INADEQUATE_TOKEN_COUNT();\n  error NO_MSG_VALUE_ALLOWED();\n  error PAY_TO_ZERO_ADDRESS();\n  error PROJECT_TERMINAL_MISMATCH();\n  error REDEEM_TO_ZERO_ADDRESS();\n  error TERMINAL_IN_SPLIT_ZERO_ADDRESS();\n  error TERMINAL_TOKENS_INCOMPATIBLE();\n  //*********//\n  // ---------------------------- modifiers ---------------------------- //\n  //*********//\n  / \n    @notice \n    A modifier that verifies this terminal is a terminal of provided project ID.\n  /\n  modifier isTerminalOf(uint256 projectId) {\n    if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();\n    ;\n  }\n  //**********//\n  // --------------------- internal stored constants ------------------- //\n  //*********//\n  /\n    @notice\n    Maximum fee that can be set for a funding cycle configuration.\n    @dev\n    Out of MAX_FEE (50_000_000 / 1_000_000_000).\n  /\n  uint256 internal constant _FEE_CAP = 50_000_000;\n  /\n    @notice\n    The protocol project ID is 1, as it should be the first project launched during the deployment process.\n  /\n  uint256 internal constant _PROTOCOL_PROJECT_ID = 1;\n  //**********//\n  // --------------------- internal stored properties ------------------ //\n  //**********//\n  /\n    @notice\n    Fees that are being held to be processed later.\n    _projectId The ID of the project for which fees are being held.\n  /\n  mapping(uint256 =&gt; JBFee[]) internal _heldFeesOf;\n  //**********//\n  // ---------------- public immutable stored properties --------------- //\n  //*********//\n  /\n    @notice\n    Mints ERC-721\'s that represent project ownership and transfers.\n  /\n  IJBProjects public immutable override projects;\n  /\n    @notice\n    The directory of terminals and controllers for projects.\n  /\n  IJBDirectory public immutable override directory;\n  /\n    @notice\n    The contract that stores splits for each project.\n  /\n  IJBSplitsStore public immutable override splitsStore;\n  /\n    @notice\n    The contract that exposes price feeds.\n  /\n  IJBPrices public immutable override prices;\n  /\n    @notice\n    The contract that stores and manages the terminal\'s data.\n  */\n  IJBSingleTokenPaymentTerminalStore public immutable override store;\n  /\n    @notice\n    The currency to base token issuance on.\n    @dev\n    If this differs from currency, there must be a price feed available to convert currency to baseWeightCurrency.\n  /\n  uint256 public immutable override baseWeightCurrency;\n  /\n    @notice\n    The group that payout splits coming from this terminal are identified by.\n  /\n  uint256 public immutable override payoutSplitsGroup;\n  //*********//\n  // --------------------- public stored properties -------------------- //\n  //*********//\n  /\n    @notice\n    The platform fee percent.\n    @dev\n    Out of MAX_FEE (25_000_000 / 1_000_000_000)\n  /\n  uint256 public override fee = 25_000_000; // 2.5%\n  /\n    @notice\n    The data source that returns a discount to apply to a project\'s fee.\n  /\n  IJBFeeGauge public override feeGauge;\n  /\n    @notice\n    Addresses that can be paid towards from this terminal without incurring a fee.\n    _address The address that can be paid toward.\n  /\n  mapping(address =&gt; bool) public override isFeelessAddress;\n  //***********//\n  // ------------------------- external views -------------------------- //\n  //**********//\n  /\n    @notice\n    Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.\n    @dev\n    The current overflow is represented as a fixed point number with 18 decimals.\n    @param _projectId The ID of the project to get overflow for.\n    @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.\n  /\n  function currentEthOverflowOf(uint256 _projectId)\n    external\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    // Get this terminal\'s current overflow.\n    uint256 _overflow = store.currentOverflowOf(this, _projectId);\n    // Adjust the decimals of the fixed point number if needed to have 18 decimals.\n    uint256 _adjustedOverflow = (decimals == 18)\n      ? _overflow\n      : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);\n    // Return the amount converted to ETH.\n    return\n      (currency == JBCurrencies.ETH)\n        ? _adjustedOverflow\n        : PRBMath.mulDiv(\n          _adjustedOverflow,\n          10decimals,\n          prices.priceFor(currency, JBCurrencies.ETH, decimals)\n        );\n  }\n  /\n    @notice\n    The fees that are currently being held to be processed later for each project.\n    @param _projectId The ID of the project for which fees are being held.\n    @return An array of fees that are being held.\n  /\n  function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {\n    return _heldFeesOf[_projectId];\n  }\n  //*********//\n  // -------------------------- public views --------------------------- //\n  //*********//\n  /\n    @notice\n    Indicates if this contract adheres to the specified interface.\n    @dev \n    See {IERC165-supportsInterface}.\n    @param _interfaceId The ID of the interface to check for adherance to.\n  /\n  function supportsInterface(bytes4 _interfaceId)\n    public\n    view\n    virtual\n    override(JBSingleTokenPaymentTerminal, IERC165)\n    returns (bool)\n  {\n    return\n      _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||\n      _interfaceId == type(IJBPayoutTerminal).interfaceId ||\n      _interfaceId == type(IJBAllowanceTerminal).interfaceId ||\n      _interfaceId == type(IJBRedemptionTerminal).interfaceId ||\n      _interfaceId == type(IJBOperatable).interfaceId ||\n      super.supportsInterface(_interfaceId);\n  }\n  //**********//\n  // -------------------------- constructor ---------------------------- //\n  //*********//\n  /\n    @param _token The token that this terminal manages.\n    @param _decimals The number of decimals the token fixed point amounts are expected to have.\n    @param _currency The currency that this terminal\'s token adheres to for price feeds.\n    @param _baseWeightCurrency The currency to base token issuance on.\n    @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.\n    @param _operatorStore A contract storing operator assignments.\n    @param _projects A contract which mints ERC-721\'s that represent project ownership and transfers.\n    @param _directory A contract storing directories of terminals and controllers for each project.\n    @param _splitsStore A contract that stores splits for each project.\n    @param _prices A contract that exposes price feeds.\n    @param _store A contract that stores the terminal\'s data.\n    @param _owner The address that will own this contract.\n  /\n  constructor(\n    // payable constructor save the gas used to check msg.value==0\n    address _token,\n    uint256 _decimals,\n    uint256 _currency,\n    uint256 _baseWeightCurrency,\n    uint256 _payoutSplitsGroup,\n    IJBOperatorStore _operatorStore,\n    IJBProjects _projects,\n    IJBDirectory _directory,\n    IJBSplitsStore _splitsStore,\n    IJBPrices _prices,\n    IJBSingleTokenPaymentTerminalStore _store,\n    address _owner\n  )\n    payable\n    JBSingleTokenPaymentTerminal(_token, _decimals, _currency)\n    JBOperatable(_operatorStore)\n  {\n    baseWeightCurrency = _baseWeightCurrency;\n    payoutSplitsGroup = _payoutSplitsGroup;\n    projects = _projects;\n    directory = _directory;\n    splitsStore = _splitsStore;\n    prices = _prices;\n    store = _store;\n    transferOwnership(_owner);\n  }\n  //**********//\n  // ---------------------- external transactions ---------------------- //\n  //*********//\n  /\n    @notice\n    Contribute tokens to a project.\n    @param _projectId The ID of the project being paid.\n    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal\'s token is ETH, this is ignored and msg.value is used in its place.\n    @param _token The token being paid. This terminal ignores this property since it only manages one token. \n    @param _beneficiary The address to mint tokens for and pass along to the funding cycle\'s data source and delegate.\n    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.\n    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.\n    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle\'s data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.\n    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.\n    @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.\n  /\n  function pay(\n    uint256 _projectId,\n    uint256 _amount,\n    address _token,\n    address _beneficiary,\n    uint256 _minReturnedTokens,\n    bool _preferClaimedTokens,\n    string calldata _memo,\n    bytes calldata _metadata\n  ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {\n    _token; // Prevents unused var compiler and natspec complaints.\n    // ETH shouldn\'t be sent if this terminal\'s token isn\'t ETH.\n    if (token != JBTokens.ETH) {\n      if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();\n      // Transfer tokens to this terminal from the msg sender.\n      _transferFrom(msg.sender, payable(address(this)), _amount);\n    }\n    // If this terminal\'s token is ETH, override _amount with msg.value.\n    else _amount = msg.value;\n    return\n      _pay(\n        _amount,\n        msg.sender,\n        _projectId,\n        _beneficiary,\n        _minReturnedTokens,\n        _preferClaimedTokens,\n        _memo,\n        _metadata\n      );\n  }\n  /\n    @notice\n    Holders can redeem their tokens to claim the project\'s overflowed tokens, or to trigger rules determined by the project\'s current funding cycle\'s data source.\n    @dev\n    Only a token holder or a designated operator can redeem its tokens.\n    @param _holder The account to redeem tokens for.\n    @param _projectId The ID of the project to which the tokens being redeemed belong.\n    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.\n    @param _token The token being reclaimed. This terminal ignores this property since it only manages one token. \n    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.\n    @param _beneficiary The address to send the terminal tokens to.\n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.\n    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.\n  /\n  function redeemTokensOf(\n    address _holder,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    address _token,\n    uint256 _minReturnedTokens,\n    address payable _beneficiary,\n    string memory _memo,\n    bytes memory _metadata\n  )\n    external\n    virtual\n    override\n    requirePermission(_holder, _projectId, JBOperations.REDEEM)\n    returns (uint256 reclaimAmount)\n  {\n    _token; // Prevents unused var compiler and natspec complaints.\n    return\n      _redeemTokensOf(\n        _holder,\n        _projectId,\n        _tokenCount,\n        _minReturnedTokens,\n        _beneficiary,\n        _memo,\n        _metadata\n      );\n  }\n  /\n    @notice\n    Distributes payouts for a project with the distribution limit of its current funding cycle.\n    @dev\n    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project\'s owner.\n    @dev\n    Anyone can distribute payouts on a project\'s behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.\n    @dev\n    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.\n    @param _projectId The ID of the project having its payouts distributed.\n    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.\n    @param _currency The expected currency of the amount being distributed. Must match the project\'s current funding cycle\'s distribution limit currency.\n    @param _token The token being distributed. This terminal ignores this property since it only manages one token. \n    @param _minReturnedTokens The minimum number of terminal tokens that the _amount should be valued at in terms of this terminal\'s currency, as a fixed point number with the same number of decimals as this terminal.\n    @param _memo A memo to pass along to the emitted event.\n    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.\n  /\n  function distributePayoutsOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency,\n    address _token,\n    uint256 _minReturnedTokens,\n    string calldata _memo\n  ) external virtual override returns (uint256 netLeftoverDistributionAmount) {\n    _token; // Prevents unused var compiler and natspec complaints.\n    return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);\n  }\n  /\n    @notice\n    Allows a project to send funds from its overflow up to the preconfigured allowance.\n    @dev\n    Only a project\'s owner or a designated operator can use its allowance.\n    @dev\n    Incurs the protocol fee.\n    @param _projectId The ID of the project to use the allowance of.\n    @param _amount The amount of terminal tokens to use from this project\'s current allowance, as a fixed point number with the same amount of decimals as this terminal.\n    @param _currency The expected currency of the amount being distributed. Must match the project\'s current funding cycle\'s overflow allowance currency.\n    @param _token The token being distributed. This terminal ignores this property since it only manages one token. \n    @param _minReturnedTokens The minimum number of tokens that the _amount should be valued at in terms of this terminal\'s currency, as a fixed point number with 18 decimals.\n    @param _beneficiary The address to send the funds to.\n    @param _memo A memo to pass along to the emitted event.\n    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.\n  /\n  function useAllowanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency,\n    address _token,\n    uint256 _minReturnedTokens,\n    address payable _beneficiary,\n    string memory _memo\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)\n    returns (uint256 netDistributedAmount)\n  {\n    _token; // Prevents unused var compiler and natspec complaints.\n    return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);\n  }\n  /\n    @notice\n    Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.\n    @dev\n    Only a project\'s owner or a designated operator can migrate it.\n    @param _projectId The ID of the project being migrated.\n    @param _to The terminal contract that will gain the project\'s funds.\n    @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.\n  */\n  function migrate(uint256 _projectId, IJBPaymentTerminal _to)\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)\n    returns (uint256 balance)\n  {\n    // The terminal being migrated to must accept the same token as this terminal.\n    if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE();\n    // Record the migration in the store.\n    balance = store.recordMigration(_projectId);\n    // Transfer the balance if needed.\n    if (balance &gt; 0) {\n      // Trigger any inherited pre-transfer logic.\n      _beforeTransferTo(address(_to), balance);\n      // If this terminal\'s token is ETH, send it in msg.value.\n      uint256 _payableValue = token == JBTokens.ETH ? balance : 0;\n      // Withdraw the balance to transfer to the new terminal;\n      _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, \'\', bytes(\'\'));\n    }\n    emit Migrate(_projectId, _to, balance, msg.sender);\n  }\n  /\n    @notice\n    Receives funds belonging to the specified project.\n    @param _projectId The ID of the project to which the funds received belong.\n    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.\n    @param _token The token being paid. This terminal ignores this property since it only manages one currency. \n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Extra data to pass along to the emitted event.\n  /\n  function addToBalanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    address _token,\n    string calldata _memo,\n    bytes calldata _metadata\n  ) external payable virtual override isTerminalOf(_projectId) {\n    _token; // Prevents unused var compiler and natspec complaints.\n    // If this terminal\'s token isn\'t ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender.\n    if (token != JBTokens.ETH) {\n      // Amount must be greater than 0.\n      if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();\n      // Transfer tokens to this terminal from the msg sender.\n      _transferFrom(msg.sender, payable(address(this)), _amount);\n    }\n    // If the terminal\'s token is ETH, override _amount with msg.value.\n    else _amount = msg.value;\n    // Add to balance while only refunding held fees if the funds aren\'t originating from a feeless terminal.\n    _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);\n  }\n  /\n    @notice\n    Process any fees that are being held for the project.\n    @dev\n    Only a project owner, an operator, or the contract\'s owner can process held fees.\n    @param _projectId The ID of the project whos held fees should be processed.\n  /\n  function processFees(uint256 _projectId)\n    external\n    virtual\n    override\n    requirePermissionAllowingOverride(\n      projects.ownerOf(_projectId),\n      _projectId,\n      JBOperations.PROCESS_FEES,\n      msg.sender == owner()\n    )\n  {\n    // Get a reference to the project\'s held fees.\n    JBFee[] memory _heldFees = _heldFeesOf[_projectId];\n    // Delete the held fees.\n    delete _heldFeesOf[_projectId];\n    // Push array length in stack\n    uint256 _heldFeeLength = _heldFees.length;\n    // Process each fee.\n    for (uint256 _i = 0; _i &lt; _heldFeeLength; ) {\n      // Get the fee amount.\n      uint256 _amount = _feeAmount(\n        _heldFees[_i].amount,\n        _heldFees[_i].fee,\n        _heldFees[_i].feeDiscount\n      );\n      // Process the fee.\n      _processFee(_amount, _heldFees[_i].beneficiary);\n      emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n  /\n    @notice\n    Allows the fee to be updated.\n    @dev\n    Only the owner of this contract can change the fee.\n    @param _fee The new fee, out of MAX_FEE.\n  */\n  function setFee(uint256 _fee) external virtual override onlyOwner {\n    // The provided fee must be within the max.\n    if (_fee &gt; _FEE_CAP) revert FEE_TOO_HIGH();\n    // Store the new fee.\n    fee = _fee;\n    emit SetFee(_fee, msg.sender);\n  }\n  /\n    @notice\n    Allows the fee gauge to be updated.\n    @dev\n    Only the owner of this contract can change the fee gauge.\n    @dev\n    If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project\'s funds will be locked. This is a known risk.\n    @param _feeGauge The new fee gauge.\n  /\n  function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {\n    // Store the new fee gauge.\n    feeGauge = _feeGauge;\n    emit SetFeeGauge(_feeGauge, msg.sender);\n  }\n  /\n    @notice\n    Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.\n    @dev\n    Only the owner of this contract can set addresses as feeless.\n    @param _address The address that can be paid towards while still bypassing fees.\n    @param _flag A flag indicating whether the terminal should be feeless or not.\n  /\n  function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {\n    // Set the flag value.\n    isFeelessAddress[_address] = _flag;\n    emit SetFeelessAddress(_address, _flag, msg.sender);\n  }\n  //*********//\n  // ---------------------- internal transactions ---------------------- //\n  //*********//\n  / \n    @notice\n    Transfers tokens.\n    @param _from The address from which the transfer should originate.\n    @param _to The address to which the transfer should go.\n    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.\n  /\n  function _transferFrom(\n    address _from,\n    address payable _to,\n    uint256 _amount\n  ) internal virtual;\n  / \n    @notice\n    Logic to be triggered before transferring tokens from this terminal.\n    @param _to The address to which the transfer is going.\n    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.\n  /\n  function _beforeTransferTo(address _to, uint256 _amount) internal virtual;\n  /\n    @notice\n    Holders can redeem their tokens to claim the project\'s overflowed tokens, or to trigger rules determined by the project\'s current funding cycle\'s data source.\n    @dev\n    Only a token holder or a designated operator can redeem its tokens.\n    @param _holder The account to redeem tokens for.\n    @param _projectId The ID of the project to which the tokens being redeemed belong.\n    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.\n    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.\n    @param _beneficiary The address to send the terminal tokens to.\n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.\n    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.\n  /\n  function _redeemTokensOf(\n    address _holder,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    uint256 _minReturnedTokens,\n    address payable _beneficiary,\n    string memory _memo,\n    bytes memory _metadata\n  ) internal returns (uint256 reclaimAmount) {\n    // Can\'t send reclaimed funds to the zero address.\n    if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS();\n    // Define variables that will be needed outside the scoped section below.\n    // Keep a reference to the funding cycle during which the redemption is being made.\n    JBFundingCycle memory _fundingCycle;\n    // Scoped section prevents stack too deep. _delegate only used within scope.\n    {\n      IJBRedemptionDelegate _delegate;\n      // Record the redemption.\n      (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(\n        _holder,\n        _projectId,\n        _tokenCount,\n        _memo,\n        _metadata\n      );\n      // The amount being reclaimed must be at least as much as was expected.\n      if (reclaimAmount &lt; _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();\n      // Burn the project tokens.\n      if (_tokenCount &gt; 0)\n        IJBController(directory.controllerOf(_projectId)).burnTokensOf(\n          _holder,\n          _projectId,\n          _tokenCount,\n          \'\',\n          false\n        );\n      // If a delegate was returned by the data source, issue a callback to it.\n      if (_delegate != IJBRedemptionDelegate(address(0))) {\n        JBDidRedeemData memory _data = JBDidRedeemData(\n          _holder,\n          _projectId,\n          _fundingCycle.configuration,\n          _tokenCount,\n          JBTokenAmount(token, reclaimAmount, decimals, currency),\n          _beneficiary,\n          _memo,\n          _metadata\n        );\n        _delegate.didRedeem(_data);\n        emit DelegateDidRedeem(_delegate, _data, msg.sender);\n      }\n    }\n    // Send the reclaimed funds to the beneficiary.\n    if (reclaimAmount &gt; 0) _transferFrom(address(this), _beneficiary, reclaimAmount);\n    emit RedeemTokens(\n      _fundingCycle.configuration,\n      _fundingCycle.number,\n      _projectId,\n      _holder,\n      _beneficiary,\n      _tokenCount,\n      reclaimAmount,\n      _memo,\n      _metadata,\n      msg.sender\n    );\n  }\n  /\n    @notice\n    Distributes payouts for a project with the distribution limit of its current funding cycle.\n    @dev\n    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project\'s owner.\n    @dev\n    Anyone can distribute payouts on a project\'s behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.\n    @dev\n    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.\n    @param _projectId The ID of the project having its payouts distributed.\n    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.\n    @param _currency The expected currency of the amount being distributed. Must match the project\'s current funding cycle\'s distribution limit currency.\n    @param _minReturnedTokens The minimum number of terminal tokens that the _amount should be valued at in terms of this terminal\'s currency, as a fixed point number with the same number of decimals as this terminal.\n    @param _memo A memo to pass along to the emitted event.\n    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.\n  /\n  function _distributePayoutsOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency,\n    uint256 _minReturnedTokens,\n    string calldata _memo\n  ) internal returns (uint256 netLeftoverDistributionAmount) {\n    // Record the distribution.\n    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(\n      _projectId,\n      _amount,\n      _currency\n    );\n    // The amount being distributed must be at least as much as was expected.\n    if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();\n    // Get a reference to the project owner, which will receive tokens from paying the platform fee\n    // and receive any extra distributable funds not allocated to payout splits.\n    address payable _projectOwner = payable(projects.ownerOf(_projectId));\n    // Define variables that will be needed outside the scoped section below.\n    // Keep a reference to the fee amount that was paid.\n    uint256 _fee;\n    // Scoped section prevents stack too deep. _feeDiscount, _feeEligibleDistributionAmount, and _leftoverDistributionAmount only used within scope.\n    {\n      // Get the amount of discount that should be applied to any fees taken.\n      // If the fee is zero or if the fee is being used by an address that doesn\'t incur fees, set the discount to 100% for convinience.\n      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]\n        ? JBConstants.MAX_FEE_DISCOUNT\n        : _currentFeeDiscount(_projectId);\n      // The amount distributed that is eligible for incurring fees.\n      uint256 _feeEligibleDistributionAmount;\n      // The amount leftover after distributing to the splits.\n      uint256 _leftoverDistributionAmount;\n      // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.\n      // Also get a reference to the amount that was distributed to splits from which fees should be taken.\n      (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(\n        _projectId,\n        _fundingCycle.configuration,\n        payoutSplitsGroup,\n        _distributedAmount,\n        _feeDiscount\n      );\n      // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.\n      unchecked {\n        _feeEligibleDistributionAmount += _leftoverDistributionAmount;\n      }\n      // Take the fee.\n      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0\n        ? 0\n        : _takeFeeFrom(\n          _projectId,\n          _fundingCycle,\n          _feeEligibleDistributionAmount,\n          _projectOwner,\n          _feeDiscount\n        );\n      // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.\n      unchecked {\n        netLeftoverDistributionAmount = _leftoverDistributionAmount == 0\n          ? 0\n          : _leftoverDistributionAmount -\n            _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);\n      }\n      // Transfer any remaining balance to the project owner.\n      if (netLeftoverDistributionAmount &gt; 0)\n        _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount);\n    }\n    emit DistributePayouts(\n      _fundingCycle.configuration,\n      _fundingCycle.number,\n      _projectId,\n      _projectOwner,\n      _amount,\n      _distributedAmount,\n      _fee,\n      netLeftoverDistributionAmount,\n      _memo,\n      msg.sender\n    );\n  }\n  /\n    @notice\n    Allows a project to send funds from its overflow up to the preconfigured allowance.\n    @dev\n    Only a project\'s owner or a designated operator can use its allowance.\n    @dev\n    Incurs the protocol fee.\n    @param _projectId The ID of the project to use the allowance of.\n    @param _amount The amount of terminal tokens to use from this project\'s current allowance, as a fixed point number with the same amount of decimals as this terminal.\n    @param _currency The expected currency of the amount being distributed. Must match the project\'s current funding cycle\'s overflow allowance currency.\n    @param _minReturnedTokens The minimum number of tokens that the _amount should be valued at in terms of this terminal\'s currency, as a fixed point number with 18 decimals.\n    @param _beneficiary The address to send the funds to.\n    @param _memo A memo to pass along to the emitted event.\n    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.\n  */\n  function _useAllowanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency,\n    uint256 _minReturnedTokens,\n    address payable _beneficiary,\n    string memory _memo\n  ) internal returns (uint256 netDistributedAmount) {\n    // Record the use of the allowance.\n    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(\n      _projectId,\n      _amount,\n      _currency\n    );\n    // The amount being withdrawn must be at least as much as was expected.\n    if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();\n    // Scoped section prevents stack too deep. _fee, _projectOwner, _feeDiscount, and _netAmount only used within scope.\n    {\n      // Keep a reference to the fee amount that was paid.\n      uint256 _fee;\n      // Get a reference to the project owner, which will receive tokens from paying the platform fee.\n      address _projectOwner = projects.ownerOf(_projectId);\n      // Get the amount of discount that should be applied to any fees taken.\n      // If the fee is zero or if the fee is being used by an address that doesn\'t incur fees, set the discount to 100% for convinience.\n      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]\n        ? JBConstants.MAX_FEE_DISCOUNT\n        : _currentFeeDiscount(_projectId);\n      // Take a fee from the _distributedAmount, if needed.\n      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT\n        ? 0\n        : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);\n      unchecked {\n        // The net amount is the withdrawn amount without the fee.\n        netDistributedAmount = _distributedAmount - _fee;\n      }\n      // Transfer any remaining balance to the beneficiary.\n      if (netDistributedAmount &gt; 0)\n        _transferFrom(address(this), _beneficiary, netDistributedAmount);\n    }\n    emit UseAllowance(\n      _fundingCycle.configuration,\n      _fundingCycle.number,\n      _projectId,\n      _beneficiary,\n      _amount,\n      _distributedAmount,\n      netDistributedAmount,\n      _memo,\n      msg.sender\n    );\n  }\n  /\n    @notice\n    Pays out splits for a project\'s funding cycle configuration.\n    @param _projectId The ID of the project for which payout splits are being distributed.\n    @param _domain The domain of the splits to distribute the payout between.\n    @param _group The group of the splits to distribute the payout between.\n    @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal.\n    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.\n    @return leftoverAmount If the leftover amount if the splits don\'t add up to 100%.\n    @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.\n  /\n  function _distributeToPayoutSplitsOf(\n    uint256 _projectId,\n    uint256 _domain,\n    uint256 _group,\n    uint256 _amount,\n    uint256 _feeDiscount\n  ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {\n    // Set the leftover amount to the initial amount.\n    leftoverAmount = _amount;\n    // Get a reference to the project\'s payout splits.\n    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);\n    // Transfer between all splits.\n    for (uint256 _i = 0; _i &lt; _splits.length; ) {\n      // Get a reference to the split being iterated on.\n      JBSplit memory _split = _splits[_i];\n      // The amount to send towards the split.\n      uint256 _payoutAmount = PRBMath.mulDiv(\n        _amount,\n        _split.percent,\n        JBConstants.SPLITS_TOTAL_PERCENT\n      );\n      // The payout amount substracting any applicable incurred fees.\n      uint256 _netPayoutAmount;\n      if (_payoutAmount &gt; 0) {\n        // Transfer tokens to the split.\n        // If there\'s an allocator set, transfer to its allocate function.\n        if (_split.allocator != IJBSplitAllocator(address(0))) {\n          // If the split allocator is set as feeless, this distribution is not eligible for a fee.\n          if (isFeelessAddress[address(_split.allocator)])\n            _netPayoutAmount = _payoutAmount;\n            // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn\'t listed as feeless.\n          else {\n            unchecked {\n              _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT\n                ? _payoutAmount\n                : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);\n            }\n            // This distribution is eligible for a fee since the funds are leaving the ecosystem.\n            feeEligibleDistributionAmount += _payoutAmount;\n          }\n          // Trigger any inherited pre-transfer logic.\n          _beforeTransferTo(address(_split.allocator), _netPayoutAmount);\n          // If this terminal\'s token is ETH, send it in msg.value.\n          uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;\n          // Create the data to send to the allocator.\n          JBSplitAllocationData memory _data = JBSplitAllocationData(\n            token,\n            _netPayoutAmount,\n            decimals,\n            _projectId,\n            _group,\n            _split\n          );\n          // Trigger the allocator\'s allocate function.\n          _split.allocator.allocate{value: _payableValue}(_data);\n          // Otherwise, if a project is specified, make a payment to it.\n        } else if (_split.projectId != 0) {\n          // Get a reference to the Juicebox terminal being used.\n          IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);\n          // The project must have a terminal to send funds to.\n          if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();\n          // Save gas if this contract is being used as the terminal.\n          if (_terminal == this) {\n            // This distribution does not incur a fee.\n            _netPayoutAmount = _payoutAmount;\n            // Send the projectId in the metadata.\n            bytes memory _projectMetadata = new bytes(32);\n            _projectMetadata = bytes(abi.encodePacked(_projectId));\n            // Add to balance if prefered.\n            if (_split.preferAddToBalance)\n              _addToBalanceOf(_split.projectId, _netPayoutAmount, false, \'\', _projectMetadata);\n            else\n              _pay(\n                _netPayoutAmount,\n                address(this),\n                _split.projectId,\n                (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,\n                0,\n                _split.preferClaimed,\n                \'\',\n                _projectMetadata\n              );\n          } else {\n            // If the terminal is set as feeless, this distribution is not eligible for a fee.\n            if (isFeelessAddress[address(_terminal)])\n              _netPayoutAmount = _payoutAmount;\n              // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn\'t listed as feeless.\n            else {\n              unchecked {\n                _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT\n                  ? _payoutAmount\n                  : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);\n              }\n              feeEligibleDistributionAmount += _payoutAmount;\n            }\n            // Trigger any inherited pre-transfer logic.\n            _beforeTransferTo(address(_terminal), _netPayoutAmount);\n            // If this terminal\'s token is ETH, send it in msg.value.\n            uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;\n            // Send the projectId in the metadata.\n            bytes memory _projectMetadata = new bytes(32);\n            _projectMetadata = bytes(abi.encodePacked(_projectId));\n            // Add to balance if prefered.\n            if (_split.preferAddToBalance)\n              _terminal.addToBalanceOf{value: _payableValue}(\n                _split.projectId,\n                _netPayoutAmount,\n                token,\n                \'\',\n                _projectMetadata\n              );\n            else\n              _terminal.pay{value: _payableValue}(\n                _split.projectId,\n                _netPayoutAmount,\n                token,\n                _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,\n                0,\n                _split.preferClaimed,\n                \'\',\n                _projectMetadata\n              );\n          }\n        } else {\n          unchecked {\n            _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT\n              ? _payoutAmount\n              : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);\n          }\n          // This distribution is eligible for a fee since the funds are leaving the ecosystem.\n          feeEligibleDistributionAmount += _payoutAmount;\n          // If there\'s a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.\n          _transferFrom(\n            address(this),\n            _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),\n            _netPayoutAmount\n          );\n        }\n        // Subtract from the amount to be sent to the beneficiary.\n        unchecked {\n          leftoverAmount = leftoverAmount - _payoutAmount;\n        }\n      }\n      emit DistributeToPayoutSplit(\n        _projectId,\n        _domain,\n        _group,\n        _split,\n        _netPayoutAmount,\n        msg.sender\n      );\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n  /\n    @notice\n    Takes a fee into the platform\'s project, which has an id of _PROTOCOL_PROJECT_ID.\n    @param _projectId The ID of the project having fees taken from.\n    @param _fundingCycle The funding cycle during which the fee is being taken.\n    @param _amount The amount of the fee to take, as a floating point number with 18 decimals.\n    @param _beneficiary The address to mint the platforms tokens for.\n    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.\n    @return feeAmount The amount of the fee taken.\n  /\n  function _takeFeeFrom(\n    uint256 _projectId,\n    JBFundingCycle memory _fundingCycle,\n    uint256 _amount,\n    address _beneficiary,\n    uint256 _feeDiscount\n  ) internal returns (uint256 feeAmount) {\n    feeAmount = _feeAmount(_amount, fee, _feeDiscount);\n    if (_fundingCycle.shouldHoldFees()) {\n      // Store the held fee.\n      _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));\n      emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender);\n    } else {\n      // Process the fee.\n      _processFee(feeAmount, _beneficiary); // Take the fee.\n      emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender);\n    }\n  }\n  /\n    @notice\n    Process a fee of the specified amount.\n    @param _amount The fee amount, as a floating point number with 18 decimals.\n    @param _beneficiary The address to mint the platform\'s tokens for.\n  */\n  function _processFee(uint256 _amount, address _beneficiary) internal {\n    // Get the terminal for the protocol project.\n    IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token);\n    // When processing the admin fee, save gas if the admin is using this contract as its terminal.\n    if (_terminal == this)\n      _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, \'\', bytes(\'\')); // Use the local pay call.\n    else {\n      // Trigger any inherited pre-transfer logic.\n      _beforeTransferTo(address(_terminal), _amount);\n      // If this terminal\'s token is ETH, send it in msg.value.\n      uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;\n      // Send the payment.\n      _terminal.pay{value: _payableValue}(\n        _PROTOCOL_PROJECT_ID,\n        _amount,\n        token,\n        _beneficiary,\n        0,\n        false,\n        \'\',\n        bytes(\'\')\n      ); // Use the external pay call of the correct terminal.\n    }\n  }\n  /\n    @notice\n    Contribute tokens to a project.\n    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal\'s token is ETH, this is ignored and msg.value is used in its place.\n    @param _payer The address making the payment.\n    @param _projectId The ID of the project being paid.\n    @param _beneficiary The address to mint tokens for and pass along to the funding cycle\'s data source and delegate.\n    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.\n    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.\n    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle\'s data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.\n    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.\n    @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.\n  /\n  function _pay(\n    uint256 _amount,\n    address _payer,\n    uint256 _projectId,\n    address _beneficiary,\n    uint256 _minReturnedTokens,\n    bool _preferClaimedTokens,\n    string memory _memo,\n    bytes memory _metadata\n  ) internal returns (uint256 beneficiaryTokenCount) {\n    // Cant send tokens to the zero address.\n    if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS();\n    // Define variables that will be needed outside the scoped section below.\n    // Keep a reference to the funding cycle during which the payment is being made.\n    JBFundingCycle memory _fundingCycle;\n    // Scoped section prevents stack too deep. _delegate and _tokenCount only used within scope.\n    {\n      IJBPayDelegate _delegate;\n      uint256 _tokenCount;\n      // Bundle the amount info into a JBTokenAmount struct.\n      JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);\n      // Record the payment.\n      (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(\n        _payer,\n        _bundledAmount,\n        _projectId,\n        baseWeightCurrency,\n        _beneficiary,\n        _memo,\n        _metadata\n      );\n      // Mint the tokens if needed.\n      if (_tokenCount &gt; 0)\n        // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.\n        beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(\n          _projectId,\n          _tokenCount,\n          _beneficiary,\n          \'\',\n          _preferClaimedTokens,\n          true\n        );\n      // The token count for the beneficiary must be greater than or equal to the minimum expected.\n      if (beneficiaryTokenCount &lt; _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();\n      // If a delegate was returned by the data source, issue a callback to it.\n      if (_delegate != IJBPayDelegate(address(0))) {\n        JBDidPayData memory _data = JBDidPayData(\n          _payer,\n          _projectId,\n          _fundingCycle.configuration,\n          _bundledAmount,\n          beneficiaryTokenCount,\n          _beneficiary,\n          _preferClaimedTokens,\n          _memo,\n          _metadata\n        );\n        _delegate.didPay(_data);\n        emit DelegateDidPay(_delegate, _data, msg.sender);\n      }\n    }\n    emit Pay(\n      _fundingCycle.configuration,\n      _fundingCycle.number,\n      _projectId,\n      _payer,\n      _beneficiary,\n      _amount,\n      beneficiaryTokenCount,\n      _memo,\n      _metadata,\n      msg.sender\n    );\n  }\n  /\n    @notice\n    Receives funds belonging to the specified project.\n    @param _projectId The ID of the project to which the funds received belong.\n    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.\n    @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added.\n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Extra data to pass along to the emitted event.\n  /\n  function _addToBalanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    bool _shouldRefundHeldFees,\n    string memory _memo,\n    bytes memory _metadata\n  ) internal {\n    // Refund any held fees to make sure the project doesn\'t pay double for funds going in and out of the protocol.\n    uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0;\n    // Record the added funds with any refunded fees.\n    store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);\n    emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);\n  }\n  /\n    @notice\n    Refund fees based on the specified amount.\n    @param _projectId The project for which fees are being refunded.\n    @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.\n    @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal\n  */\n  function _refundHeldFees(uint256 _projectId, uint256 _amount)\n    internal\n    returns (uint256 refundedFees)\n  {\n    // Get a reference to the project\'s held fees.\n    JBFee[] memory _heldFees = _heldFeesOf[_projectId];\n    // Delete the current held fees.\n    delete _heldFeesOf[_projectId];\n    // Get a reference to the leftover amount once all fees have been settled.\n    uint256 leftoverAmount = _amount;\n    // Push length in stack\n    uint256 _heldFeesLength = _heldFees.length;\n    // Process each fee.\n    for (uint256 _i = 0; _i &lt; _heldFeesLength; ) {\n      if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);\n      else if (leftoverAmount &gt;= _heldFees[_i].amount) {\n        unchecked {\n          leftoverAmount = leftoverAmount - _heldFees[_i].amount;\n          refundedFees += _feeAmount(\n            _heldFees[_i].amount,\n            _heldFees[_i].fee,\n            _heldFees[_i].feeDiscount\n          );\n        }\n      } else {\n        _heldFeesOf[_projectId].push(\n          JBFee(\n            _heldFees[_i].amount - leftoverAmount,\n            _heldFees[_i].fee,\n            _heldFees[_i].feeDiscount,\n            _heldFees[_i].beneficiary\n          )\n        );\n        unchecked {\n          refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);\n        }\n        leftoverAmount = 0;\n      }\n      unchecked {\n        ++_i;\n      }\n    }\n    emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);\n  }\n  / \n    @notice \n    Returns the fee amount based on the provided amount for the specified project.\n    @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal.\n    @param _fee The percentage of the fee, out of MAX_FEE. \n    @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.\n    @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.\n  /\n  function _feeAmount(\n    uint256 _amount,\n    uint256 _fee,\n    uint256 _feeDiscount\n  ) internal pure returns (uint256) {\n    // Calculate the discounted fee.\n    uint256 _discountedFee = _fee -\n      PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT);\n    // The amount of tokens from the _amount to pay as a fee.\n    return\n      _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);\n  }\n  / \n    @notice\n    Get the fee discount from the fee gauge for the specified project.\n    @param _projectId The ID of the project to get a fee discount for.\n    \n    @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.\n  /\n  function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {\n    // Can\'t take a fee if the protocol project doesn\'t have a terminal that accepts the token.\n    if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))\n      return JBConstants.MAX_FEE_DISCOUNT;\n    // Get the fee discount.\n    if (feeGauge == IJBFeeGauge(address(0)))\n      feeDiscount = 0;\n      // If the guage reverts, set the discount to 0.\n    else\n      try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {\n        feeDiscount = discount;\n      } catch {\n        feeDiscount = 0;\n      }\n    // If the fee discount is greater than the max, nullify the discount.\n    if (feeDiscount &gt; JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;\n  }\n}\n.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\nimport \'@openzeppelin/contracts/access/Ownable.sol\';\nimport \'@openzeppelin/contracts/security/ReentrancyGuard.sol\';\nimport \'@openzeppelin/contracts/token/ERC20/IERC20.sol\';\nimport \'@paulrberg/contracts/math/PRBMath.sol\';\nimport \'./../interfaces/IJBController.sol\';\nimport \'./../interfaces/IJBPayoutRedemptionPaymentTerminal.sol\';\nimport \'./../libraries/JBConstants.sol\';\nimport \'./../libraries/JBCurrencies.sol\';\nimport \'./../libraries/JBFixedPointNumber.sol\';\nimport \'./../libraries/JBFundingCycleMetadataResolver.sol\';\nimport \'./../libraries/JBOperations.sol\';\nimport \'./../libraries/JBSplitsGroups.sol\';\nimport \'./../libraries/JBTokens.sol\';\nimport \'./../structs/JBTokenAmount.sol\';\nimport \'./JBOperatable.sol\';\nimport \'./JBSingleTokenPaymentTerminal.sol\';\n/*\n  @notice\n  Generic terminal managing all inflows and outflows of funds into the protocol ecosystem.\n  @dev\n  A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time.\n  @dev\n  Adheres to -\n  IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain\'s state according to the protocol\'s rules.\n  @dev\n  Inherits from -\n  JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.\n  JBOperatable: Includes convenience functionality for checking a message sender\'s permissions before executing certain transactions.\n  Ownable: Includes convenience functionality for checking a message sender\'s permissions before executing certain transactions.\n  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.\n/\nabstract contract JBPayoutRedemptionPaymentTerminal is\n  IJBPayoutRedemptionPaymentTerminal,\n  JBSingleTokenPaymentTerminal,\n  JBOperatable,\n  Ownable,\n  ReentrancyGuard\n{\n  // A library that parses the packed funding cycle metadata into a friendlier format.\n  using JBFundingCycleMetadataResolver for JBFundingCycle;\n  //*********//\n  // --------------------------- custom errors ------------------------- //\n  //*********//\n  error FEE_TOO_HIGH();\n  error INADEQUATE_DISTRIBUTION_AMOUNT();\n  error INADEQUATE_RECLAIM_AMOUNT();\n  error INADEQUATE_TOKEN_COUNT();\n  error NO_MSG_VALUE_ALLOWED();\n  error PAY_TO_ZERO_ADDRESS();\n  error PROJECT_TERMINAL_MISMATCH();\n  error REDEEM_TO_ZERO_ADDRESS();\n  error TERMINAL_IN_SPLIT_ZERO_ADDRESS();\n  error TERMINAL_TOKENS_INCOMPATIBLE();\n  //*********//\n  // ---------------------------- modifiers ---------------------------- //\n  //*********//\n  / \n    @notice \n    A modifier that verifies this terminal is a terminal of provided project ID.\n  /\n  modifier isTerminalOf(uint256 projectId) {\n    if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();\n    ;\n  }\n  //**********//\n  // --------------------- internal stored constants ------------------- //\n  //*********//\n  /\n    @notice\n    Maximum fee that can be set for a funding cycle configuration.\n    @dev\n    Out of MAX_FEE (50_000_000 / 1_000_000_000).\n  /\n  uint256 internal constant _FEE_CAP = 50_000_000;\n  /\n    @notice\n    The protocol project ID is 1, as it should be the first project launched during the deployment process.\n  /\n  uint256 internal constant _PROTOCOL_PROJECT_ID = 1;\n  //**********//\n  // --------------------- internal stored properties ------------------ //\n  //**********//\n  /\n    @notice\n    Fees that are being held to be processed later.\n    _projectId The ID of the project for which fees are being held.\n  /\n  mapping(uint256 =&gt; JBFee[]) internal _heldFeesOf;\n  //**********//\n  // ---------------- public immutable stored properties --------------- //\n  //*********//\n  /\n    @notice\n    Mints ERC-721\'s that represent project ownership and transfers.\n  /\n  IJBProjects public immutable override projects;\n  /\n    @notice\n    The directory of terminals and controllers for projects.\n  /\n  IJBDirectory public immutable override directory;\n  /\n    @notice\n    The contract that stores splits for each project.\n  /\n  IJBSplitsStore public immutable override splitsStore;\n  /\n    @notice\n    The contract that exposes price feeds.\n  /\n  IJBPrices public immutable override prices;\n  /\n    @notice\n    The contract that stores and manages the terminal\'s data.\n  */\n  IJBSingleTokenPaymentTerminalStore public immutable override store;\n  /\n    @notice\n    The currency to base token issuance on.\n    @dev\n    If this differs from currency, there must be a price feed available to convert currency to baseWeightCurrency.\n  /\n  uint256 public immutable override baseWeightCurrency;\n  /\n    @notice\n    The group that payout splits coming from this terminal are identified by.\n  /\n  uint256 public immutable override payoutSplitsGroup;\n  //*********//\n  // --------------------- public stored properties -------------------- //\n  //*********//\n  /\n    @notice\n    The platform fee percent.\n    @dev\n    Out of MAX_FEE (25_000_000 / 1_000_000_000)\n  /\n  uint256 public override fee = 25_000_000; // 2.5%\n  /\n    @notice\n    The data source that returns a discount to apply to a project\'s fee.\n  /\n  IJBFeeGauge public override feeGauge;\n  /\n    @notice\n    Addresses that can be paid towards from this terminal without incurring a fee.\n    _address The address that can be paid toward.\n  /\n  mapping(address =&gt; bool) public override isFeelessAddress;\n  //***********//\n  // ------------------------- external views -------------------------- //\n  //**********//\n  /\n    @notice\n    Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.\n    @dev\n    The current overflow is represented as a fixed point number with 18 decimals.\n    @param _projectId The ID of the project to get overflow for.\n    @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.\n  /\n  function currentEthOverflowOf(uint256 _projectId)\n    external\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    // Get this terminal\'s current overflow.\n    uint256 _overflow = store.currentOverflowOf(this, _projectId);\n    // Adjust the decimals of the fixed point number if needed to have 18 decimals.\n    uint256 _adjustedOverflow = (decimals == 18)\n      ? _overflow\n      : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);\n    // Return the amount converted to ETH.\n    return\n      (currency == JBCurrencies.ETH)\n        ? _adjustedOverflow\n        : PRBMath.mulDiv(\n          _adjustedOverflow,\n          10decimals,\n          prices.priceFor(currency, JBCurrencies.ETH, decimals)\n        );\n  }\n  /\n    @notice\n    The fees that are currently being held to be processed later for each project.\n    @param _projectId The ID of the project for which fees are being held.\n    @return An array of fees that are being held.\n  /\n  function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {\n    return _heldFeesOf[_projectId];\n  }\n  //*********//\n  // -------------------------- public views --------------------------- //\n  //*********//\n  /\n    @notice\n    Indicates if this contract adheres to the specified interface.\n    @dev \n    See {IERC165-supportsInterface}.\n    @param _interfaceId The ID of the interface to check for adherance to.\n  /\n  function supportsInterface(bytes4 _interfaceId)\n    public\n    view\n    virtual\n    override(JBSingleTokenPaymentTerminal, IERC165)\n    returns (bool)\n  {\n    return\n      _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||\n      _interfaceId == type(IJBPayoutTerminal).interfaceId ||\n      _interfaceId == type(IJBAllowanceTerminal).interfaceId ||\n      _interfaceId == type(IJBRedemptionTerminal).interfaceId ||\n      _interfaceId == type(IJBOperatable).interfaceId ||\n      super.supportsInterface(_interfaceId);\n  }\n  //**********//\n  // -------------------------- constructor ---------------------------- //\n  //*********//\n  /\n    @param _token The token that this terminal manages.\n    @param _decimals The number of decimals the token fixed point amounts are expected to have.\n    @param _currency The currency that this terminal\'s token adheres to for price feeds.\n    @param _baseWeightCurrency The currency to base token issuance on.\n    @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.\n    @param _operatorStore A contract storing operator assignments.\n    @param _projects A contract which mints ERC-721\'s that represent project ownership and transfers.\n    @param _directory A contract storing directories of terminals and controllers for each project.\n    @param _splitsStore A contract that stores splits for each project.\n    @param _prices A contract that exposes price feeds.\n    @param _store A contract that stores the terminal\'s data.\n    @param _owner The address that will own this contract.\n  /\n  constructor(\n    // payable constructor save the gas used to check msg.value==0\n    address _token,\n    uint256 _decimals,\n    uint256 _currency,\n    uint256 _baseWeightCurrency,\n    uint256 _payoutSplitsGroup,\n    IJBOperatorStore _operatorStore,\n    IJBProjects _projects,\n    IJBDirectory _directory,\n    IJBSplitsStore _splitsStore,\n    IJBPrices _prices,\n    IJBSingleTokenPaymentTerminalStore _store,\n    address _owner\n  )\n    payable\n    JBSingleTokenPaymentTerminal(_token, _decimals, _currency)\n    JBOperatable(_operatorStore)\n  {\n    baseWeightCurrency = _baseWeightCurrency;\n    payoutSplitsGroup = _payoutSplitsGroup;\n    projects = _projects;\n    directory = _directory;\n    splitsStore = _splitsStore;\n    prices = _prices;\n    store = _store;\n    transferOwnership(_owner);\n  }\n  //**********//\n  // ---------------------- external transactions ---------------------- //\n  //*********//\n  /\n    @notice\n    Contribute tokens to a project.\n    @param _projectId The ID of the project being paid.\n    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal\'s token is ETH, this is ignored and msg.value is used in its place.\n    @param _token The token being paid. This terminal ignores this property since it only manages one token. \n    @param _beneficiary The address to mint tokens for and pass along to the funding cycle\'s data source and delegate.\n    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.\n    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.\n    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle\'s data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.\n    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.\n    @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.\n  /\n  function pay(\n    uint256 _projectId,\n    uint256 _amount,\n    address _token,\n    address _beneficiary,\n    uint256 _minReturnedTokens,\n    bool _preferClaimedTokens,\n    string calldata _memo,\n    bytes calldata _metadata\n  ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {\n    _token; // Prevents unused var compiler and natspec complaints.\n    // ETH shouldn\'t be sent if this terminal\'s token isn\'t ETH.\n    if (token != JBTokens.ETH) {\n      if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();\n      // Transfer tokens to this terminal from the msg sender.\n      _transferFrom(msg.sender, payable(address(this)), _amount);\n    }\n    // If this terminal\'s token is ETH, override _amount with msg.value.\n    else _amount = msg.value;\n    return\n      _pay(\n        _amount,\n        msg.sender,\n        _projectId,\n        _beneficiary,\n        _minReturnedTokens,\n        _preferClaimedTokens,\n        _memo,\n        _metadata\n      );\n  }\n  /\n    @notice\n    Holders can redeem their tokens to claim the project\'s overflowed tokens, or to trigger rules determined by the project\'s current funding cycle\'s data source.\n    @dev\n    Only a token holder or a designated operator can redeem its tokens.\n    @param _holder The account to redeem tokens for.\n    @param _projectId The ID of the project to which the tokens being redeemed belong.\n    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.\n    @param _token The token being reclaimed. This terminal ignores this property since it only manages one token. \n    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.\n    @param _beneficiary The address to send the terminal tokens to.\n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.\n    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.\n  /\n  function redeemTokensOf(\n    address _holder,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    address _token,\n    uint256 _minReturnedTokens,\n    address payable _beneficiary,\n    string memory _memo,\n    bytes memory _metadata\n  )\n    external\n    virtual\n    override\n    requirePermission(_holder, _projectId, JBOperations.REDEEM)\n    returns (uint256 reclaimAmount)\n  {\n    _token; // Prevents unused var compiler and natspec complaints.\n    return\n      _redeemTokensOf(\n        _holder,\n        _projectId,\n        _tokenCount,\n        _minReturnedTokens,\n        _beneficiary,\n        _memo,\n        _metadata\n      );\n  }\n  /\n    @notice\n    Distributes payouts for a project with the distribution limit of its current funding cycle.\n    @dev\n    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project\'s owner.\n    @dev\n    Anyone can distribute payouts on a project\'s behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.\n    @dev\n    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.\n    @param _projectId The ID of the project having its payouts distributed.\n    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.\n    @param _currency The expected currency of the amount being distributed. Must match the project\'s current funding cycle\'s distribution limit currency.\n    @param _token The token being distributed. This terminal ignores this property since it only manages one token. \n    @param _minReturnedTokens The minimum number of terminal tokens that the _amount should be valued at in terms of this terminal\'s currency, as a fixed point number with the same number of decimals as this terminal.\n    @param _memo A memo to pass along to the emitted event.\n    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.\n  /\n  function distributePayoutsOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency,\n    address _token,\n    uint256 _minReturnedTokens,\n    string calldata _memo\n  ) external virtual override returns (uint256 netLeftoverDistributionAmount) {\n    _token; // Prevents unused var compiler and natspec complaints.\n    return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);\n  }\n  /\n    @notice\n    Allows a project to send funds from its overflow up to the preconfigured allowance.\n    @dev\n    Only a project\'s owner or a designated operator can use its allowance.\n    @dev\n    Incurs the protocol fee.\n    @param _projectId The ID of the project to use the allowance of.\n    @param _amount The amount of terminal tokens to use from this project\'s current allowance, as a fixed point number with the same amount of decimals as this terminal.\n    @param _currency The expected currency of the amount being distributed. Must match the project\'s current funding cycle\'s overflow allowance currency.\n    @param _token The token being distributed. This terminal ignores this property since it only manages one token. \n    @param _minReturnedTokens The minimum number of tokens that the _amount should be valued at in terms of this terminal\'s currency, as a fixed point number with 18 decimals.\n    @param _beneficiary The address to send the funds to.\n    @param _memo A memo to pass along to the emitted event.\n    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.\n  /\n  function useAllowanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency,\n    address _token,\n    uint256 _minReturnedTokens,\n    address payable _beneficiary,\n    string memory _memo\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)\n    returns (uint256 netDistributedAmount)\n  {\n    _token; // Prevents unused var compiler and natspec complaints.\n    return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);\n  }\n  /\n    @notice\n    Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.\n    @dev\n    Only a project\'s owner or a designated operator can migrate it.\n    @param _projectId The ID of the project being migrated.\n    @param _to The terminal contract that will gain the project\'s funds.\n    @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.\n  */\n  function migrate(uint256 _projectId, IJBPaymentTerminal _to)\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)\n    returns (uint256 balance)\n  {\n    // The terminal being migrated to must accept the same token as this terminal.\n    if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE();\n    // Record the migration in the store.\n    balance = store.recordMigration(_projectId);\n    // Transfer the balance if needed.\n    if (balance &gt; 0) {\n      // Trigger any inherited pre-transfer logic.\n      _beforeTransferTo(address(_to), balance);\n      // If this terminal\'s token is ETH, send it in msg.value.\n      uint256 _payableValue = token == JBTokens.ETH ? balance : 0;\n      // Withdraw the balance to transfer to the new terminal;\n      _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, \'\', bytes(\'\'));\n    }\n    emit Migrate(_projectId, _to, balance, msg.sender);\n  }\n  /\n    @notice\n    Receives funds belonging to the specified project.\n    @param _projectId The ID of the project to which the funds received belong.\n    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.\n    @param _token The token being paid. This terminal ignores this property since it only manages one currency. \n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Extra data to pass along to the emitted event.\n  /\n  function addToBalanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    address _token,\n    string calldata _memo,\n    bytes calldata _metadata\n  ) external payable virtual override isTerminalOf(_projectId) {\n    _token; // Prevents unused var compiler and natspec complaints.\n    // If this terminal\'s token isn\'t ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender.\n    if (token != JBTokens.ETH) {\n      // Amount must be greater than 0.\n      if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();\n      // Transfer tokens to this terminal from the msg sender.\n      _transferFrom(msg.sender, payable(address(this)), _amount);\n    }\n    // If the terminal\'s token is ETH, override _amount with msg.value.\n    else _amount = msg.value;\n    // Add to balance while only refunding held fees if the funds aren\'t originating from a feeless terminal.\n    _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);\n  }\n  /\n    @notice\n    Process any fees that are being held for the project.\n    @dev\n    Only a project owner, an operator, or the contract\'s owner can process held fees.\n    @param _projectId The ID of the project whos held fees should be processed.\n  /\n  function processFees(uint256 _projectId)\n    external\n    virtual\n    override\n    requirePermissionAllowingOverride(\n      projects.ownerOf(_projectId),\n      _projectId,\n      JBOperations.PROCESS_FEES,\n      msg.sender == owner()\n    )\n  {\n    // Get a reference to the project\'s held fees.\n    JBFee[] memory _heldFees = _heldFeesOf[_projectId];\n    // Delete the held fees.\n    delete _heldFeesOf[_projectId];\n    // Push array length in stack\n    uint256 _heldFeeLength = _heldFees.length;\n    // Process each fee.\n    for (uint256 _i = 0; _i &lt; _heldFeeLength; ) {\n      // Get the fee amount.\n      uint256 _amount = _feeAmount(\n        _heldFees[_i].amount,\n        _heldFees[_i].fee,\n        _heldFees[_i].feeDiscount\n      );\n      // Process the fee.\n      _processFee(_amount, _heldFees[_i].beneficiary);\n      emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n  /\n    @notice\n    Allows the fee to be updated.\n    @dev\n    Only the owner of this contract can change the fee.\n    @param _fee The new fee, out of MAX_FEE.\n  */\n  function setFee(uint256 _fee) external virtual override onlyOwner {\n    // The provided fee must be within the max.\n    if (_fee &gt; _FEE_CAP) revert FEE_TOO_HIGH();\n    // Store the new fee.\n    fee = _fee;\n    emit SetFee(_fee, msg.sender);\n  }\n  /\n    @notice\n    Allows the fee gauge to be updated.\n    @dev\n    Only the owner of this contract can change the fee gauge.\n    @dev\n    If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project\'s funds will be locked. This is a known risk.\n    @param _feeGauge The new fee gauge.\n  /\n  function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {\n    // Store the new fee gauge.\n    feeGauge = _feeGauge;\n    emit SetFeeGauge(_feeGauge, msg.sender);\n  }\n  /\n    @notice\n    Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.\n    @dev\n    Only the owner of this contract can set addresses as feeless.\n    @param _address The address that can be paid towards while still bypassing fees.\n    @param _flag A flag indicating whether the terminal should be feeless or not.\n  /\n  function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {\n    // Set the flag value.\n    isFeelessAddress[_address] = _flag;\n    emit SetFeelessAddress(_address, _flag, msg.sender);\n  }\n  //*********//\n  // ---------------------- internal transactions ---------------------- //\n  //*********//\n  / \n    @notice\n    Transfers tokens.\n    @param _from The address from which the transfer should originate.\n    @param _to The address to which the transfer should go.\n    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.\n  /\n  function _transferFrom(\n    address _from,\n    address payable _to,\n    uint256 _amount\n  ) internal virtual;\n  / \n    @notice\n    Logic to be triggered before transferring tokens from this terminal.\n    @param _to The address to which the transfer is going.\n    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.\n  /\n  function _beforeTransferTo(address _to, uint256 _amount) internal virtual;\n  /\n    @notice\n    Holders can redeem their tokens to claim the project\'s overflowed tokens, or to trigger rules determined by the project\'s current funding cycle\'s data source.\n    @dev\n    Only a token holder or a designated operator can redeem its tokens.\n    @param _holder The account to redeem tokens for.\n    @param _projectId The ID of the project to which the tokens being redeemed belong.\n    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.\n    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.\n    @param _beneficiary The address to send the terminal tokens to.\n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.\n    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.\n  /\n  function _redeemTokensOf(\n    address _holder,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    uint256 _minReturnedTokens,\n    address payable _beneficiary,\n    string memory _memo,\n    bytes memory _metadata\n  ) internal returns (uint256 reclaimAmount) {\n    // Can\'t send reclaimed funds to the zero address.\n    if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS();\n    // Define variables that will be needed outside the scoped section below.\n    // Keep a reference to the funding cycle during which the redemption is being made.\n    JBFundingCycle memory _fundingCycle;\n    // Scoped section prevents stack too deep. _delegate only used within scope.\n    {\n      IJBRedemptionDelegate _delegate;\n      // Record the redemption.\n      (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(\n        _holder,\n        _projectId,\n        _tokenCount,\n        _memo,\n        _metadata\n      );\n      // The amount being reclaimed must be at least as much as was expected.\n      if (reclaimAmount &lt; _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();\n      // Burn the project tokens.\n      if (_tokenCount &gt; 0)\n        IJBController(directory.controllerOf(_projectId)).burnTokensOf(\n          _holder,\n          _projectId,\n          _tokenCount,\n          \'\',\n          false\n        );\n      // If a delegate was returned by the data source, issue a callback to it.\n      if (_delegate != IJBRedemptionDelegate(address(0))) {\n        JBDidRedeemData memory _data = JBDidRedeemData(\n          _holder,\n          _projectId,\n          _fundingCycle.configuration,\n          _tokenCount,\n          JBTokenAmount(token, reclaimAmount, decimals, currency),\n          _beneficiary,\n          _memo,\n          _metadata\n        );\n        _delegate.didRedeem(_data);\n        emit DelegateDidRedeem(_delegate, _data, msg.sender);\n      }\n    }\n    // Send the reclaimed funds to the beneficiary.\n    if (reclaimAmount &gt; 0) _transferFrom(address(this), _beneficiary, reclaimAmount);\n    emit RedeemTokens(\n      _fundingCycle.configuration,\n      _fundingCycle.number,\n      _projectId,\n      _holder,\n      _beneficiary,\n      _tokenCount,\n      reclaimAmount,\n      _memo,\n      _metadata,\n      msg.sender\n    );\n  }\n  /\n    @notice\n    Distributes payouts for a project with the distribution limit of its current funding cycle.\n    @dev\n    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project\'s owner.\n    @dev\n    Anyone can distribute payouts on a project\'s behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.\n    @dev\n    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.\n    @param _projectId The ID of the project having its payouts distributed.\n    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.\n    @param _currency The expected currency of the amount being distributed. Must match the project\'s current funding cycle\'s distribution limit currency.\n    @param _minReturnedTokens The minimum number of terminal tokens that the _amount should be valued at in terms of this terminal\'s currency, as a fixed point number with the same number of decimals as this terminal.\n    @param _memo A memo to pass along to the emitted event.\n    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.\n  */\n  function _distributePayoutsOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency,\n    uint256 _minReturnedTokens,\n    string calldata _memo\n  ) internal returns (uint256 netLeftoverDistributionAmount) {\n    // Record the distribution.\n    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(\n      _projectId,\n      _amount,\n      _currency\n    );\n    // The amount being distributed must be at least as much as was expected.\n    if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();\n    // Get a reference to the project owner, which will receive tokens from paying the platform fee\n    // and receive any extra distributable funds not allocated to payout splits.\n    address payable _projectOwner = payable(projects.ownerOf(_projectId));\n    // Define variables that will be needed outside the scoped section below.\n    // Keep a reference to the fee amount that was paid.\n    uint256 _fee;\n    // Scoped section prevents stack too deep. _feeDiscount, _feeEligibleDistributionAmount, and _leftoverDistributionAmount only used within scope.\n    {\n      // Get the amount of discount that should be applied to any fees taken.\n      // If the fee is zero or if the fee is being used by an address that doesn\'t incur fees, set the discount to 100% for convinience.\n      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]\n        ? JBConstants.MAX_FEE_DISCOUNT\n        : _currentFeeDiscount(_projectId);\n      // The amount distributed that is eligible for incurring fees.\n      uint256 _feeEligibleDistributionAmount;\n      // The amount leftover after distributing to the splits.\n      uint256 _leftoverDistributionAmount;\n      // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.\n      // Also get a reference to the amount that was distributed to splits from which fees should be taken.\n      (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(\n        _projectId,\n        _fundingCycle.configuration,\n        payoutSplitsGroup,\n        _distributedAmount,\n        _feeDiscount\n      );\n      // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.\n      unchecked {\n        _feeEligibleDistributionAmount += _leftoverDistributionAmount;\n      }\n      // Take the fee.\n      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0\n        ? 0\n        : _takeFeeFrom(\n          _projectId,\n          _fundingCycle,\n          _feeEligibleDistributionAmount,\n          _projectOwner,\n          _feeDiscount\n        );\n      // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.\n      unchecked {\n        netLeftoverDistributionAmount = _leftoverDistributionAmount == 0\n          ? 0\n          : _leftoverDistributionAmount -\n            _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);\n      }\n      // Transfer any remaining balance to the project owner.\n      if (netLeftoverDistributionAmount &gt; 0)\n        _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount);\n    }\n    emit DistributePayouts(\n      _fundingCycle.configuration,\n      _fundingCycle.number,\n      _projectId,\n      _projectOwner,\n      _amount,\n      _distributedAmount,\n      _fee,\n      netLeftoverDistributionAmount,\n      _memo,\n      msg.sender\n    );\n  }\n  /\n    @notice\n    Allows a project to send funds from its overflow up to the preconfigured allowance.\n    @dev\n    Only a project\'s owner or a designated operator can use its allowance.\n    @dev\n    Incurs the protocol fee.\n    @param _projectId The ID of the project to use the allowance of.\n    @param _amount The amount of terminal tokens to use from this project\'s current allowance, as a fixed point number with the same amount of decimals as this terminal.\n    @param _currency The expected currency of the amount being distributed. Must match the project\'s current funding cycle\'s overflow allowance currency.\n    @param _minReturnedTokens The minimum number of tokens that the _amount should be valued at in terms of this terminal\'s currency, as a fixed point number with 18 decimals.\n    @param _beneficiary The address to send the funds to.\n    @param _memo A memo to pass along to the emitted event.\n    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.\n  /\n  function _useAllowanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency,\n    uint256 _minReturnedTokens,\n    address payable _beneficiary,\n    string memory _memo\n  ) internal returns (uint256 netDistributedAmount) {\n    // Record the use of the allowance.\n    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(\n      _projectId,\n      _amount,\n      _currency\n    );\n    // The amount being withdrawn must be at least as much as was expected.\n    if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();\n    // Scoped section prevents stack too deep. _fee, _projectOwner, _feeDiscount, and _netAmount only used within scope.\n    {\n      // Keep a reference to the fee amount that was paid.\n      uint256 _fee;\n      // Get a reference to the project owner, which will receive tokens from paying the platform fee.\n      address _projectOwner = projects.ownerOf(_projectId);\n      // Get the amount of discount that should be applied to any fees taken.\n      // If the fee is zero or if the fee is being used by an address that doesn\'t incur fees, set the discount to 100% for convinience.\n      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]\n        ? JBConstants.MAX_FEE_DISCOUNT\n        : _currentFeeDiscount(_projectId);\n      // Take a fee from the _distributedAmount, if needed.\n      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT\n        ? 0\n        : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);\n      unchecked {\n        // The net amount is the withdrawn amount without the fee.\n        netDistributedAmount = _distributedAmount - _fee;\n      }\n      // Transfer any remaining balance to the beneficiary.\n      if (netDistributedAmount &gt; 0)\n        _transferFrom(address(this), _beneficiary, netDistributedAmount);\n    }\n    emit UseAllowance(\n      _fundingCycle.configuration,\n      _fundingCycle.number,\n      _projectId,\n      _beneficiary,\n      _amount,\n      _distributedAmount,\n      netDistributedAmount,\n      _memo,\n      msg.sender\n    );\n  }\n  /\n    @notice\n    Pays out splits for a project\'s funding cycle configuration.\n    @param _projectId The ID of the project for which payout splits are being distributed.\n    @param _domain The domain of the splits to distribute the payout between.\n    @param _group The group of the splits to distribute the payout between.\n    @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal.\n    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.\n    @return leftoverAmount If the leftover amount if the splits don\'t add up to 100%.\n    @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.\n  /\n  function _distributeToPayoutSplitsOf(\n    uint256 _projectId,\n    uint256 _domain,\n    uint256 _group,\n    uint256 _amount,\n    uint256 _feeDiscount\n  ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {\n    // Set the leftover amount to the initial amount.\n    leftoverAmount = _amount;\n    // Get a reference to the project\'s payout splits.\n    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);\n    // Transfer between all splits.\n    for (uint256 _i = 0; _i &lt; _splits.length; ) {\n      // Get a reference to the split being iterated on.\n      JBSplit memory _split = _splits[_i];\n      // The amount to send towards the split.\n      uint256 _payoutAmount = PRBMath.mulDiv(\n        _amount,\n        _split.percent,\n        JBConstants.SPLITS_TOTAL_PERCENT\n      );\n      // The payout amount substracting any applicable incurred fees.\n      uint256 _netPayoutAmount;\n      if (_payoutAmount &gt; 0) {\n        // Transfer tokens to the split.\n        // If there\'s an allocator set, transfer to its allocate function.\n        if (_split.allocator != IJBSplitAllocator(address(0))) {\n          // If the split allocator is set as feeless, this distribution is not eligible for a fee.\n          if (isFeelessAddress[address(_split.allocator)])\n            _netPayoutAmount = _payoutAmount;\n            // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn\'t listed as feeless.\n          else {\n            unchecked {\n              _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT\n                ? _payoutAmount\n                : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);\n            }\n            // This distribution is eligible for a fee since the funds are leaving the ecosystem.\n            feeEligibleDistributionAmount += _payoutAmount;\n          }\n          // Trigger any inherited pre-transfer logic.\n          _beforeTransferTo(address(_split.allocator), _netPayoutAmount);\n          // If this terminal\'s token is ETH, send it in msg.value.\n          uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;\n          // Create the data to send to the allocator.\n          JBSplitAllocationData memory _data = JBSplitAllocationData(\n            token,\n            _netPayoutAmount,\n            decimals,\n            _projectId,\n            _group,\n            _split\n          );\n          // Trigger the allocator\'s allocate function.\n          _split.allocator.allocate{value: _payableValue}(_data);\n          // Otherwise, if a project is specified, make a payment to it.\n        } else if (_split.projectId != 0) {\n          // Get a reference to the Juicebox terminal being used.\n          IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);\n          // The project must have a terminal to send funds to.\n          if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();\n          // Save gas if this contract is being used as the terminal.\n          if (_terminal == this) {\n            // This distribution does not incur a fee.\n            _netPayoutAmount = _payoutAmount;\n            // Send the projectId in the metadata.\n            bytes memory _projectMetadata = new bytes(32);\n            _projectMetadata = bytes(abi.encodePacked(_projectId));\n            // Add to balance if prefered.\n            if (_split.preferAddToBalance)\n              _addToBalanceOf(_split.projectId, _netPayoutAmount, false, \'\', _projectMetadata);\n            else\n              _pay(\n                _netPayoutAmount,\n                address(this),\n                _split.projectId,\n                (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,\n                0,\n                _split.preferClaimed,\n                \'\',\n                _projectMetadata\n              );\n          } else {\n            // If the terminal is set as feeless, this distribution is not eligible for a fee.\n            if (isFeelessAddress[address(_terminal)])\n              _netPayoutAmount = _payoutAmount;\n              // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn\'t listed as feeless.\n            else {\n              unchecked {\n                _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT\n                  ? _payoutAmount\n                  : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);\n              }\n              feeEligibleDistributionAmount += _payoutAmount;\n            }\n            // Trigger any inherited pre-transfer logic.\n            _beforeTransferTo(address(_terminal), _netPayoutAmount);\n            // If this terminal\'s token is ETH, send it in msg.value.\n            uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;\n            // Send the projectId in the metadata.\n            bytes memory _projectMetadata = new bytes(32);\n            _projectMetadata = bytes(abi.encodePacked(_projectId));\n            // Add to balance if prefered.\n            if (_split.preferAddToBalance)\n              _terminal.addToBalanceOf{value: _payableValue}(\n                _split.projectId,\n                _netPayoutAmount,\n                token,\n                \'\',\n                _projectMetadata\n              );\n            else\n              _terminal.pay{value: _payableValue}(\n                _split.projectId,\n                _netPayoutAmount,\n                token,\n                _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,\n                0,\n                _split.preferClaimed,\n                \'\',\n                _projectMetadata\n              );\n          }\n        } else {\n          unchecked {\n            _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT\n              ? _payoutAmount\n              : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);\n          }\n          // This distribution is eligible for a fee since the funds are leaving the ecosystem.\n          feeEligibleDistributionAmount += _payoutAmount;\n          // If there\'s a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.\n          _transferFrom(\n            address(this),\n            _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),\n            _netPayoutAmount\n          );\n        }\n        // Subtract from the amount to be sent to the beneficiary.\n        unchecked {\n          leftoverAmount = leftoverAmount - _payoutAmount;\n        }\n      }\n      emit DistributeToPayoutSplit(\n        _projectId,\n        _domain,\n        _group,\n        _split,\n        _netPayoutAmount,\n        msg.sender\n      );\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n  /\n    @notice\n    Takes a fee into the platform\'s project, which has an id of _PROTOCOL_PROJECT_ID.\n    @param _projectId The ID of the project having fees taken from.\n    @param _fundingCycle The funding cycle during which the fee is being taken.\n    @param _amount The amount of the fee to take, as a floating point number with 18 decimals.\n    @param _beneficiary The address to mint the platforms tokens for.\n    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.\n    @return feeAmount The amount of the fee taken.\n  */\n  function _takeFeeFrom(\n    uint256 _projectId,\n    JBFundingCycle memory _fundingCycle,\n    uint256 _amount,\n    address _beneficiary,\n    uint256 _feeDiscount\n  ) internal returns (uint256 feeAmount) {\n    feeAmount = _feeAmount(_amount, fee, _feeDiscount);\n    if (_fundingCycle.shouldHoldFees()) {\n      // Store the held fee.\n      _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));\n      emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender);\n    } else {\n      // Process the fee.\n      _processFee(feeAmount, _beneficiary); // Take the fee.\n      emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender);\n    }\n  }\n  /\n    @notice\n    Process a fee of the specified amount.\n    @param _amount The fee amount, as a floating point number with 18 decimals.\n    @param _beneficiary The address to mint the platform\'s tokens for.\n  /\n  function _processFee(uint256 _amount, address _beneficiary) internal {\n    // Get the terminal for the protocol project.\n    IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token);\n    // When processing the admin fee, save gas if the admin is using this contract as its terminal.\n    if (_terminal == this)\n      _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, \'\', bytes(\'\')); // Use the local pay call.\n    else {\n      // Trigger any inherited pre-transfer logic.\n      _beforeTransferTo(address(_terminal), _amount);\n      // If this terminal\'s token is ETH, send it in msg.value.\n      uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;\n      // Send the payment.\n      _terminal.pay{value: _payableValue}(\n        _PROTOCOL_PROJECT_ID,\n        _amount,\n        token,\n        _beneficiary,\n        0,\n        false,\n        \'\',\n        bytes(\'\')\n      ); // Use the external pay call of the correct terminal.\n    }\n  }\n  /\n    @notice\n    Contribute tokens to a project.\n    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal\'s token is ETH, this is ignored and msg.value is used in its place.\n    @param _payer The address making the payment.\n    @param _projectId The ID of the project being paid.\n    @param _beneficiary The address to mint tokens for and pass along to the funding cycle\'s data source and delegate.\n    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.\n    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.\n    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle\'s data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.\n    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.\n    @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.\n  /\n  function _pay(\n    uint256 _amount,\n    address _payer,\n    uint256 _projectId,\n    address _beneficiary,\n    uint256 _minReturnedTokens,\n    bool _preferClaimedTokens,\n    string memory _memo,\n    bytes memory _metadata\n  ) internal returns (uint256 beneficiaryTokenCount) {\n    // Cant send tokens to the zero address.\n    if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS();\n    // Define variables that will be needed outside the scoped section below.\n    // Keep a reference to the funding cycle during which the payment is being made.\n    JBFundingCycle memory _fundingCycle;\n    // Scoped section prevents stack too deep. _delegate and _tokenCount only used within scope.\n    {\n      IJBPayDelegate _delegate;\n      uint256 _tokenCount;\n      // Bundle the amount info into a JBTokenAmount struct.\n      JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);\n      // Record the payment.\n      (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(\n        _payer,\n        _bundledAmount,\n        _projectId,\n        baseWeightCurrency,\n        _beneficiary,\n        _memo,\n        _metadata\n      );\n      // Mint the tokens if needed.\n      if (_tokenCount &gt; 0)\n        // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.\n        beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(\n          _projectId,\n          _tokenCount,\n          _beneficiary,\n          \'\',\n          _preferClaimedTokens,\n          true\n        );\n      // The token count for the beneficiary must be greater than or equal to the minimum expected.\n      if (beneficiaryTokenCount &lt; _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();\n      // If a delegate was returned by the data source, issue a callback to it.\n      if (_delegate != IJBPayDelegate(address(0))) {\n        JBDidPayData memory _data = JBDidPayData(\n          _payer,\n          _projectId,\n          _fundingCycle.configuration,\n          _bundledAmount,\n          beneficiaryTokenCount,\n          _beneficiary,\n          _preferClaimedTokens,\n          _memo,\n          _metadata\n        );\n        _delegate.didPay(_data);\n        emit DelegateDidPay(_delegate, _data, msg.sender);\n      }\n    }\n    emit Pay(\n      _fundingCycle.configuration,\n      _fundingCycle.number,\n      _projectId,\n      _payer,\n      _beneficiary,\n      _amount,\n      beneficiaryTokenCount,\n      _memo,\n      _metadata,\n      msg.sender\n    );\n  }\n  /\n    @notice\n    Receives funds belonging to the specified project.\n    @param _projectId The ID of the project to which the funds received belong.\n    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.\n    @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added.\n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Extra data to pass along to the emitted event.\n  */\n  function _addToBalanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    bool _shouldRefundHeldFees,\n    string memory _memo,\n    bytes memory _metadata\n  ) internal {\n    // Refund any held fees to make sure the project doesn\'t pay double for funds going in and out of the protocol.\n    uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0;\n    // Record the added funds with any refunded fees.\n    store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);\n    emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);\n  }\n  /\n    @notice\n    Refund fees based on the specified amount.\n    @param _projectId The project for which fees are being refunded.\n    @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.\n    @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal\n  /\n  function _refundHeldFees(uint256 _projectId, uint256 _amount)\n    internal\n    returns (uint256 refundedFees)\n  {\n    // Get a reference to the project\'s held fees.\n    JBFee[] memory _heldFees = _heldFeesOf[_projectId];\n    // Delete the current held fees.\n    delete _heldFeesOf[_projectId];\n    // Get a reference to the leftover amount once all fees have been settled.\n    uint256 leftoverAmount = _amount;\n    // Push length in stack\n    uint256 _heldFeesLength = _heldFees.length;\n    // Process each fee.\n    for (uint256 _i = 0; _i &lt; _heldFeesLength; ) {\n      if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);\n      else if (leftoverAmount &gt;= _heldFees[_i].amount) {\n        unchecked {\n          leftoverAmount = leftoverAmount - _heldFees[_i].amount;\n          refundedFees += _feeAmount(\n            _heldFees[_i].amount,\n            _heldFees[_i].fee,\n            _heldFees[_i].feeDiscount\n          );\n        }\n      } else {\n        _heldFeesOf[_projectId].push(\n          JBFee(\n            _heldFees[_i].amount - leftoverAmount,\n            _heldFees[_i].fee,\n            _heldFees[_i].feeDiscount,\n            _heldFees[_i].beneficiary\n          )\n        );\n        unchecked {\n          refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);\n        }\n        leftoverAmount = 0;\n      }\n      unchecked {\n        ++_i;\n      }\n    }\n    emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);\n  }\n  / \n    @notice \n    Returns the fee amount based on the provided amount for the specified project.\n    @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal.\n    @param _fee The percentage of the fee, out of MAX_FEE. \n    @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.\n    @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.\n  /\n  function _feeAmount(\n    uint256 _amount,\n    uint256 _fee,\n    uint256 _feeDiscount\n  ) internal pure returns (uint256) {\n    // Calculate the discounted fee.\n    uint256 _discountedFee = _fee -\n      PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT);\n    // The amount of tokens from the _amount to pay as a fee.\n    return\n      _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);\n  }\n  /* \n    @notice\n    Get the fee discount from the fee gauge for the specified project.\n    @param _projectId The ID of the project to get a fee discount for.\n    \n    @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.\n  /\n  function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {\n    // Can\'t take a fee if the protocol project doesn\'t have a terminal that accepts the token.\n    if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))\n      return JBConstants.MAX_FEE_DISCOUNT;\n    // Get the fee discount.\n    if (feeGauge == IJBFeeGauge(address(0)))\n      feeDiscount = 0;\n      // If the guage reverts, set the discount to 0.\n    else\n      try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {\n        feeDiscount = discount;\n      } catch {\n        feeDiscount = 0;\n      }\n    // If the fee discount is greater than the max, nullify the discount.\n    if (feeDiscount &gt; JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;\n  }\n}\n".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 17:17:35 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/security/ReentrancyGuard.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './../interfaces/IJBController.sol'; import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol'; import './../libraries/JBConstants.sol'; import './../libraries/JBCurrencies.sol'; import './../libraries/JBFixedPointNumber.sol'; import './../libraries/JBFundingCycleMetadataResolver.sol'; import './../libraries/JBOperations.sol'; import './../libraries/JBSplitsGroups.sol'; import './../libraries/JBTokens.sol'; import './../structs/JBTokenAmount.sol'; import './JBOperatable.sol'; import './JBSingleTokenPaymentTerminal.sol'; /**   @notice   Generic terminal managing all inflows and outflows of funds into the protocol ecosystem. @dev   A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time. @dev   Adheres to -   IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules. @dev   Inherits from -   JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.   JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.   Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.   ReentrancyGuard: Contract module that helps prevent reentrant calls to a function. */ abstract contract JBPayoutRedemptionPaymentTerminal is   IJBPayoutRedemptionPaymentTerminal,   JBSingleTokenPaymentTerminal,   JBOperatable,   Ownable,   ReentrancyGuard {   // A library that parses the packed funding cycle metadata into a friendlier format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error FEE_TOO_HIGH();   error INADEQUATE_DISTRIBUTION_AMOUNT();   error INADEQUATE_RECLAIM_AMOUNT();   error INADEQUATE_TOKEN_COUNT();   error NO_MSG_VALUE_ALLOWED();   error PAY_TO_ZERO_ADDRESS();   error PROJECT_TERMINAL_MISMATCH();   error REDEEM_TO_ZERO_ADDRESS();   error TERMINAL_IN_SPLIT_ZERO_ADDRESS();   error TERMINAL_TOKENS_INCOMPATIBLE(); //***********//   // ---------------------------- modifiers ---------------------------- //   //*************// /*      @notice      A modifier that verifies this terminal is a terminal of provided project ID.   /   modifier isTerminalOf(uint256 projectId) {     if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();     ;   } //***********//   // --------------------- internal stored constants ------------------- //   //*************// /**     @notice     Maximum fee that can be set for a funding cycle configuration. @dev Out of MAX_FEE (50_000_000 / 1_000_000_000).  */   uint256 internal constant _FEE_CAP = 50_000_000; /*     @notice     The protocol project ID is 1, as it should be the first project launched during the deployment process.   /   uint256 internal constant _PROTOCOL_PROJECT_ID = 1; //***********//   // --------------------- internal stored properties ------------------ //   //*************// /**     @notice     Fees that are being held to be processed later. _projectId The ID of the project for which fees are being held.  */   mapping(uint256 =&gt; JBFee[]) internal _heldFeesOf; //***********//   // ---------------- public immutable stored properties --------------- //   //*************// /*     @notice     Mints ERC-721's that represent project ownership and transfers.   /   IJBProjects public immutable override projects; /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; /*     @notice     The contract that stores splits for each project.   /   IJBSplitsStore public immutable override splitsStore; /*     @notice     The contract that exposes price feeds.   /   IJBPrices public immutable override prices; /*     @notice     The contract that stores and manages the terminal's data.   /   IJBSingleTokenPaymentTerminalStore public immutable override store; /**     @notice     The currency to base token issuance on. @dev If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.  */   uint256 public immutable override baseWeightCurrency; /*     @notice     The group that payout splits coming from this terminal are identified by.   /   uint256 public immutable override payoutSplitsGroup; //***********//   // --------------------- public stored properties -------------------- //   //*************// /**     @notice     The platform fee percent. @dev Out of MAX_FEE (25_000_000 / 1_000_000_000)  */   uint256 public override fee = 25_000_000; // 2.5% /*     @notice     The data source that returns a discount to apply to a project's fee.   /   IJBFeeGauge public override feeGauge; /**     @notice     Addresses that can be paid towards from this terminal without incurring a fee. _address The address that can be paid toward.  */   mapping(address =&gt; bool) public override isFeelessAddress; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     Gets the current overflowed amount in this terminal for a specified project, in terms of ETH. @dev The current overflow is represented as a fixed point number with 18 decimals.  @param _projectId The ID of the project to get overflow for.  @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.  */   function currentEthOverflowOf(uint256 _projectId)     external     view     virtual     override     returns (uint256)   {     // Get this terminal's current overflow.     uint256 _overflow = store.currentOverflowOf(this, _projectId); // Adjust the decimals of the fixed point number if needed to have 18 decimals. uint256 _adjustedOverflow = (decimals == 18)   ? _overflow   : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);  // Return the amount converted to ETH. return   (currency == JBCurrencies.ETH)     ? _adjustedOverflow     : PRBMath.mulDiv(       _adjustedOverflow,       10**decimals,       prices.priceFor(currency, JBCurrencies.ETH, decimals)     );  } /**     @notice     The fees that are currently being held to be processed later for each project. @param _projectId The ID of the project for which fees are being held.  @return An array of fees that are being held.  */   function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {     return _heldFeesOf[_projectId];   } //***********//   // -------------------------- public views --------------------------- //   //*************// /**     @notice     Indicates if this contract adheres to the specified interface. @dev  See {IERC165-supportsInterface}.  @param _interfaceId The ID of the interface to check for adherance to.  */   function supportsInterface(bytes4 _interfaceId)     public     view     virtual     override(JBSingleTokenPaymentTerminal, IERC165)     returns (bool)   {     return       _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||       _interfaceId == type(IJBPayoutTerminal).interfaceId ||       _interfaceId == type(IJBAllowanceTerminal).interfaceId ||       _interfaceId == type(IJBRedemptionTerminal).interfaceId ||       _interfaceId == type(IJBOperatable).interfaceId ||       super.supportsInterface(_interfaceId);   } //***********//   // -------------------------- constructor ---------------------------- //   //*************// /*     @param _token The token that this terminal manages.     @param _decimals The number of decimals the token fixed point amounts are expected to have.     @param _currency The currency that this terminal's token adheres to for price feeds.     @param _baseWeightCurrency The currency to base token issuance on.     @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.     @param _operatorStore A contract storing operator assignments.     @param _projects A contract which mints ERC-721's that represent project ownership and transfers.     @param _directory A contract storing directories of terminals and controllers for each project.     @param _splitsStore A contract that stores splits for each project.     @param _prices A contract that exposes price feeds.     @param _store A contract that stores the terminal's data.     @param _owner The address that will own this contract.   /   constructor(     // payable constructor save the gas used to check msg.value==0     address _token,     uint256 _decimals,     uint256 _currency,     uint256 _baseWeightCurrency,     uint256 _payoutSplitsGroup,     IJBOperatorStore _operatorStore,     IJBProjects _projects,     IJBDirectory _directory,     IJBSplitsStore _splitsStore,     IJBPrices _prices,     IJBSingleTokenPaymentTerminalStore _store,     address _owner   )     payable     JBSingleTokenPaymentTerminal(_token, _decimals, _currency)     JBOperatable(_operatorStore)   {     baseWeightCurrency = _baseWeightCurrency;     payoutSplitsGroup = _payoutSplitsGroup;     projects = _projects;     directory = _directory;     splitsStore = _splitsStore;     prices = _prices;     store = _store; transferOwnership(_owner);  } //***********//   // ---------------------- external transactions ---------------------- //   //*************// /**     @notice     Contribute tokens to a project. @param _projectId The ID of the project being paid. @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place. @param _token The token being paid. This terminal ignores this property since it only manages one token.  @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate. @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal. @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas. @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.  */   function pay(     uint256 _projectId,     uint256 _amount,     address _token,     address _beneficiary,     uint256 _minReturnedTokens,     bool _preferClaimedTokens,     string calldata _memo,     bytes calldata _metadata   ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {     _token; // Prevents unused var compiler and natspec complaints. // ETH shouldn't be sent if this terminal's token isn't ETH. if (token != JBTokens.ETH) {   if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();    // Transfer tokens to this terminal from the msg sender.   _transferFrom(msg.sender, payable(address(this)), _amount); } // If this terminal's token is ETH, override _amount with msg.value. else _amount = msg.value;  return   _pay(     _amount,     msg.sender,     _projectId,     _beneficiary,     _minReturnedTokens,     _preferClaimedTokens,     _memo,     _metadata   );  } /**     @notice     Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source. @dev Only a token holder or a designated operator can redeem its tokens.  @param _holder The account to redeem tokens for. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _token The token being reclaimed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal. @param _beneficiary The address to send the terminal tokens to. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.  */   function redeemTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     address _token,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo,     bytes memory _metadata   )     external     virtual     override     requirePermission(_holder, _projectId, JBOperations.REDEEM)     returns (uint256 reclaimAmount)   {     _token; // Prevents unused var compiler and natspec complaints. return   _redeemTokensOf(     _holder,     _projectId,     _tokenCount,     _minReturnedTokens,     _beneficiary,     _memo,     _metadata   );  } /**     @notice     Distributes payouts for a project with the distribution limit of its current funding cycle. @dev Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.  @dev Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.  @dev All funds distributed outside of this contract or any feeless terminals incure the protocol fee.  @param _projectId The ID of the project having its payouts distributed. @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency. @param _token The token being distributed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal. @param _memo A memo to pass along to the emitted event.  @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.  */   function distributePayoutsOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     address _token,     uint256 _minReturnedTokens,     string calldata _memo   ) external virtual override returns (uint256 netLeftoverDistributionAmount) {     _token; // Prevents unused var compiler and natspec complaints. return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);  } /**     @notice     Allows a project to send funds from its overflow up to the preconfigured allowance. @dev Only a project's owner or a designated operator can use its allowance.  @dev Incurs the protocol fee.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency. @param _token The token being distributed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals. @param _beneficiary The address to send the funds to. @param _memo A memo to pass along to the emitted event.  @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.  */   function useAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     address _token,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)     returns (uint256 netDistributedAmount)   {     _token; // Prevents unused var compiler and natspec complaints. return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);  } /**     @notice     Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type. @dev Only a project's owner or a designated operator can migrate it.  @param _projectId The ID of the project being migrated. @param _to The terminal contract that will gain the project's funds.  @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.  */   function migrate(uint256 _projectId, IJBPaymentTerminal _to)     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)     returns (uint256 balance)   {     // The terminal being migrated to must accept the same token as this terminal.     if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE(); // Record the migration in the store. balance = store.recordMigration(_projectId);  // Transfer the balance if needed. if (balance &gt; 0) {   // Trigger any inherited pre-transfer logic.   _beforeTransferTo(address(_to), balance);    // If this terminal's token is ETH, send it in msg.value.   uint256 _payableValue = token == JBTokens.ETH ? balance : 0;    // Withdraw the balance to transfer to the new terminal;   _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes('')); }  emit Migrate(_projectId, _to, balance, msg.sender);  } /**     @notice     Receives funds belonging to the specified project. @param _projectId The ID of the project to which the funds received belong. @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead. @param _token The token being paid. This terminal ignores this property since it only manages one currency.  @param _memo A memo to pass along to the emitted event. @param _metadata Extra data to pass along to the emitted event.  */   function addToBalanceOf(     uint256 _projectId,     uint256 _amount,     address _token,     string calldata _memo,     bytes calldata _metadata   ) external payable virtual override isTerminalOf(_projectId) {     _token; // Prevents unused var compiler and natspec complaints. // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender. if (token != JBTokens.ETH) {   // Amount must be greater than 0.   if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();    // Transfer tokens to this terminal from the msg sender.   _transferFrom(msg.sender, payable(address(this)), _amount); } // If the terminal's token is ETH, override `_amount` with msg.value. else _amount = msg.value;  // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal. _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);  } /**     @notice     Process any fees that are being held for the project. @dev Only a project owner, an operator, or the contract's owner can process held fees.  @param _projectId The ID of the project whos held fees should be processed.  */   function processFees(uint256 _projectId)     external     virtual     override     requirePermissionAllowingOverride(       projects.ownerOf(_projectId),       _projectId,       JBOperations.PROCESS_FEES,       msg.sender == owner()     )   {     // Get a reference to the project's held fees.     JBFee[] memory _heldFees = _heldFeesOf[_projectId]; // Delete the held fees. delete _heldFeesOf[_projectId];  // Push array length in stack uint256 _heldFeeLength = _heldFees.length;  // Process each fee. for (uint256 _i = 0; _i &lt; _heldFeeLength; ) {   // Get the fee amount.   uint256 _amount = _feeAmount(     _heldFees[_i].amount,     _heldFees[_i].fee,     _heldFees[_i].feeDiscount   );    // Process the fee.   _processFee(_amount, _heldFees[_i].beneficiary);    emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);    unchecked {     ++_i;   } }  } /**     @notice     Allows the fee to be updated. @dev Only the owner of this contract can change the fee.  @param _fee The new fee, out of MAX_FEE.  */   function setFee(uint256 _fee) external virtual override onlyOwner {     // The provided fee must be within the max.     if (_fee &gt; _FEE_CAP) revert FEE_TOO_HIGH(); // Store the new fee. fee = _fee;  emit SetFee(_fee, msg.sender);  } /**     @notice     Allows the fee gauge to be updated. @dev Only the owner of this contract can change the fee gauge.  @dev If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.  @param _feeGauge The new fee gauge.  */   function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {     // Store the new fee gauge.     feeGauge = _feeGauge; emit SetFeeGauge(_feeGauge, msg.sender);  } /**     @notice     Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee. @dev Only the owner of this contract can set addresses as feeless.  @param _address The address that can be paid towards while still bypassing fees. @param _flag A flag indicating whether the terminal should be feeless or not.  */   function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {     // Set the flag value.     isFeelessAddress[_address] = _flag; emit SetFeelessAddress(_address, _flag, msg.sender);  } //***********//   // ---------------------- internal transactions ---------------------- //   //*************// /**      @notice     Transfers tokens. @param _from The address from which the transfer should originate. @param _to The address to which the transfer should go. @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.  */   function _transferFrom(     address _from,     address payable _to,     uint256 _amount   ) internal virtual; /**      @notice     Logic to be triggered before transferring tokens from this terminal. @param _to The address to which the transfer is going. @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.  */   function _beforeTransferTo(address _to, uint256 _amount) internal virtual; /**     @notice     Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source. @dev Only a token holder or a designated operator can redeem its tokens.  @param _holder The account to redeem tokens for. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal. @param _beneficiary The address to send the terminal tokens to. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.  */   function _redeemTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo,     bytes memory _metadata   ) internal returns (uint256 reclaimAmount) {     // Can't send reclaimed funds to the zero address.     if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS(); // Define variables that will be needed outside the scoped section below. // Keep a reference to the funding cycle during which the redemption is being made. JBFundingCycle memory _fundingCycle;  // Scoped section prevents stack too deep. `_delegate` only used within scope. {   IJBRedemptionDelegate _delegate;    // Record the redemption.   (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(     _holder,     _projectId,     _tokenCount,     _memo,     _metadata   );    // The amount being reclaimed must be at least as much as was expected.   if (reclaimAmount &lt; _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();    // Burn the project tokens.   if (_tokenCount &gt; 0)     IJBController(directory.controllerOf(_projectId)).burnTokensOf(       _holder,       _projectId,       _tokenCount,       '',       false     );    // If a delegate was returned by the data source, issue a callback to it.   if (_delegate != IJBRedemptionDelegate(address(0))) {     JBDidRedeemData memory _data = JBDidRedeemData(       _holder,       _projectId,       _fundingCycle.configuration,       _tokenCount,       JBTokenAmount(token, reclaimAmount, decimals, currency),       _beneficiary,       _memo,       _metadata     );     _delegate.didRedeem(_data);     emit DelegateDidRedeem(_delegate, _data, msg.sender);   } }  // Send the reclaimed funds to the beneficiary. if (reclaimAmount &gt; 0) _transferFrom(address(this), _beneficiary, reclaimAmount);  emit RedeemTokens(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _holder,   _beneficiary,   _tokenCount,   reclaimAmount,   _memo,   _metadata,   msg.sender );  } /**     @notice     Distributes payouts for a project with the distribution limit of its current funding cycle. @dev Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.  @dev Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.  @dev All funds distributed outside of this contract or any feeless terminals incure the protocol fee.  @param _projectId The ID of the project having its payouts distributed. @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency. @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal. @param _memo A memo to pass along to the emitted event.  @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.  */   function _distributePayoutsOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     uint256 _minReturnedTokens,     string calldata _memo   ) internal returns (uint256 netLeftoverDistributionAmount) {     // Record the distribution.     (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(       _projectId,       _amount,       _currency     ); // The amount being distributed must be at least as much as was expected. if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();  // Get a reference to the project owner, which will receive tokens from paying the platform fee // and receive any extra distributable funds not allocated to payout splits. address payable _projectOwner = payable(projects.ownerOf(_projectId));  // Define variables that will be needed outside the scoped section below. // Keep a reference to the fee amount that was paid. uint256 _fee;  // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope. {   // Get the amount of discount that should be applied to any fees taken.   // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.   uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]     ? JBConstants.MAX_FEE_DISCOUNT     : _currentFeeDiscount(_projectId);    // The amount distributed that is eligible for incurring fees.   uint256 _feeEligibleDistributionAmount;    // The amount leftover after distributing to the splits.   uint256 _leftoverDistributionAmount;    // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.   // Also get a reference to the amount that was distributed to splits from which fees should be taken.   (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(     _projectId,     _fundingCycle.configuration,     payoutSplitsGroup,     _distributedAmount,     _feeDiscount   );    // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.   unchecked {     _feeEligibleDistributionAmount += _leftoverDistributionAmount;   }    // Take the fee.   _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0     ? 0     : _takeFeeFrom(       _projectId,       _fundingCycle,       _feeEligibleDistributionAmount,       _projectOwner,       _feeDiscount     );    // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.    unchecked {     netLeftoverDistributionAmount = _leftoverDistributionAmount == 0       ? 0       : _leftoverDistributionAmount -         _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);   }    // Transfer any remaining balance to the project owner.   if (netLeftoverDistributionAmount &gt; 0)     _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount); }  emit DistributePayouts(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _projectOwner,   _amount,   _distributedAmount,   _fee,   netLeftoverDistributionAmount,   _memo,   msg.sender );  } /**     @notice     Allows a project to send funds from its overflow up to the preconfigured allowance. @dev Only a project's owner or a designated operator can use its allowance.  @dev Incurs the protocol fee.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency. @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals. @param _beneficiary The address to send the funds to. @param _memo A memo to pass along to the emitted event.  @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.  */   function _useAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo   ) internal returns (uint256 netDistributedAmount) {     // Record the use of the allowance.     (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(       _projectId,       _amount,       _currency     ); // The amount being withdrawn must be at least as much as was expected. if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();  // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope. {   // Keep a reference to the fee amount that was paid.   uint256 _fee;    // Get a reference to the project owner, which will receive tokens from paying the platform fee.   address _projectOwner = projects.ownerOf(_projectId);    // Get the amount of discount that should be applied to any fees taken.   // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.   uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]     ? JBConstants.MAX_FEE_DISCOUNT     : _currentFeeDiscount(_projectId);    // Take a fee from the `_distributedAmount`, if needed.   _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT     ? 0     : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);    unchecked {     // The net amount is the withdrawn amount without the fee.     netDistributedAmount = _distributedAmount - _fee;   }    // Transfer any remaining balance to the beneficiary.   if (netDistributedAmount &gt; 0)     _transferFrom(address(this), _beneficiary, netDistributedAmount); }  emit UseAllowance(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _beneficiary,   _amount,   _distributedAmount,   netDistributedAmount,   _memo,   msg.sender );  } /**     @notice     Pays out splits for a project's funding cycle configuration. @param _projectId The ID of the project for which payout splits are being distributed. @param _domain The domain of the splits to distribute the payout between. @param _group The group of the splits to distribute the payout between. @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal. @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.  @return leftoverAmount If the leftover amount if the splits don't add up to 100%. @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.  */   function _distributeToPayoutSplitsOf(     uint256 _projectId,     uint256 _domain,     uint256 _group,     uint256 _amount,     uint256 _feeDiscount   ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {     // Set the leftover amount to the initial amount.     leftoverAmount = _amount; // Get a reference to the project's payout splits. JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);  // Transfer between all splits. for (uint256 _i = 0; _i &lt; _splits.length; ) {   // Get a reference to the split being iterated on.   JBSplit memory _split = _splits[_i];    // The amount to send towards the split.   uint256 _payoutAmount = PRBMath.mulDiv(     _amount,     _split.percent,     JBConstants.SPLITS_TOTAL_PERCENT   );    // The payout amount substracting any applicable incurred fees.   uint256 _netPayoutAmount;    if (_payoutAmount &gt; 0) {     // Transfer tokens to the split.     // If there's an allocator set, transfer to its `allocate` function.     if (_split.allocator != IJBSplitAllocator(address(0))) {       // If the split allocator is set as feeless, this distribution is not eligible for a fee.       if (isFeelessAddress[address(_split.allocator)])         _netPayoutAmount = _payoutAmount;         // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.       else {         unchecked {           _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT             ? _payoutAmount             : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);         }          // This distribution is eligible for a fee since the funds are leaving the ecosystem.         feeEligibleDistributionAmount += _payoutAmount;       }        // Trigger any inherited pre-transfer logic.       _beforeTransferTo(address(_split.allocator), _netPayoutAmount);        // If this terminal's token is ETH, send it in msg.value.       uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;        // Create the data to send to the allocator.       JBSplitAllocationData memory _data = JBSplitAllocationData(         token,         _netPayoutAmount,         decimals,         _projectId,         _group,         _split       );        // Trigger the allocator's `allocate` function.       _split.allocator.allocate{value: _payableValue}(_data);        // Otherwise, if a project is specified, make a payment to it.     } else if (_split.projectId != 0) {       // Get a reference to the Juicebox terminal being used.       IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);        // The project must have a terminal to send funds to.       if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();        // Save gas if this contract is being used as the terminal.       if (_terminal == this) {         // This distribution does not incur a fee.         _netPayoutAmount = _payoutAmount;          // Send the projectId in the metadata.         bytes memory _projectMetadata = new bytes(32);         _projectMetadata = bytes(abi.encodePacked(_projectId));          // Add to balance if prefered.         if (_split.preferAddToBalance)           _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);         else           _pay(             _netPayoutAmount,             address(this),             _split.projectId,             (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,             0,             _split.preferClaimed,             '',             _projectMetadata           );       } else {         // If the terminal is set as feeless, this distribution is not eligible for a fee.         if (isFeelessAddress[address(_terminal)])           _netPayoutAmount = _payoutAmount;           // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.         else {           unchecked {             _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT               ? _payoutAmount               : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);           }            feeEligibleDistributionAmount += _payoutAmount;         }          // Trigger any inherited pre-transfer logic.         _beforeTransferTo(address(_terminal), _netPayoutAmount);          // If this terminal's token is ETH, send it in msg.value.         uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;          // Send the projectId in the metadata.         bytes memory _projectMetadata = new bytes(32);         _projectMetadata = bytes(abi.encodePacked(_projectId));          // Add to balance if prefered.         if (_split.preferAddToBalance)           _terminal.addToBalanceOf{value: _payableValue}(             _split.projectId,             _netPayoutAmount,             token,             '',             _projectMetadata           );         else           _terminal.pay{value: _payableValue}(             _split.projectId,             _netPayoutAmount,             token,             _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,             0,             _split.preferClaimed,             '',             _projectMetadata           );       }     } else {       unchecked {         _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT           ? _payoutAmount           : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);       }        // This distribution is eligible for a fee since the funds are leaving the ecosystem.       feeEligibleDistributionAmount += _payoutAmount;        // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.       _transferFrom(         address(this),         _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),         _netPayoutAmount       );     }      // Subtract from the amount to be sent to the beneficiary.     unchecked {       leftoverAmount = leftoverAmount - _payoutAmount;     }   }    emit DistributeToPayoutSplit(     _projectId,     _domain,     _group,     _split,     _netPayoutAmount,     msg.sender   );    unchecked {     ++_i;   } }  } /**     @notice     Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID. @param _projectId The ID of the project having fees taken from. @param _fundingCycle The funding cycle during which the fee is being taken. @param _amount The amount of the fee to take, as a floating point number with 18 decimals. @param _beneficiary The address to mint the platforms tokens for. @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.  @return feeAmount The amount of the fee taken.  */   function _takeFeeFrom(     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _amount,     address _beneficiary,     uint256 _feeDiscount   ) internal returns (uint256 feeAmount) {     feeAmount = _feeAmount(_amount, fee, _feeDiscount); if (_fundingCycle.shouldHoldFees()) {   // Store the held fee.   _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));    emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender); } else {   // Process the fee.   _processFee(feeAmount, _beneficiary); // Take the fee.    emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender); }  } /**     @notice     Process a fee of the specified amount. @param _amount The fee amount, as a floating point number with 18 decimals. @param _beneficiary The address to mint the platform's tokens for.  */   function _processFee(uint256 _amount, address _beneficiary) internal {     // Get the terminal for the protocol project.     IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token); // When processing the admin fee, save gas if the admin is using this contract as its terminal. if (_terminal == this)   _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call. else {   // Trigger any inherited pre-transfer logic.   _beforeTransferTo(address(_terminal), _amount);    // If this terminal's token is ETH, send it in msg.value.   uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;    // Send the payment.   _terminal.pay{value: _payableValue}(     _PROTOCOL_PROJECT_ID,     _amount,     token,     _beneficiary,     0,     false,     '',     bytes('')   ); // Use the external pay call of the correct terminal. }  } /**     @notice     Contribute tokens to a project. @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place. @param _payer The address making the payment. @param _projectId The ID of the project being paid. @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate. @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal. @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas. @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.  */   function _pay(     uint256 _amount,     address _payer,     uint256 _projectId,     address _beneficiary,     uint256 _minReturnedTokens,     bool _preferClaimedTokens,     string memory _memo,     bytes memory _metadata   ) internal returns (uint256 beneficiaryTokenCount) {     // Cant send tokens to the zero address.     if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS(); // Define variables that will be needed outside the scoped section below. // Keep a reference to the funding cycle during which the payment is being made. JBFundingCycle memory _fundingCycle;  // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope. {   IJBPayDelegate _delegate;   uint256 _tokenCount;    // Bundle the amount info into a JBTokenAmount struct.   JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);    // Record the payment.   (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(     _payer,     _bundledAmount,     _projectId,     baseWeightCurrency,     _beneficiary,     _memo,     _metadata   );    // Mint the tokens if needed.   if (_tokenCount &gt; 0)     // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.     beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(       _projectId,       _tokenCount,       _beneficiary,       '',       _preferClaimedTokens,       true     );    // The token count for the beneficiary must be greater than or equal to the minimum expected.   if (beneficiaryTokenCount &lt; _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();    // If a delegate was returned by the data source, issue a callback to it.   if (_delegate != IJBPayDelegate(address(0))) {     JBDidPayData memory _data = JBDidPayData(       _payer,       _projectId,       _fundingCycle.configuration,       _bundledAmount,       beneficiaryTokenCount,       _beneficiary,       _preferClaimedTokens,       _memo,       _metadata     );      _delegate.didPay(_data);     emit DelegateDidPay(_delegate, _data, msg.sender);   } }  emit Pay(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _payer,   _beneficiary,   _amount,   beneficiaryTokenCount,   _memo,   _metadata,   msg.sender );  } /**     @notice     Receives funds belonging to the specified project. @param _projectId The ID of the project to which the funds received belong. @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead. @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added. @param _memo A memo to pass along to the emitted event. @param _metadata Extra data to pass along to the emitted event.  */   function _addToBalanceOf(     uint256 _projectId,     uint256 _amount,     bool _shouldRefundHeldFees,     string memory _memo,     bytes memory _metadata   ) internal {     // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.     uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0; // Record the added funds with any refunded fees. store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);  emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);  } /**     @notice     Refund fees based on the specified amount. @param _projectId The project for which fees are being refunded. @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.  @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal  */   function _refundHeldFees(uint256 _projectId, uint256 _amount)     internal     returns (uint256 refundedFees)   {     // Get a reference to the project's held fees.     JBFee[] memory _heldFees = _heldFeesOf[_projectId]; // Delete the current held fees. delete _heldFeesOf[_projectId];  // Get a reference to the leftover amount once all fees have been settled. uint256 leftoverAmount = _amount;  // Push length in stack uint256 _heldFeesLength = _heldFees.length;  // Process each fee. for (uint256 _i = 0; _i &lt; _heldFeesLength; ) {   if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);   else if (leftoverAmount &gt;= _heldFees[_i].amount) {     unchecked {       leftoverAmount = leftoverAmount - _heldFees[_i].amount;       refundedFees += _feeAmount(         _heldFees[_i].amount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount       );     }   } else {     _heldFeesOf[_projectId].push(       JBFee(         _heldFees[_i].amount - leftoverAmount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount,         _heldFees[_i].beneficiary       )     );     unchecked {       refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);     }     leftoverAmount = 0;   }    unchecked {     ++_i;   } }  emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);  } /**      @notice      Returns the fee amount based on the provided amount for the specified project. @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal. @param _fee The percentage of the fee, out of MAX_FEE.  @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.  @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.  */   function _feeAmount(     uint256 _amount,     uint256 _fee,     uint256 _feeDiscount   ) internal pure returns (uint256) {     // Calculate the discounted fee.     uint256 _discountedFee = _fee -       PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT); // The amount of tokens from the `_amount` to pay as a fee. return   _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);  } /**      @notice     Get the fee discount from the fee gauge for the specified project. @param _projectId The ID of the project to get a fee discount for.  @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.  */   function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {     // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.     if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))       return JBConstants.MAX_FEE_DISCOUNT; // Get the fee discount. if (feeGauge == IJBFeeGauge(address(0)))   feeDiscount = 0;   // If the guage reverts, set the discount to 0. else   try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {     feeDiscount = discount;   } catch {     feeDiscount = 0;   }  // If the fee discount is greater than the max, nullify the discount. if (feeDiscount &gt; JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 17:17:35 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './../interfaces/IJBController.sol';
import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol';
import './../libraries/JBConstants.sol';
import './../libraries/JBCurrencies.sol';
import './../libraries/JBFixedPointNumber.sol';
import './../libraries/JBFundingCycleMetadataResolver.sol';
import './../libraries/JBOperations.sol';
import './../libraries/JBSplitsGroups.sol';
import './../libraries/JBTokens.sol';
import './../structs/JBTokenAmount.sol';
import './JBOperatable.sol';
import './JBSingleTokenPaymentTerminal.sol';

/**
  @notice
  Generic terminal managing all inflows and outflows of funds into the protocol ecosystem.

  @dev
  A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time.

  @dev
  Adheres to -
  IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.
  JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
abstract contract JBPayoutRedemptionPaymentTerminal is
  IJBPayoutRedemptionPaymentTerminal,
  JBSingleTokenPaymentTerminal,
  JBOperatable,
  Ownable,
  ReentrancyGuard
{
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error FEE_TOO_HIGH();
  error INADEQUATE_DISTRIBUTION_AMOUNT();
  error INADEQUATE_RECLAIM_AMOUNT();
  error INADEQUATE_TOKEN_COUNT();
  error NO_MSG_VALUE_ALLOWED();
  error PAY_TO_ZERO_ADDRESS();
  error PROJECT_TERMINAL_MISMATCH();
  error REDEEM_TO_ZERO_ADDRESS();
  error TERMINAL_IN_SPLIT_ZERO_ADDRESS();
  error TERMINAL_TOKENS_INCOMPATIBLE();

  //*********************************************************************//
  // ---------------------------- modifiers ---------------------------- //
  //*********************************************************************//

  /** 
    @notice 
    A modifier that verifies this terminal is a terminal of provided project ID.
  */
  modifier isTerminalOf(uint256 _projectId) {
    if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();
    _;
  }

  //*********************************************************************//
  // --------------------- internal stored constants ------------------- //
  //*********************************************************************//

  /**
    @notice
    Maximum fee that can be set for a funding cycle configuration.

    @dev
    Out of MAX_FEE (50_000_000 / 1_000_000_000).
  */
  uint256 internal constant _FEE_CAP = 50_000_000;

  /**
    @notice
    The protocol project ID is 1, as it should be the first project launched during the deployment process.
  */
  uint256 internal constant _PROTOCOL_PROJECT_ID = 1;

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    Fees that are being held to be processed later.

    _projectId The ID of the project for which fees are being held.
  */
  mapping(uint256 => JBFee[]) internal _heldFeesOf;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership and transfers.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  /**
    @notice
    The contract that stores and manages the terminal's data.
  */
  IJBSingleTokenPaymentTerminalStore public immutable override store;

  /**
    @notice
    The currency to base token issuance on.

    @dev
    If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.
  */
  uint256 public immutable override baseWeightCurrency;

  /**
    @notice
    The group that payout splits coming from this terminal are identified by.
  */
  uint256 public immutable override payoutSplitsGroup;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The platform fee percent.

    @dev
    Out of MAX_FEE (25_000_000 / 1_000_000_000)
  */
  uint256 public override fee = 25_000_000; // 2.5%

  /**
    @notice
    The data source that returns a discount to apply to a project's fee.
  */
  IJBFeeGauge public override feeGauge;

  /**
    @notice
    Addresses that can be paid towards from this terminal without incurring a fee.

    _address The address that can be paid toward.
  */
  mapping(address => bool) public override isFeelessAddress;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.

    @dev
    The current overflow is represented as a fixed point number with 18 decimals.

    @param _projectId The ID of the project to get overflow for.

    @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.
  */
  function currentEthOverflowOf(uint256 _projectId)
    external
    view
    virtual
    override
    returns (uint256)
  {
    // Get this terminal's current overflow.
    uint256 _overflow = store.currentOverflowOf(this, _projectId);

    // Adjust the decimals of the fixed point number if needed to have 18 decimals.
    uint256 _adjustedOverflow = (decimals == 18)
      ? _overflow
      : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);

    // Return the amount converted to ETH.
    return
      (currency == JBCurrencies.ETH)
        ? _adjustedOverflow
        : PRBMath.mulDiv(
          _adjustedOverflow,
          10**decimals,
          prices.priceFor(currency, JBCurrencies.ETH, decimals)
        );
  }

  /**
    @notice
    The fees that are currently being held to be processed later for each project.

    @param _projectId The ID of the project for which fees are being held.

    @return An array of fees that are being held.
  */
  function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {
    return _heldFeesOf[_projectId];
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(JBSingleTokenPaymentTerminal, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||
      _interfaceId == type(IJBPayoutTerminal).interfaceId ||
      _interfaceId == type(IJBAllowanceTerminal).interfaceId ||
      _interfaceId == type(IJBRedemptionTerminal).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _token The token that this terminal manages.
    @param _decimals The number of decimals the token fixed point amounts are expected to have.
    @param _currency The currency that this terminal's token adheres to for price feeds.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _splitsStore A contract that stores splits for each project.
    @param _prices A contract that exposes price feeds.
    @param _store A contract that stores the terminal's data.
    @param _owner The address that will own this contract.
  */
  constructor(
    // payable constructor save the gas used to check msg.value==0
    address _token,
    uint256 _decimals,
    uint256 _currency,
    uint256 _baseWeightCurrency,
    uint256 _payoutSplitsGroup,
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBSplitsStore _splitsStore,
    IJBPrices _prices,
    IJBSingleTokenPaymentTerminalStore _store,
    address _owner
  )
    payable
    JBSingleTokenPaymentTerminal(_token, _decimals, _currency)
    JBOperatable(_operatorStore)
  {
    baseWeightCurrency = _baseWeightCurrency;
    payoutSplitsGroup = _payoutSplitsGroup;
    projects = _projects;
    directory = _directory;
    splitsStore = _splitsStore;
    prices = _prices;
    store = _store;

    transferOwnership(_owner);
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Contribute tokens to a project.

    @param _projectId The ID of the project being paid.
    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _token The token being paid. This terminal ignores this property since it only manages one token. 
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function pay(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {
    _token; // Prevents unused var compiler and natspec complaints.

    // ETH shouldn't be sent if this terminal's token isn't ETH.
    if (token != JBTokens.ETH) {
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If this terminal's token is ETH, override _amount with msg.value.
    else _amount = msg.value;

    return
      _pay(
        _amount,
        msg.sender,
        _projectId,
        _beneficiary,
        _minReturnedTokens,
        _preferClaimedTokens,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _token The token being reclaimed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  )
    external
    virtual
    override
    requirePermission(_holder, _projectId, JBOperations.REDEEM)
    returns (uint256 reclaimAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return
      _redeemTokensOf(
        _holder,
        _projectId,
        _tokenCount,
        _minReturnedTokens,
        _beneficiary,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) external virtual override returns (uint256 netLeftoverDistributionAmount) {
    _token; // Prevents unused var compiler and natspec complaints.

    return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)
    returns (uint256 netDistributedAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);
  }

  /**
    @notice
    Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project being migrated.
    @param _to The terminal contract that will gain the project's funds.

    @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.
  */
  function migrate(uint256 _projectId, IJBPaymentTerminal _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)
    returns (uint256 balance)
  {
    // The terminal being migrated to must accept the same token as this terminal.
    if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE();

    // Record the migration in the store.
    balance = store.recordMigration(_projectId);

    // Transfer the balance if needed.
    if (balance > 0) {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_to), balance);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? balance : 0;

      // Withdraw the balance to transfer to the new terminal;
      _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes(''));
    }

    emit Migrate(_projectId, _to, balance, msg.sender);
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _token The token being paid. This terminal ignores this property since it only manages one currency. 
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) {
    _token; // Prevents unused var compiler and natspec complaints.

    // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender.
    if (token != JBTokens.ETH) {
      // Amount must be greater than 0.
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If the terminal's token is ETH, override `_amount` with msg.value.
    else _amount = msg.value;

    // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal.
    _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);
  }

  /**
    @notice
    Process any fees that are being held for the project.

    @dev
    Only a project owner, an operator, or the contract's owner can process held fees.

    @param _projectId The ID of the project whos held fees should be processed.
  */
  function processFees(uint256 _projectId)
    external
    virtual
    override
    requirePermissionAllowingOverride(
      projects.ownerOf(_projectId),
      _projectId,
      JBOperations.PROCESS_FEES,
      msg.sender == owner()
    )
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the held fees.
    delete _heldFeesOf[_projectId];

    // Push array length in stack
    uint256 _heldFeeLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeeLength; ) {
      // Get the fee amount.
      uint256 _amount = _feeAmount(
        _heldFees[_i].amount,
        _heldFees[_i].fee,
        _heldFees[_i].feeDiscount
      );

      // Process the fee.
      _processFee(_amount, _heldFees[_i].beneficiary);

      emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Allows the fee to be updated.

    @dev
    Only the owner of this contract can change the fee.

    @param _fee The new fee, out of MAX_FEE.
  */
  function setFee(uint256 _fee) external virtual override onlyOwner {
    // The provided fee must be within the max.
    if (_fee > _FEE_CAP) revert FEE_TOO_HIGH();

    // Store the new fee.
    fee = _fee;

    emit SetFee(_fee, msg.sender);
  }

  /**
    @notice
    Allows the fee gauge to be updated.

    @dev
    Only the owner of this contract can change the fee gauge.

    @dev
    If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.

    @param _feeGauge The new fee gauge.
  */
  function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {
    // Store the new fee gauge.
    feeGauge = _feeGauge;

    emit SetFeeGauge(_feeGauge, msg.sender);
  }

  /**
    @notice
    Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.

    @dev
    Only the owner of this contract can set addresses as feeless.

    @param _address The address that can be paid towards while still bypassing fees.
    @param _flag A flag indicating whether the terminal should be feeless or not.
  */
  function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {
    // Set the flag value.
    isFeelessAddress[_address] = _flag;

    emit SetFeelessAddress(_address, _flag, msg.sender);
  }

  //*********************************************************************//
  // ---------------------- internal transactions ---------------------- //
  //*********************************************************************//

  /** 
    @notice
    Transfers tokens.

    @param _from The address from which the transfer should originate.
    @param _to The address to which the transfer should go.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _transferFrom(
    address _from,
    address payable _to,
    uint256 _amount
  ) internal virtual;

  /** 
    @notice
    Logic to be triggered before transferring tokens from this terminal.

    @param _to The address to which the transfer is going.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _beforeTransferTo(address _to, uint256 _amount) internal virtual;

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function _redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 reclaimAmount) {
    // Can't send reclaimed funds to the zero address.
    if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the redemption is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` only used within scope.
    {
      IJBRedemptionDelegate _delegate;

      // Record the redemption.
      (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(
        _holder,
        _projectId,
        _tokenCount,
        _memo,
        _metadata
      );

      // The amount being reclaimed must be at least as much as was expected.
      if (reclaimAmount < _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();

      // Burn the project tokens.
      if (_tokenCount > 0)
        IJBController(directory.controllerOf(_projectId)).burnTokensOf(
          _holder,
          _projectId,
          _tokenCount,
          '',
          false
        );

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBRedemptionDelegate(address(0))) {
        JBDidRedeemData memory _data = JBDidRedeemData(
          _holder,
          _projectId,
          _fundingCycle.configuration,
          _tokenCount,
          JBTokenAmount(token, reclaimAmount, decimals, currency),
          _beneficiary,
          _memo,
          _metadata
        );
        _delegate.didRedeem(_data);
        emit DelegateDidRedeem(_delegate, _data, msg.sender);
      }
    }

    // Send the reclaimed funds to the beneficiary.
    if (reclaimAmount > 0) _transferFrom(address(this), _beneficiary, reclaimAmount);

    emit RedeemTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _holder,
      _beneficiary,
      _tokenCount,
      reclaimAmount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) internal returns (uint256 netLeftoverDistributionAmount) {
    // Record the distribution.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(
      _projectId,
      _amount,
      _currency
    );

    // The amount being distributed must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Get a reference to the project owner, which will receive tokens from paying the platform fee
    // and receive any extra distributable funds not allocated to payout splits.
    address payable _projectOwner = payable(projects.ownerOf(_projectId));

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the fee amount that was paid.
    uint256 _fee;

    // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope.
    {
      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // The amount distributed that is eligible for incurring fees.
      uint256 _feeEligibleDistributionAmount;

      // The amount leftover after distributing to the splits.
      uint256 _leftoverDistributionAmount;

      // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.
      // Also get a reference to the amount that was distributed to splits from which fees should be taken.
      (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        payoutSplitsGroup,
        _distributedAmount,
        _feeDiscount
      );

      // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.
      unchecked {
        _feeEligibleDistributionAmount += _leftoverDistributionAmount;
      }

      // Take the fee.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0
        ? 0
        : _takeFeeFrom(
          _projectId,
          _fundingCycle,
          _feeEligibleDistributionAmount,
          _projectOwner,
          _feeDiscount
        );

      // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.

      unchecked {
        netLeftoverDistributionAmount = _leftoverDistributionAmount == 0
          ? 0
          : _leftoverDistributionAmount -
            _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);
      }

      // Transfer any remaining balance to the project owner.
      if (netLeftoverDistributionAmount > 0)
        _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount);
    }

    emit DistributePayouts(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _projectOwner,
      _amount,
      _distributedAmount,
      _fee,
      netLeftoverDistributionAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function _useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  ) internal returns (uint256 netDistributedAmount) {
    // Record the use of the allowance.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(
      _projectId,
      _amount,
      _currency
    );

    // The amount being withdrawn must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope.
    {
      // Keep a reference to the fee amount that was paid.
      uint256 _fee;

      // Get a reference to the project owner, which will receive tokens from paying the platform fee.
      address _projectOwner = projects.ownerOf(_projectId);

      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // Take a fee from the `_distributedAmount`, if needed.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
        ? 0
        : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);

      unchecked {
        // The net amount is the withdrawn amount without the fee.
        netDistributedAmount = _distributedAmount - _fee;
      }

      // Transfer any remaining balance to the beneficiary.
      if (netDistributedAmount > 0)
        _transferFrom(address(this), _beneficiary, netDistributedAmount);
    }

    emit UseAllowance(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _beneficiary,
      _amount,
      _distributedAmount,
      netDistributedAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Pays out splits for a project's funding cycle configuration.

    @param _projectId The ID of the project for which payout splits are being distributed.
    @param _domain The domain of the splits to distribute the payout between.
    @param _group The group of the splits to distribute the payout between.
    @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return leftoverAmount If the leftover amount if the splits don't add up to 100%.
    @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.
  */
  function _distributeToPayoutSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount,
    uint256 _feeDiscount
  ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's payout splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    // Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; ) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _payoutAmount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // The payout amount substracting any applicable incurred fees.
      uint256 _netPayoutAmount;

      if (_payoutAmount > 0) {
        // Transfer tokens to the split.
        // If there's an allocator set, transfer to its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0))) {
          // If the split allocator is set as feeless, this distribution is not eligible for a fee.
          if (isFeelessAddress[address(_split.allocator)])
            _netPayoutAmount = _payoutAmount;
            // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.
          else {
            unchecked {
              _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                ? _payoutAmount
                : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
            }

            // This distribution is eligible for a fee since the funds are leaving the ecosystem.
            feeEligibleDistributionAmount += _payoutAmount;
          }

          // Trigger any inherited pre-transfer logic.
          _beforeTransferTo(address(_split.allocator), _netPayoutAmount);

          // If this terminal's token is ETH, send it in msg.value.
          uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

          // Create the data to send to the allocator.
          JBSplitAllocationData memory _data = JBSplitAllocationData(
            token,
            _netPayoutAmount,
            decimals,
            _projectId,
            _group,
            _split
          );

          // Trigger the allocator's `allocate` function.
          _split.allocator.allocate{value: _payableValue}(_data);

          // Otherwise, if a project is specified, make a payment to it.
        } else if (_split.projectId != 0) {
          // Get a reference to the Juicebox terminal being used.
          IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);

          // The project must have a terminal to send funds to.
          if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();

          // Save gas if this contract is being used as the terminal.
          if (_terminal == this) {
            // This distribution does not incur a fee.
            _netPayoutAmount = _payoutAmount;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);
            else
              _pay(
                _netPayoutAmount,
                address(this),
                _split.projectId,
                (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          } else {
            // If the terminal is set as feeless, this distribution is not eligible for a fee.
            if (isFeelessAddress[address(_terminal)])
              _netPayoutAmount = _payoutAmount;
              // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.
            else {
              unchecked {
                _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                  ? _payoutAmount
                  : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
              }

              feeEligibleDistributionAmount += _payoutAmount;
            }

            // Trigger any inherited pre-transfer logic.
            _beforeTransferTo(address(_terminal), _netPayoutAmount);

            // If this terminal's token is ETH, send it in msg.value.
            uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _terminal.addToBalanceOf{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                '',
                _projectMetadata
              );
            else
              _terminal.pay{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          }
        } else {
          unchecked {
            _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
              ? _payoutAmount
              : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
          }

          // This distribution is eligible for a fee since the funds are leaving the ecosystem.
          feeEligibleDistributionAmount += _payoutAmount;

          // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.
          _transferFrom(
            address(this),
            _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),
            _netPayoutAmount
          );
        }

        // Subtract from the amount to be sent to the beneficiary.
        unchecked {
          leftoverAmount = leftoverAmount - _payoutAmount;
        }
      }

      emit DistributeToPayoutSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _netPayoutAmount,
        msg.sender
      );

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID.

    @param _projectId The ID of the project having fees taken from.
    @param _fundingCycle The funding cycle during which the fee is being taken.
    @param _amount The amount of the fee to take, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platforms tokens for.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return feeAmount The amount of the fee taken.
  */
  function _takeFeeFrom(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _amount,
    address _beneficiary,
    uint256 _feeDiscount
  ) internal returns (uint256 feeAmount) {
    feeAmount = _feeAmount(_amount, fee, _feeDiscount);

    if (_fundingCycle.shouldHoldFees()) {
      // Store the held fee.
      _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));

      emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender);
    } else {
      // Process the fee.
      _processFee(feeAmount, _beneficiary); // Take the fee.

      emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender);
    }
  }

  /**
    @notice
    Process a fee of the specified amount.

    @param _amount The fee amount, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platform's tokens for.
  */
  function _processFee(uint256 _amount, address _beneficiary) internal {
    // Get the terminal for the protocol project.
    IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token);

    // When processing the admin fee, save gas if the admin is using this contract as its terminal.
    if (_terminal == this)
      _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call.
    else {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_terminal), _amount);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;

      // Send the payment.
      _terminal.pay{value: _payableValue}(
        _PROTOCOL_PROJECT_ID,
        _amount,
        token,
        _beneficiary,
        0,
        false,
        '',
        bytes('')
      ); // Use the external pay call of the correct terminal.
    }
  }

  /**
    @notice
    Contribute tokens to a project.

    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _payer The address making the payment.
    @param _projectId The ID of the project being paid.
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function _pay(
    uint256 _amount,
    address _payer,
    uint256 _projectId,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 beneficiaryTokenCount) {
    // Cant send tokens to the zero address.
    if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the payment is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope.
    {
      IJBPayDelegate _delegate;
      uint256 _tokenCount;

      // Bundle the amount info into a JBTokenAmount struct.
      JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);

      // Record the payment.
      (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(
        _payer,
        _bundledAmount,
        _projectId,
        baseWeightCurrency,
        _beneficiary,
        _memo,
        _metadata
      );

      // Mint the tokens if needed.
      if (_tokenCount > 0)
        // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.
        beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(
          _projectId,
          _tokenCount,
          _beneficiary,
          '',
          _preferClaimedTokens,
          true
        );

      // The token count for the beneficiary must be greater than or equal to the minimum expected.
      if (beneficiaryTokenCount < _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBPayDelegate(address(0))) {
        JBDidPayData memory _data = JBDidPayData(
          _payer,
          _projectId,
          _fundingCycle.configuration,
          _bundledAmount,
          beneficiaryTokenCount,
          _beneficiary,
          _preferClaimedTokens,
          _memo,
          _metadata
        );

        _delegate.didPay(_data);
        emit DelegateDidPay(_delegate, _data, msg.sender);
      }
    }

    emit Pay(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _payer,
      _beneficiary,
      _amount,
      beneficiaryTokenCount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function _addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    bool _shouldRefundHeldFees,
    string memory _memo,
    bytes memory _metadata
  ) internal {
    // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.
    uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0;

    // Record the added funds with any refunded fees.
    store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);

    emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);
  }

  /**
    @notice
    Refund fees based on the specified amount.

    @param _projectId The project for which fees are being refunded.
    @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.

    @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal
  */
  function _refundHeldFees(uint256 _projectId, uint256 _amount)
    internal
    returns (uint256 refundedFees)
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the current held fees.
    delete _heldFeesOf[_projectId];

    // Get a reference to the leftover amount once all fees have been settled.
    uint256 leftoverAmount = _amount;

    // Push length in stack
    uint256 _heldFeesLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeesLength; ) {
      if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);
      else if (leftoverAmount >= _heldFees[_i].amount) {
        unchecked {
          leftoverAmount = leftoverAmount - _heldFees[_i].amount;
          refundedFees += _feeAmount(
            _heldFees[_i].amount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount
          );
        }
      } else {
        _heldFeesOf[_projectId].push(
          JBFee(
            _heldFees[_i].amount - leftoverAmount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount,
            _heldFees[_i].beneficiary
          )
        );
        unchecked {
          refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);
        }
        leftoverAmount = 0;
      }

      unchecked {
        ++_i;
      }
    }

    emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);
  }

  /** 
    @notice 
    Returns the fee amount based on the provided amount for the specified project.

    @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal.
    @param _fee The percentage of the fee, out of MAX_FEE. 
    @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.

    @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _feeAmount(
    uint256 _amount,
    uint256 _fee,
    uint256 _feeDiscount
  ) internal pure returns (uint256) {
    // Calculate the discounted fee.
    uint256 _discountedFee = _fee -
      PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT);

    // The amount of tokens from the `_amount` to pay as a fee.
    return
      _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);
  }

  /** 
    @notice
    Get the fee discount from the fee gauge for the specified project.

    @param _projectId The ID of the project to get a fee discount for.
    
    @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.
  */
  function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {
    // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.
    if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))
      return JBConstants.MAX_FEE_DISCOUNT;

    // Get the fee discount.
    if (feeGauge == IJBFeeGauge(address(0)))
      feeDiscount = 0;
      // If the guage reverts, set the discount to 0.
    else
      try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {
        feeDiscount = discount;
      } catch {
        feeDiscount = 0;
      }

    // If the fee discount is greater than the max, nullify the discount.
    if (feeDiscount > JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;
  }
}
.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './../interfaces/IJBController.sol';
import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol';
import './../libraries/JBConstants.sol';
import './../libraries/JBCurrencies.sol';
import './../libraries/JBFixedPointNumber.sol';
import './../libraries/JBFundingCycleMetadataResolver.sol';
import './../libraries/JBOperations.sol';
import './../libraries/JBSplitsGroups.sol';
import './../libraries/JBTokens.sol';
import './../structs/JBTokenAmount.sol';
import './JBOperatable.sol';
import './JBSingleTokenPaymentTerminal.sol';
/**
  @notice
  Generic terminal managing all inflows and outflows of funds into the protocol ecosystem.
  @dev
  A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time.
  @dev
  Adheres to -
  IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.
  @dev
  Inherits from -
  JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.
  JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
abstract contract JBPayoutRedemptionPaymentTerminal is
  IJBPayoutRedemptionPaymentTerminal,
  JBSingleTokenPaymentTerminal,
  JBOperatable,
  Ownable,
  ReentrancyGuard
{
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;
  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error FEE_TOO_HIGH();
  error INADEQUATE_DISTRIBUTION_AMOUNT();
  error INADEQUATE_RECLAIM_AMOUNT();
  error INADEQUATE_TOKEN_COUNT();
  error NO_MSG_VALUE_ALLOWED();
  error PAY_TO_ZERO_ADDRESS();
  error PROJECT_TERMINAL_MISMATCH();
  error REDEEM_TO_ZERO_ADDRESS();
  error TERMINAL_IN_SPLIT_ZERO_ADDRESS();
  error TERMINAL_TOKENS_INCOMPATIBLE();
  //*********************************************************************//
  // ---------------------------- modifiers ---------------------------- //
  //*********************************************************************//
  /** 
    @notice 
    A modifier that verifies this terminal is a terminal of provided project ID.
  */
  modifier isTerminalOf(uint256 _projectId) {
    if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();
    _;
  }
  //*********************************************************************//
  // --------------------- internal stored constants ------------------- //
  //*********************************************************************//
  /**
    @notice
    Maximum fee that can be set for a funding cycle configuration.
    @dev
    Out of MAX_FEE (50_000_000 / 1_000_000_000).
  */
  uint256 internal constant _FEE_CAP = 50_000_000;
  /**
    @notice
    The protocol project ID is 1, as it should be the first project launched during the deployment process.
  */
  uint256 internal constant _PROTOCOL_PROJECT_ID = 1;
  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//
  /**
    @notice
    Fees that are being held to be processed later.
    _projectId The ID of the project for which fees are being held.
  */
  mapping(uint256 => JBFee[]) internal _heldFeesOf;
  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//
  /**
    @notice
    Mints ERC-721's that represent project ownership and transfers.
  */
  IJBProjects public immutable override projects;
  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;
  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;
  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;
  /**
    @notice
    The contract that stores and manages the terminal's data.
  */
  IJBSingleTokenPaymentTerminalStore public immutable override store;
  /**
    @notice
    The currency to base token issuance on.
    @dev
    If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.
  */
  uint256 public immutable override baseWeightCurrency;
  /**
    @notice
    The group that payout splits coming from this terminal are identified by.
  */
  uint256 public immutable override payoutSplitsGroup;
  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//
  /**
    @notice
    The platform fee percent.
    @dev
    Out of MAX_FEE (25_000_000 / 1_000_000_000)
  */
  uint256 public override fee = 25_000_000; // 2.5%
  /**
    @notice
    The data source that returns a discount to apply to a project's fee.
  */
  IJBFeeGauge public override feeGauge;
  /**
    @notice
    Addresses that can be paid towards from this terminal without incurring a fee.
    _address The address that can be paid toward.
  */
  mapping(address => bool) public override isFeelessAddress;
  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//
  /**
    @notice
    Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.
    @dev
    The current overflow is represented as a fixed point number with 18 decimals.
    @param _projectId The ID of the project to get overflow for.
    @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.
  */
  function currentEthOverflowOf(uint256 _projectId)
    external
    view
    virtual
    override
    returns (uint256)
  {
    // Get this terminal's current overflow.
    uint256 _overflow = store.currentOverflowOf(this, _projectId);
    // Adjust the decimals of the fixed point number if needed to have 18 decimals.
    uint256 _adjustedOverflow = (decimals == 18)
      ? _overflow
      : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);
    // Return the amount converted to ETH.
    return
      (currency == JBCurrencies.ETH)
        ? _adjustedOverflow
        : PRBMath.mulDiv(
          _adjustedOverflow,
          10**decimals,
          prices.priceFor(currency, JBCurrencies.ETH, decimals)
        );
  }
  /**
    @notice
    The fees that are currently being held to be processed later for each project.
    @param _projectId The ID of the project for which fees are being held.
    @return An array of fees that are being held.
  */
  function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {
    return _heldFeesOf[_projectId];
  }
  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//
  /**
    @notice
    Indicates if this contract adheres to the specified interface.
    @dev 
    See {IERC165-supportsInterface}.
    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(JBSingleTokenPaymentTerminal, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||
      _interfaceId == type(IJBPayoutTerminal).interfaceId ||
      _interfaceId == type(IJBAllowanceTerminal).interfaceId ||
      _interfaceId == type(IJBRedemptionTerminal).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }
  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//
  /**
    @param _token The token that this terminal manages.
    @param _decimals The number of decimals the token fixed point amounts are expected to have.
    @param _currency The currency that this terminal's token adheres to for price feeds.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _splitsStore A contract that stores splits for each project.
    @param _prices A contract that exposes price feeds.
    @param _store A contract that stores the terminal's data.
    @param _owner The address that will own this contract.
  */
  constructor(
    // payable constructor save the gas used to check msg.value==0
    address _token,
    uint256 _decimals,
    uint256 _currency,
    uint256 _baseWeightCurrency,
    uint256 _payoutSplitsGroup,
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBSplitsStore _splitsStore,
    IJBPrices _prices,
    IJBSingleTokenPaymentTerminalStore _store,
    address _owner
  )
    payable
    JBSingleTokenPaymentTerminal(_token, _decimals, _currency)
    JBOperatable(_operatorStore)
  {
    baseWeightCurrency = _baseWeightCurrency;
    payoutSplitsGroup = _payoutSplitsGroup;
    projects = _projects;
    directory = _directory;
    splitsStore = _splitsStore;
    prices = _prices;
    store = _store;
    transferOwnership(_owner);
  }
  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//
  /**
    @notice
    Contribute tokens to a project.
    @param _projectId The ID of the project being paid.
    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _token The token being paid. This terminal ignores this property since it only manages one token. 
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.
    @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function pay(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {
    _token; // Prevents unused var compiler and natspec complaints.
    // ETH shouldn't be sent if this terminal's token isn't ETH.
    if (token != JBTokens.ETH) {
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();
      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If this terminal's token is ETH, override _amount with msg.value.
    else _amount = msg.value;
    return
      _pay(
        _amount,
        msg.sender,
        _projectId,
        _beneficiary,
        _minReturnedTokens,
        _preferClaimedTokens,
        _memo,
        _metadata
      );
  }
  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.
    @dev
    Only a token holder or a designated operator can redeem its tokens.
    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _token The token being reclaimed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.
    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  )
    external
    virtual
    override
    requirePermission(_holder, _projectId, JBOperations.REDEEM)
    returns (uint256 reclaimAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.
    return
      _redeemTokensOf(
        _holder,
        _projectId,
        _tokenCount,
        _minReturnedTokens,
        _beneficiary,
        _memo,
        _metadata
      );
  }
  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.
    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.
    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.
    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.
    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.
    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) external virtual override returns (uint256 netLeftoverDistributionAmount) {
    _token; // Prevents unused var compiler and natspec complaints.
    return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);
  }
  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.
    @dev
    Only a project's owner or a designated operator can use its allowance.
    @dev
    Incurs the protocol fee.
    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.
    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)
    returns (uint256 netDistributedAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.
    return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);
  }
  /**
    @notice
    Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.
    @dev
    Only a project's owner or a designated operator can migrate it.
    @param _projectId The ID of the project being migrated.
    @param _to The terminal contract that will gain the project's funds.
    @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.
  */
  function migrate(uint256 _projectId, IJBPaymentTerminal _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)
    returns (uint256 balance)
  {
    // The terminal being migrated to must accept the same token as this terminal.
    if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE();
    // Record the migration in the store.
    balance = store.recordMigration(_projectId);
    // Transfer the balance if needed.
    if (balance > 0) {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_to), balance);
      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? balance : 0;
      // Withdraw the balance to transfer to the new terminal;
      _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes(''));
    }
    emit Migrate(_projectId, _to, balance, msg.sender);
  }
  /**
    @notice
    Receives funds belonging to the specified project.
    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _token The token being paid. This terminal ignores this property since it only manages one currency. 
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) {
    _token; // Prevents unused var compiler and natspec complaints.
    // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender.
    if (token != JBTokens.ETH) {
      // Amount must be greater than 0.
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();
      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If the terminal's token is ETH, override `_amount` with msg.value.
    else _amount = msg.value;
    // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal.
    _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);
  }
  /**
    @notice
    Process any fees that are being held for the project.
    @dev
    Only a project owner, an operator, or the contract's owner can process held fees.
    @param _projectId The ID of the project whos held fees should be processed.
  */
  function processFees(uint256 _projectId)
    external
    virtual
    override
    requirePermissionAllowingOverride(
      projects.ownerOf(_projectId),
      _projectId,
      JBOperations.PROCESS_FEES,
      msg.sender == owner()
    )
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];
    // Delete the held fees.
    delete _heldFeesOf[_projectId];
    // Push array length in stack
    uint256 _heldFeeLength = _heldFees.length;
    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeeLength; ) {
      // Get the fee amount.
      uint256 _amount = _feeAmount(
        _heldFees[_i].amount,
        _heldFees[_i].fee,
        _heldFees[_i].feeDiscount
      );
      // Process the fee.
      _processFee(_amount, _heldFees[_i].beneficiary);
      emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);
      unchecked {
        ++_i;
      }
    }
  }
  /**
    @notice
    Allows the fee to be updated.
    @dev
    Only the owner of this contract can change the fee.
    @param _fee The new fee, out of MAX_FEE.
  */
  function setFee(uint256 _fee) external virtual override onlyOwner {
    // The provided fee must be within the max.
    if (_fee > _FEE_CAP) revert FEE_TOO_HIGH();
    // Store the new fee.
    fee = _fee;
    emit SetFee(_fee, msg.sender);
  }
  /**
    @notice
    Allows the fee gauge to be updated.
    @dev
    Only the owner of this contract can change the fee gauge.
    @dev
    If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.
    @param _feeGauge The new fee gauge.
  */
  function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {
    // Store the new fee gauge.
    feeGauge = _feeGauge;
    emit SetFeeGauge(_feeGauge, msg.sender);
  }
  /**
    @notice
    Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.
    @dev
    Only the owner of this contract can set addresses as feeless.
    @param _address The address that can be paid towards while still bypassing fees.
    @param _flag A flag indicating whether the terminal should be feeless or not.
  */
  function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {
    // Set the flag value.
    isFeelessAddress[_address] = _flag;
    emit SetFeelessAddress(_address, _flag, msg.sender);
  }
  //*********************************************************************//
  // ---------------------- internal transactions ---------------------- //
  //*********************************************************************//
  /** 
    @notice
    Transfers tokens.
    @param _from The address from which the transfer should originate.
    @param _to The address to which the transfer should go.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _transferFrom(
    address _from,
    address payable _to,
    uint256 _amount
  ) internal virtual;
  /** 
    @notice
    Logic to be triggered before transferring tokens from this terminal.
    @param _to The address to which the transfer is going.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _beforeTransferTo(address _to, uint256 _amount) internal virtual;
  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.
    @dev
    Only a token holder or a designated operator can redeem its tokens.
    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.
    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function _redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 reclaimAmount) {
    // Can't send reclaimed funds to the zero address.
    if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS();
    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the redemption is being made.
    JBFundingCycle memory _fundingCycle;
    // Scoped section prevents stack too deep. `_delegate` only used within scope.
    {
      IJBRedemptionDelegate _delegate;
      // Record the redemption.
      (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(
        _holder,
        _projectId,
        _tokenCount,
        _memo,
        _metadata
      );
      // The amount being reclaimed must be at least as much as was expected.
      if (reclaimAmount < _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();
      // Burn the project tokens.
      if (_tokenCount > 0)
        IJBController(directory.controllerOf(_projectId)).burnTokensOf(
          _holder,
          _projectId,
          _tokenCount,
          '',
          false
        );
      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBRedemptionDelegate(address(0))) {
        JBDidRedeemData memory _data = JBDidRedeemData(
          _holder,
          _projectId,
          _fundingCycle.configuration,
          _tokenCount,
          JBTokenAmount(token, reclaimAmount, decimals, currency),
          _beneficiary,
          _memo,
          _metadata
        );
        _delegate.didRedeem(_data);
        emit DelegateDidRedeem(_delegate, _data, msg.sender);
      }
    }
    // Send the reclaimed funds to the beneficiary.
    if (reclaimAmount > 0) _transferFrom(address(this), _beneficiary, reclaimAmount);
    emit RedeemTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _holder,
      _beneficiary,
      _tokenCount,
      reclaimAmount,
      _memo,
      _metadata,
      msg.sender
    );
  }
  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.
    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.
    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.
    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.
    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.
    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) internal returns (uint256 netLeftoverDistributionAmount) {
    // Record the distribution.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(
      _projectId,
      _amount,
      _currency
    );
    // The amount being distributed must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();
    // Get a reference to the project owner, which will receive tokens from paying the platform fee
    // and receive any extra distributable funds not allocated to payout splits.
    address payable _projectOwner = payable(projects.ownerOf(_projectId));
    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the fee amount that was paid.
    uint256 _fee;
    // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope.
    {
      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);
      // The amount distributed that is eligible for incurring fees.
      uint256 _feeEligibleDistributionAmount;
      // The amount leftover after distributing to the splits.
      uint256 _leftoverDistributionAmount;
      // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.
      // Also get a reference to the amount that was distributed to splits from which fees should be taken.
      (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        payoutSplitsGroup,
        _distributedAmount,
        _feeDiscount
      );
      // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.
      unchecked {
        _feeEligibleDistributionAmount += _leftoverDistributionAmount;
      }
      // Take the fee.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0
        ? 0
        : _takeFeeFrom(
          _projectId,
          _fundingCycle,
          _feeEligibleDistributionAmount,
          _projectOwner,
          _feeDiscount
        );
      // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.
      unchecked {
        netLeftoverDistributionAmount = _leftoverDistributionAmount == 0
          ? 0
          : _leftoverDistributionAmount -
            _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);
      }
      // Transfer any remaining balance to the project owner.
      if (netLeftoverDistributionAmount > 0)
        _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount);
    }
    emit DistributePayouts(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _projectOwner,
      _amount,
      _distributedAmount,
      _fee,
      netLeftoverDistributionAmount,
      _memo,
      msg.sender
    );
  }
  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.
    @dev
    Only a project's owner or a designated operator can use its allowance.
    @dev
    Incurs the protocol fee.
    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.
    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function _useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  ) internal returns (uint256 netDistributedAmount) {
    // Record the use of the allowance.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(
      _projectId,
      _amount,
      _currency
    );
    // The amount being withdrawn must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();
    // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope.
    {
      // Keep a reference to the fee amount that was paid.
      uint256 _fee;
      // Get a reference to the project owner, which will receive tokens from paying the platform fee.
      address _projectOwner = projects.ownerOf(_projectId);
      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);
      // Take a fee from the `_distributedAmount`, if needed.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
        ? 0
        : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);
      unchecked {
        // The net amount is the withdrawn amount without the fee.
        netDistributedAmount = _distributedAmount - _fee;
      }
      // Transfer any remaining balance to the beneficiary.
      if (netDistributedAmount > 0)
        _transferFrom(address(this), _beneficiary, netDistributedAmount);
    }
    emit UseAllowance(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _beneficiary,
      _amount,
      _distributedAmount,
      netDistributedAmount,
      _memo,
      msg.sender
    );
  }
  /**
    @notice
    Pays out splits for a project's funding cycle configuration.
    @param _projectId The ID of the project for which payout splits are being distributed.
    @param _domain The domain of the splits to distribute the payout between.
    @param _group The group of the splits to distribute the payout between.
    @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.
    @return leftoverAmount If the leftover amount if the splits don't add up to 100%.
    @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.
  */
  function _distributeToPayoutSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount,
    uint256 _feeDiscount
  ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;
    // Get a reference to the project's payout splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);
    // Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; ) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];
      // The amount to send towards the split.
      uint256 _payoutAmount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );
      // The payout amount substracting any applicable incurred fees.
      uint256 _netPayoutAmount;
      if (_payoutAmount > 0) {
        // Transfer tokens to the split.
        // If there's an allocator set, transfer to its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0))) {
          // If the split allocator is set as feeless, this distribution is not eligible for a fee.
          if (isFeelessAddress[address(_split.allocator)])
            _netPayoutAmount = _payoutAmount;
            // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.
          else {
            unchecked {
              _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                ? _payoutAmount
                : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
            }
            // This distribution is eligible for a fee since the funds are leaving the ecosystem.
            feeEligibleDistributionAmount += _payoutAmount;
          }
          // Trigger any inherited pre-transfer logic.
          _beforeTransferTo(address(_split.allocator), _netPayoutAmount);
          // If this terminal's token is ETH, send it in msg.value.
          uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;
          // Create the data to send to the allocator.
          JBSplitAllocationData memory _data = JBSplitAllocationData(
            token,
            _netPayoutAmount,
            decimals,
            _projectId,
            _group,
            _split
          );
          // Trigger the allocator's `allocate` function.
          _split.allocator.allocate{value: _payableValue}(_data);
          // Otherwise, if a project is specified, make a payment to it.
        } else if (_split.projectId != 0) {
          // Get a reference to the Juicebox terminal being used.
          IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);
          // The project must have a terminal to send funds to.
          if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();
          // Save gas if this contract is being used as the terminal.
          if (_terminal == this) {
            // This distribution does not incur a fee.
            _netPayoutAmount = _payoutAmount;
            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));
            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);
            else
              _pay(
                _netPayoutAmount,
                address(this),
                _split.projectId,
                (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          } else {
            // If the terminal is set as feeless, this distribution is not eligible for a fee.
            if (isFeelessAddress[address(_terminal)])
              _netPayoutAmount = _payoutAmount;
              // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.
            else {
              unchecked {
                _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                  ? _payoutAmount
                  : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
              }
              feeEligibleDistributionAmount += _payoutAmount;
            }
            // Trigger any inherited pre-transfer logic.
            _beforeTransferTo(address(_terminal), _netPayoutAmount);
            // If this terminal's token is ETH, send it in msg.value.
            uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;
            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));
            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _terminal.addToBalanceOf{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                '',
                _projectMetadata
              );
            else
              _terminal.pay{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          }
        } else {
          unchecked {
            _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
              ? _payoutAmount
              : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
          }
          // This distribution is eligible for a fee since the funds are leaving the ecosystem.
          feeEligibleDistributionAmount += _payoutAmount;
          // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.
          _transferFrom(
            address(this),
            _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),
            _netPayoutAmount
          );
        }
        // Subtract from the amount to be sent to the beneficiary.
        unchecked {
          leftoverAmount = leftoverAmount - _payoutAmount;
        }
      }
      emit DistributeToPayoutSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _netPayoutAmount,
        msg.sender
      );
      unchecked {
        ++_i;
      }
    }
  }
  /**
    @notice
    Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID.
    @param _projectId The ID of the project having fees taken from.
    @param _fundingCycle The funding cycle during which the fee is being taken.
    @param _amount The amount of the fee to take, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platforms tokens for.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.
    @return feeAmount The amount of the fee taken.
  */
  function _takeFeeFrom(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _amount,
    address _beneficiary,
    uint256 _feeDiscount
  ) internal returns (uint256 feeAmount) {
    feeAmount = _feeAmount(_amount, fee, _feeDiscount);
    if (_fundingCycle.shouldHoldFees()) {
      // Store the held fee.
      _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));
      emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender);
    } else {
      // Process the fee.
      _processFee(feeAmount, _beneficiary); // Take the fee.
      emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender);
    }
  }
  /**
    @notice
    Process a fee of the specified amount.
    @param _amount The fee amount, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platform's tokens for.
  */
  function _processFee(uint256 _amount, address _beneficiary) internal {
    // Get the terminal for the protocol project.
    IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token);
    // When processing the admin fee, save gas if the admin is using this contract as its terminal.
    if (_terminal == this)
      _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call.
    else {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_terminal), _amount);
      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;
      // Send the payment.
      _terminal.pay{value: _payableValue}(
        _PROTOCOL_PROJECT_ID,
        _amount,
        token,
        _beneficiary,
        0,
        false,
        '',
        bytes('')
      ); // Use the external pay call of the correct terminal.
    }
  }
  /**
    @notice
    Contribute tokens to a project.
    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _payer The address making the payment.
    @param _projectId The ID of the project being paid.
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.
    @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function _pay(
    uint256 _amount,
    address _payer,
    uint256 _projectId,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 beneficiaryTokenCount) {
    // Cant send tokens to the zero address.
    if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS();
    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the payment is being made.
    JBFundingCycle memory _fundingCycle;
    // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope.
    {
      IJBPayDelegate _delegate;
      uint256 _tokenCount;
      // Bundle the amount info into a JBTokenAmount struct.
      JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);
      // Record the payment.
      (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(
        _payer,
        _bundledAmount,
        _projectId,
        baseWeightCurrency,
        _beneficiary,
        _memo,
        _metadata
      );
      // Mint the tokens if needed.
      if (_tokenCount > 0)
        // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.
        beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(
          _projectId,
          _tokenCount,
          _beneficiary,
          '',
          _preferClaimedTokens,
          true
        );
      // The token count for the beneficiary must be greater than or equal to the minimum expected.
      if (beneficiaryTokenCount < _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();
      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBPayDelegate(address(0))) {
        JBDidPayData memory _data = JBDidPayData(
          _payer,
          _projectId,
          _fundingCycle.configuration,
          _bundledAmount,
          beneficiaryTokenCount,
          _beneficiary,
          _preferClaimedTokens,
          _memo,
          _metadata
        );
        _delegate.didPay(_data);
        emit DelegateDidPay(_delegate, _data, msg.sender);
      }
    }
    emit Pay(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _payer,
      _beneficiary,
      _amount,
      beneficiaryTokenCount,
      _memo,
      _metadata,
      msg.sender
    );
  }
  /**
    @notice
    Receives funds belonging to the specified project.
    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function _addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    bool _shouldRefundHeldFees,
    string memory _memo,
    bytes memory _metadata
  ) internal {
    // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.
    uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0;
    // Record the added funds with any refunded fees.
    store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);
    emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);
  }
  /**
    @notice
    Refund fees based on the specified amount.
    @param _projectId The project for which fees are being refunded.
    @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.
    @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal
  */
  function _refundHeldFees(uint256 _projectId, uint256 _amount)
    internal
    returns (uint256 refundedFees)
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];
    // Delete the current held fees.
    delete _heldFeesOf[_projectId];
    // Get a reference to the leftover amount once all fees have been settled.
    uint256 leftoverAmount = _amount;
    // Push length in stack
    uint256 _heldFeesLength = _heldFees.length;
    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeesLength; ) {
      if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);
      else if (leftoverAmount >= _heldFees[_i].amount) {
        unchecked {
          leftoverAmount = leftoverAmount - _heldFees[_i].amount;
          refundedFees += _feeAmount(
            _heldFees[_i].amount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount
          );
        }
      } else {
        _heldFeesOf[_projectId].push(
          JBFee(
            _heldFees[_i].amount - leftoverAmount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount,
            _heldFees[_i].beneficiary
          )
        );
        unchecked {
          refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);
        }
        leftoverAmount = 0;
      }
      unchecked {
        ++_i;
      }
    }
    emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);
  }
  /** 
    @notice 
    Returns the fee amount based on the provided amount for the specified project.
    @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal.
    @param _fee The percentage of the fee, out of MAX_FEE. 
    @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.
    @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _feeAmount(
    uint256 _amount,
    uint256 _fee,
    uint256 _feeDiscount
  ) internal pure returns (uint256) {
    // Calculate the discounted fee.
    uint256 _discountedFee = _fee -
      PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT);
    // The amount of tokens from the `_amount` to pay as a fee.
    return
      _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);
  }
  /** 
    @notice
    Get the fee discount from the fee gauge for the specified project.
    @param _projectId The ID of the project to get a fee discount for.
    
    @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.
  */
  function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {
    // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.
    if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))
      return JBConstants.MAX_FEE_DISCOUNT;
    // Get the fee discount.
    if (feeGauge == IJBFeeGauge(address(0)))
      feeDiscount = 0;
      // If the guage reverts, set the discount to 0.
    else
      try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {
        feeDiscount = discount;
      } catch {
        feeDiscount = 0;
      }
    // If the fee discount is greater than the max, nullify the discount.
    if (feeDiscount > JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;
  }
}
.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT
pragma solidity 0.8.6;
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './../interfaces/IJBController.sol';
import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol';
import './../libraries/JBConstants.sol';
import './../libraries/JBCurrencies.sol';
import './../libraries/JBFixedPointNumber.sol';
import './../libraries/JBFundingCycleMetadataResolver.sol';
import './../libraries/JBOperations.sol';
import './../libraries/JBSplitsGroups.sol';
import './../libraries/JBTokens.sol';
import './../structs/JBTokenAmount.sol';
import './JBOperatable.sol';
import './JBSingleTokenPaymentTerminal.sol';
/**
  @notice
  Generic terminal managing all inflows and outflows of funds into the protocol ecosystem.
  @dev
  A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time.
  @dev
  Adheres to -
  IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.
  @dev
  Inherits from -
  JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.
  JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
abstract contract JBPayoutRedemptionPaymentTerminal is
  IJBPayoutRedemptionPaymentTerminal,
  JBSingleTokenPaymentTerminal,
  JBOperatable,
  Ownable,
  ReentrancyGuard
{
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;
  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error FEE_TOO_HIGH();
  error INADEQUATE_DISTRIBUTION_AMOUNT();
  error INADEQUATE_RECLAIM_AMOUNT();
  error INADEQUATE_TOKEN_COUNT();
  error NO_MSG_VALUE_ALLOWED();
  error PAY_TO_ZERO_ADDRESS();
  error PROJECT_TERMINAL_MISMATCH();
  error REDEEM_TO_ZERO_ADDRESS();
  error TERMINAL_IN_SPLIT_ZERO_ADDRESS();
  error TERMINAL_TOKENS_INCOMPATIBLE();
  //*********************************************************************//
  // ---------------------------- modifiers ---------------------------- //
  //*********************************************************************//
  /** 
    @notice 
    A modifier that verifies this terminal is a terminal of provided project ID.
  */
  modifier isTerminalOf(uint256 _projectId) {
    if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();
    _;
  }
  //*********************************************************************//
  // --------------------- internal stored constants ------------------- //
  //*********************************************************************//
  /**
    @notice
    Maximum fee that can be set for a funding cycle configuration.
    @dev
    Out of MAX_FEE (50_000_000 / 1_000_000_000).
  */
  uint256 internal constant _FEE_CAP = 50_000_000;
  /**
    @notice
    The protocol project ID is 1, as it should be the first project launched during the deployment process.
  */
  uint256 internal constant _PROTOCOL_PROJECT_ID = 1;
  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//
  /**
    @notice
    Fees that are being held to be processed later.
    _projectId The ID of the project for which fees are being held.
  */
  mapping(uint256 => JBFee[]) internal _heldFeesOf;
  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//
  /**
    @notice
    Mints ERC-721's that represent project ownership and transfers.
  */
  IJBProjects public immutable override projects;
  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;
  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;
  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;
  /**
    @notice
    The contract that stores and manages the terminal's data.
  */
  IJBSingleTokenPaymentTerminalStore public immutable override store;
  /**
    @notice
    The currency to base token issuance on.
    @dev
    If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.
  */
  uint256 public immutable override baseWeightCurrency;
  /**
    @notice
    The group that payout splits coming from this terminal are identified by.
  */
  uint256 public immutable override payoutSplitsGroup;
  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//
  /**
    @notice
    The platform fee percent.
    @dev
    Out of MAX_FEE (25_000_000 / 1_000_000_000)
  */
  uint256 public override fee = 25_000_000; // 2.5%
  /**
    @notice
    The data source that returns a discount to apply to a project's fee.
  */
  IJBFeeGauge public override feeGauge;
  /**
    @notice
    Addresses that can be paid towards from this terminal without incurring a fee.
    _address The address that can be paid toward.
  */
  mapping(address => bool) public override isFeelessAddress;
  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//
  /**
    @notice
    Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.
    @dev
    The current overflow is represented as a fixed point number with 18 decimals.
    @param _projectId The ID of the project to get overflow for.
    @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.
  */
  function currentEthOverflowOf(uint256 _projectId)
    external
    view
    virtual
    override
    returns (uint256)
  {
    // Get this terminal's current overflow.
    uint256 _overflow = store.currentOverflowOf(this, _projectId);
    // Adjust the decimals of the fixed point number if needed to have 18 decimals.
    uint256 _adjustedOverflow = (decimals == 18)
      ? _overflow
      : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);
    // Return the amount converted to ETH.
    return
      (currency == JBCurrencies.ETH)
        ? _adjustedOverflow
        : PRBMath.mulDiv(
          _adjustedOverflow,
          10**decimals,
          prices.priceFor(currency, JBCurrencies.ETH, decimals)
        );
  }
  /**
    @notice
    The fees that are currently being held to be processed later for each project.
    @param _projectId The ID of the project for which fees are being held.
    @return An array of fees that are being held.
  */
  function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {
    return _heldFeesOf[_projectId];
  }
  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//
  /**
    @notice
    Indicates if this contract adheres to the specified interface.
    @dev 
    See {IERC165-supportsInterface}.
    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(JBSingleTokenPaymentTerminal, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||
      _interfaceId == type(IJBPayoutTerminal).interfaceId ||
      _interfaceId == type(IJBAllowanceTerminal).interfaceId ||
      _interfaceId == type(IJBRedemptionTerminal).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }
  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//
  /**
    @param _token The token that this terminal manages.
    @param _decimals The number of decimals the token fixed point amounts are expected to have.
    @param _currency The currency that this terminal's token adheres to for price feeds.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _splitsStore A contract that stores splits for each project.
    @param _prices A contract that exposes price feeds.
    @param _store A contract that stores the terminal's data.
    @param _owner The address that will own this contract.
  */
  constructor(
    // payable constructor save the gas used to check msg.value==0
    address _token,
    uint256 _decimals,
    uint256 _currency,
    uint256 _baseWeightCurrency,
    uint256 _payoutSplitsGroup,
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBSplitsStore _splitsStore,
    IJBPrices _prices,
    IJBSingleTokenPaymentTerminalStore _store,
    address _owner
  )
    payable
    JBSingleTokenPaymentTerminal(_token, _decimals, _currency)
    JBOperatable(_operatorStore)
  {
    baseWeightCurrency = _baseWeightCurrency;
    payoutSplitsGroup = _payoutSplitsGroup;
    projects = _projects;
    directory = _directory;
    splitsStore = _splitsStore;
    prices = _prices;
    store = _store;
    transferOwnership(_owner);
  }
  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//
  /**
    @notice
    Contribute tokens to a project.
    @param _projectId The ID of the project being paid.
    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _token The token being paid. This terminal ignores this property since it only manages one token. 
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.
    @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function pay(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {
    _token; // Prevents unused var compiler and natspec complaints.
    // ETH shouldn't be sent if this terminal's token isn't ETH.
    if (token != JBTokens.ETH) {
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();
      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If this terminal's token is ETH, override _amount with msg.value.
    else _amount = msg.value;
    return
      _pay(
        _amount,
        msg.sender,
        _projectId,
        _beneficiary,
        _minReturnedTokens,
        _preferClaimedTokens,
        _memo,
        _metadata
      );
  }
  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.
    @dev
    Only a token holder or a designated operator can redeem its tokens.
    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _token The token being reclaimed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.
    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  )
    external
    virtual
    override
    requirePermission(_holder, _projectId, JBOperations.REDEEM)
    returns (uint256 reclaimAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.
    return
      _redeemTokensOf(
        _holder,
        _projectId,
        _tokenCount,
        _minReturnedTokens,
        _beneficiary,
        _memo,
        _metadata
      );
  }
  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.
    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.
    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.
    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.
    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.
    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) external virtual override returns (uint256 netLeftoverDistributionAmount) {
    _token; // Prevents unused var compiler and natspec complaints.
    return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);
  }
  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.
    @dev
    Only a project's owner or a designated operator can use its allowance.
    @dev
    Incurs the protocol fee.
    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.
    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)
    returns (uint256 netDistributedAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.
    return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);
  }
  /**
    @notice
    Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.
    @dev
    Only a project's owner or a designated operator can migrate it.
    @param _projectId The ID of the project being migrated.
    @param _to The terminal contract that will gain the project's funds.
    @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.
  */
  function migrate(uint256 _projectId, IJBPaymentTerminal _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)
    returns (uint256 balance)
  {
    // The terminal being migrated to must accept the same token as this terminal.
    if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE();
    // Record the migration in the store.
    balance = store.recordMigration(_projectId);
    // Transfer the balance if needed.
    if (balance > 0) {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_to), balance);
      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? balance : 0;
      // Withdraw the balance to transfer to the new terminal;
      _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes(''));
    }
    emit Migrate(_projectId, _to, balance, msg.sender);
  }
  /**
    @notice
    Receives funds belonging to the specified project.
    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _token The token being paid. This terminal ignores this property since it only manages one currency. 
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) {
    _token; // Prevents unused var compiler and natspec complaints.
    // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender.
    if (token != JBTokens.ETH) {
      // Amount must be greater than 0.
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();
      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If the terminal's token is ETH, override `_amount` with msg.value.
    else _amount = msg.value;
    // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal.
    _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);
  }
  /**
    @notice
    Process any fees that are being held for the project.
    @dev
    Only a project owner, an operator, or the contract's owner can process held fees.
    @param _projectId The ID of the project whos held fees should be processed.
  */
  function processFees(uint256 _projectId)
    external
    virtual
    override
    requirePermissionAllowingOverride(
      projects.ownerOf(_projectId),
      _projectId,
      JBOperations.PROCESS_FEES,
      msg.sender == owner()
    )
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];
    // Delete the held fees.
    delete _heldFeesOf[_projectId];
    // Push array length in stack
    uint256 _heldFeeLength = _heldFees.length;
    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeeLength; ) {
      // Get the fee amount.
      uint256 _amount = _feeAmount(
        _heldFees[_i].amount,
        _heldFees[_i].fee,
        _heldFees[_i].feeDiscount
      );
      // Process the fee.
      _processFee(_amount, _heldFees[_i].beneficiary);
      emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);
      unchecked {
        ++_i;
      }
    }
  }
  /**
    @notice
    Allows the fee to be updated.
    @dev
    Only the owner of this contract can change the fee.
    @param _fee The new fee, out of MAX_FEE.
  */
  function setFee(uint256 _fee) external virtual override onlyOwner {
    // The provided fee must be within the max.
    if (_fee > _FEE_CAP) revert FEE_TOO_HIGH();
    // Store the new fee.
    fee = _fee;
    emit SetFee(_fee, msg.sender);
  }
  /**
    @notice
    Allows the fee gauge to be updated.
    @dev
    Only the owner of this contract can change the fee gauge.
    @dev
    If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.
    @param _feeGauge The new fee gauge.
  */
  function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {
    // Store the new fee gauge.
    feeGauge = _feeGauge;
    emit SetFeeGauge(_feeGauge, msg.sender);
  }
  /**
    @notice
    Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.
    @dev
    Only the owner of this contract can set addresses as feeless.
    @param _address The address that can be paid towards while still bypassing fees.
    @param _flag A flag indicating whether the terminal should be feeless or not.
  */
  function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {
    // Set the flag value.
    isFeelessAddress[_address] = _flag;
    emit SetFeelessAddress(_address, _flag, msg.sender);
  }
  //*********************************************************************//
  // ---------------------- internal transactions ---------------------- //
  //*********************************************************************//
  /** 
    @notice
    Transfers tokens.
    @param _from The address from which the transfer should originate.
    @param _to The address to which the transfer should go.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _transferFrom(
    address _from,
    address payable _to,
    uint256 _amount
  ) internal virtual;
  /** 
    @notice
    Logic to be triggered before transferring tokens from this terminal.
    @param _to The address to which the transfer is going.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _beforeTransferTo(address _to, uint256 _amount) internal virtual;
  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.
    @dev
    Only a token holder or a designated operator can redeem its tokens.
    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.
    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function _redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 reclaimAmount) {
    // Can't send reclaimed funds to the zero address.
    if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS();
    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the redemption is being made.
    JBFundingCycle memory _fundingCycle;
    // Scoped section prevents stack too deep. `_delegate` only used within scope.
    {
      IJBRedemptionDelegate _delegate;
      // Record the redemption.
      (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(
        _holder,
        _projectId,
        _tokenCount,
        _memo,
        _metadata
      );
      // The amount being reclaimed must be at least as much as was expected.
      if (reclaimAmount < _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();
      // Burn the project tokens.
      if (_tokenCount > 0)
        IJBController(directory.controllerOf(_projectId)).burnTokensOf(
          _holder,
          _projectId,
          _tokenCount,
          '',
          false
        );
      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBRedemptionDelegate(address(0))) {
        JBDidRedeemData memory _data = JBDidRedeemData(
          _holder,
          _projectId,
          _fundingCycle.configuration,
          _tokenCount,
          JBTokenAmount(token, reclaimAmount, decimals, currency),
          _beneficiary,
          _memo,
          _metadata
        );
        _delegate.didRedeem(_data);
        emit DelegateDidRedeem(_delegate, _data, msg.sender);
      }
    }
    // Send the reclaimed funds to the beneficiary.
    if (reclaimAmount > 0) _transferFrom(address(this), _beneficiary, reclaimAmount);
    emit RedeemTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _holder,
      _beneficiary,
      _tokenCount,
      reclaimAmount,
      _memo,
      _metadata,
      msg.sender
    );
  }
  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.
    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.
    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.
    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.
    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.
    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) internal returns (uint256 netLeftoverDistributionAmount) {
    // Record the distribution.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(
      _projectId,
      _amount,
      _currency
    );
    // The amount being distributed must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();
    // Get a reference to the project owner, which will receive tokens from paying the platform fee
    // and receive any extra distributable funds not allocated to payout splits.
    address payable _projectOwner = payable(projects.ownerOf(_projectId));
    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the fee amount that was paid.
    uint256 _fee;
    // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope.
    {
      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);
      // The amount distributed that is eligible for incurring fees.
      uint256 _feeEligibleDistributionAmount;
      // The amount leftover after distributing to the splits.
      uint256 _leftoverDistributionAmount;
      // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.
      // Also get a reference to the amount that was distributed to splits from which fees should be taken.
      (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        payoutSplitsGroup,
        _distributedAmount,
        _feeDiscount
      );
      // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.
      unchecked {
        _feeEligibleDistributionAmount += _leftoverDistributionAmount;
      }
      // Take the fee.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0
        ? 0
        : _takeFeeFrom(
          _projectId,
          _fundingCycle,
          _feeEligibleDistributionAmount,
          _projectOwner,
          _feeDiscount
        );
      // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.
      unchecked {
        netLeftoverDistributionAmount = _leftoverDistributionAmount == 0
          ? 0
          : _leftoverDistributionAmount -
            _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);
      }
      // Transfer any remaining balance to the project owner.
      if (netLeftoverDistributionAmount > 0)
        _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount);
    }
    emit DistributePayouts(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _projectOwner,
      _amount,
      _distributedAmount,
      _fee,
      netLeftoverDistributionAmount,
      _memo,
      msg.sender
    );
  }
  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.
    @dev
    Only a project's owner or a designated operator can use its allowance.
    @dev
    Incurs the protocol fee.
    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.
    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function _useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  ) internal returns (uint256 netDistributedAmount) {
    // Record the use of the allowance.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(
      _projectId,
      _amount,
      _currency
    );
    // The amount being withdrawn must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();
    // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope.
    {
      // Keep a reference to the fee amount that was paid.
      uint256 _fee;
      // Get a reference to the project owner, which will receive tokens from paying the platform fee.
      address _projectOwner = projects.ownerOf(_projectId);
      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);
      // Take a fee from the `_distributedAmount`, if needed.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
        ? 0
        : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);
      unchecked {
        // The net amount is the withdrawn amount without the fee.
        netDistributedAmount = _distributedAmount - _fee;
      }
      // Transfer any remaining balance to the beneficiary.
      if (netDistributedAmount > 0)
        _transferFrom(address(this), _beneficiary, netDistributedAmount);
    }
    emit UseAllowance(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _beneficiary,
      _amount,
      _distributedAmount,
      netDistributedAmount,
      _memo,
      msg.sender
    );
  }
  /**
    @notice
    Pays out splits for a project's funding cycle configuration.
    @param _projectId The ID of the project for which payout splits are being distributed.
    @param _domain The domain of the splits to distribute the payout between.
    @param _group The group of the splits to distribute the payout between.
    @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.
    @return leftoverAmount If the leftover amount if the splits don't add up to 100%.
    @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.
  */
  function _distributeToPayoutSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount,
    uint256 _feeDiscount
  ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;
    // Get a reference to the project's payout splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);
    // Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; ) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];
      // The amount to send towards the split.
      uint256 _payoutAmount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );
      // The payout amount substracting any applicable incurred fees.
      uint256 _netPayoutAmount;
      if (_payoutAmount > 0) {
        // Transfer tokens to the split.
        // If there's an allocator set, transfer to its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0))) {
          // If the split allocator is set as feeless, this distribution is not eligible for a fee.
          if (isFeelessAddress[address(_split.allocator)])
            _netPayoutAmount = _payoutAmount;
            // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.
          else {
            unchecked {
              _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                ? _payoutAmount
                : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
            }
            // This distribution is eligible for a fee since the funds are leaving the ecosystem.
            feeEligibleDistributionAmount += _payoutAmount;
          }
          // Trigger any inherited pre-transfer logic.
          _beforeTransferTo(address(_split.allocator), _netPayoutAmount);
          // If this terminal's token is ETH, send it in msg.value.
          uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;
          // Create the data to send to the allocator.
          JBSplitAllocationData memory _data = JBSplitAllocationData(
            token,
            _netPayoutAmount,
            decimals,
            _projectId,
            _group,
            _split
          );
          // Trigger the allocator's `allocate` function.
          _split.allocator.allocate{value: _payableValue}(_data);
          // Otherwise, if a project is specified, make a payment to it.
        } else if (_split.projectId != 0) {
          // Get a reference to the Juicebox terminal being used.
          IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);
          // The project must have a terminal to send funds to.
          if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();
          // Save gas if this contract is being used as the terminal.
          if (_terminal == this) {
            // This distribution does not incur a fee.
            _netPayoutAmount = _payoutAmount;
            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));
            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);
            else
              _pay(
                _netPayoutAmount,
                address(this),
                _split.projectId,
                (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          } else {
            // If the terminal is set as feeless, this distribution is not eligible for a fee.
            if (isFeelessAddress[address(_terminal)])
              _netPayoutAmount = _payoutAmount;
              // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.
            else {
              unchecked {
                _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                  ? _payoutAmount
                  : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
              }
              feeEligibleDistributionAmount += _payoutAmount;
            }
            // Trigger any inherited pre-transfer logic.
            _beforeTransferTo(address(_terminal), _netPayoutAmount);
            // If this terminal's token is ETH, send it in msg.value.
            uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;
            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));
            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _terminal.addToBalanceOf{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                '',
                _projectMetadata
              );
            else
              _terminal.pay{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          }
        } else {
          unchecked {
            _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
              ? _payoutAmount
              : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
          }
          // This distribution is eligible for a fee since the funds are leaving the ecosystem.
          feeEligibleDistributionAmount += _payoutAmount;
          // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.
          _transferFrom(
            address(this),
            _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),
            _netPayoutAmount
          );
        }
        // Subtract from the amount to be sent to the beneficiary.
        unchecked {
          leftoverAmount = leftoverAmount - _payoutAmount;
        }
      }
      emit DistributeToPayoutSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _netPayoutAmount,
        msg.sender
      );
      unchecked {
        ++_i;
      }
    }
  }
  /**
    @notice
    Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID.
    @param _projectId The ID of the project having fees taken from.
    @param _fundingCycle The funding cycle during which the fee is being taken.
    @param _amount The amount of the fee to take, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platforms tokens for.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.
    @return feeAmount The amount of the fee taken.
  */
  function _takeFeeFrom(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _amount,
    address _beneficiary,
    uint256 _feeDiscount
  ) internal returns (uint256 feeAmount) {
    feeAmount = _feeAmount(_amount, fee, _feeDiscount);
    if (_fundingCycle.shouldHoldFees()) {
      // Store the held fee.
      _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));
      emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender);
    } else {
      // Process the fee.
      _processFee(feeAmount, _beneficiary); // Take the fee.
      emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender);
    }
  }
  /**
    @notice
    Process a fee of the specified amount.
    @param _amount The fee amount, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platform's tokens for.
  */
  function _processFee(uint256 _amount, address _beneficiary) internal {
    // Get the terminal for the protocol project.
    IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token);
    // When processing the admin fee, save gas if the admin is using this contract as its terminal.
    if (_terminal == this)
      _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call.
    else {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_terminal), _amount);
      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;
      // Send the payment.
      _terminal.pay{value: _payableValue}(
        _PROTOCOL_PROJECT_ID,
        _amount,
        token,
        _beneficiary,
        0,
        false,
        '',
        bytes('')
      ); // Use the external pay call of the correct terminal.
    }
  }
  /**
    @notice
    Contribute tokens to a project.
    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _payer The address making the payment.
    @param _projectId The ID of the project being paid.
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.
    @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function _pay(
    uint256 _amount,
    address _payer,
    uint256 _projectId,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 beneficiaryTokenCount) {
    // Cant send tokens to the zero address.
    if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS();
    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the payment is being made.
    JBFundingCycle memory _fundingCycle;
    // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope.
    {
      IJBPayDelegate _delegate;
      uint256 _tokenCount;
      // Bundle the amount info into a JBTokenAmount struct.
      JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);
      // Record the payment.
      (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(
        _payer,
        _bundledAmount,
        _projectId,
        baseWeightCurrency,
        _beneficiary,
        _memo,
        _metadata
      );
      // Mint the tokens if needed.
      if (_tokenCount > 0)
        // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.
        beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(
          _projectId,
          _tokenCount,
          _beneficiary,
          '',
          _preferClaimedTokens,
          true
        );
      // The token count for the beneficiary must be greater than or equal to the minimum expected.
      if (beneficiaryTokenCount < _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();
      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBPayDelegate(address(0))) {
        JBDidPayData memory _data = JBDidPayData(
          _payer,
          _projectId,
          _fundingCycle.configuration,
          _bundledAmount,
          beneficiaryTokenCount,
          _beneficiary,
          _preferClaimedTokens,
          _memo,
          _metadata
        );
        _delegate.didPay(_data);
        emit DelegateDidPay(_delegate, _data, msg.sender);
      }
    }
    emit Pay(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _payer,
      _beneficiary,
      _amount,
      beneficiaryTokenCount,
      _memo,
      _metadata,
      msg.sender
    );
  }
  /**
    @notice
    Receives funds belonging to the specified project.
    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function _addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    bool _shouldRefundHeldFees,
    string memory _memo,
    bytes memory _metadata
  ) internal {
    // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.
    uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0;
    // Record the added funds with any refunded fees.
    store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);
    emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);
  }
  /**
    @notice
    Refund fees based on the specified amount.
    @param _projectId The project for which fees are being refunded.
    @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.
    @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal
  */
  function _refundHeldFees(uint256 _projectId, uint256 _amount)
    internal
    returns (uint256 refundedFees)
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];
    // Delete the current held fees.
    delete _heldFeesOf[_projectId];
    // Get a reference to the leftover amount once all fees have been settled.
    uint256 leftoverAmount = _amount;
    // Push length in stack
    uint256 _heldFeesLength = _heldFees.length;
    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeesLength; ) {
      if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);
      else if (leftoverAmount >= _heldFees[_i].amount) {
        unchecked {
          leftoverAmount = leftoverAmount - _heldFees[_i].amount;
          refundedFees += _feeAmount(
            _heldFees[_i].amount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount
          );
        }
      } else {
        _heldFeesOf[_projectId].push(
          JBFee(
            _heldFees[_i].amount - leftoverAmount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount,
            _heldFees[_i].beneficiary
          )
        );
        unchecked {
          refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);
        }
        leftoverAmount = 0;
      }
      unchecked {
        ++_i;
      }
    }
    emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);
  }
  /** 
    @notice 
    Returns the fee amount based on the provided amount for the specified project.
    @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal.
    @param _fee The percentage of the fee, out of MAX_FEE. 
    @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.
    @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _feeAmount(
    uint256 _amount,
    uint256 _fee,
    uint256 _feeDiscount
  ) internal pure returns (uint256) {
    // Calculate the discounted fee.
    uint256 _discountedFee = _fee -
      PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT);
    // The amount of tokens from the `_amount` to pay as a fee.
    return
      _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);
  }
  /** 
    @notice
    Get the fee discount from the fee gauge for the specified project.
    @param _projectId The ID of the project to get a fee discount for.
    
    @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.
  */
  function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {
    // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.
    if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))
      return JBConstants.MAX_FEE_DISCOUNT;
    // Get the fee discount.
    if (feeGauge == IJBFeeGauge(address(0)))
      feeDiscount = 0;
      // If the guage reverts, set the discount to 0.
    else
      try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {
        feeDiscount = discount;
      } catch {
        feeDiscount = 0;
      }
    // If the fee discount is greater than the max, nullify the discount.
    if (feeDiscount > JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;
  }
}
".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-01-09 17:17:40 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 17:17:40 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 38236
completion_tokens: 1
total_tokens: 38237
cost: $-1.000000


[2024-01-09 17:17:40 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './../interfaces/IJBController.sol';
import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol';
import './../libraries/JBConstants.sol';
import './../libraries/JBCurrencies.sol';
import './../libraries/JBFixedPointNumber.sol';
import './../libraries/JBFundingCycleMetadataResolver.sol';
import './../libraries/JBOperations.sol';
import './../libraries/JBSplitsGroups.sol';
import './../libraries/JBTokens.sol';
import './../structs/JBTokenAmount.sol';
import './JBOperatable.sol';
import './JBSingleTokenPaymentTerminal.sol';

/**
  @notice
  Generic terminal managing all inflows and outflows of funds into the protocol ecosystem.

  @dev
  A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time.

  @dev
  Adheres to -
  IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.
  JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
abstract contract JBPayoutRedemptionPaymentTerminal is
  IJBPayoutRedemptionPaymentTerminal,
  JBSingleTokenPaymentTerminal,
  JBOperatable,
  Ownable,
  ReentrancyGuard
{
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error FEE_TOO_HIGH();
  error INADEQUATE_DISTRIBUTION_AMOUNT();
  error INADEQUATE_RECLAIM_AMOUNT();
  error INADEQUATE_TOKEN_COUNT();
  error NO_MSG_VALUE_ALLOWED();
  error PAY_TO_ZERO_ADDRESS();
  error PROJECT_TERMINAL_MISMATCH();
  error REDEEM_TO_ZERO_ADDRESS();
  error TERMINAL_IN_SPLIT_ZERO_ADDRESS();
  error TERMINAL_TOKENS_INCOMPATIBLE();

  //*********************************************************************//
  // ---------------------------- modifiers ---------------------------- //
  //*********************************************************************//

  /** 
    @notice 
    A modifier that verifies this terminal is a terminal of provided project ID.
  */
  modifier isTerminalOf(uint256 _projectId) {
    if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();
    _;
  }

  //*********************************************************************//
  // --------------------- internal stored constants ------------------- //
  //*********************************************************************//

  /**
    @notice
    Maximum fee that can be set for a funding cycle configuration.

    @dev
    Out of MAX_FEE (50_000_000 / 1_000_000_000).
  */
  uint256 internal constant _FEE_CAP = 50_000_000;

  /**
    @notice
    The protocol project ID is 1, as it should be the first project launched during the deployment process.
  */
  uint256 internal constant _PROTOCOL_PROJECT_ID = 1;

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    Fees that are being held to be processed later.

    _projectId The ID of the project for which fees are being held.
  */
  mapping(uint256 => JBFee[]) internal _heldFeesOf;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership and transfers.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  /**
    @notice
    The contract that stores and manages the terminal's data.
  */
  IJBSingleTokenPaymentTerminalStore public immutable override store;

  /**
    @notice
    The currency to base token issuance on.

    @dev
    If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.
  */
  uint256 public immutable override baseWeightCurrency;

  /**
    @notice
    The group that payout splits coming from this terminal are identified by.
  */
  uint256 public immutable override payoutSplitsGroup;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The platform fee percent.

    @dev
    Out of MAX_FEE (25_000_000 / 1_000_000_000)
  */
  uint256 public override fee = 25_000_000; // 2.5%

  /**
    @notice
    The data source that returns a discount to apply to a project's fee.
  */
  IJBFeeGauge public override feeGauge;

  /**
    @notice
    Addresses that can be paid towards from this terminal without incurring a fee.

    _address The address that can be paid toward.
  */
  mapping(address => bool) public override isFeelessAddress;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.

    @dev
    The current overflow is represented as a fixed point number with 18 decimals.

    @param _projectId The ID of the project to get overflow for.

    @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.
  */
  function currentEthOverflowOf(uint256 _projectId)
    external
    view
    virtual
    override
    returns (uint256)
  {
    // Get this terminal's current overflow.
    uint256 _overflow = store.currentOverflowOf(this, _projectId);

    // Adjust the decimals of the fixed point number if needed to have 18 decimals.
    uint256 _adjustedOverflow = (decimals == 18)
      ? _overflow
      : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);

    // Return the amount converted to ETH.
    return
      (currency == JBCurrencies.ETH)
        ? _adjustedOverflow
        : PRBMath.mulDiv(
          _adjustedOverflow,
          10**decimals,
          prices.priceFor(currency, JBCurrencies.ETH, decimals)
        );
  }

  /**
    @notice
    The fees that are currently being held to be processed later for each project.

    @param _projectId The ID of the project for which fees are being held.

    @return An array of fees that are being held.
  */
  function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {
    return _heldFeesOf[_projectId];
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(JBSingleTokenPaymentTerminal, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||
      _interfaceId == type(IJBPayoutTerminal).interfaceId ||
      _interfaceId == type(IJBAllowanceTerminal).interfaceId ||
      _interfaceId == type(IJBRedemptionTerminal).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _token The token that this terminal manages.
    @param _decimals The number of decimals the token fixed point amounts are expected to have.
    @param _currency The currency that this terminal's token adheres to for price feeds.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _splitsStore A contract that stores splits for each project.
    @param _prices A contract that exposes price feeds.
    @param _store A contract that stores the terminal's data.
    @param _owner The address that will own this contract.
  */
  constructor(
    // payable constructor save the gas used to check msg.value==0
    address _token,
    uint256 _decimals,
    uint256 _currency,
    uint256 _baseWeightCurrency,
    uint256 _payoutSplitsGroup,
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBSplitsStore _splitsStore,
    IJBPrices _prices,
    IJBSingleTokenPaymentTerminalStore _store,
    address _owner
  )
    payable
    JBSingleTokenPaymentTerminal(_token, _decimals, _currency)
    JBOperatable(_operatorStore)
  {
    baseWeightCurrency = _baseWeightCurrency;
    payoutSplitsGroup = _payoutSplitsGroup;
    projects = _projects;
    directory = _directory;
    splitsStore = _splitsStore;
    prices = _prices;
    store = _store;

    transferOwnership(_owner);
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Contribute tokens to a project.

    @param _projectId The ID of the project being paid.
    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _token The token being paid. This terminal ignores this property since it only manages one token. 
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function pay(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {
    _token; // Prevents unused var compiler and natspec complaints.

    // ETH shouldn't be sent if this terminal's token isn't ETH.
    if (token != JBTokens.ETH) {
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If this terminal's token is ETH, override _amount with msg.value.
    else _amount = msg.value;

    return
      _pay(
        _amount,
        msg.sender,
        _projectId,
        _beneficiary,
        _minReturnedTokens,
        _preferClaimedTokens,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _token The token being reclaimed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  )
    external
    virtual
    override
    requirePermission(_holder, _projectId, JBOperations.REDEEM)
    returns (uint256 reclaimAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return
      _redeemTokensOf(
        _holder,
        _projectId,
        _tokenCount,
        _minReturnedTokens,
        _beneficiary,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) external virtual override returns (uint256 netLeftoverDistributionAmount) {
    _token; // Prevents unused var compiler and natspec complaints.

    return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)
    returns (uint256 netDistributedAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);
  }

  /**
    @notice
    Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project being migrated.
    @param _to The terminal contract that will gain the project's funds.

    @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.
  */
  function migrate(uint256 _projectId, IJBPaymentTerminal _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)
    returns (uint256 balance)
  {
    // The terminal being migrated to must accept the same token as this terminal.
    if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE();

    // Record the migration in the store.
    balance = store.recordMigration(_projectId);

    // Transfer the balance if needed.
    if (balance > 0) {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_to), balance);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? balance : 0;

      // Withdraw the balance to transfer to the new terminal;
      _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes(''));
    }

    emit Migrate(_projectId, _to, balance, msg.sender);
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _token The token being paid. This terminal ignores this property since it only manages one currency. 
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) {
    _token; // Prevents unused var compiler and natspec complaints.

    // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender.
    if (token != JBTokens.ETH) {
      // Amount must be greater than 0.
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If the terminal's token is ETH, override `_amount` with msg.value.
    else _amount = msg.value;

    // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal.
    _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);
  }

  /**
    @notice
    Process any fees that are being held for the project.

    @dev
    Only a project owner, an operator, or the contract's owner can process held fees.

    @param _projectId The ID of the project whos held fees should be processed.
  */
  function processFees(uint256 _projectId)
    external
    virtual
    override
    requirePermissionAllowingOverride(
      projects.ownerOf(_projectId),
      _projectId,
      JBOperations.PROCESS_FEES,
      msg.sender == owner()
    )
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the held fees.
    delete _heldFeesOf[_projectId];

    // Push array length in stack
    uint256 _heldFeeLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeeLength; ) {
      // Get the fee amount.
      uint256 _amount = _feeAmount(
        _heldFees[_i].amount,
        _heldFees[_i].fee,
        _heldFees[_i].feeDiscount
      );

      // Process the fee.
      _processFee(_amount, _heldFees[_i].beneficiary);

      emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Allows the fee to be updated.

    @dev
    Only the owner of this contract can change the fee.

    @param _fee The new fee, out of MAX_FEE.
  */
  function setFee(uint256 _fee) external virtual override onlyOwner {
    // The provided fee must be within the max.
    if (_fee > _FEE_CAP) revert FEE_TOO_HIGH();

    // Store the new fee.
    fee = _fee;

    emit SetFee(_fee, msg.sender);
  }

  /**
    @notice
    Allows the fee gauge to be updated.

    @dev
    Only the owner of this contract can change the fee gauge.

    @dev
    If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.

    @param _feeGauge The new fee gauge.
  */
  function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {
    // Store the new fee gauge.
    feeGauge = _feeGauge;

    emit SetFeeGauge(_feeGauge, msg.sender);
  }

  /**
    @notice
    Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.

    @dev
    Only the owner of this contract can set addresses as feeless.

    @param _address The address that can be paid towards while still bypassing fees.
    @param _flag A flag indicating whether the terminal should be feeless or not.
  */
  function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {
    // Set the flag value.
    isFeelessAddress[_address] = _flag;

    emit SetFeelessAddress(_address, _flag, msg.sender);
  }

  //*********************************************************************//
  // ---------------------- internal transactions ---------------------- //
  //*********************************************************************//

  /** 
    @notice
    Transfers tokens.

    @param _from The address from which the transfer should originate.
    @param _to The address to which the transfer should go.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _transferFrom(
    address _from,
    address payable _to,
    uint256 _amount
  ) internal virtual;

  /** 
    @notice
    Logic to be triggered before transferring tokens from this terminal.

    @param _to The address to which the transfer is going.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _beforeTransferTo(address _to, uint256 _amount) internal virtual;

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function _redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 reclaimAmount) {
    // Can't send reclaimed funds to the zero address.
    if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the redemption is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` only used within scope.
    {
      IJBRedemptionDelegate _delegate;

      // Record the redemption.
      (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(
        _holder,
        _projectId,
        _tokenCount,
        _memo,
        _metadata
      );

      // The amount being reclaimed must be at least as much as was expected.
      if (reclaimAmount < _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();

      // Burn the project tokens.
      if (_tokenCount > 0)
        IJBController(directory.controllerOf(_projectId)).burnTokensOf(
          _holder,
          _projectId,
          _tokenCount,
          '',
          false
        );

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBRedemptionDelegate(address(0))) {
        JBDidRedeemData memory _data = JBDidRedeemData(
          _holder,
          _projectId,
          _fundingCycle.configuration,
          _tokenCount,
          JBTokenAmount(token, reclaimAmount, decimals, currency),
          _beneficiary,
          _memo,
          _metadata
        );
        _delegate.didRedeem(_data);
        emit DelegateDidRedeem(_delegate, _data, msg.sender);
      }
    }

    // Send the reclaimed funds to the beneficiary.
    if (reclaimAmount > 0) _transferFrom(address(this), _beneficiary, reclaimAmount);

    emit RedeemTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _holder,
      _beneficiary,
      _tokenCount,
      reclaimAmount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) internal returns (uint256 netLeftoverDistributionAmount) {
    // Record the distribution.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(
      _projectId,
      _amount,
      _currency
    );

    // The amount being distributed must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Get a reference to the project owner, which will receive tokens from paying the platform fee
    // and receive any extra distributable funds not allocated to payout splits.
    address payable _projectOwner = payable(projects.ownerOf(_projectId));

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the fee amount that was paid.
    uint256 _fee;

    // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope.
    {
      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // The amount distributed that is eligible for incurring fees.
      uint256 _feeEligibleDistributionAmount;

      // The amount leftover after distributing to the splits.
      uint256 _leftoverDistributionAmount;

      // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.
      // Also get a reference to the amount that was distributed to splits from which fees should be taken.
      (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        payoutSplitsGroup,
        _distributedAmount,
        _feeDiscount
      );

      // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.
      unchecked {
        _feeEligibleDistributionAmount += _leftoverDistributionAmount;
      }

      // Take the fee.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0
        ? 0
        : _takeFeeFrom(
          _projectId,
          _fundingCycle,
          _feeEligibleDistributionAmount,
          _projectOwner,
          _feeDiscount
        );

      // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.

      unchecked {
        netLeftoverDistributionAmount = _leftoverDistributionAmount == 0
          ? 0
          : _leftoverDistributionAmount -
            _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);
      }

      // Transfer any remaining balance to the project owner.
      if (netLeftoverDistributionAmount > 0)
        _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount);
    }

    emit DistributePayouts(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _projectOwner,
      _amount,
      _distributedAmount,
      _fee,
      netLeftoverDistributionAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function _useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  ) internal returns (uint256 netDistributedAmount) {
    // Record the use of the allowance.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(
      _projectId,
      _amount,
      _currency
    );

    // The amount being withdrawn must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope.
    {
      // Keep a reference to the fee amount that was paid.
      uint256 _fee;

      // Get a reference to the project owner, which will receive tokens from paying the platform fee.
      address _projectOwner = projects.ownerOf(_projectId);

      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // Take a fee from the `_distributedAmount`, if needed.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
        ? 0
        : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);

      unchecked {
        // The net amount is the withdrawn amount without the fee.
        netDistributedAmount = _distributedAmount - _fee;
      }

      // Transfer any remaining balance to the beneficiary.
      if (netDistributedAmount > 0)
        _transferFrom(address(this), _beneficiary, netDistributedAmount);
    }

    emit UseAllowance(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _beneficiary,
      _amount,
      _distributedAmount,
      netDistributedAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Pays out splits for a project's funding cycle configuration.

    @param _projectId The ID of the project for which payout splits are being distributed.
    @param _domain The domain of the splits to distribute the payout between.
    @param _group The group of the splits to distribute the payout between.
    @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return leftoverAmount If the leftover amount if the splits don't add up to 100%.
    @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.
  */
  function _distributeToPayoutSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount,
    uint256 _feeDiscount
  ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's payout splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    // Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; ) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _payoutAmount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // The payout amount substracting any applicable incurred fees.
      uint256 _netPayoutAmount;

      if (_payoutAmount > 0) {
        // Transfer tokens to the split.
        // If there's an allocator set, transfer to its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0))) {
          // If the split allocator is set as feeless, this distribution is not eligible for a fee.
          if (isFeelessAddress[address(_split.allocator)])
            _netPayoutAmount = _payoutAmount;
            // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.
          else {
            unchecked {
              _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                ? _payoutAmount
                : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
            }

            // This distribution is eligible for a fee since the funds are leaving the ecosystem.
            feeEligibleDistributionAmount += _payoutAmount;
          }

          // Trigger any inherited pre-transfer logic.
          _beforeTransferTo(address(_split.allocator), _netPayoutAmount);

          // If this terminal's token is ETH, send it in msg.value.
          uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

          // Create the data to send to the allocator.
          JBSplitAllocationData memory _data = JBSplitAllocationData(
            token,
            _netPayoutAmount,
            decimals,
            _projectId,
            _group,
            _split
          );

          // Trigger the allocator's `allocate` function.
          _split.allocator.allocate{value: _payableValue}(_data);

          // Otherwise, if a project is specified, make a payment to it.
        } else if (_split.projectId != 0) {
          // Get a reference to the Juicebox terminal being used.
          IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);

          // The project must have a terminal to send funds to.
          if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();

          // Save gas if this contract is being used as the terminal.
          if (_terminal == this) {
            // This distribution does not incur a fee.
            _netPayoutAmount = _payoutAmount;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);
            else
              _pay(
                _netPayoutAmount,
                address(this),
                _split.projectId,
                (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          } else {
            // If the terminal is set as feeless, this distribution is not eligible for a fee.
            if (isFeelessAddress[address(_terminal)])
              _netPayoutAmount = _payoutAmount;
              // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.
            else {
              unchecked {
                _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                  ? _payoutAmount
                  : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
              }

              feeEligibleDistributionAmount += _payoutAmount;
            }

            // Trigger any inherited pre-transfer logic.
            _beforeTransferTo(address(_terminal), _netPayoutAmount);

            // If this terminal's token is ETH, send it in msg.value.
            uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _terminal.addToBalanceOf{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                '',
                _projectMetadata
              );
            else
              _terminal.pay{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          }
        } else {
          unchecked {
            _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
              ? _payoutAmount
              : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
          }

          // This distribution is eligible for a fee since the funds are leaving the ecosystem.
          feeEligibleDistributionAmount += _payoutAmount;

          // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.
          _transferFrom(
            address(this),
            _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),
            _netPayoutAmount
          );
        }

        // Subtract from the amount to be sent to the beneficiary.
        unchecked {
          leftoverAmount = leftoverAmount - _payoutAmount;
        }
      }

      emit DistributeToPayoutSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _netPayoutAmount,
        msg.sender
      );

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID.

    @param _projectId The ID of the project having fees taken from.
    @param _fundingCycle The funding cycle during which the fee is being taken.
    @param _amount The amount of the fee to take, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platforms tokens for.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return feeAmount The amount of the fee taken.
  */
  function _takeFeeFrom(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _amount,
    address _beneficiary,
    uint256 _feeDiscount
  ) internal returns (uint256 feeAmount) {
    feeAmount = _feeAmount(_amount, fee, _feeDiscount);

    if (_fundingCycle.shouldHoldFees()) {
      // Store the held fee.
      _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));

      emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender);
    } else {
      // Process the fee.
      _processFee(feeAmount, _beneficiary); // Take the fee.

      emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender);
    }
  }

  /**
    @notice
    Process a fee of the specified amount.

    @param _amount The fee amount, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platform's tokens for.
  */
  function _processFee(uint256 _amount, address _beneficiary) internal {
    // Get the terminal for the protocol project.
    IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token);

    // When processing the admin fee, save gas if the admin is using this contract as its terminal.
    if (_terminal == this)
      _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call.
    else {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_terminal), _amount);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;

      // Send the payment.
      _terminal.pay{value: _payableValue}(
        _PROTOCOL_PROJECT_ID,
        _amount,
        token,
        _beneficiary,
        0,
        false,
        '',
        bytes('')
      ); // Use the external pay call of the correct terminal.
    }
  }

  /**
    @notice
    Contribute tokens to a project.

    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _payer The address making the payment.
    @param _projectId The ID of the project being paid.
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function _pay(
    uint256 _amount,
    address _payer,
    uint256 _projectId,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 beneficiaryTokenCount) {
    // Cant send tokens to the zero address.
    if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the payment is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope.
    {
      IJBPayDelegate _delegate;
      uint256 _tokenCount;

      // Bundle the amount info into a JBTokenAmount struct.
      JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);

      // Record the payment.
      (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(
        _payer,
        _bundledAmount,
        _projectId,
        baseWeightCurrency,
        _beneficiary,
        _memo,
        _metadata
      );

      // Mint the tokens if needed.
      if (_tokenCount > 0)
        // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.
        beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(
          _projectId,
          _tokenCount,
          _beneficiary,
          '',
          _preferClaimedTokens,
          true
        );

      // The token count for the beneficiary must be greater than or equal to the minimum expected.
      if (beneficiaryTokenCount < _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBPayDelegate(address(0))) {
        JBDidPayData memory _data = JBDidPayData(
          _payer,
          _projectId,
          _fundingCycle.configuration,
          _bundledAmount,
          beneficiaryTokenCount,
          _beneficiary,
          _preferClaimedTokens,
          _memo,
          _metadata
        );

        _delegate.didPay(_data);
        emit DelegateDidPay(_delegate, _data, msg.sender);
      }
    }

    emit Pay(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _payer,
      _beneficiary,
      _amount,
      beneficiaryTokenCount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function _addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    bool _shouldRefundHeldFees,
    string memory _memo,
    bytes memory _metadata
  ) internal {
    // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.
    uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0;

    // Record the added funds with any refunded fees.
    store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);

    emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);
  }

  /**
    @notice
    Refund fees based on the specified amount.

    @param _projectId The project for which fees are being refunded.
    @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.

    @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal
  */
  function _refundHeldFees(uint256 _projectId, uint256 _amount)
    internal
    returns (uint256 refundedFees)
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the current held fees.
    delete _heldFeesOf[_projectId];

    // Get a reference to the leftover amount once all fees have been settled.
    uint256 leftoverAmount = _amount;

    // Push length in stack
    uint256 _heldFeesLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeesLength; ) {
      if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);
      else if (leftoverAmount >= _heldFees[_i].amount) {
        unchecked {
          leftoverAmount = leftoverAmount - _heldFees[_i].amount;
          refundedFees += _feeAmount(
            _heldFees[_i].amount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount
          );
        }
      } else {
        _heldFeesOf[_projectId].push(
          JBFee(
            _heldFees[_i].amount - leftoverAmount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount,
            _heldFees[_i].beneficiary
          )
        );
        unchecked {
          refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);
        }
        leftoverAmount = 0;
      }

      unchecked {
        ++_i;
      }
    }

    emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);
  }

  /** 
    @notice 
    Returns the fee amount based on the provided amount for the specified project.

    @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal.
    @param _fee The percentage of the fee, out of MAX_FEE. 
    @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.

    @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _feeAmount(
    uint256 _amount,
    uint256 _fee,
    uint256 _feeDiscount
  ) internal pure returns (uint256) {
    // Calculate the discounted fee.
    uint256 _discountedFee = _fee -
      PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT);

    // The amount of tokens from the `_amount` to pay as a fee.
    return
      _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);
  }

  /** 
    @notice
    Get the fee discount from the fee gauge for the specified project.

    @param _projectId The ID of the project to get a fee discount for.
    
    @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.
  */
  function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {
    // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.
    if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))
      return JBConstants.MAX_FEE_DISCOUNT;

    // Get the fee discount.
    if (feeGauge == IJBFeeGauge(address(0)))
      feeDiscount = 0;
      // If the guage reverts, set the discount to 0.
    else
      try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {
        feeDiscount = discount;
      } catch {
        feeDiscount = 0;
      }

    // If the fee discount is greater than the max, nullify the discount.
    if (feeDiscount > JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;
  }
}
.]

Security

[2024-01-09 17:17:40 INFO] **[Seminar Conclusion]**:

 Security

[2024-01-09 17:17:40 INFO] **[Seminar Conclusion]**:

 <INFO> Security

[2024-01-09 17:17:40 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-01-09 17:17:40 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/security/ReentrancyGuard.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './../interfaces/IJBController.sol'; import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol'; import './../libraries/JBConstants.sol'; import './../libraries/JBCurrencies.sol'; import './../libraries/JBFixedPointNumber.sol'; import './../libraries/JBFundingCycleMetadataResolver.sol'; import './../libraries/JBOperations.sol'; import './../libraries/JBSplitsGroups.sol'; import './../libraries/JBTokens.sol'; import './../structs/JBTokenAmount.sol'; import './JBOperatable.sol'; import './JBSingleTokenPaymentTerminal.sol'; /**   @notice   Generic terminal managing all inflows and outflows of funds into the protocol ecosystem. @dev   A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time. @dev   Adheres to -   IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules. @dev   Inherits from -   JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.   JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.   Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.   ReentrancyGuard: Contract module that helps prevent reentrant calls to a function. */ abstract contract JBPayoutRedemptionPaymentTerminal is   IJBPayoutRedemptionPaymentTerminal,   JBSingleTokenPaymentTerminal,   JBOperatable,   Ownable,   ReentrancyGuard {   // A library that parses the packed funding cycle metadata into a friendlier format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error FEE_TOO_HIGH();   error INADEQUATE_DISTRIBUTION_AMOUNT();   error INADEQUATE_RECLAIM_AMOUNT();   error INADEQUATE_TOKEN_COUNT();   error NO_MSG_VALUE_ALLOWED();   error PAY_TO_ZERO_ADDRESS();   error PROJECT_TERMINAL_MISMATCH();   error REDEEM_TO_ZERO_ADDRESS();   error TERMINAL_IN_SPLIT_ZERO_ADDRESS();   error TERMINAL_TOKENS_INCOMPATIBLE(); //***********//   // ---------------------------- modifiers ---------------------------- //   //*************// /*      @notice      A modifier that verifies this terminal is a terminal of provided project ID.   /   modifier isTerminalOf(uint256 projectId) {     if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();     ;   } //***********//   // --------------------- internal stored constants ------------------- //   //*************// /**     @notice     Maximum fee that can be set for a funding cycle configuration. @dev Out of MAX_FEE (50_000_000 / 1_000_000_000).  */   uint256 internal constant _FEE_CAP = 50_000_000; /*     @notice     The protocol project ID is 1, as it should be the first project launched during the deployment process.   /   uint256 internal constant _PROTOCOL_PROJECT_ID = 1; //***********//   // --------------------- internal stored properties ------------------ //   //*************// /**     @notice     Fees that are being held to be processed later. _projectId The ID of the project for which fees are being held.  */   mapping(uint256 =&gt; JBFee[]) internal _heldFeesOf; //***********//   // ---------------- public immutable stored properties --------------- //   //*************// /*     @notice     Mints ERC-721's that represent project ownership and transfers.   /   IJBProjects public immutable override projects; /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; /*     @notice     The contract that stores splits for each project.   /   IJBSplitsStore public immutable override splitsStore; /*     @notice     The contract that exposes price feeds.   /   IJBPrices public immutable override prices; /*     @notice     The contract that stores and manages the terminal's data.   /   IJBSingleTokenPaymentTerminalStore public immutable override store; /**     @notice     The currency to base token issuance on. @dev If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.  */   uint256 public immutable override baseWeightCurrency; /*     @notice     The group that payout splits coming from this terminal are identified by.   /   uint256 public immutable override payoutSplitsGroup; //***********//   // --------------------- public stored properties -------------------- //   //*************// /**     @notice     The platform fee percent. @dev Out of MAX_FEE (25_000_000 / 1_000_000_000)  */   uint256 public override fee = 25_000_000; // 2.5% /*     @notice     The data source that returns a discount to apply to a project's fee.   /   IJBFeeGauge public override feeGauge; /**     @notice     Addresses that can be paid towards from this terminal without incurring a fee. _address The address that can be paid toward.  */   mapping(address =&gt; bool) public override isFeelessAddress; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     Gets the current overflowed amount in this terminal for a specified project, in terms of ETH. @dev The current overflow is represented as a fixed point number with 18 decimals.  @param _projectId The ID of the project to get overflow for.  @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.  */   function currentEthOverflowOf(uint256 _projectId)     external     view     virtual     override     returns (uint256)   {     // Get this terminal's current overflow.     uint256 _overflow = store.currentOverflowOf(this, _projectId); // Adjust the decimals of the fixed point number if needed to have 18 decimals. uint256 _adjustedOverflow = (decimals == 18)   ? _overflow   : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);  // Return the amount converted to ETH. return   (currency == JBCurrencies.ETH)     ? _adjustedOverflow     : PRBMath.mulDiv(       _adjustedOverflow,       10**decimals,       prices.priceFor(currency, JBCurrencies.ETH, decimals)     );  } /**     @notice     The fees that are currently being held to be processed later for each project. @param _projectId The ID of the project for which fees are being held.  @return An array of fees that are being held.  */   function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {     return _heldFeesOf[_projectId];   } //***********//   // -------------------------- public views --------------------------- //   //*************// /**     @notice     Indicates if this contract adheres to the specified interface. @dev  See {IERC165-supportsInterface}.  @param _interfaceId The ID of the interface to check for adherance to.  */   function supportsInterface(bytes4 _interfaceId)     public     view     virtual     override(JBSingleTokenPaymentTerminal, IERC165)     returns (bool)   {     return       _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||       _interfaceId == type(IJBPayoutTerminal).interfaceId ||       _interfaceId == type(IJBAllowanceTerminal).interfaceId ||       _interfaceId == type(IJBRedemptionTerminal).interfaceId ||       _interfaceId == type(IJBOperatable).interfaceId ||       super.supportsInterface(_interfaceId);   } //***********//   // -------------------------- constructor ---------------------------- //   //*************// /*     @param _token The token that this terminal manages.     @param _decimals The number of decimals the token fixed point amounts are expected to have.     @param _currency The currency that this terminal's token adheres to for price feeds.     @param _baseWeightCurrency The currency to base token issuance on.     @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.     @param _operatorStore A contract storing operator assignments.     @param _projects A contract which mints ERC-721's that represent project ownership and transfers.     @param _directory A contract storing directories of terminals and controllers for each project.     @param _splitsStore A contract that stores splits for each project.     @param _prices A contract that exposes price feeds.     @param _store A contract that stores the terminal's data.     @param _owner The address that will own this contract.   /   constructor(     // payable constructor save the gas used to check msg.value==0     address _token,     uint256 _decimals,     uint256 _currency,     uint256 _baseWeightCurrency,     uint256 _payoutSplitsGroup,     IJBOperatorStore _operatorStore,     IJBProjects _projects,     IJBDirectory _directory,     IJBSplitsStore _splitsStore,     IJBPrices _prices,     IJBSingleTokenPaymentTerminalStore _store,     address _owner   )     payable     JBSingleTokenPaymentTerminal(_token, _decimals, _currency)     JBOperatable(_operatorStore)   {     baseWeightCurrency = _baseWeightCurrency;     payoutSplitsGroup = _payoutSplitsGroup;     projects = _projects;     directory = _directory;     splitsStore = _splitsStore;     prices = _prices;     store = _store; transferOwnership(_owner);  } //***********//   // ---------------------- external transactions ---------------------- //   //*************// /**     @notice     Contribute tokens to a project. @param _projectId The ID of the project being paid. @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place. @param _token The token being paid. This terminal ignores this property since it only manages one token.  @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate. @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal. @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas. @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.  */   function pay(     uint256 _projectId,     uint256 _amount,     address _token,     address _beneficiary,     uint256 _minReturnedTokens,     bool _preferClaimedTokens,     string calldata _memo,     bytes calldata _metadata   ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {     _token; // Prevents unused var compiler and natspec complaints. // ETH shouldn't be sent if this terminal's token isn't ETH. if (token != JBTokens.ETH) {   if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();    // Transfer tokens to this terminal from the msg sender.   _transferFrom(msg.sender, payable(address(this)), _amount); } // If this terminal's token is ETH, override _amount with msg.value. else _amount = msg.value;  return   _pay(     _amount,     msg.sender,     _projectId,     _beneficiary,     _minReturnedTokens,     _preferClaimedTokens,     _memo,     _metadata   );  } /**     @notice     Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source. @dev Only a token holder or a designated operator can redeem its tokens.  @param _holder The account to redeem tokens for. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _token The token being reclaimed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal. @param _beneficiary The address to send the terminal tokens to. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.  */   function redeemTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     address _token,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo,     bytes memory _metadata   )     external     virtual     override     requirePermission(_holder, _projectId, JBOperations.REDEEM)     returns (uint256 reclaimAmount)   {     _token; // Prevents unused var compiler and natspec complaints. return   _redeemTokensOf(     _holder,     _projectId,     _tokenCount,     _minReturnedTokens,     _beneficiary,     _memo,     _metadata   );  } /**     @notice     Distributes payouts for a project with the distribution limit of its current funding cycle. @dev Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.  @dev Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.  @dev All funds distributed outside of this contract or any feeless terminals incure the protocol fee.  @param _projectId The ID of the project having its payouts distributed. @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency. @param _token The token being distributed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal. @param _memo A memo to pass along to the emitted event.  @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.  */   function distributePayoutsOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     address _token,     uint256 _minReturnedTokens,     string calldata _memo   ) external virtual override returns (uint256 netLeftoverDistributionAmount) {     _token; // Prevents unused var compiler and natspec complaints. return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);  } /**     @notice     Allows a project to send funds from its overflow up to the preconfigured allowance. @dev Only a project's owner or a designated operator can use its allowance.  @dev Incurs the protocol fee.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency. @param _token The token being distributed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals. @param _beneficiary The address to send the funds to. @param _memo A memo to pass along to the emitted event.  @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.  */   function useAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     address _token,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)     returns (uint256 netDistributedAmount)   {     _token; // Prevents unused var compiler and natspec complaints. return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);  } /**     @notice     Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type. @dev Only a project's owner or a designated operator can migrate it.  @param _projectId The ID of the project being migrated. @param _to The terminal contract that will gain the project's funds.  @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.  */   function migrate(uint256 _projectId, IJBPaymentTerminal _to)     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)     returns (uint256 balance)   {     // The terminal being migrated to must accept the same token as this terminal.     if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE(); // Record the migration in the store. balance = store.recordMigration(_projectId);  // Transfer the balance if needed. if (balance &gt; 0) {   // Trigger any inherited pre-transfer logic.   _beforeTransferTo(address(_to), balance);    // If this terminal's token is ETH, send it in msg.value.   uint256 _payableValue = token == JBTokens.ETH ? balance : 0;    // Withdraw the balance to transfer to the new terminal;   _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes('')); }  emit Migrate(_projectId, _to, balance, msg.sender);  } /**     @notice     Receives funds belonging to the specified project. @param _projectId The ID of the project to which the funds received belong. @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead. @param _token The token being paid. This terminal ignores this property since it only manages one currency.  @param _memo A memo to pass along to the emitted event. @param _metadata Extra data to pass along to the emitted event.  */   function addToBalanceOf(     uint256 _projectId,     uint256 _amount,     address _token,     string calldata _memo,     bytes calldata _metadata   ) external payable virtual override isTerminalOf(_projectId) {     _token; // Prevents unused var compiler and natspec complaints. // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender. if (token != JBTokens.ETH) {   // Amount must be greater than 0.   if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();    // Transfer tokens to this terminal from the msg sender.   _transferFrom(msg.sender, payable(address(this)), _amount); } // If the terminal's token is ETH, override `_amount` with msg.value. else _amount = msg.value;  // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal. _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);  } /**     @notice     Process any fees that are being held for the project. @dev Only a project owner, an operator, or the contract's owner can process held fees.  @param _projectId The ID of the project whos held fees should be processed.  */   function processFees(uint256 _projectId)     external     virtual     override     requirePermissionAllowingOverride(       projects.ownerOf(_projectId),       _projectId,       JBOperations.PROCESS_FEES,       msg.sender == owner()     )   {     // Get a reference to the project's held fees.     JBFee[] memory _heldFees = _heldFeesOf[_projectId]; // Delete the held fees. delete _heldFeesOf[_projectId];  // Push array length in stack uint256 _heldFeeLength = _heldFees.length;  // Process each fee. for (uint256 _i = 0; _i &lt; _heldFeeLength; ) {   // Get the fee amount.   uint256 _amount = _feeAmount(     _heldFees[_i].amount,     _heldFees[_i].fee,     _heldFees[_i].feeDiscount   );    // Process the fee.   _processFee(_amount, _heldFees[_i].beneficiary);    emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);    unchecked {     ++_i;   } }  } /**     @notice     Allows the fee to be updated. @dev Only the owner of this contract can change the fee.  @param _fee The new fee, out of MAX_FEE.  */   function setFee(uint256 _fee) external virtual override onlyOwner {     // The provided fee must be within the max.     if (_fee &gt; _FEE_CAP) revert FEE_TOO_HIGH(); // Store the new fee. fee = _fee;  emit SetFee(_fee, msg.sender);  } /**     @notice     Allows the fee gauge to be updated. @dev Only the owner of this contract can change the fee gauge.  @dev If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.  @param _feeGauge The new fee gauge.  */   function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {     // Store the new fee gauge.     feeGauge = _feeGauge; emit SetFeeGauge(_feeGauge, msg.sender);  } /**     @notice     Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee. @dev Only the owner of this contract can set addresses as feeless.  @param _address The address that can be paid towards while still bypassing fees. @param _flag A flag indicating whether the terminal should be feeless or not.  */   function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {     // Set the flag value.     isFeelessAddress[_address] = _flag; emit SetFeelessAddress(_address, _flag, msg.sender);  } //***********//   // ---------------------- internal transactions ---------------------- //   //*************// /**      @notice     Transfers tokens. @param _from The address from which the transfer should originate. @param _to The address to which the transfer should go. @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.  */   function _transferFrom(     address _from,     address payable _to,     uint256 _amount   ) internal virtual; /**      @notice     Logic to be triggered before transferring tokens from this terminal. @param _to The address to which the transfer is going. @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.  */   function _beforeTransferTo(address _to, uint256 _amount) internal virtual; /**     @notice     Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source. @dev Only a token holder or a designated operator can redeem its tokens.  @param _holder The account to redeem tokens for. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal. @param _beneficiary The address to send the terminal tokens to. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.  */   function _redeemTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo,     bytes memory _metadata   ) internal returns (uint256 reclaimAmount) {     // Can't send reclaimed funds to the zero address.     if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS(); // Define variables that will be needed outside the scoped section below. // Keep a reference to the funding cycle during which the redemption is being made. JBFundingCycle memory _fundingCycle;  // Scoped section prevents stack too deep. `_delegate` only used within scope. {   IJBRedemptionDelegate _delegate;    // Record the redemption.   (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(     _holder,     _projectId,     _tokenCount,     _memo,     _metadata   );    // The amount being reclaimed must be at least as much as was expected.   if (reclaimAmount &lt; _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();    // Burn the project tokens.   if (_tokenCount &gt; 0)     IJBController(directory.controllerOf(_projectId)).burnTokensOf(       _holder,       _projectId,       _tokenCount,       '',       false     );    // If a delegate was returned by the data source, issue a callback to it.   if (_delegate != IJBRedemptionDelegate(address(0))) {     JBDidRedeemData memory _data = JBDidRedeemData(       _holder,       _projectId,       _fundingCycle.configuration,       _tokenCount,       JBTokenAmount(token, reclaimAmount, decimals, currency),       _beneficiary,       _memo,       _metadata     );     _delegate.didRedeem(_data);     emit DelegateDidRedeem(_delegate, _data, msg.sender);   } }  // Send the reclaimed funds to the beneficiary. if (reclaimAmount &gt; 0) _transferFrom(address(this), _beneficiary, reclaimAmount);  emit RedeemTokens(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _holder,   _beneficiary,   _tokenCount,   reclaimAmount,   _memo,   _metadata,   msg.sender );  } /**     @notice     Distributes payouts for a project with the distribution limit of its current funding cycle. @dev Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.  @dev Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.  @dev All funds distributed outside of this contract or any feeless terminals incure the protocol fee.  @param _projectId The ID of the project having its payouts distributed. @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency. @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal. @param _memo A memo to pass along to the emitted event.  @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.  */   function _distributePayoutsOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     uint256 _minReturnedTokens,     string calldata _memo   ) internal returns (uint256 netLeftoverDistributionAmount) {     // Record the distribution.     (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(       _projectId,       _amount,       _currency     ); // The amount being distributed must be at least as much as was expected. if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();  // Get a reference to the project owner, which will receive tokens from paying the platform fee // and receive any extra distributable funds not allocated to payout splits. address payable _projectOwner = payable(projects.ownerOf(_projectId));  // Define variables that will be needed outside the scoped section below. // Keep a reference to the fee amount that was paid. uint256 _fee;  // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope. {   // Get the amount of discount that should be applied to any fees taken.   // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.   uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]     ? JBConstants.MAX_FEE_DISCOUNT     : _currentFeeDiscount(_projectId);    // The amount distributed that is eligible for incurring fees.   uint256 _feeEligibleDistributionAmount;    // The amount leftover after distributing to the splits.   uint256 _leftoverDistributionAmount;    // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.   // Also get a reference to the amount that was distributed to splits from which fees should be taken.   (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(     _projectId,     _fundingCycle.configuration,     payoutSplitsGroup,     _distributedAmount,     _feeDiscount   );    // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.   unchecked {     _feeEligibleDistributionAmount += _leftoverDistributionAmount;   }    // Take the fee.   _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0     ? 0     : _takeFeeFrom(       _projectId,       _fundingCycle,       _feeEligibleDistributionAmount,       _projectOwner,       _feeDiscount     );    // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.    unchecked {     netLeftoverDistributionAmount = _leftoverDistributionAmount == 0       ? 0       : _leftoverDistributionAmount -         _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);   }    // Transfer any remaining balance to the project owner.   if (netLeftoverDistributionAmount &gt; 0)     _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount); }  emit DistributePayouts(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _projectOwner,   _amount,   _distributedAmount,   _fee,   netLeftoverDistributionAmount,   _memo,   msg.sender );  } /**     @notice     Allows a project to send funds from its overflow up to the preconfigured allowance. @dev Only a project's owner or a designated operator can use its allowance.  @dev Incurs the protocol fee.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency. @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals. @param _beneficiary The address to send the funds to. @param _memo A memo to pass along to the emitted event.  @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.  */   function _useAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo   ) internal returns (uint256 netDistributedAmount) {     // Record the use of the allowance.     (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(       _projectId,       _amount,       _currency     ); // The amount being withdrawn must be at least as much as was expected. if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();  // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope. {   // Keep a reference to the fee amount that was paid.   uint256 _fee;    // Get a reference to the project owner, which will receive tokens from paying the platform fee.   address _projectOwner = projects.ownerOf(_projectId);    // Get the amount of discount that should be applied to any fees taken.   // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.   uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]     ? JBConstants.MAX_FEE_DISCOUNT     : _currentFeeDiscount(_projectId);    // Take a fee from the `_distributedAmount`, if needed.   _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT     ? 0     : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);    unchecked {     // The net amount is the withdrawn amount without the fee.     netDistributedAmount = _distributedAmount - _fee;   }    // Transfer any remaining balance to the beneficiary.   if (netDistributedAmount &gt; 0)     _transferFrom(address(this), _beneficiary, netDistributedAmount); }  emit UseAllowance(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _beneficiary,   _amount,   _distributedAmount,   netDistributedAmount,   _memo,   msg.sender );  } /**     @notice     Pays out splits for a project's funding cycle configuration. @param _projectId The ID of the project for which payout splits are being distributed. @param _domain The domain of the splits to distribute the payout between. @param _group The group of the splits to distribute the payout between. @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal. @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.  @return leftoverAmount If the leftover amount if the splits don't add up to 100%. @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.  */   function _distributeToPayoutSplitsOf(     uint256 _projectId,     uint256 _domain,     uint256 _group,     uint256 _amount,     uint256 _feeDiscount   ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {     // Set the leftover amount to the initial amount.     leftoverAmount = _amount; // Get a reference to the project's payout splits. JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);  // Transfer between all splits. for (uint256 _i = 0; _i &lt; _splits.length; ) {   // Get a reference to the split being iterated on.   JBSplit memory _split = _splits[_i];    // The amount to send towards the split.   uint256 _payoutAmount = PRBMath.mulDiv(     _amount,     _split.percent,     JBConstants.SPLITS_TOTAL_PERCENT   );    // The payout amount substracting any applicable incurred fees.   uint256 _netPayoutAmount;    if (_payoutAmount &gt; 0) {     // Transfer tokens to the split.     // If there's an allocator set, transfer to its `allocate` function.     if (_split.allocator != IJBSplitAllocator(address(0))) {       // If the split allocator is set as feeless, this distribution is not eligible for a fee.       if (isFeelessAddress[address(_split.allocator)])         _netPayoutAmount = _payoutAmount;         // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.       else {         unchecked {           _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT             ? _payoutAmount             : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);         }          // This distribution is eligible for a fee since the funds are leaving the ecosystem.         feeEligibleDistributionAmount += _payoutAmount;       }        // Trigger any inherited pre-transfer logic.       _beforeTransferTo(address(_split.allocator), _netPayoutAmount);        // If this terminal's token is ETH, send it in msg.value.       uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;        // Create the data to send to the allocator.       JBSplitAllocationData memory _data = JBSplitAllocationData(         token,         _netPayoutAmount,         decimals,         _projectId,         _group,         _split       );        // Trigger the allocator's `allocate` function.       _split.allocator.allocate{value: _payableValue}(_data);        // Otherwise, if a project is specified, make a payment to it.     } else if (_split.projectId != 0) {       // Get a reference to the Juicebox terminal being used.       IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);        // The project must have a terminal to send funds to.       if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();        // Save gas if this contract is being used as the terminal.       if (_terminal == this) {         // This distribution does not incur a fee.         _netPayoutAmount = _payoutAmount;          // Send the projectId in the metadata.         bytes memory _projectMetadata = new bytes(32);         _projectMetadata = bytes(abi.encodePacked(_projectId));          // Add to balance if prefered.         if (_split.preferAddToBalance)           _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);         else           _pay(             _netPayoutAmount,             address(this),             _split.projectId,             (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,             0,             _split.preferClaimed,             '',             _projectMetadata           );       } else {         // If the terminal is set as feeless, this distribution is not eligible for a fee.         if (isFeelessAddress[address(_terminal)])           _netPayoutAmount = _payoutAmount;           // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.         else {           unchecked {             _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT               ? _payoutAmount               : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);           }            feeEligibleDistributionAmount += _payoutAmount;         }          // Trigger any inherited pre-transfer logic.         _beforeTransferTo(address(_terminal), _netPayoutAmount);          // If this terminal's token is ETH, send it in msg.value.         uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;          // Send the projectId in the metadata.         bytes memory _projectMetadata = new bytes(32);         _projectMetadata = bytes(abi.encodePacked(_projectId));          // Add to balance if prefered.         if (_split.preferAddToBalance)           _terminal.addToBalanceOf{value: _payableValue}(             _split.projectId,             _netPayoutAmount,             token,             '',             _projectMetadata           );         else           _terminal.pay{value: _payableValue}(             _split.projectId,             _netPayoutAmount,             token,             _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,             0,             _split.preferClaimed,             '',             _projectMetadata           );       }     } else {       unchecked {         _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT           ? _payoutAmount           : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);       }        // This distribution is eligible for a fee since the funds are leaving the ecosystem.       feeEligibleDistributionAmount += _payoutAmount;        // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.       _transferFrom(         address(this),         _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),         _netPayoutAmount       );     }      // Subtract from the amount to be sent to the beneficiary.     unchecked {       leftoverAmount = leftoverAmount - _payoutAmount;     }   }    emit DistributeToPayoutSplit(     _projectId,     _domain,     _group,     _split,     _netPayoutAmount,     msg.sender   );    unchecked {     ++_i;   } }  } /**     @notice     Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID. @param _projectId The ID of the project having fees taken from. @param _fundingCycle The funding cycle during which the fee is being taken. @param _amount The amount of the fee to take, as a floating point number with 18 decimals. @param _beneficiary The address to mint the platforms tokens for. @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.  @return feeAmount The amount of the fee taken.  */   function _takeFeeFrom(     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _amount,     address _beneficiary,     uint256 _feeDiscount   ) internal returns (uint256 feeAmount) {     feeAmount = _feeAmount(_amount, fee, _feeDiscount); if (_fundingCycle.shouldHoldFees()) {   // Store the held fee.   _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));    emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender); } else {   // Process the fee.   _processFee(feeAmount, _beneficiary); // Take the fee.    emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender); }  } /**     @notice     Process a fee of the specified amount. @param _amount The fee amount, as a floating point number with 18 decimals. @param _beneficiary The address to mint the platform's tokens for.  */   function _processFee(uint256 _amount, address _beneficiary) internal {     // Get the terminal for the protocol project.     IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token); // When processing the admin fee, save gas if the admin is using this contract as its terminal. if (_terminal == this)   _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call. else {   // Trigger any inherited pre-transfer logic.   _beforeTransferTo(address(_terminal), _amount);    // If this terminal's token is ETH, send it in msg.value.   uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;    // Send the payment.   _terminal.pay{value: _payableValue}(     _PROTOCOL_PROJECT_ID,     _amount,     token,     _beneficiary,     0,     false,     '',     bytes('')   ); // Use the external pay call of the correct terminal. }  } /**     @notice     Contribute tokens to a project. @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place. @param _payer The address making the payment. @param _projectId The ID of the project being paid. @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate. @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal. @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas. @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.  */   function _pay(     uint256 _amount,     address _payer,     uint256 _projectId,     address _beneficiary,     uint256 _minReturnedTokens,     bool _preferClaimedTokens,     string memory _memo,     bytes memory _metadata   ) internal returns (uint256 beneficiaryTokenCount) {     // Cant send tokens to the zero address.     if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS(); // Define variables that will be needed outside the scoped section below. // Keep a reference to the funding cycle during which the payment is being made. JBFundingCycle memory _fundingCycle;  // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope. {   IJBPayDelegate _delegate;   uint256 _tokenCount;    // Bundle the amount info into a JBTokenAmount struct.   JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);    // Record the payment.   (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(     _payer,     _bundledAmount,     _projectId,     baseWeightCurrency,     _beneficiary,     _memo,     _metadata   );    // Mint the tokens if needed.   if (_tokenCount &gt; 0)     // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.     beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(       _projectId,       _tokenCount,       _beneficiary,       '',       _preferClaimedTokens,       true     );    // The token count for the beneficiary must be greater than or equal to the minimum expected.   if (beneficiaryTokenCount &lt; _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();    // If a delegate was returned by the data source, issue a callback to it.   if (_delegate != IJBPayDelegate(address(0))) {     JBDidPayData memory _data = JBDidPayData(       _payer,       _projectId,       _fundingCycle.configuration,       _bundledAmount,       beneficiaryTokenCount,       _beneficiary,       _preferClaimedTokens,       _memo,       _metadata     );      _delegate.didPay(_data);     emit DelegateDidPay(_delegate, _data, msg.sender);   } }  emit Pay(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _payer,   _beneficiary,   _amount,   beneficiaryTokenCount,   _memo,   _metadata,   msg.sender );  } /**     @notice     Receives funds belonging to the specified project. @param _projectId The ID of the project to which the funds received belong. @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead. @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added. @param _memo A memo to pass along to the emitted event. @param _metadata Extra data to pass along to the emitted event.  */   function _addToBalanceOf(     uint256 _projectId,     uint256 _amount,     bool _shouldRefundHeldFees,     string memory _memo,     bytes memory _metadata   ) internal {     // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.     uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0; // Record the added funds with any refunded fees. store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);  emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);  } /**     @notice     Refund fees based on the specified amount. @param _projectId The project for which fees are being refunded. @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.  @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal  */   function _refundHeldFees(uint256 _projectId, uint256 _amount)     internal     returns (uint256 refundedFees)   {     // Get a reference to the project's held fees.     JBFee[] memory _heldFees = _heldFeesOf[_projectId]; // Delete the current held fees. delete _heldFeesOf[_projectId];  // Get a reference to the leftover amount once all fees have been settled. uint256 leftoverAmount = _amount;  // Push length in stack uint256 _heldFeesLength = _heldFees.length;  // Process each fee. for (uint256 _i = 0; _i &lt; _heldFeesLength; ) {   if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);   else if (leftoverAmount &gt;= _heldFees[_i].amount) {     unchecked {       leftoverAmount = leftoverAmount - _heldFees[_i].amount;       refundedFees += _feeAmount(         _heldFees[_i].amount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount       );     }   } else {     _heldFeesOf[_projectId].push(       JBFee(         _heldFees[_i].amount - leftoverAmount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount,         _heldFees[_i].beneficiary       )     );     unchecked {       refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);     }     leftoverAmount = 0;   }    unchecked {     ++_i;   } }  emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);  } /**      @notice      Returns the fee amount based on the provided amount for the specified project. @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal. @param _fee The percentage of the fee, out of MAX_FEE.  @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.  @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.  */   function _feeAmount(     uint256 _amount,     uint256 _fee,     uint256 _feeDiscount   ) internal pure returns (uint256) {     // Calculate the discounted fee.     uint256 _discountedFee = _fee -       PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT); // The amount of tokens from the `_amount` to pay as a fee. return   _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);  } /**      @notice     Get the fee discount from the fee gauge for the specified project. @param _projectId The ID of the project to get a fee discount for.  @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.  */   function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {     // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.     if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))       return JBConstants.MAX_FEE_DISCOUNT; // Get the fee discount. if (feeGauge == IJBFeeGauge(address(0)))   feeDiscount = 0;   // If the guage reverts, set the discount to 0. else   try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {     feeDiscount = discount;   } catch {     feeDiscount = 0;   }  // If the fee discount is greater than the max, nullify the discount. if (feeDiscount &gt; JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;  } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@paulrberg/contracts/math/PRBMath.sol';\nimport './../interfaces/IJBController.sol';\nimport './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol';\nimport './../libraries/JBConstants.sol';\nimport './../libraries/JBCurrencies.sol';\nimport './../libraries/JBFixedPointNumber.sol';\nimport './../libraries/JBFundingCycleMetadataResolver.sol';\nimport './../libraries/JBOperations.sol';\nimport './../libraries/JBSplitsGroups.sol';\nimport './../libraries/JBTokens.sol';\nimport './../structs/JBTokenAmount.sol';\nimport './JBOperatable.sol';\nimport './JBSingleTokenPaymentTerminal.sol';\n\n/\n  @notice\n  Generic terminal managing all inflows and outflows of funds into the protocol ecosystem.\n\n  @dev\n  A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time.\n\n  @dev\n  Adheres to -\n  IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.\n\n  @dev\n  Inherits from -\n  JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.\n  JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.\n  Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.\n  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.\n/\nabstract contract JBPayoutRedemptionPaymentTerminal is\n  IJBPayoutRedemptionPaymentTerminal,\n  JBSingleTokenPaymentTerminal,\n  JBOperatable,\n  Ownable,\n  ReentrancyGuard\n{\n  // A library that parses the packed funding cycle metadata into a friendlier format.\n  using JBFundingCycleMetadataResolver for JBFundingCycle;\n\n  //*********//\n  // --------------------------- custom errors ------------------------- //\n  //*********//\n  error FEE_TOO_HIGH();\n  error INADEQUATE_DISTRIBUTION_AMOUNT();\n  error INADEQUATE_RECLAIM_AMOUNT();\n  error INADEQUATE_TOKEN_COUNT();\n  error NO_MSG_VALUE_ALLOWED();\n  error PAY_TO_ZERO_ADDRESS();\n  error PROJECT_TERMINAL_MISMATCH();\n  error REDEEM_TO_ZERO_ADDRESS();\n  error TERMINAL_IN_SPLIT_ZERO_ADDRESS();\n  error TERMINAL_TOKENS_INCOMPATIBLE();\n\n  //*********//\n  // ---------------------------- modifiers ---------------------------- //\n  //*********//\n\n  / \n    @notice \n    A modifier that verifies this terminal is a terminal of provided project ID.\n  /\n  modifier isTerminalOf(uint256 projectId) {\n    if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();\n    ;\n  }\n\n  //**********//\n  // --------------------- internal stored constants ------------------- //\n  //*********//\n\n  /\n    @notice\n    Maximum fee that can be set for a funding cycle configuration.\n\n    @dev\n    Out of MAX_FEE (50_000_000 / 1_000_000_000).\n  /\n  uint256 internal constant _FEE_CAP = 50_000_000;\n\n  /\n    @notice\n    The protocol project ID is 1, as it should be the first project launched during the deployment process.\n  /\n  uint256 internal constant _PROTOCOL_PROJECT_ID = 1;\n\n  //**********//\n  // --------------------- internal stored properties ------------------ //\n  //**********//\n\n  /\n    @notice\n    Fees that are being held to be processed later.\n\n    _projectId The ID of the project for which fees are being held.\n  /\n  mapping(uint256 =&gt; JBFee[]) internal _heldFeesOf;\n\n  //**********//\n  // ---------------- public immutable stored properties --------------- //\n  //*********//\n\n  /\n    @notice\n    Mints ERC-721's that represent project ownership and transfers.\n  /\n  IJBProjects public immutable override projects;\n\n  /\n    @notice\n    The directory of terminals and controllers for projects.\n  /\n  IJBDirectory public immutable override directory;\n\n  /\n    @notice\n    The contract that stores splits for each project.\n  /\n  IJBSplitsStore public immutable override splitsStore;\n\n  /\n    @notice\n    The contract that exposes price feeds.\n  /\n  IJBPrices public immutable override prices;\n\n  /\n    @notice\n    The contract that stores and manages the terminal's data.\n  */\n  IJBSingleTokenPaymentTerminalStore public immutable override store;\n\n  /\n    @notice\n    The currency to base token issuance on.\n\n    @dev\n    If this differs from currency, there must be a price feed available to convert currency to baseWeightCurrency.\n  /\n  uint256 public immutable override baseWeightCurrency;\n\n  /\n    @notice\n    The group that payout splits coming from this terminal are identified by.\n  /\n  uint256 public immutable override payoutSplitsGroup;\n\n  //*********//\n  // --------------------- public stored properties -------------------- //\n  //*********//\n\n  /\n    @notice\n    The platform fee percent.\n\n    @dev\n    Out of MAX_FEE (25_000_000 / 1_000_000_000)\n  /\n  uint256 public override fee = 25_000_000; // 2.5%\n\n  /\n    @notice\n    The data source that returns a discount to apply to a project's fee.\n  /\n  IJBFeeGauge public override feeGauge;\n\n  /\n    @notice\n    Addresses that can be paid towards from this terminal without incurring a fee.\n\n    _address The address that can be paid toward.\n  /\n  mapping(address =&gt; bool) public override isFeelessAddress;\n\n  //***********//\n  // ------------------------- external views -------------------------- //\n  //**********//\n\n  /\n    @notice\n    Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.\n\n    @dev\n    The current overflow is represented as a fixed point number with 18 decimals.\n\n    @param _projectId The ID of the project to get overflow for.\n\n    @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.\n  /\n  function currentEthOverflowOf(uint256 _projectId)\n    external\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    // Get this terminal's current overflow.\n    uint256 _overflow = store.currentOverflowOf(this, _projectId);\n\n    // Adjust the decimals of the fixed point number if needed to have 18 decimals.\n    uint256 _adjustedOverflow = (decimals == 18)\n      ? _overflow\n      : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);\n\n    // Return the amount converted to ETH.\n    return\n      (currency == JBCurrencies.ETH)\n        ? _adjustedOverflow\n        : PRBMath.mulDiv(\n          _adjustedOverflow,\n          10decimals,\n          prices.priceFor(currency, JBCurrencies.ETH, decimals)\n        );\n  }\n\n  /\n    @notice\n    The fees that are currently being held to be processed later for each project.\n\n    @param _projectId The ID of the project for which fees are being held.\n\n    @return An array of fees that are being held.\n  /\n  function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {\n    return _heldFeesOf[_projectId];\n  }\n\n  //*********//\n  // -------------------------- public views --------------------------- //\n  //*********//\n\n  /\n    @notice\n    Indicates if this contract adheres to the specified interface.\n\n    @dev \n    See {IERC165-supportsInterface}.\n\n    @param _interfaceId The ID of the interface to check for adherance to.\n  /\n  function supportsInterface(bytes4 _interfaceId)\n    public\n    view\n    virtual\n    override(JBSingleTokenPaymentTerminal, IERC165)\n    returns (bool)\n  {\n    return\n      _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||\n      _interfaceId == type(IJBPayoutTerminal).interfaceId ||\n      _interfaceId == type(IJBAllowanceTerminal).interfaceId ||\n      _interfaceId == type(IJBRedemptionTerminal).interfaceId ||\n      _interfaceId == type(IJBOperatable).interfaceId ||\n      super.supportsInterface(_interfaceId);\n  }\n\n  //**********//\n  // -------------------------- constructor ---------------------------- //\n  //*********//\n\n  /\n    @param _token The token that this terminal manages.\n    @param _decimals The number of decimals the token fixed point amounts are expected to have.\n    @param _currency The currency that this terminal's token adheres to for price feeds.\n    @param _baseWeightCurrency The currency to base token issuance on.\n    @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.\n    @param _operatorStore A contract storing operator assignments.\n    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.\n    @param _directory A contract storing directories of terminals and controllers for each project.\n    @param _splitsStore A contract that stores splits for each project.\n    @param _prices A contract that exposes price feeds.\n    @param _store A contract that stores the terminal's data.\n    @param _owner The address that will own this contract.\n  /\n  constructor(\n    // payable constructor save the gas used to check msg.value==0\n    address _token,\n    uint256 _decimals,\n    uint256 _currency,\n    uint256 _baseWeightCurrency,\n    uint256 _payoutSplitsGroup,\n    IJBOperatorStore _operatorStore,\n    IJBProjects _projects,\n    IJBDirectory _directory,\n    IJBSplitsStore _splitsStore,\n    IJBPrices _prices,\n    IJBSingleTokenPaymentTerminalStore _store,\n    address _owner\n  )\n    payable\n    JBSingleTokenPaymentTerminal(_token, _decimals, _currency)\n    JBOperatable(_operatorStore)\n  {\n    baseWeightCurrency = _baseWeightCurrency;\n    payoutSplitsGroup = _payoutSplitsGroup;\n    projects = _projects;\n    directory = _directory;\n    splitsStore = _splitsStore;\n    prices = _prices;\n    store = _store;\n\n    transferOwnership(_owner);\n  }\n\n  //**********//\n  // ---------------------- external transactions ---------------------- //\n  //*********//\n\n  /\n    @notice\n    Contribute tokens to a project.\n\n    @param _projectId The ID of the project being paid.\n    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.\n    @param _token The token being paid. This terminal ignores this property since it only manages one token. \n    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.\n    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.\n    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.\n    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.\n    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.\n\n    @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.\n  /\n  function pay(\n    uint256 _projectId,\n    uint256 _amount,\n    address _token,\n    address _beneficiary,\n    uint256 _minReturnedTokens,\n    bool _preferClaimedTokens,\n    string calldata _memo,\n    bytes calldata _metadata\n  ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {\n    _token; // Prevents unused var compiler and natspec complaints.\n\n    // ETH shouldn't be sent if this terminal's token isn't ETH.\n    if (token != JBTokens.ETH) {\n      if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();\n\n      // Transfer tokens to this terminal from the msg sender.\n      _transferFrom(msg.sender, payable(address(this)), _amount);\n    }\n    // If this terminal's token is ETH, override _amount with msg.value.\n    else _amount = msg.value;\n\n    return\n      _pay(\n        _amount,\n        msg.sender,\n        _projectId,\n        _beneficiary,\n        _minReturnedTokens,\n        _preferClaimedTokens,\n        _memo,\n        _metadata\n      );\n  }\n\n  /\n    @notice\n    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.\n\n    @dev\n    Only a token holder or a designated operator can redeem its tokens.\n\n    @param _holder The account to redeem tokens for.\n    @param _projectId The ID of the project to which the tokens being redeemed belong.\n    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.\n    @param _token The token being reclaimed. This terminal ignores this property since it only manages one token. \n    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.\n    @param _beneficiary The address to send the terminal tokens to.\n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.\n\n    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.\n  /\n  function redeemTokensOf(\n    address _holder,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    address _token,\n    uint256 _minReturnedTokens,\n    address payable _beneficiary,\n    string memory _memo,\n    bytes memory _metadata\n  )\n    external\n    virtual\n    override\n    requirePermission(_holder, _projectId, JBOperations.REDEEM)\n    returns (uint256 reclaimAmount)\n  {\n    _token; // Prevents unused var compiler and natspec complaints.\n\n    return\n      _redeemTokensOf(\n        _holder,\n        _projectId,\n        _tokenCount,\n        _minReturnedTokens,\n        _beneficiary,\n        _memo,\n        _metadata\n      );\n  }\n\n  /\n    @notice\n    Distributes payouts for a project with the distribution limit of its current funding cycle.\n\n    @dev\n    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.\n\n    @dev\n    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.\n\n    @dev\n    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.\n\n    @param _projectId The ID of the project having its payouts distributed.\n    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.\n    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.\n    @param _token The token being distributed. This terminal ignores this property since it only manages one token. \n    @param _minReturnedTokens The minimum number of terminal tokens that the _amount should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.\n  /\n  function distributePayoutsOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency,\n    address _token,\n    uint256 _minReturnedTokens,\n    string calldata _memo\n  ) external virtual override returns (uint256 netLeftoverDistributionAmount) {\n    _token; // Prevents unused var compiler and natspec complaints.\n\n    return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);\n  }\n\n  /\n    @notice\n    Allows a project to send funds from its overflow up to the preconfigured allowance.\n\n    @dev\n    Only a project's owner or a designated operator can use its allowance.\n\n    @dev\n    Incurs the protocol fee.\n\n    @param _projectId The ID of the project to use the allowance of.\n    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.\n    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.\n    @param _token The token being distributed. This terminal ignores this property since it only manages one token. \n    @param _minReturnedTokens The minimum number of tokens that the _amount should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.\n    @param _beneficiary The address to send the funds to.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.\n  /\n  function useAllowanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency,\n    address _token,\n    uint256 _minReturnedTokens,\n    address payable _beneficiary,\n    string memory _memo\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)\n    returns (uint256 netDistributedAmount)\n  {\n    _token; // Prevents unused var compiler and natspec complaints.\n\n    return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);\n  }\n\n  /\n    @notice\n    Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.\n\n    @dev\n    Only a project's owner or a designated operator can migrate it.\n\n    @param _projectId The ID of the project being migrated.\n    @param _to The terminal contract that will gain the project's funds.\n\n    @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.\n  */\n  function migrate(uint256 _projectId, IJBPaymentTerminal _to)\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)\n    returns (uint256 balance)\n  {\n    // The terminal being migrated to must accept the same token as this terminal.\n    if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE();\n\n    // Record the migration in the store.\n    balance = store.recordMigration(_projectId);\n\n    // Transfer the balance if needed.\n    if (balance &gt; 0) {\n      // Trigger any inherited pre-transfer logic.\n      _beforeTransferTo(address(_to), balance);\n\n      // If this terminal's token is ETH, send it in msg.value.\n      uint256 _payableValue = token == JBTokens.ETH ? balance : 0;\n\n      // Withdraw the balance to transfer to the new terminal;\n      _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes(''));\n    }\n\n    emit Migrate(_projectId, _to, balance, msg.sender);\n  }\n\n  /\n    @notice\n    Receives funds belonging to the specified project.\n\n    @param _projectId The ID of the project to which the funds received belong.\n    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.\n    @param _token The token being paid. This terminal ignores this property since it only manages one currency. \n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Extra data to pass along to the emitted event.\n  /\n  function addToBalanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    address _token,\n    string calldata _memo,\n    bytes calldata _metadata\n  ) external payable virtual override isTerminalOf(_projectId) {\n    _token; // Prevents unused var compiler and natspec complaints.\n\n    // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender.\n    if (token != JBTokens.ETH) {\n      // Amount must be greater than 0.\n      if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();\n\n      // Transfer tokens to this terminal from the msg sender.\n      _transferFrom(msg.sender, payable(address(this)), _amount);\n    }\n    // If the terminal's token is ETH, override _amount with msg.value.\n    else _amount = msg.value;\n\n    // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal.\n    _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);\n  }\n\n  /\n    @notice\n    Process any fees that are being held for the project.\n\n    @dev\n    Only a project owner, an operator, or the contract's owner can process held fees.\n\n    @param _projectId The ID of the project whos held fees should be processed.\n  /\n  function processFees(uint256 _projectId)\n    external\n    virtual\n    override\n    requirePermissionAllowingOverride(\n      projects.ownerOf(_projectId),\n      _projectId,\n      JBOperations.PROCESS_FEES,\n      msg.sender == owner()\n    )\n  {\n    // Get a reference to the project's held fees.\n    JBFee[] memory _heldFees = _heldFeesOf[_projectId];\n\n    // Delete the held fees.\n    delete _heldFeesOf[_projectId];\n\n    // Push array length in stack\n    uint256 _heldFeeLength = _heldFees.length;\n\n    // Process each fee.\n    for (uint256 _i = 0; _i &lt; _heldFeeLength; ) {\n      // Get the fee amount.\n      uint256 _amount = _feeAmount(\n        _heldFees[_i].amount,\n        _heldFees[_i].fee,\n        _heldFees[_i].feeDiscount\n      );\n\n      // Process the fee.\n      _processFee(_amount, _heldFees[_i].beneficiary);\n\n      emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /\n    @notice\n    Allows the fee to be updated.\n\n    @dev\n    Only the owner of this contract can change the fee.\n\n    @param _fee The new fee, out of MAX_FEE.\n  */\n  function setFee(uint256 _fee) external virtual override onlyOwner {\n    // The provided fee must be within the max.\n    if (_fee &gt; _FEE_CAP) revert FEE_TOO_HIGH();\n\n    // Store the new fee.\n    fee = _fee;\n\n    emit SetFee(_fee, msg.sender);\n  }\n\n  /\n    @notice\n    Allows the fee gauge to be updated.\n\n    @dev\n    Only the owner of this contract can change the fee gauge.\n\n    @dev\n    If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.\n\n    @param _feeGauge The new fee gauge.\n  /\n  function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {\n    // Store the new fee gauge.\n    feeGauge = _feeGauge;\n\n    emit SetFeeGauge(_feeGauge, msg.sender);\n  }\n\n  /\n    @notice\n    Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.\n\n    @dev\n    Only the owner of this contract can set addresses as feeless.\n\n    @param _address The address that can be paid towards while still bypassing fees.\n    @param _flag A flag indicating whether the terminal should be feeless or not.\n  /\n  function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {\n    // Set the flag value.\n    isFeelessAddress[_address] = _flag;\n\n    emit SetFeelessAddress(_address, _flag, msg.sender);\n  }\n\n  //*********//\n  // ---------------------- internal transactions ---------------------- //\n  //*********//\n\n  / \n    @notice\n    Transfers tokens.\n\n    @param _from The address from which the transfer should originate.\n    @param _to The address to which the transfer should go.\n    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.\n  /\n  function _transferFrom(\n    address _from,\n    address payable _to,\n    uint256 _amount\n  ) internal virtual;\n\n  / \n    @notice\n    Logic to be triggered before transferring tokens from this terminal.\n\n    @param _to The address to which the transfer is going.\n    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.\n  /\n  function _beforeTransferTo(address _to, uint256 _amount) internal virtual;\n\n  /\n    @notice\n    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.\n\n    @dev\n    Only a token holder or a designated operator can redeem its tokens.\n\n    @param _holder The account to redeem tokens for.\n    @param _projectId The ID of the project to which the tokens being redeemed belong.\n    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.\n    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.\n    @param _beneficiary The address to send the terminal tokens to.\n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.\n\n    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.\n  /\n  function _redeemTokensOf(\n    address _holder,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    uint256 _minReturnedTokens,\n    address payable _beneficiary,\n    string memory _memo,\n    bytes memory _metadata\n  ) internal returns (uint256 reclaimAmount) {\n    // Can't send reclaimed funds to the zero address.\n    if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS();\n\n    // Define variables that will be needed outside the scoped section below.\n    // Keep a reference to the funding cycle during which the redemption is being made.\n    JBFundingCycle memory _fundingCycle;\n\n    // Scoped section prevents stack too deep. _delegate only used within scope.\n    {\n      IJBRedemptionDelegate _delegate;\n\n      // Record the redemption.\n      (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(\n        _holder,\n        _projectId,\n        _tokenCount,\n        _memo,\n        _metadata\n      );\n\n      // The amount being reclaimed must be at least as much as was expected.\n      if (reclaimAmount &lt; _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();\n\n      // Burn the project tokens.\n      if (_tokenCount &gt; 0)\n        IJBController(directory.controllerOf(_projectId)).burnTokensOf(\n          _holder,\n          _projectId,\n          _tokenCount,\n          '',\n          false\n        );\n\n      // If a delegate was returned by the data source, issue a callback to it.\n      if (_delegate != IJBRedemptionDelegate(address(0))) {\n        JBDidRedeemData memory _data = JBDidRedeemData(\n          _holder,\n          _projectId,\n          _fundingCycle.configuration,\n          _tokenCount,\n          JBTokenAmount(token, reclaimAmount, decimals, currency),\n          _beneficiary,\n          _memo,\n          _metadata\n        );\n        _delegate.didRedeem(_data);\n        emit DelegateDidRedeem(_delegate, _data, msg.sender);\n      }\n    }\n\n    // Send the reclaimed funds to the beneficiary.\n    if (reclaimAmount &gt; 0) _transferFrom(address(this), _beneficiary, reclaimAmount);\n\n    emit RedeemTokens(\n      _fundingCycle.configuration,\n      _fundingCycle.number,\n      _projectId,\n      _holder,\n      _beneficiary,\n      _tokenCount,\n      reclaimAmount,\n      _memo,\n      _metadata,\n      msg.sender\n    );\n  }\n\n  /\n    @notice\n    Distributes payouts for a project with the distribution limit of its current funding cycle.\n\n    @dev\n    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.\n\n    @dev\n    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.\n\n    @dev\n    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.\n\n    @param _projectId The ID of the project having its payouts distributed.\n    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.\n    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.\n    @param _minReturnedTokens The minimum number of terminal tokens that the _amount should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.\n  */\n  function _distributePayoutsOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency,\n    uint256 _minReturnedTokens,\n    string calldata _memo\n  ) internal returns (uint256 netLeftoverDistributionAmount) {\n    // Record the distribution.\n    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(\n      _projectId,\n      _amount,\n      _currency\n    );\n\n    // The amount being distributed must be at least as much as was expected.\n    if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();\n\n    // Get a reference to the project owner, which will receive tokens from paying the platform fee\n    // and receive any extra distributable funds not allocated to payout splits.\n    address payable _projectOwner = payable(projects.ownerOf(_projectId));\n\n    // Define variables that will be needed outside the scoped section below.\n    // Keep a reference to the fee amount that was paid.\n    uint256 _fee;\n\n    // Scoped section prevents stack too deep. _feeDiscount, _feeEligibleDistributionAmount, and _leftoverDistributionAmount only used within scope.\n    {\n      // Get the amount of discount that should be applied to any fees taken.\n      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.\n      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]\n        ? JBConstants.MAX_FEE_DISCOUNT\n        : _currentFeeDiscount(_projectId);\n\n      // The amount distributed that is eligible for incurring fees.\n      uint256 _feeEligibleDistributionAmount;\n\n      // The amount leftover after distributing to the splits.\n      uint256 _leftoverDistributionAmount;\n\n      // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.\n      // Also get a reference to the amount that was distributed to splits from which fees should be taken.\n      (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(\n        _projectId,\n        _fundingCycle.configuration,\n        payoutSplitsGroup,\n        _distributedAmount,\n        _feeDiscount\n      );\n\n      // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.\n      unchecked {\n        _feeEligibleDistributionAmount += _leftoverDistributionAmount;\n      }\n\n      // Take the fee.\n      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0\n        ? 0\n        : _takeFeeFrom(\n          _projectId,\n          _fundingCycle,\n          _feeEligibleDistributionAmount,\n          _projectOwner,\n          _feeDiscount\n        );\n\n      // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.\n\n      unchecked {\n        netLeftoverDistributionAmount = _leftoverDistributionAmount == 0\n          ? 0\n          : _leftoverDistributionAmount -\n            _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);\n      }\n\n      // Transfer any remaining balance to the project owner.\n      if (netLeftoverDistributionAmount &gt; 0)\n        _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount);\n    }\n\n    emit DistributePayouts(\n      _fundingCycle.configuration,\n      _fundingCycle.number,\n      _projectId,\n      _projectOwner,\n      _amount,\n      _distributedAmount,\n      _fee,\n      netLeftoverDistributionAmount,\n      _memo,\n      msg.sender\n    );\n  }\n\n  /\n    @notice\n    Allows a project to send funds from its overflow up to the preconfigured allowance.\n\n    @dev\n    Only a project's owner or a designated operator can use its allowance.\n\n    @dev\n    Incurs the protocol fee.\n\n    @param _projectId The ID of the project to use the allowance of.\n    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.\n    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.\n    @param _minReturnedTokens The minimum number of tokens that the _amount should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.\n    @param _beneficiary The address to send the funds to.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.\n  /\n  function _useAllowanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency,\n    uint256 _minReturnedTokens,\n    address payable _beneficiary,\n    string memory _memo\n  ) internal returns (uint256 netDistributedAmount) {\n    // Record the use of the allowance.\n    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(\n      _projectId,\n      _amount,\n      _currency\n    );\n\n    // The amount being withdrawn must be at least as much as was expected.\n    if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();\n\n    // Scoped section prevents stack too deep. _fee, _projectOwner, _feeDiscount, and _netAmount only used within scope.\n    {\n      // Keep a reference to the fee amount that was paid.\n      uint256 _fee;\n\n      // Get a reference to the project owner, which will receive tokens from paying the platform fee.\n      address _projectOwner = projects.ownerOf(_projectId);\n\n      // Get the amount of discount that should be applied to any fees taken.\n      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.\n      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]\n        ? JBConstants.MAX_FEE_DISCOUNT\n        : _currentFeeDiscount(_projectId);\n\n      // Take a fee from the _distributedAmount, if needed.\n      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT\n        ? 0\n        : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);\n\n      unchecked {\n        // The net amount is the withdrawn amount without the fee.\n        netDistributedAmount = _distributedAmount - _fee;\n      }\n\n      // Transfer any remaining balance to the beneficiary.\n      if (netDistributedAmount &gt; 0)\n        _transferFrom(address(this), _beneficiary, netDistributedAmount);\n    }\n\n    emit UseAllowance(\n      _fundingCycle.configuration,\n      _fundingCycle.number,\n      _projectId,\n      _beneficiary,\n      _amount,\n      _distributedAmount,\n      netDistributedAmount,\n      _memo,\n      msg.sender\n    );\n  }\n\n  /\n    @notice\n    Pays out splits for a project's funding cycle configuration.\n\n    @param _projectId The ID of the project for which payout splits are being distributed.\n    @param _domain The domain of the splits to distribute the payout between.\n    @param _group The group of the splits to distribute the payout between.\n    @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal.\n    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.\n\n    @return leftoverAmount If the leftover amount if the splits don't add up to 100%.\n    @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.\n  /\n  function _distributeToPayoutSplitsOf(\n    uint256 _projectId,\n    uint256 _domain,\n    uint256 _group,\n    uint256 _amount,\n    uint256 _feeDiscount\n  ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {\n    // Set the leftover amount to the initial amount.\n    leftoverAmount = _amount;\n\n    // Get a reference to the project's payout splits.\n    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);\n\n    // Transfer between all splits.\n    for (uint256 _i = 0; _i &lt; _splits.length; ) {\n      // Get a reference to the split being iterated on.\n      JBSplit memory _split = _splits[_i];\n\n      // The amount to send towards the split.\n      uint256 _payoutAmount = PRBMath.mulDiv(\n        _amount,\n        _split.percent,\n        JBConstants.SPLITS_TOTAL_PERCENT\n      );\n\n      // The payout amount substracting any applicable incurred fees.\n      uint256 _netPayoutAmount;\n\n      if (_payoutAmount &gt; 0) {\n        // Transfer tokens to the split.\n        // If there's an allocator set, transfer to its allocate function.\n        if (_split.allocator != IJBSplitAllocator(address(0))) {\n          // If the split allocator is set as feeless, this distribution is not eligible for a fee.\n          if (isFeelessAddress[address(_split.allocator)])\n            _netPayoutAmount = _payoutAmount;\n            // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.\n          else {\n            unchecked {\n              _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT\n                ? _payoutAmount\n                : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);\n            }\n\n            // This distribution is eligible for a fee since the funds are leaving the ecosystem.\n            feeEligibleDistributionAmount += _payoutAmount;\n          }\n\n          // Trigger any inherited pre-transfer logic.\n          _beforeTransferTo(address(_split.allocator), _netPayoutAmount);\n\n          // If this terminal's token is ETH, send it in msg.value.\n          uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;\n\n          // Create the data to send to the allocator.\n          JBSplitAllocationData memory _data = JBSplitAllocationData(\n            token,\n            _netPayoutAmount,\n            decimals,\n            _projectId,\n            _group,\n            _split\n          );\n\n          // Trigger the allocator's allocate function.\n          _split.allocator.allocate{value: _payableValue}(_data);\n\n          // Otherwise, if a project is specified, make a payment to it.\n        } else if (_split.projectId != 0) {\n          // Get a reference to the Juicebox terminal being used.\n          IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);\n\n          // The project must have a terminal to send funds to.\n          if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();\n\n          // Save gas if this contract is being used as the terminal.\n          if (_terminal == this) {\n            // This distribution does not incur a fee.\n            _netPayoutAmount = _payoutAmount;\n\n            // Send the projectId in the metadata.\n            bytes memory _projectMetadata = new bytes(32);\n            _projectMetadata = bytes(abi.encodePacked(_projectId));\n\n            // Add to balance if prefered.\n            if (_split.preferAddToBalance)\n              _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);\n            else\n              _pay(\n                _netPayoutAmount,\n                address(this),\n                _split.projectId,\n                (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,\n                0,\n                _split.preferClaimed,\n                '',\n                _projectMetadata\n              );\n          } else {\n            // If the terminal is set as feeless, this distribution is not eligible for a fee.\n            if (isFeelessAddress[address(_terminal)])\n              _netPayoutAmount = _payoutAmount;\n              // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.\n            else {\n              unchecked {\n                _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT\n                  ? _payoutAmount\n                  : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);\n              }\n\n              feeEligibleDistributionAmount += _payoutAmount;\n            }\n\n            // Trigger any inherited pre-transfer logic.\n            _beforeTransferTo(address(_terminal), _netPayoutAmount);\n\n            // If this terminal's token is ETH, send it in msg.value.\n            uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;\n\n            // Send the projectId in the metadata.\n            bytes memory _projectMetadata = new bytes(32);\n            _projectMetadata = bytes(abi.encodePacked(_projectId));\n\n            // Add to balance if prefered.\n            if (_split.preferAddToBalance)\n              _terminal.addToBalanceOf{value: _payableValue}(\n                _split.projectId,\n                _netPayoutAmount,\n                token,\n                '',\n                _projectMetadata\n              );\n            else\n              _terminal.pay{value: _payableValue}(\n                _split.projectId,\n                _netPayoutAmount,\n                token,\n                _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,\n                0,\n                _split.preferClaimed,\n                '',\n                _projectMetadata\n              );\n          }\n        } else {\n          unchecked {\n            _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT\n              ? _payoutAmount\n              : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);\n          }\n\n          // This distribution is eligible for a fee since the funds are leaving the ecosystem.\n          feeEligibleDistributionAmount += _payoutAmount;\n\n          // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.\n          _transferFrom(\n            address(this),\n            _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),\n            _netPayoutAmount\n          );\n        }\n\n        // Subtract from the amount to be sent to the beneficiary.\n        unchecked {\n          leftoverAmount = leftoverAmount - _payoutAmount;\n        }\n      }\n\n      emit DistributeToPayoutSplit(\n        _projectId,\n        _domain,\n        _group,\n        _split,\n        _netPayoutAmount,\n        msg.sender\n      );\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /\n    @notice\n    Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID.\n\n    @param _projectId The ID of the project having fees taken from.\n    @param _fundingCycle The funding cycle during which the fee is being taken.\n    @param _amount The amount of the fee to take, as a floating point number with 18 decimals.\n    @param _beneficiary The address to mint the platforms tokens for.\n    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.\n\n    @return feeAmount The amount of the fee taken.\n  */\n  function _takeFeeFrom(\n    uint256 _projectId,\n    JBFundingCycle memory _fundingCycle,\n    uint256 _amount,\n    address _beneficiary,\n    uint256 _feeDiscount\n  ) internal returns (uint256 feeAmount) {\n    feeAmount = _feeAmount(_amount, fee, _feeDiscount);\n\n    if (_fundingCycle.shouldHoldFees()) {\n      // Store the held fee.\n      _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));\n\n      emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender);\n    } else {\n      // Process the fee.\n      _processFee(feeAmount, _beneficiary); // Take the fee.\n\n      emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender);\n    }\n  }\n\n  /\n    @notice\n    Process a fee of the specified amount.\n\n    @param _amount The fee amount, as a floating point number with 18 decimals.\n    @param _beneficiary The address to mint the platform's tokens for.\n  /\n  function _processFee(uint256 _amount, address _beneficiary) internal {\n    // Get the terminal for the protocol project.\n    IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token);\n\n    // When processing the admin fee, save gas if the admin is using this contract as its terminal.\n    if (_terminal == this)\n      _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call.\n    else {\n      // Trigger any inherited pre-transfer logic.\n      _beforeTransferTo(address(_terminal), _amount);\n\n      // If this terminal's token is ETH, send it in msg.value.\n      uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;\n\n      // Send the payment.\n      _terminal.pay{value: _payableValue}(\n        _PROTOCOL_PROJECT_ID,\n        _amount,\n        token,\n        _beneficiary,\n        0,\n        false,\n        '',\n        bytes('')\n      ); // Use the external pay call of the correct terminal.\n    }\n  }\n\n  /\n    @notice\n    Contribute tokens to a project.\n\n    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.\n    @param _payer The address making the payment.\n    @param _projectId The ID of the project being paid.\n    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.\n    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.\n    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.\n    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.\n    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.\n\n    @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.\n  /\n  function _pay(\n    uint256 _amount,\n    address _payer,\n    uint256 _projectId,\n    address _beneficiary,\n    uint256 _minReturnedTokens,\n    bool _preferClaimedTokens,\n    string memory _memo,\n    bytes memory _metadata\n  ) internal returns (uint256 beneficiaryTokenCount) {\n    // Cant send tokens to the zero address.\n    if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS();\n\n    // Define variables that will be needed outside the scoped section below.\n    // Keep a reference to the funding cycle during which the payment is being made.\n    JBFundingCycle memory _fundingCycle;\n\n    // Scoped section prevents stack too deep. _delegate and _tokenCount only used within scope.\n    {\n      IJBPayDelegate _delegate;\n      uint256 _tokenCount;\n\n      // Bundle the amount info into a JBTokenAmount struct.\n      JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);\n\n      // Record the payment.\n      (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(\n        _payer,\n        _bundledAmount,\n        _projectId,\n        baseWeightCurrency,\n        _beneficiary,\n        _memo,\n        _metadata\n      );\n\n      // Mint the tokens if needed.\n      if (_tokenCount &gt; 0)\n        // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.\n        beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(\n          _projectId,\n          _tokenCount,\n          _beneficiary,\n          '',\n          _preferClaimedTokens,\n          true\n        );\n\n      // The token count for the beneficiary must be greater than or equal to the minimum expected.\n      if (beneficiaryTokenCount &lt; _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();\n\n      // If a delegate was returned by the data source, issue a callback to it.\n      if (_delegate != IJBPayDelegate(address(0))) {\n        JBDidPayData memory _data = JBDidPayData(\n          _payer,\n          _projectId,\n          _fundingCycle.configuration,\n          _bundledAmount,\n          beneficiaryTokenCount,\n          _beneficiary,\n          _preferClaimedTokens,\n          _memo,\n          _metadata\n        );\n\n        _delegate.didPay(_data);\n        emit DelegateDidPay(_delegate, _data, msg.sender);\n      }\n    }\n\n    emit Pay(\n      _fundingCycle.configuration,\n      _fundingCycle.number,\n      _projectId,\n      _payer,\n      _beneficiary,\n      _amount,\n      beneficiaryTokenCount,\n      _memo,\n      _metadata,\n      msg.sender\n    );\n  }\n\n  /\n    @notice\n    Receives funds belonging to the specified project.\n\n    @param _projectId The ID of the project to which the funds received belong.\n    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.\n    @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added.\n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Extra data to pass along to the emitted event.\n  */\n  function _addToBalanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    bool _shouldRefundHeldFees,\n    string memory _memo,\n    bytes memory _metadata\n  ) internal {\n    // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.\n    uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0;\n\n    // Record the added funds with any refunded fees.\n    store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);\n\n    emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);\n  }\n\n  /\n    @notice\n    Refund fees based on the specified amount.\n\n    @param _projectId The project for which fees are being refunded.\n    @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.\n\n    @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal\n  /\n  function _refundHeldFees(uint256 _projectId, uint256 _amount)\n    internal\n    returns (uint256 refundedFees)\n  {\n    // Get a reference to the project's held fees.\n    JBFee[] memory _heldFees = _heldFeesOf[_projectId];\n\n    // Delete the current held fees.\n    delete _heldFeesOf[_projectId];\n\n    // Get a reference to the leftover amount once all fees have been settled.\n    uint256 leftoverAmount = _amount;\n\n    // Push length in stack\n    uint256 _heldFeesLength = _heldFees.length;\n\n    // Process each fee.\n    for (uint256 _i = 0; _i &lt; _heldFeesLength; ) {\n      if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);\n      else if (leftoverAmount &gt;= _heldFees[_i].amount) {\n        unchecked {\n          leftoverAmount = leftoverAmount - _heldFees[_i].amount;\n          refundedFees += _feeAmount(\n            _heldFees[_i].amount,\n            _heldFees[_i].fee,\n            _heldFees[_i].feeDiscount\n          );\n        }\n      } else {\n        _heldFeesOf[_projectId].push(\n          JBFee(\n            _heldFees[_i].amount - leftoverAmount,\n            _heldFees[_i].fee,\n            _heldFees[_i].feeDiscount,\n            _heldFees[_i].beneficiary\n          )\n        );\n        unchecked {\n          refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);\n        }\n        leftoverAmount = 0;\n      }\n\n      unchecked {\n        ++_i;\n      }\n    }\n\n    emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);\n  }\n\n  / \n    @notice \n    Returns the fee amount based on the provided amount for the specified project.\n\n    @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal.\n    @param _fee The percentage of the fee, out of MAX_FEE. \n    @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.\n\n    @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.\n  /\n  function _feeAmount(\n    uint256 _amount,\n    uint256 _fee,\n    uint256 _feeDiscount\n  ) internal pure returns (uint256) {\n    // Calculate the discounted fee.\n    uint256 _discountedFee = _fee -\n      PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT);\n\n    // The amount of tokens from the _amount to pay as a fee.\n    return\n      _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);\n  }\n\n  /* \n    @notice\n    Get the fee discount from the fee gauge for the specified project.\n\n    @param _projectId The ID of the project to get a fee discount for.\n    \n    @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.\n  /\n  function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {\n    // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.\n    if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))\n      return JBConstants.MAX_FEE_DISCOUNT;\n\n    // Get the fee discount.\n    if (feeGauge == IJBFeeGauge(address(0)))\n      feeDiscount = 0;\n      // If the guage reverts, set the discount to 0.\n    else\n      try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {\n        feeDiscount = discount;\n      } catch {\n        feeDiscount = 0;\n      }\n\n    // If the fee discount is greater than the max, nullify the discount.\n    if (feeDiscount &gt; JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;\n  }\n}\n", 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 17:17:40 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/security/ReentrancyGuard.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './../interfaces/IJBController.sol'; import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol'; import './../libraries/JBConstants.sol'; import './../libraries/JBCurrencies.sol'; import './../libraries/JBFixedPointNumber.sol'; import './../libraries/JBFundingCycleMetadataResolver.sol'; import './../libraries/JBOperations.sol'; import './../libraries/JBSplitsGroups.sol'; import './../libraries/JBTokens.sol'; import './../structs/JBTokenAmount.sol'; import './JBOperatable.sol'; import './JBSingleTokenPaymentTerminal.sol'; /**   @notice   Generic terminal managing all inflows and outflows of funds into the protocol ecosystem. @dev   A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time. @dev   Adheres to -   IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules. @dev   Inherits from -   JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.   JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.   Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.   ReentrancyGuard: Contract module that helps prevent reentrant calls to a function. */ abstract contract JBPayoutRedemptionPaymentTerminal is   IJBPayoutRedemptionPaymentTerminal,   JBSingleTokenPaymentTerminal,   JBOperatable,   Ownable,   ReentrancyGuard {   // A library that parses the packed funding cycle metadata into a friendlier format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error FEE_TOO_HIGH();   error INADEQUATE_DISTRIBUTION_AMOUNT();   error INADEQUATE_RECLAIM_AMOUNT();   error INADEQUATE_TOKEN_COUNT();   error NO_MSG_VALUE_ALLOWED();   error PAY_TO_ZERO_ADDRESS();   error PROJECT_TERMINAL_MISMATCH();   error REDEEM_TO_ZERO_ADDRESS();   error TERMINAL_IN_SPLIT_ZERO_ADDRESS();   error TERMINAL_TOKENS_INCOMPATIBLE(); //***********//   // ---------------------------- modifiers ---------------------------- //   //*************// /*      @notice      A modifier that verifies this terminal is a terminal of provided project ID.   /   modifier isTerminalOf(uint256 projectId) {     if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();     ;   } //***********//   // --------------------- internal stored constants ------------------- //   //*************// /**     @notice     Maximum fee that can be set for a funding cycle configuration. @dev Out of MAX_FEE (50_000_000 / 1_000_000_000).  */   uint256 internal constant _FEE_CAP = 50_000_000; /*     @notice     The protocol project ID is 1, as it should be the first project launched during the deployment process.   /   uint256 internal constant _PROTOCOL_PROJECT_ID = 1; //***********//   // --------------------- internal stored properties ------------------ //   //*************// /**     @notice     Fees that are being held to be processed later. _projectId The ID of the project for which fees are being held.  */   mapping(uint256 =&gt; JBFee[]) internal _heldFeesOf; //***********//   // ---------------- public immutable stored properties --------------- //   //*************// /*     @notice     Mints ERC-721's that represent project ownership and transfers.   /   IJBProjects public immutable override projects; /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; /*     @notice     The contract that stores splits for each project.   /   IJBSplitsStore public immutable override splitsStore; /*     @notice     The contract that exposes price feeds.   /   IJBPrices public immutable override prices; /*     @notice     The contract that stores and manages the terminal's data.   /   IJBSingleTokenPaymentTerminalStore public immutable override store; /**     @notice     The currency to base token issuance on. @dev If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.  */   uint256 public immutable override baseWeightCurrency; /*     @notice     The group that payout splits coming from this terminal are identified by.   /   uint256 public immutable override payoutSplitsGroup; //***********//   // --------------------- public stored properties -------------------- //   //*************// /**     @notice     The platform fee percent. @dev Out of MAX_FEE (25_000_000 / 1_000_000_000)  */   uint256 public override fee = 25_000_000; // 2.5% /*     @notice     The data source that returns a discount to apply to a project's fee.   /   IJBFeeGauge public override feeGauge; /**     @notice     Addresses that can be paid towards from this terminal without incurring a fee. _address The address that can be paid toward.  */   mapping(address =&gt; bool) public override isFeelessAddress; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     Gets the current overflowed amount in this terminal for a specified project, in terms of ETH. @dev The current overflow is represented as a fixed point number with 18 decimals.  @param _projectId The ID of the project to get overflow for.  @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.  */   function currentEthOverflowOf(uint256 _projectId)     external     view     virtual     override     returns (uint256)   {     // Get this terminal's current overflow.     uint256 _overflow = store.currentOverflowOf(this, _projectId); // Adjust the decimals of the fixed point number if needed to have 18 decimals. uint256 _adjustedOverflow = (decimals == 18)   ? _overflow   : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);  // Return the amount converted to ETH. return   (currency == JBCurrencies.ETH)     ? _adjustedOverflow     : PRBMath.mulDiv(       _adjustedOverflow,       10**decimals,       prices.priceFor(currency, JBCurrencies.ETH, decimals)     );  } /**     @notice     The fees that are currently being held to be processed later for each project. @param _projectId The ID of the project for which fees are being held.  @return An array of fees that are being held.  */   function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {     return _heldFeesOf[_projectId];   } //***********//   // -------------------------- public views --------------------------- //   //*************// /**     @notice     Indicates if this contract adheres to the specified interface. @dev  See {IERC165-supportsInterface}.  @param _interfaceId The ID of the interface to check for adherance to.  */   function supportsInterface(bytes4 _interfaceId)     public     view     virtual     override(JBSingleTokenPaymentTerminal, IERC165)     returns (bool)   {     return       _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||       _interfaceId == type(IJBPayoutTerminal).interfaceId ||       _interfaceId == type(IJBAllowanceTerminal).interfaceId ||       _interfaceId == type(IJBRedemptionTerminal).interfaceId ||       _interfaceId == type(IJBOperatable).interfaceId ||       super.supportsInterface(_interfaceId);   } //***********//   // -------------------------- constructor ---------------------------- //   //*************// /*     @param _token The token that this terminal manages.     @param _decimals The number of decimals the token fixed point amounts are expected to have.     @param _currency The currency that this terminal's token adheres to for price feeds.     @param _baseWeightCurrency The currency to base token issuance on.     @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.     @param _operatorStore A contract storing operator assignments.     @param _projects A contract which mints ERC-721's that represent project ownership and transfers.     @param _directory A contract storing directories of terminals and controllers for each project.     @param _splitsStore A contract that stores splits for each project.     @param _prices A contract that exposes price feeds.     @param _store A contract that stores the terminal's data.     @param _owner The address that will own this contract.   /   constructor(     // payable constructor save the gas used to check msg.value==0     address _token,     uint256 _decimals,     uint256 _currency,     uint256 _baseWeightCurrency,     uint256 _payoutSplitsGroup,     IJBOperatorStore _operatorStore,     IJBProjects _projects,     IJBDirectory _directory,     IJBSplitsStore _splitsStore,     IJBPrices _prices,     IJBSingleTokenPaymentTerminalStore _store,     address _owner   )     payable     JBSingleTokenPaymentTerminal(_token, _decimals, _currency)     JBOperatable(_operatorStore)   {     baseWeightCurrency = _baseWeightCurrency;     payoutSplitsGroup = _payoutSplitsGroup;     projects = _projects;     directory = _directory;     splitsStore = _splitsStore;     prices = _prices;     store = _store; transferOwnership(_owner);  } //***********//   // ---------------------- external transactions ---------------------- //   //*************// /**     @notice     Contribute tokens to a project. @param _projectId The ID of the project being paid. @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place. @param _token The token being paid. This terminal ignores this property since it only manages one token.  @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate. @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal. @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas. @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.  */   function pay(     uint256 _projectId,     uint256 _amount,     address _token,     address _beneficiary,     uint256 _minReturnedTokens,     bool _preferClaimedTokens,     string calldata _memo,     bytes calldata _metadata   ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {     _token; // Prevents unused var compiler and natspec complaints. // ETH shouldn't be sent if this terminal's token isn't ETH. if (token != JBTokens.ETH) {   if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();    // Transfer tokens to this terminal from the msg sender.   _transferFrom(msg.sender, payable(address(this)), _amount); } // If this terminal's token is ETH, override _amount with msg.value. else _amount = msg.value;  return   _pay(     _amount,     msg.sender,     _projectId,     _beneficiary,     _minReturnedTokens,     _preferClaimedTokens,     _memo,     _metadata   );  } /**     @notice     Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source. @dev Only a token holder or a designated operator can redeem its tokens.  @param _holder The account to redeem tokens for. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _token The token being reclaimed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal. @param _beneficiary The address to send the terminal tokens to. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.  */   function redeemTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     address _token,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo,     bytes memory _metadata   )     external     virtual     override     requirePermission(_holder, _projectId, JBOperations.REDEEM)     returns (uint256 reclaimAmount)   {     _token; // Prevents unused var compiler and natspec complaints. return   _redeemTokensOf(     _holder,     _projectId,     _tokenCount,     _minReturnedTokens,     _beneficiary,     _memo,     _metadata   );  } /**     @notice     Distributes payouts for a project with the distribution limit of its current funding cycle. @dev Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.  @dev Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.  @dev All funds distributed outside of this contract or any feeless terminals incure the protocol fee.  @param _projectId The ID of the project having its payouts distributed. @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency. @param _token The token being distributed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal. @param _memo A memo to pass along to the emitted event.  @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.  */   function distributePayoutsOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     address _token,     uint256 _minReturnedTokens,     string calldata _memo   ) external virtual override returns (uint256 netLeftoverDistributionAmount) {     _token; // Prevents unused var compiler and natspec complaints. return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);  } /**     @notice     Allows a project to send funds from its overflow up to the preconfigured allowance. @dev Only a project's owner or a designated operator can use its allowance.  @dev Incurs the protocol fee.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency. @param _token The token being distributed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals. @param _beneficiary The address to send the funds to. @param _memo A memo to pass along to the emitted event.  @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.  */   function useAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     address _token,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)     returns (uint256 netDistributedAmount)   {     _token; // Prevents unused var compiler and natspec complaints. return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);  } /**     @notice     Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type. @dev Only a project's owner or a designated operator can migrate it.  @param _projectId The ID of the project being migrated. @param _to The terminal contract that will gain the project's funds.  @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.  */   function migrate(uint256 _projectId, IJBPaymentTerminal _to)     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)     returns (uint256 balance)   {     // The terminal being migrated to must accept the same token as this terminal.     if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE(); // Record the migration in the store. balance = store.recordMigration(_projectId);  // Transfer the balance if needed. if (balance &gt; 0) {   // Trigger any inherited pre-transfer logic.   _beforeTransferTo(address(_to), balance);    // If this terminal's token is ETH, send it in msg.value.   uint256 _payableValue = token == JBTokens.ETH ? balance : 0;    // Withdraw the balance to transfer to the new terminal;   _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes('')); }  emit Migrate(_projectId, _to, balance, msg.sender);  } /**     @notice     Receives funds belonging to the specified project. @param _projectId The ID of the project to which the funds received belong. @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead. @param _token The token being paid. This terminal ignores this property since it only manages one currency.  @param _memo A memo to pass along to the emitted event. @param _metadata Extra data to pass along to the emitted event.  */   function addToBalanceOf(     uint256 _projectId,     uint256 _amount,     address _token,     string calldata _memo,     bytes calldata _metadata   ) external payable virtual override isTerminalOf(_projectId) {     _token; // Prevents unused var compiler and natspec complaints. // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender. if (token != JBTokens.ETH) {   // Amount must be greater than 0.   if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();    // Transfer tokens to this terminal from the msg sender.   _transferFrom(msg.sender, payable(address(this)), _amount); } // If the terminal's token is ETH, override `_amount` with msg.value. else _amount = msg.value;  // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal. _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);  } /**     @notice     Process any fees that are being held for the project. @dev Only a project owner, an operator, or the contract's owner can process held fees.  @param _projectId The ID of the project whos held fees should be processed.  */   function processFees(uint256 _projectId)     external     virtual     override     requirePermissionAllowingOverride(       projects.ownerOf(_projectId),       _projectId,       JBOperations.PROCESS_FEES,       msg.sender == owner()     )   {     // Get a reference to the project's held fees.     JBFee[] memory _heldFees = _heldFeesOf[_projectId]; // Delete the held fees. delete _heldFeesOf[_projectId];  // Push array length in stack uint256 _heldFeeLength = _heldFees.length;  // Process each fee. for (uint256 _i = 0; _i &lt; _heldFeeLength; ) {   // Get the fee amount.   uint256 _amount = _feeAmount(     _heldFees[_i].amount,     _heldFees[_i].fee,     _heldFees[_i].feeDiscount   );    // Process the fee.   _processFee(_amount, _heldFees[_i].beneficiary);    emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);    unchecked {     ++_i;   } }  } /**     @notice     Allows the fee to be updated. @dev Only the owner of this contract can change the fee.  @param _fee The new fee, out of MAX_FEE.  */   function setFee(uint256 _fee) external virtual override onlyOwner {     // The provided fee must be within the max.     if (_fee &gt; _FEE_CAP) revert FEE_TOO_HIGH(); // Store the new fee. fee = _fee;  emit SetFee(_fee, msg.sender);  } /**     @notice     Allows the fee gauge to be updated. @dev Only the owner of this contract can change the fee gauge.  @dev If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.  @param _feeGauge The new fee gauge.  */   function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {     // Store the new fee gauge.     feeGauge = _feeGauge; emit SetFeeGauge(_feeGauge, msg.sender);  } /**     @notice     Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee. @dev Only the owner of this contract can set addresses as feeless.  @param _address The address that can be paid towards while still bypassing fees. @param _flag A flag indicating whether the terminal should be feeless or not.  */   function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {     // Set the flag value.     isFeelessAddress[_address] = _flag; emit SetFeelessAddress(_address, _flag, msg.sender);  } //***********//   // ---------------------- internal transactions ---------------------- //   //*************// /**      @notice     Transfers tokens. @param _from The address from which the transfer should originate. @param _to The address to which the transfer should go. @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.  */   function _transferFrom(     address _from,     address payable _to,     uint256 _amount   ) internal virtual; /**      @notice     Logic to be triggered before transferring tokens from this terminal. @param _to The address to which the transfer is going. @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.  */   function _beforeTransferTo(address _to, uint256 _amount) internal virtual; /**     @notice     Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source. @dev Only a token holder or a designated operator can redeem its tokens.  @param _holder The account to redeem tokens for. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal. @param _beneficiary The address to send the terminal tokens to. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.  */   function _redeemTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo,     bytes memory _metadata   ) internal returns (uint256 reclaimAmount) {     // Can't send reclaimed funds to the zero address.     if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS(); // Define variables that will be needed outside the scoped section below. // Keep a reference to the funding cycle during which the redemption is being made. JBFundingCycle memory _fundingCycle;  // Scoped section prevents stack too deep. `_delegate` only used within scope. {   IJBRedemptionDelegate _delegate;    // Record the redemption.   (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(     _holder,     _projectId,     _tokenCount,     _memo,     _metadata   );    // The amount being reclaimed must be at least as much as was expected.   if (reclaimAmount &lt; _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();    // Burn the project tokens.   if (_tokenCount &gt; 0)     IJBController(directory.controllerOf(_projectId)).burnTokensOf(       _holder,       _projectId,       _tokenCount,       '',       false     );    // If a delegate was returned by the data source, issue a callback to it.   if (_delegate != IJBRedemptionDelegate(address(0))) {     JBDidRedeemData memory _data = JBDidRedeemData(       _holder,       _projectId,       _fundingCycle.configuration,       _tokenCount,       JBTokenAmount(token, reclaimAmount, decimals, currency),       _beneficiary,       _memo,       _metadata     );     _delegate.didRedeem(_data);     emit DelegateDidRedeem(_delegate, _data, msg.sender);   } }  // Send the reclaimed funds to the beneficiary. if (reclaimAmount &gt; 0) _transferFrom(address(this), _beneficiary, reclaimAmount);  emit RedeemTokens(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _holder,   _beneficiary,   _tokenCount,   reclaimAmount,   _memo,   _metadata,   msg.sender );  } /**     @notice     Distributes payouts for a project with the distribution limit of its current funding cycle. @dev Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.  @dev Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.  @dev All funds distributed outside of this contract or any feeless terminals incure the protocol fee.  @param _projectId The ID of the project having its payouts distributed. @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency. @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal. @param _memo A memo to pass along to the emitted event.  @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.  */   function _distributePayoutsOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     uint256 _minReturnedTokens,     string calldata _memo   ) internal returns (uint256 netLeftoverDistributionAmount) {     // Record the distribution.     (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(       _projectId,       _amount,       _currency     ); // The amount being distributed must be at least as much as was expected. if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();  // Get a reference to the project owner, which will receive tokens from paying the platform fee // and receive any extra distributable funds not allocated to payout splits. address payable _projectOwner = payable(projects.ownerOf(_projectId));  // Define variables that will be needed outside the scoped section below. // Keep a reference to the fee amount that was paid. uint256 _fee;  // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope. {   // Get the amount of discount that should be applied to any fees taken.   // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.   uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]     ? JBConstants.MAX_FEE_DISCOUNT     : _currentFeeDiscount(_projectId);    // The amount distributed that is eligible for incurring fees.   uint256 _feeEligibleDistributionAmount;    // The amount leftover after distributing to the splits.   uint256 _leftoverDistributionAmount;    // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.   // Also get a reference to the amount that was distributed to splits from which fees should be taken.   (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(     _projectId,     _fundingCycle.configuration,     payoutSplitsGroup,     _distributedAmount,     _feeDiscount   );    // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.   unchecked {     _feeEligibleDistributionAmount += _leftoverDistributionAmount;   }    // Take the fee.   _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0     ? 0     : _takeFeeFrom(       _projectId,       _fundingCycle,       _feeEligibleDistributionAmount,       _projectOwner,       _feeDiscount     );    // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.    unchecked {     netLeftoverDistributionAmount = _leftoverDistributionAmount == 0       ? 0       : _leftoverDistributionAmount -         _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);   }    // Transfer any remaining balance to the project owner.   if (netLeftoverDistributionAmount &gt; 0)     _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount); }  emit DistributePayouts(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _projectOwner,   _amount,   _distributedAmount,   _fee,   netLeftoverDistributionAmount,   _memo,   msg.sender );  } /**     @notice     Allows a project to send funds from its overflow up to the preconfigured allowance. @dev Only a project's owner or a designated operator can use its allowance.  @dev Incurs the protocol fee.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency. @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals. @param _beneficiary The address to send the funds to. @param _memo A memo to pass along to the emitted event.  @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.  */   function _useAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo   ) internal returns (uint256 netDistributedAmount) {     // Record the use of the allowance.     (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(       _projectId,       _amount,       _currency     ); // The amount being withdrawn must be at least as much as was expected. if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();  // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope. {   // Keep a reference to the fee amount that was paid.   uint256 _fee;    // Get a reference to the project owner, which will receive tokens from paying the platform fee.   address _projectOwner = projects.ownerOf(_projectId);    // Get the amount of discount that should be applied to any fees taken.   // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.   uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]     ? JBConstants.MAX_FEE_DISCOUNT     : _currentFeeDiscount(_projectId);    // Take a fee from the `_distributedAmount`, if needed.   _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT     ? 0     : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);    unchecked {     // The net amount is the withdrawn amount without the fee.     netDistributedAmount = _distributedAmount - _fee;   }    // Transfer any remaining balance to the beneficiary.   if (netDistributedAmount &gt; 0)     _transferFrom(address(this), _beneficiary, netDistributedAmount); }  emit UseAllowance(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _beneficiary,   _amount,   _distributedAmount,   netDistributedAmount,   _memo,   msg.sender );  } /**     @notice     Pays out splits for a project's funding cycle configuration. @param _projectId The ID of the project for which payout splits are being distributed. @param _domain The domain of the splits to distribute the payout between. @param _group The group of the splits to distribute the payout between. @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal. @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.  @return leftoverAmount If the leftover amount if the splits don't add up to 100%. @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.  */   function _distributeToPayoutSplitsOf(     uint256 _projectId,     uint256 _domain,     uint256 _group,     uint256 _amount,     uint256 _feeDiscount   ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {     // Set the leftover amount to the initial amount.     leftoverAmount = _amount; // Get a reference to the project's payout splits. JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);  // Transfer between all splits. for (uint256 _i = 0; _i &lt; _splits.length; ) {   // Get a reference to the split being iterated on.   JBSplit memory _split = _splits[_i];    // The amount to send towards the split.   uint256 _payoutAmount = PRBMath.mulDiv(     _amount,     _split.percent,     JBConstants.SPLITS_TOTAL_PERCENT   );    // The payout amount substracting any applicable incurred fees.   uint256 _netPayoutAmount;    if (_payoutAmount &gt; 0) {     // Transfer tokens to the split.     // If there's an allocator set, transfer to its `allocate` function.     if (_split.allocator != IJBSplitAllocator(address(0))) {       // If the split allocator is set as feeless, this distribution is not eligible for a fee.       if (isFeelessAddress[address(_split.allocator)])         _netPayoutAmount = _payoutAmount;         // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.       else {         unchecked {           _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT             ? _payoutAmount             : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);         }          // This distribution is eligible for a fee since the funds are leaving the ecosystem.         feeEligibleDistributionAmount += _payoutAmount;       }        // Trigger any inherited pre-transfer logic.       _beforeTransferTo(address(_split.allocator), _netPayoutAmount);        // If this terminal's token is ETH, send it in msg.value.       uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;        // Create the data to send to the allocator.       JBSplitAllocationData memory _data = JBSplitAllocationData(         token,         _netPayoutAmount,         decimals,         _projectId,         _group,         _split       );        // Trigger the allocator's `allocate` function.       _split.allocator.allocate{value: _payableValue}(_data);        // Otherwise, if a project is specified, make a payment to it.     } else if (_split.projectId != 0) {       // Get a reference to the Juicebox terminal being used.       IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);        // The project must have a terminal to send funds to.       if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();        // Save gas if this contract is being used as the terminal.       if (_terminal == this) {         // This distribution does not incur a fee.         _netPayoutAmount = _payoutAmount;          // Send the projectId in the metadata.         bytes memory _projectMetadata = new bytes(32);         _projectMetadata = bytes(abi.encodePacked(_projectId));          // Add to balance if prefered.         if (_split.preferAddToBalance)           _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);         else           _pay(             _netPayoutAmount,             address(this),             _split.projectId,             (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,             0,             _split.preferClaimed,             '',             _projectMetadata           );       } else {         // If the terminal is set as feeless, this distribution is not eligible for a fee.         if (isFeelessAddress[address(_terminal)])           _netPayoutAmount = _payoutAmount;           // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.         else {           unchecked {             _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT               ? _payoutAmount               : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);           }            feeEligibleDistributionAmount += _payoutAmount;         }          // Trigger any inherited pre-transfer logic.         _beforeTransferTo(address(_terminal), _netPayoutAmount);          // If this terminal's token is ETH, send it in msg.value.         uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;          // Send the projectId in the metadata.         bytes memory _projectMetadata = new bytes(32);         _projectMetadata = bytes(abi.encodePacked(_projectId));          // Add to balance if prefered.         if (_split.preferAddToBalance)           _terminal.addToBalanceOf{value: _payableValue}(             _split.projectId,             _netPayoutAmount,             token,             '',             _projectMetadata           );         else           _terminal.pay{value: _payableValue}(             _split.projectId,             _netPayoutAmount,             token,             _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,             0,             _split.preferClaimed,             '',             _projectMetadata           );       }     } else {       unchecked {         _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT           ? _payoutAmount           : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);       }        // This distribution is eligible for a fee since the funds are leaving the ecosystem.       feeEligibleDistributionAmount += _payoutAmount;        // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.       _transferFrom(         address(this),         _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),         _netPayoutAmount       );     }      // Subtract from the amount to be sent to the beneficiary.     unchecked {       leftoverAmount = leftoverAmount - _payoutAmount;     }   }    emit DistributeToPayoutSplit(     _projectId,     _domain,     _group,     _split,     _netPayoutAmount,     msg.sender   );    unchecked {     ++_i;   } }  } /**     @notice     Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID. @param _projectId The ID of the project having fees taken from. @param _fundingCycle The funding cycle during which the fee is being taken. @param _amount The amount of the fee to take, as a floating point number with 18 decimals. @param _beneficiary The address to mint the platforms tokens for. @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.  @return feeAmount The amount of the fee taken.  */   function _takeFeeFrom(     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _amount,     address _beneficiary,     uint256 _feeDiscount   ) internal returns (uint256 feeAmount) {     feeAmount = _feeAmount(_amount, fee, _feeDiscount); if (_fundingCycle.shouldHoldFees()) {   // Store the held fee.   _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));    emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender); } else {   // Process the fee.   _processFee(feeAmount, _beneficiary); // Take the fee.    emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender); }  } /**     @notice     Process a fee of the specified amount. @param _amount The fee amount, as a floating point number with 18 decimals. @param _beneficiary The address to mint the platform's tokens for.  */   function _processFee(uint256 _amount, address _beneficiary) internal {     // Get the terminal for the protocol project.     IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token); // When processing the admin fee, save gas if the admin is using this contract as its terminal. if (_terminal == this)   _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call. else {   // Trigger any inherited pre-transfer logic.   _beforeTransferTo(address(_terminal), _amount);    // If this terminal's token is ETH, send it in msg.value.   uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;    // Send the payment.   _terminal.pay{value: _payableValue}(     _PROTOCOL_PROJECT_ID,     _amount,     token,     _beneficiary,     0,     false,     '',     bytes('')   ); // Use the external pay call of the correct terminal. }  } /**     @notice     Contribute tokens to a project. @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place. @param _payer The address making the payment. @param _projectId The ID of the project being paid. @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate. @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal. @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas. @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.  */   function _pay(     uint256 _amount,     address _payer,     uint256 _projectId,     address _beneficiary,     uint256 _minReturnedTokens,     bool _preferClaimedTokens,     string memory _memo,     bytes memory _metadata   ) internal returns (uint256 beneficiaryTokenCount) {     // Cant send tokens to the zero address.     if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS(); // Define variables that will be needed outside the scoped section below. // Keep a reference to the funding cycle during which the payment is being made. JBFundingCycle memory _fundingCycle;  // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope. {   IJBPayDelegate _delegate;   uint256 _tokenCount;    // Bundle the amount info into a JBTokenAmount struct.   JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);    // Record the payment.   (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(     _payer,     _bundledAmount,     _projectId,     baseWeightCurrency,     _beneficiary,     _memo,     _metadata   );    // Mint the tokens if needed.   if (_tokenCount &gt; 0)     // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.     beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(       _projectId,       _tokenCount,       _beneficiary,       '',       _preferClaimedTokens,       true     );    // The token count for the beneficiary must be greater than or equal to the minimum expected.   if (beneficiaryTokenCount &lt; _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();    // If a delegate was returned by the data source, issue a callback to it.   if (_delegate != IJBPayDelegate(address(0))) {     JBDidPayData memory _data = JBDidPayData(       _payer,       _projectId,       _fundingCycle.configuration,       _bundledAmount,       beneficiaryTokenCount,       _beneficiary,       _preferClaimedTokens,       _memo,       _metadata     );      _delegate.didPay(_data);     emit DelegateDidPay(_delegate, _data, msg.sender);   } }  emit Pay(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _payer,   _beneficiary,   _amount,   beneficiaryTokenCount,   _memo,   _metadata,   msg.sender );  } /**     @notice     Receives funds belonging to the specified project. @param _projectId The ID of the project to which the funds received belong. @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead. @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added. @param _memo A memo to pass along to the emitted event. @param _metadata Extra data to pass along to the emitted event.  */   function _addToBalanceOf(     uint256 _projectId,     uint256 _amount,     bool _shouldRefundHeldFees,     string memory _memo,     bytes memory _metadata   ) internal {     // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.     uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0; // Record the added funds with any refunded fees. store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);  emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);  } /**     @notice     Refund fees based on the specified amount. @param _projectId The project for which fees are being refunded. @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.  @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal  */   function _refundHeldFees(uint256 _projectId, uint256 _amount)     internal     returns (uint256 refundedFees)   {     // Get a reference to the project's held fees.     JBFee[] memory _heldFees = _heldFeesOf[_projectId]; // Delete the current held fees. delete _heldFeesOf[_projectId];  // Get a reference to the leftover amount once all fees have been settled. uint256 leftoverAmount = _amount;  // Push length in stack uint256 _heldFeesLength = _heldFees.length;  // Process each fee. for (uint256 _i = 0; _i &lt; _heldFeesLength; ) {   if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);   else if (leftoverAmount &gt;= _heldFees[_i].amount) {     unchecked {       leftoverAmount = leftoverAmount - _heldFees[_i].amount;       refundedFees += _feeAmount(         _heldFees[_i].amount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount       );     }   } else {     _heldFeesOf[_projectId].push(       JBFee(         _heldFees[_i].amount - leftoverAmount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount,         _heldFees[_i].beneficiary       )     );     unchecked {       refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);     }     leftoverAmount = 0;   }    unchecked {     ++_i;   } }  emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);  } /**      @notice      Returns the fee amount based on the provided amount for the specified project. @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal. @param _fee The percentage of the fee, out of MAX_FEE.  @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.  @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.  */   function _feeAmount(     uint256 _amount,     uint256 _fee,     uint256 _feeDiscount   ) internal pure returns (uint256) {     // Calculate the discounted fee.     uint256 _discountedFee = _fee -       PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT); // The amount of tokens from the `_amount` to pay as a fee. return   _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);  } /**      @notice     Get the fee discount from the fee gauge for the specified project. @param _projectId The ID of the project to get a fee discount for.  @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.  */   function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {     // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.     if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))       return JBConstants.MAX_FEE_DISCOUNT; // Get the fee discount. if (feeGauge == IJBFeeGauge(address(0)))   feeDiscount = 0;   // If the guage reverts, set the discount to 0. else   try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {     feeDiscount = discount;   } catch {     feeDiscount = 0;   }  // If the fee discount is greater than the max, nullify the discount. if (feeDiscount &gt; JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 17:17:40 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './../interfaces/IJBController.sol';
import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol';
import './../libraries/JBConstants.sol';
import './../libraries/JBCurrencies.sol';
import './../libraries/JBFixedPointNumber.sol';
import './../libraries/JBFundingCycleMetadataResolver.sol';
import './../libraries/JBOperations.sol';
import './../libraries/JBSplitsGroups.sol';
import './../libraries/JBTokens.sol';
import './../structs/JBTokenAmount.sol';
import './JBOperatable.sol';
import './JBSingleTokenPaymentTerminal.sol';

/**
  @notice
  Generic terminal managing all inflows and outflows of funds into the protocol ecosystem.

  @dev
  A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time.

  @dev
  Adheres to -
  IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.
  JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
abstract contract JBPayoutRedemptionPaymentTerminal is
  IJBPayoutRedemptionPaymentTerminal,
  JBSingleTokenPaymentTerminal,
  JBOperatable,
  Ownable,
  ReentrancyGuard
{
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error FEE_TOO_HIGH();
  error INADEQUATE_DISTRIBUTION_AMOUNT();
  error INADEQUATE_RECLAIM_AMOUNT();
  error INADEQUATE_TOKEN_COUNT();
  error NO_MSG_VALUE_ALLOWED();
  error PAY_TO_ZERO_ADDRESS();
  error PROJECT_TERMINAL_MISMATCH();
  error REDEEM_TO_ZERO_ADDRESS();
  error TERMINAL_IN_SPLIT_ZERO_ADDRESS();
  error TERMINAL_TOKENS_INCOMPATIBLE();

  //*********************************************************************//
  // ---------------------------- modifiers ---------------------------- //
  //*********************************************************************//

  /** 
    @notice 
    A modifier that verifies this terminal is a terminal of provided project ID.
  */
  modifier isTerminalOf(uint256 _projectId) {
    if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();
    _;
  }

  //*********************************************************************//
  // --------------------- internal stored constants ------------------- //
  //*********************************************************************//

  /**
    @notice
    Maximum fee that can be set for a funding cycle configuration.

    @dev
    Out of MAX_FEE (50_000_000 / 1_000_000_000).
  */
  uint256 internal constant _FEE_CAP = 50_000_000;

  /**
    @notice
    The protocol project ID is 1, as it should be the first project launched during the deployment process.
  */
  uint256 internal constant _PROTOCOL_PROJECT_ID = 1;

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    Fees that are being held to be processed later.

    _projectId The ID of the project for which fees are being held.
  */
  mapping(uint256 => JBFee[]) internal _heldFeesOf;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership and transfers.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  /**
    @notice
    The contract that stores and manages the terminal's data.
  */
  IJBSingleTokenPaymentTerminalStore public immutable override store;

  /**
    @notice
    The currency to base token issuance on.

    @dev
    If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.
  */
  uint256 public immutable override baseWeightCurrency;

  /**
    @notice
    The group that payout splits coming from this terminal are identified by.
  */
  uint256 public immutable override payoutSplitsGroup;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The platform fee percent.

    @dev
    Out of MAX_FEE (25_000_000 / 1_000_000_000)
  */
  uint256 public override fee = 25_000_000; // 2.5%

  /**
    @notice
    The data source that returns a discount to apply to a project's fee.
  */
  IJBFeeGauge public override feeGauge;

  /**
    @notice
    Addresses that can be paid towards from this terminal without incurring a fee.

    _address The address that can be paid toward.
  */
  mapping(address => bool) public override isFeelessAddress;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.

    @dev
    The current overflow is represented as a fixed point number with 18 decimals.

    @param _projectId The ID of the project to get overflow for.

    @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.
  */
  function currentEthOverflowOf(uint256 _projectId)
    external
    view
    virtual
    override
    returns (uint256)
  {
    // Get this terminal's current overflow.
    uint256 _overflow = store.currentOverflowOf(this, _projectId);

    // Adjust the decimals of the fixed point number if needed to have 18 decimals.
    uint256 _adjustedOverflow = (decimals == 18)
      ? _overflow
      : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);

    // Return the amount converted to ETH.
    return
      (currency == JBCurrencies.ETH)
        ? _adjustedOverflow
        : PRBMath.mulDiv(
          _adjustedOverflow,
          10**decimals,
          prices.priceFor(currency, JBCurrencies.ETH, decimals)
        );
  }

  /**
    @notice
    The fees that are currently being held to be processed later for each project.

    @param _projectId The ID of the project for which fees are being held.

    @return An array of fees that are being held.
  */
  function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {
    return _heldFeesOf[_projectId];
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(JBSingleTokenPaymentTerminal, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||
      _interfaceId == type(IJBPayoutTerminal).interfaceId ||
      _interfaceId == type(IJBAllowanceTerminal).interfaceId ||
      _interfaceId == type(IJBRedemptionTerminal).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _token The token that this terminal manages.
    @param _decimals The number of decimals the token fixed point amounts are expected to have.
    @param _currency The currency that this terminal's token adheres to for price feeds.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _splitsStore A contract that stores splits for each project.
    @param _prices A contract that exposes price feeds.
    @param _store A contract that stores the terminal's data.
    @param _owner The address that will own this contract.
  */
  constructor(
    // payable constructor save the gas used to check msg.value==0
    address _token,
    uint256 _decimals,
    uint256 _currency,
    uint256 _baseWeightCurrency,
    uint256 _payoutSplitsGroup,
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBSplitsStore _splitsStore,
    IJBPrices _prices,
    IJBSingleTokenPaymentTerminalStore _store,
    address _owner
  )
    payable
    JBSingleTokenPaymentTerminal(_token, _decimals, _currency)
    JBOperatable(_operatorStore)
  {
    baseWeightCurrency = _baseWeightCurrency;
    payoutSplitsGroup = _payoutSplitsGroup;
    projects = _projects;
    directory = _directory;
    splitsStore = _splitsStore;
    prices = _prices;
    store = _store;

    transferOwnership(_owner);
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Contribute tokens to a project.

    @param _projectId The ID of the project being paid.
    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _token The token being paid. This terminal ignores this property since it only manages one token. 
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function pay(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {
    _token; // Prevents unused var compiler and natspec complaints.

    // ETH shouldn't be sent if this terminal's token isn't ETH.
    if (token != JBTokens.ETH) {
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If this terminal's token is ETH, override _amount with msg.value.
    else _amount = msg.value;

    return
      _pay(
        _amount,
        msg.sender,
        _projectId,
        _beneficiary,
        _minReturnedTokens,
        _preferClaimedTokens,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _token The token being reclaimed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  )
    external
    virtual
    override
    requirePermission(_holder, _projectId, JBOperations.REDEEM)
    returns (uint256 reclaimAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return
      _redeemTokensOf(
        _holder,
        _projectId,
        _tokenCount,
        _minReturnedTokens,
        _beneficiary,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) external virtual override returns (uint256 netLeftoverDistributionAmount) {
    _token; // Prevents unused var compiler and natspec complaints.

    return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)
    returns (uint256 netDistributedAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);
  }

  /**
    @notice
    Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project being migrated.
    @param _to The terminal contract that will gain the project's funds.

    @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.
  */
  function migrate(uint256 _projectId, IJBPaymentTerminal _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)
    returns (uint256 balance)
  {
    // The terminal being migrated to must accept the same token as this terminal.
    if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE();

    // Record the migration in the store.
    balance = store.recordMigration(_projectId);

    // Transfer the balance if needed.
    if (balance > 0) {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_to), balance);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? balance : 0;

      // Withdraw the balance to transfer to the new terminal;
      _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes(''));
    }

    emit Migrate(_projectId, _to, balance, msg.sender);
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _token The token being paid. This terminal ignores this property since it only manages one currency. 
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) {
    _token; // Prevents unused var compiler and natspec complaints.

    // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender.
    if (token != JBTokens.ETH) {
      // Amount must be greater than 0.
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If the terminal's token is ETH, override `_amount` with msg.value.
    else _amount = msg.value;

    // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal.
    _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);
  }

  /**
    @notice
    Process any fees that are being held for the project.

    @dev
    Only a project owner, an operator, or the contract's owner can process held fees.

    @param _projectId The ID of the project whos held fees should be processed.
  */
  function processFees(uint256 _projectId)
    external
    virtual
    override
    requirePermissionAllowingOverride(
      projects.ownerOf(_projectId),
      _projectId,
      JBOperations.PROCESS_FEES,
      msg.sender == owner()
    )
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the held fees.
    delete _heldFeesOf[_projectId];

    // Push array length in stack
    uint256 _heldFeeLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeeLength; ) {
      // Get the fee amount.
      uint256 _amount = _feeAmount(
        _heldFees[_i].amount,
        _heldFees[_i].fee,
        _heldFees[_i].feeDiscount
      );

      // Process the fee.
      _processFee(_amount, _heldFees[_i].beneficiary);

      emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Allows the fee to be updated.

    @dev
    Only the owner of this contract can change the fee.

    @param _fee The new fee, out of MAX_FEE.
  */
  function setFee(uint256 _fee) external virtual override onlyOwner {
    // The provided fee must be within the max.
    if (_fee > _FEE_CAP) revert FEE_TOO_HIGH();

    // Store the new fee.
    fee = _fee;

    emit SetFee(_fee, msg.sender);
  }

  /**
    @notice
    Allows the fee gauge to be updated.

    @dev
    Only the owner of this contract can change the fee gauge.

    @dev
    If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.

    @param _feeGauge The new fee gauge.
  */
  function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {
    // Store the new fee gauge.
    feeGauge = _feeGauge;

    emit SetFeeGauge(_feeGauge, msg.sender);
  }

  /**
    @notice
    Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.

    @dev
    Only the owner of this contract can set addresses as feeless.

    @param _address The address that can be paid towards while still bypassing fees.
    @param _flag A flag indicating whether the terminal should be feeless or not.
  */
  function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {
    // Set the flag value.
    isFeelessAddress[_address] = _flag;

    emit SetFeelessAddress(_address, _flag, msg.sender);
  }

  //*********************************************************************//
  // ---------------------- internal transactions ---------------------- //
  //*********************************************************************//

  /** 
    @notice
    Transfers tokens.

    @param _from The address from which the transfer should originate.
    @param _to The address to which the transfer should go.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _transferFrom(
    address _from,
    address payable _to,
    uint256 _amount
  ) internal virtual;

  /** 
    @notice
    Logic to be triggered before transferring tokens from this terminal.

    @param _to The address to which the transfer is going.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _beforeTransferTo(address _to, uint256 _amount) internal virtual;

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function _redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 reclaimAmount) {
    // Can't send reclaimed funds to the zero address.
    if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the redemption is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` only used within scope.
    {
      IJBRedemptionDelegate _delegate;

      // Record the redemption.
      (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(
        _holder,
        _projectId,
        _tokenCount,
        _memo,
        _metadata
      );

      // The amount being reclaimed must be at least as much as was expected.
      if (reclaimAmount < _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();

      // Burn the project tokens.
      if (_tokenCount > 0)
        IJBController(directory.controllerOf(_projectId)).burnTokensOf(
          _holder,
          _projectId,
          _tokenCount,
          '',
          false
        );

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBRedemptionDelegate(address(0))) {
        JBDidRedeemData memory _data = JBDidRedeemData(
          _holder,
          _projectId,
          _fundingCycle.configuration,
          _tokenCount,
          JBTokenAmount(token, reclaimAmount, decimals, currency),
          _beneficiary,
          _memo,
          _metadata
        );
        _delegate.didRedeem(_data);
        emit DelegateDidRedeem(_delegate, _data, msg.sender);
      }
    }

    // Send the reclaimed funds to the beneficiary.
    if (reclaimAmount > 0) _transferFrom(address(this), _beneficiary, reclaimAmount);

    emit RedeemTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _holder,
      _beneficiary,
      _tokenCount,
      reclaimAmount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) internal returns (uint256 netLeftoverDistributionAmount) {
    // Record the distribution.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(
      _projectId,
      _amount,
      _currency
    );

    // The amount being distributed must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Get a reference to the project owner, which will receive tokens from paying the platform fee
    // and receive any extra distributable funds not allocated to payout splits.
    address payable _projectOwner = payable(projects.ownerOf(_projectId));

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the fee amount that was paid.
    uint256 _fee;

    // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope.
    {
      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // The amount distributed that is eligible for incurring fees.
      uint256 _feeEligibleDistributionAmount;

      // The amount leftover after distributing to the splits.
      uint256 _leftoverDistributionAmount;

      // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.
      // Also get a reference to the amount that was distributed to splits from which fees should be taken.
      (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        payoutSplitsGroup,
        _distributedAmount,
        _feeDiscount
      );

      // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.
      unchecked {
        _feeEligibleDistributionAmount += _leftoverDistributionAmount;
      }

      // Take the fee.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0
        ? 0
        : _takeFeeFrom(
          _projectId,
          _fundingCycle,
          _feeEligibleDistributionAmount,
          _projectOwner,
          _feeDiscount
        );

      // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.

      unchecked {
        netLeftoverDistributionAmount = _leftoverDistributionAmount == 0
          ? 0
          : _leftoverDistributionAmount -
            _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);
      }

      // Transfer any remaining balance to the project owner.
      if (netLeftoverDistributionAmount > 0)
        _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount);
    }

    emit DistributePayouts(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _projectOwner,
      _amount,
      _distributedAmount,
      _fee,
      netLeftoverDistributionAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function _useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  ) internal returns (uint256 netDistributedAmount) {
    // Record the use of the allowance.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(
      _projectId,
      _amount,
      _currency
    );

    // The amount being withdrawn must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope.
    {
      // Keep a reference to the fee amount that was paid.
      uint256 _fee;

      // Get a reference to the project owner, which will receive tokens from paying the platform fee.
      address _projectOwner = projects.ownerOf(_projectId);

      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // Take a fee from the `_distributedAmount`, if needed.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
        ? 0
        : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);

      unchecked {
        // The net amount is the withdrawn amount without the fee.
        netDistributedAmount = _distributedAmount - _fee;
      }

      // Transfer any remaining balance to the beneficiary.
      if (netDistributedAmount > 0)
        _transferFrom(address(this), _beneficiary, netDistributedAmount);
    }

    emit UseAllowance(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _beneficiary,
      _amount,
      _distributedAmount,
      netDistributedAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Pays out splits for a project's funding cycle configuration.

    @param _projectId The ID of the project for which payout splits are being distributed.
    @param _domain The domain of the splits to distribute the payout between.
    @param _group The group of the splits to distribute the payout between.
    @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return leftoverAmount If the leftover amount if the splits don't add up to 100%.
    @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.
  */
  function _distributeToPayoutSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount,
    uint256 _feeDiscount
  ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's payout splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    // Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; ) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _payoutAmount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // The payout amount substracting any applicable incurred fees.
      uint256 _netPayoutAmount;

      if (_payoutAmount > 0) {
        // Transfer tokens to the split.
        // If there's an allocator set, transfer to its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0))) {
          // If the split allocator is set as feeless, this distribution is not eligible for a fee.
          if (isFeelessAddress[address(_split.allocator)])
            _netPayoutAmount = _payoutAmount;
            // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.
          else {
            unchecked {
              _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                ? _payoutAmount
                : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
            }

            // This distribution is eligible for a fee since the funds are leaving the ecosystem.
            feeEligibleDistributionAmount += _payoutAmount;
          }

          // Trigger any inherited pre-transfer logic.
          _beforeTransferTo(address(_split.allocator), _netPayoutAmount);

          // If this terminal's token is ETH, send it in msg.value.
          uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

          // Create the data to send to the allocator.
          JBSplitAllocationData memory _data = JBSplitAllocationData(
            token,
            _netPayoutAmount,
            decimals,
            _projectId,
            _group,
            _split
          );

          // Trigger the allocator's `allocate` function.
          _split.allocator.allocate{value: _payableValue}(_data);

          // Otherwise, if a project is specified, make a payment to it.
        } else if (_split.projectId != 0) {
          // Get a reference to the Juicebox terminal being used.
          IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);

          // The project must have a terminal to send funds to.
          if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();

          // Save gas if this contract is being used as the terminal.
          if (_terminal == this) {
            // This distribution does not incur a fee.
            _netPayoutAmount = _payoutAmount;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);
            else
              _pay(
                _netPayoutAmount,
                address(this),
                _split.projectId,
                (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          } else {
            // If the terminal is set as feeless, this distribution is not eligible for a fee.
            if (isFeelessAddress[address(_terminal)])
              _netPayoutAmount = _payoutAmount;
              // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.
            else {
              unchecked {
                _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                  ? _payoutAmount
                  : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
              }

              feeEligibleDistributionAmount += _payoutAmount;
            }

            // Trigger any inherited pre-transfer logic.
            _beforeTransferTo(address(_terminal), _netPayoutAmount);

            // If this terminal's token is ETH, send it in msg.value.
            uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _terminal.addToBalanceOf{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                '',
                _projectMetadata
              );
            else
              _terminal.pay{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          }
        } else {
          unchecked {
            _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
              ? _payoutAmount
              : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
          }

          // This distribution is eligible for a fee since the funds are leaving the ecosystem.
          feeEligibleDistributionAmount += _payoutAmount;

          // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.
          _transferFrom(
            address(this),
            _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),
            _netPayoutAmount
          );
        }

        // Subtract from the amount to be sent to the beneficiary.
        unchecked {
          leftoverAmount = leftoverAmount - _payoutAmount;
        }
      }

      emit DistributeToPayoutSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _netPayoutAmount,
        msg.sender
      );

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID.

    @param _projectId The ID of the project having fees taken from.
    @param _fundingCycle The funding cycle during which the fee is being taken.
    @param _amount The amount of the fee to take, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platforms tokens for.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return feeAmount The amount of the fee taken.
  */
  function _takeFeeFrom(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _amount,
    address _beneficiary,
    uint256 _feeDiscount
  ) internal returns (uint256 feeAmount) {
    feeAmount = _feeAmount(_amount, fee, _feeDiscount);

    if (_fundingCycle.shouldHoldFees()) {
      // Store the held fee.
      _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));

      emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender);
    } else {
      // Process the fee.
      _processFee(feeAmount, _beneficiary); // Take the fee.

      emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender);
    }
  }

  /**
    @notice
    Process a fee of the specified amount.

    @param _amount The fee amount, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platform's tokens for.
  */
  function _processFee(uint256 _amount, address _beneficiary) internal {
    // Get the terminal for the protocol project.
    IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token);

    // When processing the admin fee, save gas if the admin is using this contract as its terminal.
    if (_terminal == this)
      _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call.
    else {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_terminal), _amount);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;

      // Send the payment.
      _terminal.pay{value: _payableValue}(
        _PROTOCOL_PROJECT_ID,
        _amount,
        token,
        _beneficiary,
        0,
        false,
        '',
        bytes('')
      ); // Use the external pay call of the correct terminal.
    }
  }

  /**
    @notice
    Contribute tokens to a project.

    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _payer The address making the payment.
    @param _projectId The ID of the project being paid.
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function _pay(
    uint256 _amount,
    address _payer,
    uint256 _projectId,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 beneficiaryTokenCount) {
    // Cant send tokens to the zero address.
    if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the payment is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope.
    {
      IJBPayDelegate _delegate;
      uint256 _tokenCount;

      // Bundle the amount info into a JBTokenAmount struct.
      JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);

      // Record the payment.
      (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(
        _payer,
        _bundledAmount,
        _projectId,
        baseWeightCurrency,
        _beneficiary,
        _memo,
        _metadata
      );

      // Mint the tokens if needed.
      if (_tokenCount > 0)
        // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.
        beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(
          _projectId,
          _tokenCount,
          _beneficiary,
          '',
          _preferClaimedTokens,
          true
        );

      // The token count for the beneficiary must be greater than or equal to the minimum expected.
      if (beneficiaryTokenCount < _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBPayDelegate(address(0))) {
        JBDidPayData memory _data = JBDidPayData(
          _payer,
          _projectId,
          _fundingCycle.configuration,
          _bundledAmount,
          beneficiaryTokenCount,
          _beneficiary,
          _preferClaimedTokens,
          _memo,
          _metadata
        );

        _delegate.didPay(_data);
        emit DelegateDidPay(_delegate, _data, msg.sender);
      }
    }

    emit Pay(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _payer,
      _beneficiary,
      _amount,
      beneficiaryTokenCount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function _addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    bool _shouldRefundHeldFees,
    string memory _memo,
    bytes memory _metadata
  ) internal {
    // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.
    uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0;

    // Record the added funds with any refunded fees.
    store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);

    emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);
  }

  /**
    @notice
    Refund fees based on the specified amount.

    @param _projectId The project for which fees are being refunded.
    @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.

    @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal
  */
  function _refundHeldFees(uint256 _projectId, uint256 _amount)
    internal
    returns (uint256 refundedFees)
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the current held fees.
    delete _heldFeesOf[_projectId];

    // Get a reference to the leftover amount once all fees have been settled.
    uint256 leftoverAmount = _amount;

    // Push length in stack
    uint256 _heldFeesLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeesLength; ) {
      if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);
      else if (leftoverAmount >= _heldFees[_i].amount) {
        unchecked {
          leftoverAmount = leftoverAmount - _heldFees[_i].amount;
          refundedFees += _feeAmount(
            _heldFees[_i].amount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount
          );
        }
      } else {
        _heldFeesOf[_projectId].push(
          JBFee(
            _heldFees[_i].amount - leftoverAmount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount,
            _heldFees[_i].beneficiary
          )
        );
        unchecked {
          refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);
        }
        leftoverAmount = 0;
      }

      unchecked {
        ++_i;
      }
    }

    emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);
  }

  /** 
    @notice 
    Returns the fee amount based on the provided amount for the specified project.

    @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal.
    @param _fee The percentage of the fee, out of MAX_FEE. 
    @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.

    @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _feeAmount(
    uint256 _amount,
    uint256 _fee,
    uint256 _feeDiscount
  ) internal pure returns (uint256) {
    // Calculate the discounted fee.
    uint256 _discountedFee = _fee -
      PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT);

    // The amount of tokens from the `_amount` to pay as a fee.
    return
      _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);
  }

  /** 
    @notice
    Get the fee discount from the fee gauge for the specified project.

    @param _projectId The ID of the project to get a fee discount for.
    
    @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.
  */
  function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {
    // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.
    if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))
      return JBConstants.MAX_FEE_DISCOUNT;

    // Get the fee discount.
    if (feeGauge == IJBFeeGauge(address(0)))
      feeDiscount = 0;
      // If the guage reverts, set the discount to 0.
    else
      try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {
        feeDiscount = discount;
      } catch {
        feeDiscount = 0;
      }

    // If the fee discount is greater than the max, nullify the discount.
    if (feeDiscount > JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;
  }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './../interfaces/IJBController.sol';
import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol';
import './../libraries/JBConstants.sol';
import './../libraries/JBCurrencies.sol';
import './../libraries/JBFixedPointNumber.sol';
import './../libraries/JBFundingCycleMetadataResolver.sol';
import './../libraries/JBOperations.sol';
import './../libraries/JBSplitsGroups.sol';
import './../libraries/JBTokens.sol';
import './../structs/JBTokenAmount.sol';
import './JBOperatable.sol';
import './JBSingleTokenPaymentTerminal.sol';

/**
  @notice
  Generic terminal managing all inflows and outflows of funds into the protocol ecosystem.

  @dev
  A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time.

  @dev
  Adheres to -
  IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.
  JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
abstract contract JBPayoutRedemptionPaymentTerminal is
  IJBPayoutRedemptionPaymentTerminal,
  JBSingleTokenPaymentTerminal,
  JBOperatable,
  Ownable,
  ReentrancyGuard
{
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error FEE_TOO_HIGH();
  error INADEQUATE_DISTRIBUTION_AMOUNT();
  error INADEQUATE_RECLAIM_AMOUNT();
  error INADEQUATE_TOKEN_COUNT();
  error NO_MSG_VALUE_ALLOWED();
  error PAY_TO_ZERO_ADDRESS();
  error PROJECT_TERMINAL_MISMATCH();
  error REDEEM_TO_ZERO_ADDRESS();
  error TERMINAL_IN_SPLIT_ZERO_ADDRESS();
  error TERMINAL_TOKENS_INCOMPATIBLE();

  //*********************************************************************//
  // ---------------------------- modifiers ---------------------------- //
  //*********************************************************************//

  /** 
    @notice 
    A modifier that verifies this terminal is a terminal of provided project ID.
  */
  modifier isTerminalOf(uint256 _projectId) {
    if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();
    _;
  }

  //*********************************************************************//
  // --------------------- internal stored constants ------------------- //
  //*********************************************************************//

  /**
    @notice
    Maximum fee that can be set for a funding cycle configuration.

    @dev
    Out of MAX_FEE (50_000_000 / 1_000_000_000).
  */
  uint256 internal constant _FEE_CAP = 50_000_000;

  /**
    @notice
    The protocol project ID is 1, as it should be the first project launched during the deployment process.
  */
  uint256 internal constant _PROTOCOL_PROJECT_ID = 1;

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    Fees that are being held to be processed later.

    _projectId The ID of the project for which fees are being held.
  */
  mapping(uint256 => JBFee[]) internal _heldFeesOf;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership and transfers.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  /**
    @notice
    The contract that stores and manages the terminal's data.
  */
  IJBSingleTokenPaymentTerminalStore public immutable override store;

  /**
    @notice
    The currency to base token issuance on.

    @dev
    If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.
  */
  uint256 public immutable override baseWeightCurrency;

  /**
    @notice
    The group that payout splits coming from this terminal are identified by.
  */
  uint256 public immutable override payoutSplitsGroup;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The platform fee percent.

    @dev
    Out of MAX_FEE (25_000_000 / 1_000_000_000)
  */
  uint256 public override fee = 25_000_000; // 2.5%

  /**
    @notice
    The data source that returns a discount to apply to a project's fee.
  */
  IJBFeeGauge public override feeGauge;

  /**
    @notice
    Addresses that can be paid towards from this terminal without incurring a fee.

    _address The address that can be paid toward.
  */
  mapping(address => bool) public override isFeelessAddress;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.

    @dev
    The current overflow is represented as a fixed point number with 18 decimals.

    @param _projectId The ID of the project to get overflow for.

    @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.
  */
  function currentEthOverflowOf(uint256 _projectId)
    external
    view
    virtual
    override
    returns (uint256)
  {
    // Get this terminal's current overflow.
    uint256 _overflow = store.currentOverflowOf(this, _projectId);

    // Adjust the decimals of the fixed point number if needed to have 18 decimals.
    uint256 _adjustedOverflow = (decimals == 18)
      ? _overflow
      : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);

    // Return the amount converted to ETH.
    return
      (currency == JBCurrencies.ETH)
        ? _adjustedOverflow
        : PRBMath.mulDiv(
          _adjustedOverflow,
          10**decimals,
          prices.priceFor(currency, JBCurrencies.ETH, decimals)
        );
  }

  /**
    @notice
    The fees that are currently being held to be processed later for each project.

    @param _projectId The ID of the project for which fees are being held.

    @return An array of fees that are being held.
  */
  function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {
    return _heldFeesOf[_projectId];
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(JBSingleTokenPaymentTerminal, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||
      _interfaceId == type(IJBPayoutTerminal).interfaceId ||
      _interfaceId == type(IJBAllowanceTerminal).interfaceId ||
      _interfaceId == type(IJBRedemptionTerminal).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _token The token that this terminal manages.
    @param _decimals The number of decimals the token fixed point amounts are expected to have.
    @param _currency The currency that this terminal's token adheres to for price feeds.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _splitsStore A contract that stores splits for each project.
    @param _prices A contract that exposes price feeds.
    @param _store A contract that stores the terminal's data.
    @param _owner The address that will own this contract.
  */
  constructor(
    // payable constructor save the gas used to check msg.value==0
    address _token,
    uint256 _decimals,
    uint256 _currency,
    uint256 _baseWeightCurrency,
    uint256 _payoutSplitsGroup,
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBSplitsStore _splitsStore,
    IJBPrices _prices,
    IJBSingleTokenPaymentTerminalStore _store,
    address _owner
  )
    payable
    JBSingleTokenPaymentTerminal(_token, _decimals, _currency)
    JBOperatable(_operatorStore)
  {
    baseWeightCurrency = _baseWeightCurrency;
    payoutSplitsGroup = _payoutSplitsGroup;
    projects = _projects;
    directory = _directory;
    splitsStore = _splitsStore;
    prices = _prices;
    store = _store;

    transferOwnership(_owner);
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Contribute tokens to a project.

    @param _projectId The ID of the project being paid.
    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _token The token being paid. This terminal ignores this property since it only manages one token. 
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function pay(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {
    _token; // Prevents unused var compiler and natspec complaints.

    // ETH shouldn't be sent if this terminal's token isn't ETH.
    if (token != JBTokens.ETH) {
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If this terminal's token is ETH, override _amount with msg.value.
    else _amount = msg.value;

    return
      _pay(
        _amount,
        msg.sender,
        _projectId,
        _beneficiary,
        _minReturnedTokens,
        _preferClaimedTokens,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _token The token being reclaimed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  )
    external
    virtual
    override
    requirePermission(_holder, _projectId, JBOperations.REDEEM)
    returns (uint256 reclaimAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return
      _redeemTokensOf(
        _holder,
        _projectId,
        _tokenCount,
        _minReturnedTokens,
        _beneficiary,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) external virtual override returns (uint256 netLeftoverDistributionAmount) {
    _token; // Prevents unused var compiler and natspec complaints.

    return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)
    returns (uint256 netDistributedAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);
  }

  /**
    @notice
    Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project being migrated.
    @param _to The terminal contract that will gain the project's funds.

    @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.
  */
  function migrate(uint256 _projectId, IJBPaymentTerminal _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)
    returns (uint256 balance)
  {
    // The terminal being migrated to must accept the same token as this terminal.
    if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE();

    // Record the migration in the store.
    balance = store.recordMigration(_projectId);

    // Transfer the balance if needed.
    if (balance > 0) {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_to), balance);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? balance : 0;

      // Withdraw the balance to transfer to the new terminal;
      _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes(''));
    }

    emit Migrate(_projectId, _to, balance, msg.sender);
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _token The token being paid. This terminal ignores this property since it only manages one currency. 
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) {
    _token; // Prevents unused var compiler and natspec complaints.

    // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender.
    if (token != JBTokens.ETH) {
      // Amount must be greater than 0.
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If the terminal's token is ETH, override `_amount` with msg.value.
    else _amount = msg.value;

    // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal.
    _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);
  }

  /**
    @notice
    Process any fees that are being held for the project.

    @dev
    Only a project owner, an operator, or the contract's owner can process held fees.

    @param _projectId The ID of the project whos held fees should be processed.
  */
  function processFees(uint256 _projectId)
    external
    virtual
    override
    requirePermissionAllowingOverride(
      projects.ownerOf(_projectId),
      _projectId,
      JBOperations.PROCESS_FEES,
      msg.sender == owner()
    )
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the held fees.
    delete _heldFeesOf[_projectId];

    // Push array length in stack
    uint256 _heldFeeLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeeLength; ) {
      // Get the fee amount.
      uint256 _amount = _feeAmount(
        _heldFees[_i].amount,
        _heldFees[_i].fee,
        _heldFees[_i].feeDiscount
      );

      // Process the fee.
      _processFee(_amount, _heldFees[_i].beneficiary);

      emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Allows the fee to be updated.

    @dev
    Only the owner of this contract can change the fee.

    @param _fee The new fee, out of MAX_FEE.
  */
  function setFee(uint256 _fee) external virtual override onlyOwner {
    // The provided fee must be within the max.
    if (_fee > _FEE_CAP) revert FEE_TOO_HIGH();

    // Store the new fee.
    fee = _fee;

    emit SetFee(_fee, msg.sender);
  }

  /**
    @notice
    Allows the fee gauge to be updated.

    @dev
    Only the owner of this contract can change the fee gauge.

    @dev
    If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.

    @param _feeGauge The new fee gauge.
  */
  function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {
    // Store the new fee gauge.
    feeGauge = _feeGauge;

    emit SetFeeGauge(_feeGauge, msg.sender);
  }

  /**
    @notice
    Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.

    @dev
    Only the owner of this contract can set addresses as feeless.

    @param _address The address that can be paid towards while still bypassing fees.
    @param _flag A flag indicating whether the terminal should be feeless or not.
  */
  function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {
    // Set the flag value.
    isFeelessAddress[_address] = _flag;

    emit SetFeelessAddress(_address, _flag, msg.sender);
  }

  //*********************************************************************//
  // ---------------------- internal transactions ---------------------- //
  //*********************************************************************//

  /** 
    @notice
    Transfers tokens.

    @param _from The address from which the transfer should originate.
    @param _to The address to which the transfer should go.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _transferFrom(
    address _from,
    address payable _to,
    uint256 _amount
  ) internal virtual;

  /** 
    @notice
    Logic to be triggered before transferring tokens from this terminal.

    @param _to The address to which the transfer is going.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _beforeTransferTo(address _to, uint256 _amount) internal virtual;

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function _redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 reclaimAmount) {
    // Can't send reclaimed funds to the zero address.
    if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the redemption is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` only used within scope.
    {
      IJBRedemptionDelegate _delegate;

      // Record the redemption.
      (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(
        _holder,
        _projectId,
        _tokenCount,
        _memo,
        _metadata
      );

      // The amount being reclaimed must be at least as much as was expected.
      if (reclaimAmount < _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();

      // Burn the project tokens.
      if (_tokenCount > 0)
        IJBController(directory.controllerOf(_projectId)).burnTokensOf(
          _holder,
          _projectId,
          _tokenCount,
          '',
          false
        );

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBRedemptionDelegate(address(0))) {
        JBDidRedeemData memory _data = JBDidRedeemData(
          _holder,
          _projectId,
          _fundingCycle.configuration,
          _tokenCount,
          JBTokenAmount(token, reclaimAmount, decimals, currency),
          _beneficiary,
          _memo,
          _metadata
        );
        _delegate.didRedeem(_data);
        emit DelegateDidRedeem(_delegate, _data, msg.sender);
      }
    }

    // Send the reclaimed funds to the beneficiary.
    if (reclaimAmount > 0) _transferFrom(address(this), _beneficiary, reclaimAmount);

    emit RedeemTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _holder,
      _beneficiary,
      _tokenCount,
      reclaimAmount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) internal returns (uint256 netLeftoverDistributionAmount) {
    // Record the distribution.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(
      _projectId,
      _amount,
      _currency
    );

    // The amount being distributed must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Get a reference to the project owner, which will receive tokens from paying the platform fee
    // and receive any extra distributable funds not allocated to payout splits.
    address payable _projectOwner = payable(projects.ownerOf(_projectId));

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the fee amount that was paid.
    uint256 _fee;

    // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope.
    {
      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // The amount distributed that is eligible for incurring fees.
      uint256 _feeEligibleDistributionAmount;

      // The amount leftover after distributing to the splits.
      uint256 _leftoverDistributionAmount;

      // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.
      // Also get a reference to the amount that was distributed to splits from which fees should be taken.
      (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        payoutSplitsGroup,
        _distributedAmount,
        _feeDiscount
      );

      // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.
      unchecked {
        _feeEligibleDistributionAmount += _leftoverDistributionAmount;
      }

      // Take the fee.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0
        ? 0
        : _takeFeeFrom(
          _projectId,
          _fundingCycle,
          _feeEligibleDistributionAmount,
          _projectOwner,
          _feeDiscount
        );

      // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.

      unchecked {
        netLeftoverDistributionAmount = _leftoverDistributionAmount == 0
          ? 0
          : _leftoverDistributionAmount -
            _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);
      }

      // Transfer any remaining balance to the project owner.
      if (netLeftoverDistributionAmount > 0)
        _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount);
    }

    emit DistributePayouts(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _projectOwner,
      _amount,
      _distributedAmount,
      _fee,
      netLeftoverDistributionAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function _useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  ) internal returns (uint256 netDistributedAmount) {
    // Record the use of the allowance.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(
      _projectId,
      _amount,
      _currency
    );

    // The amount being withdrawn must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope.
    {
      // Keep a reference to the fee amount that was paid.
      uint256 _fee;

      // Get a reference to the project owner, which will receive tokens from paying the platform fee.
      address _projectOwner = projects.ownerOf(_projectId);

      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // Take a fee from the `_distributedAmount`, if needed.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
        ? 0
        : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);

      unchecked {
        // The net amount is the withdrawn amount without the fee.
        netDistributedAmount = _distributedAmount - _fee;
      }

      // Transfer any remaining balance to the beneficiary.
      if (netDistributedAmount > 0)
        _transferFrom(address(this), _beneficiary, netDistributedAmount);
    }

    emit UseAllowance(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _beneficiary,
      _amount,
      _distributedAmount,
      netDistributedAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Pays out splits for a project's funding cycle configuration.

    @param _projectId The ID of the project for which payout splits are being distributed.
    @param _domain The domain of the splits to distribute the payout between.
    @param _group The group of the splits to distribute the payout between.
    @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return leftoverAmount If the leftover amount if the splits don't add up to 100%.
    @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.
  */
  function _distributeToPayoutSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount,
    uint256 _feeDiscount
  ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's payout splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    // Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; ) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _payoutAmount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // The payout amount substracting any applicable incurred fees.
      uint256 _netPayoutAmount;

      if (_payoutAmount > 0) {
        // Transfer tokens to the split.
        // If there's an allocator set, transfer to its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0))) {
          // If the split allocator is set as feeless, this distribution is not eligible for a fee.
          if (isFeelessAddress[address(_split.allocator)])
            _netPayoutAmount = _payoutAmount;
            // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.
          else {
            unchecked {
              _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                ? _payoutAmount
                : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
            }

            // This distribution is eligible for a fee since the funds are leaving the ecosystem.
            feeEligibleDistributionAmount += _payoutAmount;
          }

          // Trigger any inherited pre-transfer logic.
          _beforeTransferTo(address(_split.allocator), _netPayoutAmount);

          // If this terminal's token is ETH, send it in msg.value.
          uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

          // Create the data to send to the allocator.
          JBSplitAllocationData memory _data = JBSplitAllocationData(
            token,
            _netPayoutAmount,
            decimals,
            _projectId,
            _group,
            _split
          );

          // Trigger the allocator's `allocate` function.
          _split.allocator.allocate{value: _payableValue}(_data);

          // Otherwise, if a project is specified, make a payment to it.
        } else if (_split.projectId != 0) {
          // Get a reference to the Juicebox terminal being used.
          IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);

          // The project must have a terminal to send funds to.
          if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();

          // Save gas if this contract is being used as the terminal.
          if (_terminal == this) {
            // This distribution does not incur a fee.
            _netPayoutAmount = _payoutAmount;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);
            else
              _pay(
                _netPayoutAmount,
                address(this),
                _split.projectId,
                (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          } else {
            // If the terminal is set as feeless, this distribution is not eligible for a fee.
            if (isFeelessAddress[address(_terminal)])
              _netPayoutAmount = _payoutAmount;
              // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.
            else {
              unchecked {
                _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                  ? _payoutAmount
                  : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
              }

              feeEligibleDistributionAmount += _payoutAmount;
            }

            // Trigger any inherited pre-transfer logic.
            _beforeTransferTo(address(_terminal), _netPayoutAmount);

            // If this terminal's token is ETH, send it in msg.value.
            uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _terminal.addToBalanceOf{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                '',
                _projectMetadata
              );
            else
              _terminal.pay{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          }
        } else {
          unchecked {
            _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
              ? _payoutAmount
              : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
          }

          // This distribution is eligible for a fee since the funds are leaving the ecosystem.
          feeEligibleDistributionAmount += _payoutAmount;

          // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.
          _transferFrom(
            address(this),
            _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),
            _netPayoutAmount
          );
        }

        // Subtract from the amount to be sent to the beneficiary.
        unchecked {
          leftoverAmount = leftoverAmount - _payoutAmount;
        }
      }

      emit DistributeToPayoutSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _netPayoutAmount,
        msg.sender
      );

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID.

    @param _projectId The ID of the project having fees taken from.
    @param _fundingCycle The funding cycle during which the fee is being taken.
    @param _amount The amount of the fee to take, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platforms tokens for.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return feeAmount The amount of the fee taken.
  */
  function _takeFeeFrom(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _amount,
    address _beneficiary,
    uint256 _feeDiscount
  ) internal returns (uint256 feeAmount) {
    feeAmount = _feeAmount(_amount, fee, _feeDiscount);

    if (_fundingCycle.shouldHoldFees()) {
      // Store the held fee.
      _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));

      emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender);
    } else {
      // Process the fee.
      _processFee(feeAmount, _beneficiary); // Take the fee.

      emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender);
    }
  }

  /**
    @notice
    Process a fee of the specified amount.

    @param _amount The fee amount, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platform's tokens for.
  */
  function _processFee(uint256 _amount, address _beneficiary) internal {
    // Get the terminal for the protocol project.
    IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token);

    // When processing the admin fee, save gas if the admin is using this contract as its terminal.
    if (_terminal == this)
      _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call.
    else {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_terminal), _amount);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;

      // Send the payment.
      _terminal.pay{value: _payableValue}(
        _PROTOCOL_PROJECT_ID,
        _amount,
        token,
        _beneficiary,
        0,
        false,
        '',
        bytes('')
      ); // Use the external pay call of the correct terminal.
    }
  }

  /**
    @notice
    Contribute tokens to a project.

    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _payer The address making the payment.
    @param _projectId The ID of the project being paid.
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function _pay(
    uint256 _amount,
    address _payer,
    uint256 _projectId,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 beneficiaryTokenCount) {
    // Cant send tokens to the zero address.
    if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the payment is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope.
    {
      IJBPayDelegate _delegate;
      uint256 _tokenCount;

      // Bundle the amount info into a JBTokenAmount struct.
      JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);

      // Record the payment.
      (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(
        _payer,
        _bundledAmount,
        _projectId,
        baseWeightCurrency,
        _beneficiary,
        _memo,
        _metadata
      );

      // Mint the tokens if needed.
      if (_tokenCount > 0)
        // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.
        beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(
          _projectId,
          _tokenCount,
          _beneficiary,
          '',
          _preferClaimedTokens,
          true
        );

      // The token count for the beneficiary must be greater than or equal to the minimum expected.
      if (beneficiaryTokenCount < _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBPayDelegate(address(0))) {
        JBDidPayData memory _data = JBDidPayData(
          _payer,
          _projectId,
          _fundingCycle.configuration,
          _bundledAmount,
          beneficiaryTokenCount,
          _beneficiary,
          _preferClaimedTokens,
          _memo,
          _metadata
        );

        _delegate.didPay(_data);
        emit DelegateDidPay(_delegate, _data, msg.sender);
      }
    }

    emit Pay(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _payer,
      _beneficiary,
      _amount,
      beneficiaryTokenCount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function _addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    bool _shouldRefundHeldFees,
    string memory _memo,
    bytes memory _metadata
  ) internal {
    // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.
    uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0;

    // Record the added funds with any refunded fees.
    store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);

    emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);
  }

  /**
    @notice
    Refund fees based on the specified amount.

    @param _projectId The project for which fees are being refunded.
    @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.

    @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal
  */
  function _refundHeldFees(uint256 _projectId, uint256 _amount)
    internal
    returns (uint256 refundedFees)
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the current held fees.
    delete _heldFeesOf[_projectId];

    // Get a reference to the leftover amount once all fees have been settled.
    uint256 leftoverAmount = _amount;

    // Push length in stack
    uint256 _heldFeesLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeesLength; ) {
      if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);
      else if (leftoverAmount >= _heldFees[_i].amount) {
        unchecked {
          leftoverAmount = leftoverAmount - _heldFees[_i].amount;
          refundedFees += _feeAmount(
            _heldFees[_i].amount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount
          );
        }
      } else {
        _heldFeesOf[_projectId].push(
          JBFee(
            _heldFees[_i].amount - leftoverAmount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount,
            _heldFees[_i].beneficiary
          )
        );
        unchecked {
          refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);
        }
        leftoverAmount = 0;
      }

      unchecked {
        ++_i;
      }
    }

    emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);
  }

  /** 
    @notice 
    Returns the fee amount based on the provided amount for the specified project.

    @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal.
    @param _fee The percentage of the fee, out of MAX_FEE. 
    @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.

    @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _feeAmount(
    uint256 _amount,
    uint256 _fee,
    uint256 _feeDiscount
  ) internal pure returns (uint256) {
    // Calculate the discounted fee.
    uint256 _discountedFee = _fee -
      PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT);

    // The amount of tokens from the `_amount` to pay as a fee.
    return
      _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);
  }

  /** 
    @notice
    Get the fee discount from the fee gauge for the specified project.

    @param _projectId The ID of the project to get a fee discount for.
    
    @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.
  */
  function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {
    // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.
    if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))
      return JBConstants.MAX_FEE_DISCOUNT;

    // Get the fee discount.
    if (feeGauge == IJBFeeGauge(address(0)))
      feeDiscount = 0;
      // If the guage reverts, set the discount to 0.
    else
      try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {
        feeDiscount = discount;
      } catch {
        feeDiscount = 0;
      }

    // If the fee discount is greater than the max, nullify the discount.
    if (feeDiscount > JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;
  }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-01-09 17:17:43 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 17:17:43 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 25445
completion_tokens: 1
total_tokens: 25446
cost: $-1.000000


[2024-01-09 17:17:43 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './../interfaces/IJBController.sol';
import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol';
import './../libraries/JBConstants.sol';
import './../libraries/JBCurrencies.sol';
import './../libraries/JBFixedPointNumber.sol';
import './../libraries/JBFundingCycleMetadataResolver.sol';
import './../libraries/JBOperations.sol';
import './../libraries/JBSplitsGroups.sol';
import './../libraries/JBTokens.sol';
import './../structs/JBTokenAmount.sol';
import './JBOperatable.sol';
import './JBSingleTokenPaymentTerminal.sol';

/**
  @notice
  Generic terminal managing all inflows and outflows of funds into the protocol ecosystem.

  @dev
  A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time.

  @dev
  Adheres to -
  IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.
  JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
abstract contract JBPayoutRedemptionPaymentTerminal is
  IJBPayoutRedemptionPaymentTerminal,
  JBSingleTokenPaymentTerminal,
  JBOperatable,
  Ownable,
  ReentrancyGuard
{
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error FEE_TOO_HIGH();
  error INADEQUATE_DISTRIBUTION_AMOUNT();
  error INADEQUATE_RECLAIM_AMOUNT();
  error INADEQUATE_TOKEN_COUNT();
  error NO_MSG_VALUE_ALLOWED();
  error PAY_TO_ZERO_ADDRESS();
  error PROJECT_TERMINAL_MISMATCH();
  error REDEEM_TO_ZERO_ADDRESS();
  error TERMINAL_IN_SPLIT_ZERO_ADDRESS();
  error TERMINAL_TOKENS_INCOMPATIBLE();

  //*********************************************************************//
  // ---------------------------- modifiers ---------------------------- //
  //*********************************************************************//

  /** 
    @notice 
    A modifier that verifies this terminal is a terminal of provided project ID.
  */
  modifier isTerminalOf(uint256 _projectId) {
    if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();
    _;
  }

  //*********************************************************************//
  // --------------------- internal stored constants ------------------- //
  //*********************************************************************//

  /**
    @notice
    Maximum fee that can be set for a funding cycle configuration.

    @dev
    Out of MAX_FEE (50_000_000 / 1_000_000_000).
  */
  uint256 internal constant _FEE_CAP = 50_000_000;

  /**
    @notice
    The protocol project ID is 1, as it should be the first project launched during the deployment process.
  */
  uint256 internal constant _PROTOCOL_PROJECT_ID = 1;

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    Fees that are being held to be processed later.

    _projectId The ID of the project for which fees are being held.
  */
  mapping(uint256 => JBFee[]) internal _heldFeesOf;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership and transfers.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  /**
    @notice
    The contract that stores and manages the terminal's data.
  */
  IJBSingleTokenPaymentTerminalStore public immutable override store;

  /**
    @notice
    The currency to base token issuance on.

    @dev
    If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.
  */
  uint256 public immutable override baseWeightCurrency;

  /**
    @notice
    The group that payout splits coming from this terminal are identified by.
  */
  uint256 public immutable override payoutSplitsGroup;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The platform fee percent.

    @dev
    Out of MAX_FEE (25_000_000 / 1_000_000_000)
  */
  uint256 public override fee = 25_000_000; // 2.5%

  /**
    @notice
    The data source that returns a discount to apply to a project's fee.
  */
  IJBFeeGauge public override feeGauge;

  /**
    @notice
    Addresses that can be paid towards from this terminal without incurring a fee.

    _address The address that can be paid toward.
  */
  mapping(address => bool) public override isFeelessAddress;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.

    @dev
    The current overflow is represented as a fixed point number with 18 decimals.

    @param _projectId The ID of the project to get overflow for.

    @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.
  */
  function currentEthOverflowOf(uint256 _projectId)
    external
    view
    virtual
    override
    returns (uint256)
  {
    // Get this terminal's current overflow.
    uint256 _overflow = store.currentOverflowOf(this, _projectId);

    // Adjust the decimals of the fixed point number if needed to have 18 decimals.
    uint256 _adjustedOverflow = (decimals == 18)
      ? _overflow
      : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);

    // Return the amount converted to ETH.
    return
      (currency == JBCurrencies.ETH)
        ? _adjustedOverflow
        : PRBMath.mulDiv(
          _adjustedOverflow,
          10**decimals,
          prices.priceFor(currency, JBCurrencies.ETH, decimals)
        );
  }

  /**
    @notice
    The fees that are currently being held to be processed later for each project.

    @param _projectId The ID of the project for which fees are being held.

    @return An array of fees that are being held.
  */
  function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {
    return _heldFeesOf[_projectId];
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(JBSingleTokenPaymentTerminal, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||
      _interfaceId == type(IJBPayoutTerminal).interfaceId ||
      _interfaceId == type(IJBAllowanceTerminal).interfaceId ||
      _interfaceId == type(IJBRedemptionTerminal).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _token The token that this terminal manages.
    @param _decimals The number of decimals the token fixed point amounts are expected to have.
    @param _currency The currency that this terminal's token adheres to for price feeds.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _splitsStore A contract that stores splits for each project.
    @param _prices A contract that exposes price feeds.
    @param _store A contract that stores the terminal's data.
    @param _owner The address that will own this contract.
  */
  constructor(
    // payable constructor save the gas used to check msg.value==0
    address _token,
    uint256 _decimals,
    uint256 _currency,
    uint256 _baseWeightCurrency,
    uint256 _payoutSplitsGroup,
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBSplitsStore _splitsStore,
    IJBPrices _prices,
    IJBSingleTokenPaymentTerminalStore _store,
    address _owner
  )
    payable
    JBSingleTokenPaymentTerminal(_token, _decimals, _currency)
    JBOperatable(_operatorStore)
  {
    baseWeightCurrency = _baseWeightCurrency;
    payoutSplitsGroup = _payoutSplitsGroup;
    projects = _projects;
    directory = _directory;
    splitsStore = _splitsStore;
    prices = _prices;
    store = _store;

    transferOwnership(_owner);
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Contribute tokens to a project.

    @param _projectId The ID of the project being paid.
    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _token The token being paid. This terminal ignores this property since it only manages one token. 
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function pay(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {
    _token; // Prevents unused var compiler and natspec complaints.

    // ETH shouldn't be sent if this terminal's token isn't ETH.
    if (token != JBTokens.ETH) {
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If this terminal's token is ETH, override _amount with msg.value.
    else _amount = msg.value;

    return
      _pay(
        _amount,
        msg.sender,
        _projectId,
        _beneficiary,
        _minReturnedTokens,
        _preferClaimedTokens,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _token The token being reclaimed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  )
    external
    virtual
    override
    requirePermission(_holder, _projectId, JBOperations.REDEEM)
    returns (uint256 reclaimAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return
      _redeemTokensOf(
        _holder,
        _projectId,
        _tokenCount,
        _minReturnedTokens,
        _beneficiary,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) external virtual override returns (uint256 netLeftoverDistributionAmount) {
    _token; // Prevents unused var compiler and natspec complaints.

    return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)
    returns (uint256 netDistributedAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);
  }

  /**
    @notice
    Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project being migrated.
    @param _to The terminal contract that will gain the project's funds.

    @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.
  */
  function migrate(uint256 _projectId, IJBPaymentTerminal _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)
    returns (uint256 balance)
  {
    // The terminal being migrated to must accept the same token as this terminal.
    if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE();

    // Record the migration in the store.
    balance = store.recordMigration(_projectId);

    // Transfer the balance if needed.
    if (balance > 0) {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_to), balance);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? balance : 0;

      // Withdraw the balance to transfer to the new terminal;
      _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes(''));
    }

    emit Migrate(_projectId, _to, balance, msg.sender);
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _token The token being paid. This terminal ignores this property since it only manages one currency. 
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) {
    _token; // Prevents unused var compiler and natspec complaints.

    // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender.
    if (token != JBTokens.ETH) {
      // Amount must be greater than 0.
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If the terminal's token is ETH, override `_amount` with msg.value.
    else _amount = msg.value;

    // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal.
    _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);
  }

  /**
    @notice
    Process any fees that are being held for the project.

    @dev
    Only a project owner, an operator, or the contract's owner can process held fees.

    @param _projectId The ID of the project whos held fees should be processed.
  */
  function processFees(uint256 _projectId)
    external
    virtual
    override
    requirePermissionAllowingOverride(
      projects.ownerOf(_projectId),
      _projectId,
      JBOperations.PROCESS_FEES,
      msg.sender == owner()
    )
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the held fees.
    delete _heldFeesOf[_projectId];

    // Push array length in stack
    uint256 _heldFeeLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeeLength; ) {
      // Get the fee amount.
      uint256 _amount = _feeAmount(
        _heldFees[_i].amount,
        _heldFees[_i].fee,
        _heldFees[_i].feeDiscount
      );

      // Process the fee.
      _processFee(_amount, _heldFees[_i].beneficiary);

      emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Allows the fee to be updated.

    @dev
    Only the owner of this contract can change the fee.

    @param _fee The new fee, out of MAX_FEE.
  */
  function setFee(uint256 _fee) external virtual override onlyOwner {
    // The provided fee must be within the max.
    if (_fee > _FEE_CAP) revert FEE_TOO_HIGH();

    // Store the new fee.
    fee = _fee;

    emit SetFee(_fee, msg.sender);
  }

  /**
    @notice
    Allows the fee gauge to be updated.

    @dev
    Only the owner of this contract can change the fee gauge.

    @dev
    If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.

    @param _feeGauge The new fee gauge.
  */
  function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {
    // Store the new fee gauge.
    feeGauge = _feeGauge;

    emit SetFeeGauge(_feeGauge, msg.sender);
  }

  /**
    @notice
    Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.

    @dev
    Only the owner of this contract can set addresses as feeless.

    @param _address The address that can be paid towards while still bypassing fees.
    @param _flag A flag indicating whether the terminal should be feeless or not.
  */
  function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {
    // Set the flag value.
    isFeelessAddress[_address] = _flag;

    emit SetFeelessAddress(_address, _flag, msg.sender);
  }

  //*********************************************************************//
  // ---------------------- internal transactions ---------------------- //
  //*********************************************************************//

  /** 
    @notice
    Transfers tokens.

    @param _from The address from which the transfer should originate.
    @param _to The address to which the transfer should go.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _transferFrom(
    address _from,
    address payable _to,
    uint256 _amount
  ) internal virtual;

  /** 
    @notice
    Logic to be triggered before transferring tokens from this terminal.

    @param _to The address to which the transfer is going.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _beforeTransferTo(address _to, uint256 _amount) internal virtual;

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function _redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 reclaimAmount) {
    // Can't send reclaimed funds to the zero address.
    if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the redemption is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` only used within scope.
    {
      IJBRedemptionDelegate _delegate;

      // Record the redemption.
      (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(
        _holder,
        _projectId,
        _tokenCount,
        _memo,
        _metadata
      );

      // The amount being reclaimed must be at least as much as was expected.
      if (reclaimAmount < _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();

      // Burn the project tokens.
      if (_tokenCount > 0)
        IJBController(directory.controllerOf(_projectId)).burnTokensOf(
          _holder,
          _projectId,
          _tokenCount,
          '',
          false
        );

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBRedemptionDelegate(address(0))) {
        JBDidRedeemData memory _data = JBDidRedeemData(
          _holder,
          _projectId,
          _fundingCycle.configuration,
          _tokenCount,
          JBTokenAmount(token, reclaimAmount, decimals, currency),
          _beneficiary,
          _memo,
          _metadata
        );
        _delegate.didRedeem(_data);
        emit DelegateDidRedeem(_delegate, _data, msg.sender);
      }
    }

    // Send the reclaimed funds to the beneficiary.
    if (reclaimAmount > 0) _transferFrom(address(this), _beneficiary, reclaimAmount);

    emit RedeemTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _holder,
      _beneficiary,
      _tokenCount,
      reclaimAmount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) internal returns (uint256 netLeftoverDistributionAmount) {
    // Record the distribution.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(
      _projectId,
      _amount,
      _currency
    );

    // The amount being distributed must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Get a reference to the project owner, which will receive tokens from paying the platform fee
    // and receive any extra distributable funds not allocated to payout splits.
    address payable _projectOwner = payable(projects.ownerOf(_projectId));

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the fee amount that was paid.
    uint256 _fee;

    // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope.
    {
      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // The amount distributed that is eligible for incurring fees.
      uint256 _feeEligibleDistributionAmount;

      // The amount leftover after distributing to the splits.
      uint256 _leftoverDistributionAmount;

      // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.
      // Also get a reference to the amount that was distributed to splits from which fees should be taken.
      (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        payoutSplitsGroup,
        _distributedAmount,
        _feeDiscount
      );

      // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.
      unchecked {
        _feeEligibleDistributionAmount += _leftoverDistributionAmount;
      }

      // Take the fee.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0
        ? 0
        : _takeFeeFrom(
          _projectId,
          _fundingCycle,
          _feeEligibleDistributionAmount,
          _projectOwner,
          _feeDiscount
        );

      // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.

      unchecked {
        netLeftoverDistributionAmount = _leftoverDistributionAmount == 0
          ? 0
          : _leftoverDistributionAmount -
            _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);
      }

      // Transfer any remaining balance to the project owner.
      if (netLeftoverDistributionAmount > 0)
        _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount);
    }

    emit DistributePayouts(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _projectOwner,
      _amount,
      _distributedAmount,
      _fee,
      netLeftoverDistributionAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function _useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  ) internal returns (uint256 netDistributedAmount) {
    // Record the use of the allowance.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(
      _projectId,
      _amount,
      _currency
    );

    // The amount being withdrawn must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope.
    {
      // Keep a reference to the fee amount that was paid.
      uint256 _fee;

      // Get a reference to the project owner, which will receive tokens from paying the platform fee.
      address _projectOwner = projects.ownerOf(_projectId);

      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // Take a fee from the `_distributedAmount`, if needed.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
        ? 0
        : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);

      unchecked {
        // The net amount is the withdrawn amount without the fee.
        netDistributedAmount = _distributedAmount - _fee;
      }

      // Transfer any remaining balance to the beneficiary.
      if (netDistributedAmount > 0)
        _transferFrom(address(this), _beneficiary, netDistributedAmount);
    }

    emit UseAllowance(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _beneficiary,
      _amount,
      _distributedAmount,
      netDistributedAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Pays out splits for a project's funding cycle configuration.

    @param _projectId The ID of the project for which payout splits are being distributed.
    @param _domain The domain of the splits to distribute the payout between.
    @param _group The group of the splits to distribute the payout between.
    @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return leftoverAmount If the leftover amount if the splits don't add up to 100%.
    @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.
  */
  function _distributeToPayoutSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount,
    uint256 _feeDiscount
  ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's payout splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    // Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; ) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _payoutAmount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // The payout amount substracting any applicable incurred fees.
      uint256 _netPayoutAmount;

      if (_payoutAmount > 0) {
        // Transfer tokens to the split.
        // If there's an allocator set, transfer to its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0))) {
          // If the split allocator is set as feeless, this distribution is not eligible for a fee.
          if (isFeelessAddress[address(_split.allocator)])
            _netPayoutAmount = _payoutAmount;
            // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.
          else {
            unchecked {
              _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                ? _payoutAmount
                : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
            }

            // This distribution is eligible for a fee since the funds are leaving the ecosystem.
            feeEligibleDistributionAmount += _payoutAmount;
          }

          // Trigger any inherited pre-transfer logic.
          _beforeTransferTo(address(_split.allocator), _netPayoutAmount);

          // If this terminal's token is ETH, send it in msg.value.
          uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

          // Create the data to send to the allocator.
          JBSplitAllocationData memory _data = JBSplitAllocationData(
            token,
            _netPayoutAmount,
            decimals,
            _projectId,
            _group,
            _split
          );

          // Trigger the allocator's `allocate` function.
          _split.allocator.allocate{value: _payableValue}(_data);

          // Otherwise, if a project is specified, make a payment to it.
        } else if (_split.projectId != 0) {
          // Get a reference to the Juicebox terminal being used.
          IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);

          // The project must have a terminal to send funds to.
          if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();

          // Save gas if this contract is being used as the terminal.
          if (_terminal == this) {
            // This distribution does not incur a fee.
            _netPayoutAmount = _payoutAmount;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);
            else
              _pay(
                _netPayoutAmount,
                address(this),
                _split.projectId,
                (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          } else {
            // If the terminal is set as feeless, this distribution is not eligible for a fee.
            if (isFeelessAddress[address(_terminal)])
              _netPayoutAmount = _payoutAmount;
              // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.
            else {
              unchecked {
                _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                  ? _payoutAmount
                  : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
              }

              feeEligibleDistributionAmount += _payoutAmount;
            }

            // Trigger any inherited pre-transfer logic.
            _beforeTransferTo(address(_terminal), _netPayoutAmount);

            // If this terminal's token is ETH, send it in msg.value.
            uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _terminal.addToBalanceOf{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                '',
                _projectMetadata
              );
            else
              _terminal.pay{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          }
        } else {
          unchecked {
            _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
              ? _payoutAmount
              : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
          }

          // This distribution is eligible for a fee since the funds are leaving the ecosystem.
          feeEligibleDistributionAmount += _payoutAmount;

          // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.
          _transferFrom(
            address(this),
            _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),
            _netPayoutAmount
          );
        }

        // Subtract from the amount to be sent to the beneficiary.
        unchecked {
          leftoverAmount = leftoverAmount - _payoutAmount;
        }
      }

      emit DistributeToPayoutSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _netPayoutAmount,
        msg.sender
      );

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID.

    @param _projectId The ID of the project having fees taken from.
    @param _fundingCycle The funding cycle during which the fee is being taken.
    @param _amount The amount of the fee to take, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platforms tokens for.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return feeAmount The amount of the fee taken.
  */
  function _takeFeeFrom(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _amount,
    address _beneficiary,
    uint256 _feeDiscount
  ) internal returns (uint256 feeAmount) {
    feeAmount = _feeAmount(_amount, fee, _feeDiscount);

    if (_fundingCycle.shouldHoldFees()) {
      // Store the held fee.
      _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));

      emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender);
    } else {
      // Process the fee.
      _processFee(feeAmount, _beneficiary); // Take the fee.

      emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender);
    }
  }

  /**
    @notice
    Process a fee of the specified amount.

    @param _amount The fee amount, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platform's tokens for.
  */
  function _processFee(uint256 _amount, address _beneficiary) internal {
    // Get the terminal for the protocol project.
    IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token);

    // When processing the admin fee, save gas if the admin is using this contract as its terminal.
    if (_terminal == this)
      _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call.
    else {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_terminal), _amount);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;

      // Send the payment.
      _terminal.pay{value: _payableValue}(
        _PROTOCOL_PROJECT_ID,
        _amount,
        token,
        _beneficiary,
        0,
        false,
        '',
        bytes('')
      ); // Use the external pay call of the correct terminal.
    }
  }

  /**
    @notice
    Contribute tokens to a project.

    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _payer The address making the payment.
    @param _projectId The ID of the project being paid.
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function _pay(
    uint256 _amount,
    address _payer,
    uint256 _projectId,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 beneficiaryTokenCount) {
    // Cant send tokens to the zero address.
    if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the payment is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope.
    {
      IJBPayDelegate _delegate;
      uint256 _tokenCount;

      // Bundle the amount info into a JBTokenAmount struct.
      JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);

      // Record the payment.
      (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(
        _payer,
        _bundledAmount,
        _projectId,
        baseWeightCurrency,
        _beneficiary,
        _memo,
        _metadata
      );

      // Mint the tokens if needed.
      if (_tokenCount > 0)
        // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.
        beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(
          _projectId,
          _tokenCount,
          _beneficiary,
          '',
          _preferClaimedTokens,
          true
        );

      // The token count for the beneficiary must be greater than or equal to the minimum expected.
      if (beneficiaryTokenCount < _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBPayDelegate(address(0))) {
        JBDidPayData memory _data = JBDidPayData(
          _payer,
          _projectId,
          _fundingCycle.configuration,
          _bundledAmount,
          beneficiaryTokenCount,
          _beneficiary,
          _preferClaimedTokens,
          _memo,
          _metadata
        );

        _delegate.didPay(_data);
        emit DelegateDidPay(_delegate, _data, msg.sender);
      }
    }

    emit Pay(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _payer,
      _beneficiary,
      _amount,
      beneficiaryTokenCount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function _addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    bool _shouldRefundHeldFees,
    string memory _memo,
    bytes memory _metadata
  ) internal {
    // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.
    uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0;

    // Record the added funds with any refunded fees.
    store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);

    emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);
  }

  /**
    @notice
    Refund fees based on the specified amount.

    @param _projectId The project for which fees are being refunded.
    @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.

    @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal
  */
  function _refundHeldFees(uint256 _projectId, uint256 _amount)
    internal
    returns (uint256 refundedFees)
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the current held fees.
    delete _heldFeesOf[_projectId];

    // Get a reference to the leftover amount once all fees have been settled.
    uint256 leftoverAmount = _amount;

    // Push length in stack
    uint256 _heldFeesLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeesLength; ) {
      if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);
      else if (leftoverAmount >= _heldFees[_i].amount) {
        unchecked {
          leftoverAmount = leftoverAmount - _heldFees[_i].amount;
          refundedFees += _feeAmount(
            _heldFees[_i].amount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount
          );
        }
      } else {
        _heldFeesOf[_projectId].push(
          JBFee(
            _heldFees[_i].amount - leftoverAmount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount,
            _heldFees[_i].beneficiary
          )
        );
        unchecked {
          refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);
        }
        leftoverAmount = 0;
      }

      unchecked {
        ++_i;
      }
    }

    emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);
  }

  /** 
    @notice 
    Returns the fee amount based on the provided amount for the specified project.

    @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal.
    @param _fee The percentage of the fee, out of MAX_FEE. 
    @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.

    @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _feeAmount(
    uint256 _amount,
    uint256 _fee,
    uint256 _feeDiscount
  ) internal pure returns (uint256) {
    // Calculate the discounted fee.
    uint256 _discountedFee = _fee -
      PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT);

    // The amount of tokens from the `_amount` to pay as a fee.
    return
      _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);
  }

  /** 
    @notice
    Get the fee discount from the fee gauge for the specified project.

    @param _projectId The ID of the project to get a fee discount for.
    
    @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.
  */
  function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {
    // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.
    if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))
      return JBConstants.MAX_FEE_DISCOUNT;

    // Get the fee discount.
    if (feeGauge == IJBFeeGauge(address(0)))
      feeDiscount = 0;
      // If the guage reverts, set the discount to 0.
    else
      try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {
        feeDiscount = discount;
      } catch {
        feeDiscount = 0;
      }

    // If the fee discount is greater than the max, nullify the discount.
    if (feeDiscount > JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;
  }
}
.]

###

[2024-01-09 17:17:43 INFO] **[Seminar Conclusion]**:

 ###

[2024-01-09 17:17:43 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-01-09 17:17:43 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/security/ReentrancyGuard.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './../interfaces/IJBController.sol'; import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol'; import './../libraries/JBConstants.sol'; import './../libraries/JBCurrencies.sol'; import './../libraries/JBFixedPointNumber.sol'; import './../libraries/JBFundingCycleMetadataResolver.sol'; import './../libraries/JBOperations.sol'; import './../libraries/JBSplitsGroups.sol'; import './../libraries/JBTokens.sol'; import './../structs/JBTokenAmount.sol'; import './JBOperatable.sol'; import './JBSingleTokenPaymentTerminal.sol'; /**   @notice   Generic terminal managing all inflows and outflows of funds into the protocol ecosystem. @dev   A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time. @dev   Adheres to -   IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules. @dev   Inherits from -   JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.   JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.   Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.   ReentrancyGuard: Contract module that helps prevent reentrant calls to a function. */ abstract contract JBPayoutRedemptionPaymentTerminal is   IJBPayoutRedemptionPaymentTerminal,   JBSingleTokenPaymentTerminal,   JBOperatable,   Ownable,   ReentrancyGuard {   // A library that parses the packed funding cycle metadata into a friendlier format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error FEE_TOO_HIGH();   error INADEQUATE_DISTRIBUTION_AMOUNT();   error INADEQUATE_RECLAIM_AMOUNT();   error INADEQUATE_TOKEN_COUNT();   error NO_MSG_VALUE_ALLOWED();   error PAY_TO_ZERO_ADDRESS();   error PROJECT_TERMINAL_MISMATCH();   error REDEEM_TO_ZERO_ADDRESS();   error TERMINAL_IN_SPLIT_ZERO_ADDRESS();   error TERMINAL_TOKENS_INCOMPATIBLE(); //***********//   // ---------------------------- modifiers ---------------------------- //   //*************// /*      @notice      A modifier that verifies this terminal is a terminal of provided project ID.   /   modifier isTerminalOf(uint256 projectId) {     if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();     ;   } //***********//   // --------------------- internal stored constants ------------------- //   //*************// /**     @notice     Maximum fee that can be set for a funding cycle configuration. @dev Out of MAX_FEE (50_000_000 / 1_000_000_000).  */   uint256 internal constant _FEE_CAP = 50_000_000; /*     @notice     The protocol project ID is 1, as it should be the first project launched during the deployment process.   /   uint256 internal constant _PROTOCOL_PROJECT_ID = 1; //***********//   // --------------------- internal stored properties ------------------ //   //*************// /**     @notice     Fees that are being held to be processed later. _projectId The ID of the project for which fees are being held.  */   mapping(uint256 =&gt; JBFee[]) internal _heldFeesOf; //***********//   // ---------------- public immutable stored properties --------------- //   //*************// /*     @notice     Mints ERC-721's that represent project ownership and transfers.   /   IJBProjects public immutable override projects; /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; /*     @notice     The contract that stores splits for each project.   /   IJBSplitsStore public immutable override splitsStore; /*     @notice     The contract that exposes price feeds.   /   IJBPrices public immutable override prices; /*     @notice     The contract that stores and manages the terminal's data.   /   IJBSingleTokenPaymentTerminalStore public immutable override store; /**     @notice     The currency to base token issuance on. @dev If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.  */   uint256 public immutable override baseWeightCurrency; /*     @notice     The group that payout splits coming from this terminal are identified by.   /   uint256 public immutable override payoutSplitsGroup; //***********//   // --------------------- public stored properties -------------------- //   //*************// /**     @notice     The platform fee percent. @dev Out of MAX_FEE (25_000_000 / 1_000_000_000)  */   uint256 public override fee = 25_000_000; // 2.5% /*     @notice     The data source that returns a discount to apply to a project's fee.   /   IJBFeeGauge public override feeGauge; /**     @notice     Addresses that can be paid towards from this terminal without incurring a fee. _address The address that can be paid toward.  */   mapping(address =&gt; bool) public override isFeelessAddress; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     Gets the current overflowed amount in this terminal for a specified project, in terms of ETH. @dev The current overflow is represented as a fixed point number with 18 decimals.  @param _projectId The ID of the project to get overflow for.  @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.  */   function currentEthOverflowOf(uint256 _projectId)     external     view     virtual     override     returns (uint256)   {     // Get this terminal's current overflow.     uint256 _overflow = store.currentOverflowOf(this, _projectId); // Adjust the decimals of the fixed point number if needed to have 18 decimals. uint256 _adjustedOverflow = (decimals == 18)   ? _overflow   : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);  // Return the amount converted to ETH. return   (currency == JBCurrencies.ETH)     ? _adjustedOverflow     : PRBMath.mulDiv(       _adjustedOverflow,       10**decimals,       prices.priceFor(currency, JBCurrencies.ETH, decimals)     );  } /**     @notice     The fees that are currently being held to be processed later for each project. @param _projectId The ID of the project for which fees are being held.  @return An array of fees that are being held.  */   function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {     return _heldFeesOf[_projectId];   } //***********//   // -------------------------- public views --------------------------- //   //*************// /**     @notice     Indicates if this contract adheres to the specified interface. @dev  See {IERC165-supportsInterface}.  @param _interfaceId The ID of the interface to check for adherance to.  */   function supportsInterface(bytes4 _interfaceId)     public     view     virtual     override(JBSingleTokenPaymentTerminal, IERC165)     returns (bool)   {     return       _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||       _interfaceId == type(IJBPayoutTerminal).interfaceId ||       _interfaceId == type(IJBAllowanceTerminal).interfaceId ||       _interfaceId == type(IJBRedemptionTerminal).interfaceId ||       _interfaceId == type(IJBOperatable).interfaceId ||       super.supportsInterface(_interfaceId);   } //***********//   // -------------------------- constructor ---------------------------- //   //*************// /*     @param _token The token that this terminal manages.     @param _decimals The number of decimals the token fixed point amounts are expected to have.     @param _currency The currency that this terminal's token adheres to for price feeds.     @param _baseWeightCurrency The currency to base token issuance on.     @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.     @param _operatorStore A contract storing operator assignments.     @param _projects A contract which mints ERC-721's that represent project ownership and transfers.     @param _directory A contract storing directories of terminals and controllers for each project.     @param _splitsStore A contract that stores splits for each project.     @param _prices A contract that exposes price feeds.     @param _store A contract that stores the terminal's data.     @param _owner The address that will own this contract.   /   constructor(     // payable constructor save the gas used to check msg.value==0     address _token,     uint256 _decimals,     uint256 _currency,     uint256 _baseWeightCurrency,     uint256 _payoutSplitsGroup,     IJBOperatorStore _operatorStore,     IJBProjects _projects,     IJBDirectory _directory,     IJBSplitsStore _splitsStore,     IJBPrices _prices,     IJBSingleTokenPaymentTerminalStore _store,     address _owner   )     payable     JBSingleTokenPaymentTerminal(_token, _decimals, _currency)     JBOperatable(_operatorStore)   {     baseWeightCurrency = _baseWeightCurrency;     payoutSplitsGroup = _payoutSplitsGroup;     projects = _projects;     directory = _directory;     splitsStore = _splitsStore;     prices = _prices;     store = _store; transferOwnership(_owner);  } //***********//   // ---------------------- external transactions ---------------------- //   //*************// /**     @notice     Contribute tokens to a project. @param _projectId The ID of the project being paid. @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place. @param _token The token being paid. This terminal ignores this property since it only manages one token.  @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate. @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal. @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas. @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.  */   function pay(     uint256 _projectId,     uint256 _amount,     address _token,     address _beneficiary,     uint256 _minReturnedTokens,     bool _preferClaimedTokens,     string calldata _memo,     bytes calldata _metadata   ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {     _token; // Prevents unused var compiler and natspec complaints. // ETH shouldn't be sent if this terminal's token isn't ETH. if (token != JBTokens.ETH) {   if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();    // Transfer tokens to this terminal from the msg sender.   _transferFrom(msg.sender, payable(address(this)), _amount); } // If this terminal's token is ETH, override _amount with msg.value. else _amount = msg.value;  return   _pay(     _amount,     msg.sender,     _projectId,     _beneficiary,     _minReturnedTokens,     _preferClaimedTokens,     _memo,     _metadata   );  } /**     @notice     Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source. @dev Only a token holder or a designated operator can redeem its tokens.  @param _holder The account to redeem tokens for. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _token The token being reclaimed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal. @param _beneficiary The address to send the terminal tokens to. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.  */   function redeemTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     address _token,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo,     bytes memory _metadata   )     external     virtual     override     requirePermission(_holder, _projectId, JBOperations.REDEEM)     returns (uint256 reclaimAmount)   {     _token; // Prevents unused var compiler and natspec complaints. return   _redeemTokensOf(     _holder,     _projectId,     _tokenCount,     _minReturnedTokens,     _beneficiary,     _memo,     _metadata   );  } /**     @notice     Distributes payouts for a project with the distribution limit of its current funding cycle. @dev Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.  @dev Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.  @dev All funds distributed outside of this contract or any feeless terminals incure the protocol fee.  @param _projectId The ID of the project having its payouts distributed. @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency. @param _token The token being distributed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal. @param _memo A memo to pass along to the emitted event.  @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.  */   function distributePayoutsOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     address _token,     uint256 _minReturnedTokens,     string calldata _memo   ) external virtual override returns (uint256 netLeftoverDistributionAmount) {     _token; // Prevents unused var compiler and natspec complaints. return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);  } /**     @notice     Allows a project to send funds from its overflow up to the preconfigured allowance. @dev Only a project's owner or a designated operator can use its allowance.  @dev Incurs the protocol fee.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency. @param _token The token being distributed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals. @param _beneficiary The address to send the funds to. @param _memo A memo to pass along to the emitted event.  @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.  */   function useAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     address _token,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)     returns (uint256 netDistributedAmount)   {     _token; // Prevents unused var compiler and natspec complaints. return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);  } /**     @notice     Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type. @dev Only a project's owner or a designated operator can migrate it.  @param _projectId The ID of the project being migrated. @param _to The terminal contract that will gain the project's funds.  @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.  */   function migrate(uint256 _projectId, IJBPaymentTerminal _to)     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)     returns (uint256 balance)   {     // The terminal being migrated to must accept the same token as this terminal.     if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE(); // Record the migration in the store. balance = store.recordMigration(_projectId);  // Transfer the balance if needed. if (balance &gt; 0) {   // Trigger any inherited pre-transfer logic.   _beforeTransferTo(address(_to), balance);    // If this terminal's token is ETH, send it in msg.value.   uint256 _payableValue = token == JBTokens.ETH ? balance : 0;    // Withdraw the balance to transfer to the new terminal;   _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes('')); }  emit Migrate(_projectId, _to, balance, msg.sender);  } /**     @notice     Receives funds belonging to the specified project. @param _projectId The ID of the project to which the funds received belong. @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead. @param _token The token being paid. This terminal ignores this property since it only manages one currency.  @param _memo A memo to pass along to the emitted event. @param _metadata Extra data to pass along to the emitted event.  */   function addToBalanceOf(     uint256 _projectId,     uint256 _amount,     address _token,     string calldata _memo,     bytes calldata _metadata   ) external payable virtual override isTerminalOf(_projectId) {     _token; // Prevents unused var compiler and natspec complaints. // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender. if (token != JBTokens.ETH) {   // Amount must be greater than 0.   if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();    // Transfer tokens to this terminal from the msg sender.   _transferFrom(msg.sender, payable(address(this)), _amount); } // If the terminal's token is ETH, override `_amount` with msg.value. else _amount = msg.value;  // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal. _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);  } /**     @notice     Process any fees that are being held for the project. @dev Only a project owner, an operator, or the contract's owner can process held fees.  @param _projectId The ID of the project whos held fees should be processed.  */   function processFees(uint256 _projectId)     external     virtual     override     requirePermissionAllowingOverride(       projects.ownerOf(_projectId),       _projectId,       JBOperations.PROCESS_FEES,       msg.sender == owner()     )   {     // Get a reference to the project's held fees.     JBFee[] memory _heldFees = _heldFeesOf[_projectId]; // Delete the held fees. delete _heldFeesOf[_projectId];  // Push array length in stack uint256 _heldFeeLength = _heldFees.length;  // Process each fee. for (uint256 _i = 0; _i &lt; _heldFeeLength; ) {   // Get the fee amount.   uint256 _amount = _feeAmount(     _heldFees[_i].amount,     _heldFees[_i].fee,     _heldFees[_i].feeDiscount   );    // Process the fee.   _processFee(_amount, _heldFees[_i].beneficiary);    emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);    unchecked {     ++_i;   } }  } /**     @notice     Allows the fee to be updated. @dev Only the owner of this contract can change the fee.  @param _fee The new fee, out of MAX_FEE.  */   function setFee(uint256 _fee) external virtual override onlyOwner {     // The provided fee must be within the max.     if (_fee &gt; _FEE_CAP) revert FEE_TOO_HIGH(); // Store the new fee. fee = _fee;  emit SetFee(_fee, msg.sender);  } /**     @notice     Allows the fee gauge to be updated. @dev Only the owner of this contract can change the fee gauge.  @dev If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.  @param _feeGauge The new fee gauge.  */   function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {     // Store the new fee gauge.     feeGauge = _feeGauge; emit SetFeeGauge(_feeGauge, msg.sender);  } /**     @notice     Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee. @dev Only the owner of this contract can set addresses as feeless.  @param _address The address that can be paid towards while still bypassing fees. @param _flag A flag indicating whether the terminal should be feeless or not.  */   function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {     // Set the flag value.     isFeelessAddress[_address] = _flag; emit SetFeelessAddress(_address, _flag, msg.sender);  } //***********//   // ---------------------- internal transactions ---------------------- //   //*************// /**      @notice     Transfers tokens. @param _from The address from which the transfer should originate. @param _to The address to which the transfer should go. @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.  */   function _transferFrom(     address _from,     address payable _to,     uint256 _amount   ) internal virtual; /**      @notice     Logic to be triggered before transferring tokens from this terminal. @param _to The address to which the transfer is going. @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.  */   function _beforeTransferTo(address _to, uint256 _amount) internal virtual; /**     @notice     Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source. @dev Only a token holder or a designated operator can redeem its tokens.  @param _holder The account to redeem tokens for. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal. @param _beneficiary The address to send the terminal tokens to. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.  */   function _redeemTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo,     bytes memory _metadata   ) internal returns (uint256 reclaimAmount) {     // Can't send reclaimed funds to the zero address.     if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS(); // Define variables that will be needed outside the scoped section below. // Keep a reference to the funding cycle during which the redemption is being made. JBFundingCycle memory _fundingCycle;  // Scoped section prevents stack too deep. `_delegate` only used within scope. {   IJBRedemptionDelegate _delegate;    // Record the redemption.   (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(     _holder,     _projectId,     _tokenCount,     _memo,     _metadata   );    // The amount being reclaimed must be at least as much as was expected.   if (reclaimAmount &lt; _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();    // Burn the project tokens.   if (_tokenCount &gt; 0)     IJBController(directory.controllerOf(_projectId)).burnTokensOf(       _holder,       _projectId,       _tokenCount,       '',       false     );    // If a delegate was returned by the data source, issue a callback to it.   if (_delegate != IJBRedemptionDelegate(address(0))) {     JBDidRedeemData memory _data = JBDidRedeemData(       _holder,       _projectId,       _fundingCycle.configuration,       _tokenCount,       JBTokenAmount(token, reclaimAmount, decimals, currency),       _beneficiary,       _memo,       _metadata     );     _delegate.didRedeem(_data);     emit DelegateDidRedeem(_delegate, _data, msg.sender);   } }  // Send the reclaimed funds to the beneficiary. if (reclaimAmount &gt; 0) _transferFrom(address(this), _beneficiary, reclaimAmount);  emit RedeemTokens(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _holder,   _beneficiary,   _tokenCount,   reclaimAmount,   _memo,   _metadata,   msg.sender );  } /**     @notice     Distributes payouts for a project with the distribution limit of its current funding cycle. @dev Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.  @dev Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.  @dev All funds distributed outside of this contract or any feeless terminals incure the protocol fee.  @param _projectId The ID of the project having its payouts distributed. @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency. @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal. @param _memo A memo to pass along to the emitted event.  @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.  */   function _distributePayoutsOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     uint256 _minReturnedTokens,     string calldata _memo   ) internal returns (uint256 netLeftoverDistributionAmount) {     // Record the distribution.     (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(       _projectId,       _amount,       _currency     ); // The amount being distributed must be at least as much as was expected. if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();  // Get a reference to the project owner, which will receive tokens from paying the platform fee // and receive any extra distributable funds not allocated to payout splits. address payable _projectOwner = payable(projects.ownerOf(_projectId));  // Define variables that will be needed outside the scoped section below. // Keep a reference to the fee amount that was paid. uint256 _fee;  // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope. {   // Get the amount of discount that should be applied to any fees taken.   // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.   uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]     ? JBConstants.MAX_FEE_DISCOUNT     : _currentFeeDiscount(_projectId);    // The amount distributed that is eligible for incurring fees.   uint256 _feeEligibleDistributionAmount;    // The amount leftover after distributing to the splits.   uint256 _leftoverDistributionAmount;    // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.   // Also get a reference to the amount that was distributed to splits from which fees should be taken.   (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(     _projectId,     _fundingCycle.configuration,     payoutSplitsGroup,     _distributedAmount,     _feeDiscount   );    // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.   unchecked {     _feeEligibleDistributionAmount += _leftoverDistributionAmount;   }    // Take the fee.   _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0     ? 0     : _takeFeeFrom(       _projectId,       _fundingCycle,       _feeEligibleDistributionAmount,       _projectOwner,       _feeDiscount     );    // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.    unchecked {     netLeftoverDistributionAmount = _leftoverDistributionAmount == 0       ? 0       : _leftoverDistributionAmount -         _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);   }    // Transfer any remaining balance to the project owner.   if (netLeftoverDistributionAmount &gt; 0)     _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount); }  emit DistributePayouts(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _projectOwner,   _amount,   _distributedAmount,   _fee,   netLeftoverDistributionAmount,   _memo,   msg.sender );  } /**     @notice     Allows a project to send funds from its overflow up to the preconfigured allowance. @dev Only a project's owner or a designated operator can use its allowance.  @dev Incurs the protocol fee.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency. @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals. @param _beneficiary The address to send the funds to. @param _memo A memo to pass along to the emitted event.  @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.  */   function _useAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo   ) internal returns (uint256 netDistributedAmount) {     // Record the use of the allowance.     (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(       _projectId,       _amount,       _currency     ); // The amount being withdrawn must be at least as much as was expected. if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();  // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope. {   // Keep a reference to the fee amount that was paid.   uint256 _fee;    // Get a reference to the project owner, which will receive tokens from paying the platform fee.   address _projectOwner = projects.ownerOf(_projectId);    // Get the amount of discount that should be applied to any fees taken.   // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.   uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]     ? JBConstants.MAX_FEE_DISCOUNT     : _currentFeeDiscount(_projectId);    // Take a fee from the `_distributedAmount`, if needed.   _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT     ? 0     : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);    unchecked {     // The net amount is the withdrawn amount without the fee.     netDistributedAmount = _distributedAmount - _fee;   }    // Transfer any remaining balance to the beneficiary.   if (netDistributedAmount &gt; 0)     _transferFrom(address(this), _beneficiary, netDistributedAmount); }  emit UseAllowance(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _beneficiary,   _amount,   _distributedAmount,   netDistributedAmount,   _memo,   msg.sender );  } /**     @notice     Pays out splits for a project's funding cycle configuration. @param _projectId The ID of the project for which payout splits are being distributed. @param _domain The domain of the splits to distribute the payout between. @param _group The group of the splits to distribute the payout between. @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal. @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.  @return leftoverAmount If the leftover amount if the splits don't add up to 100%. @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.  */   function _distributeToPayoutSplitsOf(     uint256 _projectId,     uint256 _domain,     uint256 _group,     uint256 _amount,     uint256 _feeDiscount   ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {     // Set the leftover amount to the initial amount.     leftoverAmount = _amount; // Get a reference to the project's payout splits. JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);  // Transfer between all splits. for (uint256 _i = 0; _i &lt; _splits.length; ) {   // Get a reference to the split being iterated on.   JBSplit memory _split = _splits[_i];    // The amount to send towards the split.   uint256 _payoutAmount = PRBMath.mulDiv(     _amount,     _split.percent,     JBConstants.SPLITS_TOTAL_PERCENT   );    // The payout amount substracting any applicable incurred fees.   uint256 _netPayoutAmount;    if (_payoutAmount &gt; 0) {     // Transfer tokens to the split.     // If there's an allocator set, transfer to its `allocate` function.     if (_split.allocator != IJBSplitAllocator(address(0))) {       // If the split allocator is set as feeless, this distribution is not eligible for a fee.       if (isFeelessAddress[address(_split.allocator)])         _netPayoutAmount = _payoutAmount;         // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.       else {         unchecked {           _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT             ? _payoutAmount             : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);         }          // This distribution is eligible for a fee since the funds are leaving the ecosystem.         feeEligibleDistributionAmount += _payoutAmount;       }        // Trigger any inherited pre-transfer logic.       _beforeTransferTo(address(_split.allocator), _netPayoutAmount);        // If this terminal's token is ETH, send it in msg.value.       uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;        // Create the data to send to the allocator.       JBSplitAllocationData memory _data = JBSplitAllocationData(         token,         _netPayoutAmount,         decimals,         _projectId,         _group,         _split       );        // Trigger the allocator's `allocate` function.       _split.allocator.allocate{value: _payableValue}(_data);        // Otherwise, if a project is specified, make a payment to it.     } else if (_split.projectId != 0) {       // Get a reference to the Juicebox terminal being used.       IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);        // The project must have a terminal to send funds to.       if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();        // Save gas if this contract is being used as the terminal.       if (_terminal == this) {         // This distribution does not incur a fee.         _netPayoutAmount = _payoutAmount;          // Send the projectId in the metadata.         bytes memory _projectMetadata = new bytes(32);         _projectMetadata = bytes(abi.encodePacked(_projectId));          // Add to balance if prefered.         if (_split.preferAddToBalance)           _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);         else           _pay(             _netPayoutAmount,             address(this),             _split.projectId,             (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,             0,             _split.preferClaimed,             '',             _projectMetadata           );       } else {         // If the terminal is set as feeless, this distribution is not eligible for a fee.         if (isFeelessAddress[address(_terminal)])           _netPayoutAmount = _payoutAmount;           // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.         else {           unchecked {             _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT               ? _payoutAmount               : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);           }            feeEligibleDistributionAmount += _payoutAmount;         }          // Trigger any inherited pre-transfer logic.         _beforeTransferTo(address(_terminal), _netPayoutAmount);          // If this terminal's token is ETH, send it in msg.value.         uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;          // Send the projectId in the metadata.         bytes memory _projectMetadata = new bytes(32);         _projectMetadata = bytes(abi.encodePacked(_projectId));          // Add to balance if prefered.         if (_split.preferAddToBalance)           _terminal.addToBalanceOf{value: _payableValue}(             _split.projectId,             _netPayoutAmount,             token,             '',             _projectMetadata           );         else           _terminal.pay{value: _payableValue}(             _split.projectId,             _netPayoutAmount,             token,             _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,             0,             _split.preferClaimed,             '',             _projectMetadata           );       }     } else {       unchecked {         _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT           ? _payoutAmount           : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);       }        // This distribution is eligible for a fee since the funds are leaving the ecosystem.       feeEligibleDistributionAmount += _payoutAmount;        // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.       _transferFrom(         address(this),         _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),         _netPayoutAmount       );     }      // Subtract from the amount to be sent to the beneficiary.     unchecked {       leftoverAmount = leftoverAmount - _payoutAmount;     }   }    emit DistributeToPayoutSplit(     _projectId,     _domain,     _group,     _split,     _netPayoutAmount,     msg.sender   );    unchecked {     ++_i;   } }  } /**     @notice     Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID. @param _projectId The ID of the project having fees taken from. @param _fundingCycle The funding cycle during which the fee is being taken. @param _amount The amount of the fee to take, as a floating point number with 18 decimals. @param _beneficiary The address to mint the platforms tokens for. @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.  @return feeAmount The amount of the fee taken.  */   function _takeFeeFrom(     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _amount,     address _beneficiary,     uint256 _feeDiscount   ) internal returns (uint256 feeAmount) {     feeAmount = _feeAmount(_amount, fee, _feeDiscount); if (_fundingCycle.shouldHoldFees()) {   // Store the held fee.   _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));    emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender); } else {   // Process the fee.   _processFee(feeAmount, _beneficiary); // Take the fee.    emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender); }  } /**     @notice     Process a fee of the specified amount. @param _amount The fee amount, as a floating point number with 18 decimals. @param _beneficiary The address to mint the platform's tokens for.  */   function _processFee(uint256 _amount, address _beneficiary) internal {     // Get the terminal for the protocol project.     IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token); // When processing the admin fee, save gas if the admin is using this contract as its terminal. if (_terminal == this)   _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call. else {   // Trigger any inherited pre-transfer logic.   _beforeTransferTo(address(_terminal), _amount);    // If this terminal's token is ETH, send it in msg.value.   uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;    // Send the payment.   _terminal.pay{value: _payableValue}(     _PROTOCOL_PROJECT_ID,     _amount,     token,     _beneficiary,     0,     false,     '',     bytes('')   ); // Use the external pay call of the correct terminal. }  } /**     @notice     Contribute tokens to a project. @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place. @param _payer The address making the payment. @param _projectId The ID of the project being paid. @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate. @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal. @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas. @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.  */   function _pay(     uint256 _amount,     address _payer,     uint256 _projectId,     address _beneficiary,     uint256 _minReturnedTokens,     bool _preferClaimedTokens,     string memory _memo,     bytes memory _metadata   ) internal returns (uint256 beneficiaryTokenCount) {     // Cant send tokens to the zero address.     if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS(); // Define variables that will be needed outside the scoped section below. // Keep a reference to the funding cycle during which the payment is being made. JBFundingCycle memory _fundingCycle;  // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope. {   IJBPayDelegate _delegate;   uint256 _tokenCount;    // Bundle the amount info into a JBTokenAmount struct.   JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);    // Record the payment.   (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(     _payer,     _bundledAmount,     _projectId,     baseWeightCurrency,     _beneficiary,     _memo,     _metadata   );    // Mint the tokens if needed.   if (_tokenCount &gt; 0)     // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.     beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(       _projectId,       _tokenCount,       _beneficiary,       '',       _preferClaimedTokens,       true     );    // The token count for the beneficiary must be greater than or equal to the minimum expected.   if (beneficiaryTokenCount &lt; _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();    // If a delegate was returned by the data source, issue a callback to it.   if (_delegate != IJBPayDelegate(address(0))) {     JBDidPayData memory _data = JBDidPayData(       _payer,       _projectId,       _fundingCycle.configuration,       _bundledAmount,       beneficiaryTokenCount,       _beneficiary,       _preferClaimedTokens,       _memo,       _metadata     );      _delegate.didPay(_data);     emit DelegateDidPay(_delegate, _data, msg.sender);   } }  emit Pay(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _payer,   _beneficiary,   _amount,   beneficiaryTokenCount,   _memo,   _metadata,   msg.sender );  } /**     @notice     Receives funds belonging to the specified project. @param _projectId The ID of the project to which the funds received belong. @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead. @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added. @param _memo A memo to pass along to the emitted event. @param _metadata Extra data to pass along to the emitted event.  */   function _addToBalanceOf(     uint256 _projectId,     uint256 _amount,     bool _shouldRefundHeldFees,     string memory _memo,     bytes memory _metadata   ) internal {     // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.     uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0; // Record the added funds with any refunded fees. store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);  emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);  } /**     @notice     Refund fees based on the specified amount. @param _projectId The project for which fees are being refunded. @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.  @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal  */   function _refundHeldFees(uint256 _projectId, uint256 _amount)     internal     returns (uint256 refundedFees)   {     // Get a reference to the project's held fees.     JBFee[] memory _heldFees = _heldFeesOf[_projectId]; // Delete the current held fees. delete _heldFeesOf[_projectId];  // Get a reference to the leftover amount once all fees have been settled. uint256 leftoverAmount = _amount;  // Push length in stack uint256 _heldFeesLength = _heldFees.length;  // Process each fee. for (uint256 _i = 0; _i &lt; _heldFeesLength; ) {   if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);   else if (leftoverAmount &gt;= _heldFees[_i].amount) {     unchecked {       leftoverAmount = leftoverAmount - _heldFees[_i].amount;       refundedFees += _feeAmount(         _heldFees[_i].amount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount       );     }   } else {     _heldFeesOf[_projectId].push(       JBFee(         _heldFees[_i].amount - leftoverAmount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount,         _heldFees[_i].beneficiary       )     );     unchecked {       refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);     }     leftoverAmount = 0;   }    unchecked {     ++_i;   } }  emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);  } /**      @notice      Returns the fee amount based on the provided amount for the specified project. @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal. @param _fee The percentage of the fee, out of MAX_FEE.  @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.  @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.  */   function _feeAmount(     uint256 _amount,     uint256 _fee,     uint256 _feeDiscount   ) internal pure returns (uint256) {     // Calculate the discounted fee.     uint256 _discountedFee = _fee -       PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT); // The amount of tokens from the `_amount` to pay as a fee. return   _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);  } /**      @notice     Get the fee discount from the fee gauge for the specified project. @param _projectId The ID of the project to get a fee discount for.  @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.  */   function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {     // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.     if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))       return JBConstants.MAX_FEE_DISCOUNT; // Get the fee discount. if (feeGauge == IJBFeeGauge(address(0)))   feeDiscount = 0;   // If the guage reverts, set the discount to 0. else   try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {     feeDiscount = discount;   } catch {     feeDiscount = 0;   }  // If the fee discount is greater than the max, nullify the discount. if (feeDiscount &gt; JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;  } } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 17:17:43 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/security/ReentrancyGuard.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './../interfaces/IJBController.sol'; import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol'; import './../libraries/JBConstants.sol'; import './../libraries/JBCurrencies.sol'; import './../libraries/JBFixedPointNumber.sol'; import './../libraries/JBFundingCycleMetadataResolver.sol'; import './../libraries/JBOperations.sol'; import './../libraries/JBSplitsGroups.sol'; import './../libraries/JBTokens.sol'; import './../structs/JBTokenAmount.sol'; import './JBOperatable.sol'; import './JBSingleTokenPaymentTerminal.sol'; /**   @notice   Generic terminal managing all inflows and outflows of funds into the protocol ecosystem. @dev   A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time. @dev   Adheres to -   IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules. @dev   Inherits from -   JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.   JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.   Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.   ReentrancyGuard: Contract module that helps prevent reentrant calls to a function. */ abstract contract JBPayoutRedemptionPaymentTerminal is   IJBPayoutRedemptionPaymentTerminal,   JBSingleTokenPaymentTerminal,   JBOperatable,   Ownable,   ReentrancyGuard {   // A library that parses the packed funding cycle metadata into a friendlier format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error FEE_TOO_HIGH();   error INADEQUATE_DISTRIBUTION_AMOUNT();   error INADEQUATE_RECLAIM_AMOUNT();   error INADEQUATE_TOKEN_COUNT();   error NO_MSG_VALUE_ALLOWED();   error PAY_TO_ZERO_ADDRESS();   error PROJECT_TERMINAL_MISMATCH();   error REDEEM_TO_ZERO_ADDRESS();   error TERMINAL_IN_SPLIT_ZERO_ADDRESS();   error TERMINAL_TOKENS_INCOMPATIBLE(); //***********//   // ---------------------------- modifiers ---------------------------- //   //*************// /*      @notice      A modifier that verifies this terminal is a terminal of provided project ID.   /   modifier isTerminalOf(uint256 projectId) {     if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();     ;   } //***********//   // --------------------- internal stored constants ------------------- //   //*************// /**     @notice     Maximum fee that can be set for a funding cycle configuration. @dev Out of MAX_FEE (50_000_000 / 1_000_000_000).  */   uint256 internal constant _FEE_CAP = 50_000_000; /*     @notice     The protocol project ID is 1, as it should be the first project launched during the deployment process.   /   uint256 internal constant _PROTOCOL_PROJECT_ID = 1; //***********//   // --------------------- internal stored properties ------------------ //   //*************// /**     @notice     Fees that are being held to be processed later. _projectId The ID of the project for which fees are being held.  */   mapping(uint256 =&gt; JBFee[]) internal _heldFeesOf; //***********//   // ---------------- public immutable stored properties --------------- //   //*************// /*     @notice     Mints ERC-721's that represent project ownership and transfers.   /   IJBProjects public immutable override projects; /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; /*     @notice     The contract that stores splits for each project.   /   IJBSplitsStore public immutable override splitsStore; /*     @notice     The contract that exposes price feeds.   /   IJBPrices public immutable override prices; /*     @notice     The contract that stores and manages the terminal's data.   /   IJBSingleTokenPaymentTerminalStore public immutable override store; /**     @notice     The currency to base token issuance on. @dev If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.  */   uint256 public immutable override baseWeightCurrency; /*     @notice     The group that payout splits coming from this terminal are identified by.   /   uint256 public immutable override payoutSplitsGroup; //***********//   // --------------------- public stored properties -------------------- //   //*************// /**     @notice     The platform fee percent. @dev Out of MAX_FEE (25_000_000 / 1_000_000_000)  */   uint256 public override fee = 25_000_000; // 2.5% /*     @notice     The data source that returns a discount to apply to a project's fee.   /   IJBFeeGauge public override feeGauge; /**     @notice     Addresses that can be paid towards from this terminal without incurring a fee. _address The address that can be paid toward.  */   mapping(address =&gt; bool) public override isFeelessAddress; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     Gets the current overflowed amount in this terminal for a specified project, in terms of ETH. @dev The current overflow is represented as a fixed point number with 18 decimals.  @param _projectId The ID of the project to get overflow for.  @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.  */   function currentEthOverflowOf(uint256 _projectId)     external     view     virtual     override     returns (uint256)   {     // Get this terminal's current overflow.     uint256 _overflow = store.currentOverflowOf(this, _projectId); // Adjust the decimals of the fixed point number if needed to have 18 decimals. uint256 _adjustedOverflow = (decimals == 18)   ? _overflow   : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);  // Return the amount converted to ETH. return   (currency == JBCurrencies.ETH)     ? _adjustedOverflow     : PRBMath.mulDiv(       _adjustedOverflow,       10**decimals,       prices.priceFor(currency, JBCurrencies.ETH, decimals)     );  } /**     @notice     The fees that are currently being held to be processed later for each project. @param _projectId The ID of the project for which fees are being held.  @return An array of fees that are being held.  */   function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {     return _heldFeesOf[_projectId];   } //***********//   // -------------------------- public views --------------------------- //   //*************// /**     @notice     Indicates if this contract adheres to the specified interface. @dev  See {IERC165-supportsInterface}.  @param _interfaceId The ID of the interface to check for adherance to.  */   function supportsInterface(bytes4 _interfaceId)     public     view     virtual     override(JBSingleTokenPaymentTerminal, IERC165)     returns (bool)   {     return       _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||       _interfaceId == type(IJBPayoutTerminal).interfaceId ||       _interfaceId == type(IJBAllowanceTerminal).interfaceId ||       _interfaceId == type(IJBRedemptionTerminal).interfaceId ||       _interfaceId == type(IJBOperatable).interfaceId ||       super.supportsInterface(_interfaceId);   } //***********//   // -------------------------- constructor ---------------------------- //   //*************// /*     @param _token The token that this terminal manages.     @param _decimals The number of decimals the token fixed point amounts are expected to have.     @param _currency The currency that this terminal's token adheres to for price feeds.     @param _baseWeightCurrency The currency to base token issuance on.     @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.     @param _operatorStore A contract storing operator assignments.     @param _projects A contract which mints ERC-721's that represent project ownership and transfers.     @param _directory A contract storing directories of terminals and controllers for each project.     @param _splitsStore A contract that stores splits for each project.     @param _prices A contract that exposes price feeds.     @param _store A contract that stores the terminal's data.     @param _owner The address that will own this contract.   /   constructor(     // payable constructor save the gas used to check msg.value==0     address _token,     uint256 _decimals,     uint256 _currency,     uint256 _baseWeightCurrency,     uint256 _payoutSplitsGroup,     IJBOperatorStore _operatorStore,     IJBProjects _projects,     IJBDirectory _directory,     IJBSplitsStore _splitsStore,     IJBPrices _prices,     IJBSingleTokenPaymentTerminalStore _store,     address _owner   )     payable     JBSingleTokenPaymentTerminal(_token, _decimals, _currency)     JBOperatable(_operatorStore)   {     baseWeightCurrency = _baseWeightCurrency;     payoutSplitsGroup = _payoutSplitsGroup;     projects = _projects;     directory = _directory;     splitsStore = _splitsStore;     prices = _prices;     store = _store; transferOwnership(_owner);  } //***********//   // ---------------------- external transactions ---------------------- //   //*************// /**     @notice     Contribute tokens to a project. @param _projectId The ID of the project being paid. @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place. @param _token The token being paid. This terminal ignores this property since it only manages one token.  @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate. @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal. @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas. @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.  */   function pay(     uint256 _projectId,     uint256 _amount,     address _token,     address _beneficiary,     uint256 _minReturnedTokens,     bool _preferClaimedTokens,     string calldata _memo,     bytes calldata _metadata   ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {     _token; // Prevents unused var compiler and natspec complaints. // ETH shouldn't be sent if this terminal's token isn't ETH. if (token != JBTokens.ETH) {   if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();    // Transfer tokens to this terminal from the msg sender.   _transferFrom(msg.sender, payable(address(this)), _amount); } // If this terminal's token is ETH, override _amount with msg.value. else _amount = msg.value;  return   _pay(     _amount,     msg.sender,     _projectId,     _beneficiary,     _minReturnedTokens,     _preferClaimedTokens,     _memo,     _metadata   );  } /**     @notice     Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source. @dev Only a token holder or a designated operator can redeem its tokens.  @param _holder The account to redeem tokens for. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _token The token being reclaimed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal. @param _beneficiary The address to send the terminal tokens to. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.  */   function redeemTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     address _token,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo,     bytes memory _metadata   )     external     virtual     override     requirePermission(_holder, _projectId, JBOperations.REDEEM)     returns (uint256 reclaimAmount)   {     _token; // Prevents unused var compiler and natspec complaints. return   _redeemTokensOf(     _holder,     _projectId,     _tokenCount,     _minReturnedTokens,     _beneficiary,     _memo,     _metadata   );  } /**     @notice     Distributes payouts for a project with the distribution limit of its current funding cycle. @dev Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.  @dev Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.  @dev All funds distributed outside of this contract or any feeless terminals incure the protocol fee.  @param _projectId The ID of the project having its payouts distributed. @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency. @param _token The token being distributed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal. @param _memo A memo to pass along to the emitted event.  @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.  */   function distributePayoutsOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     address _token,     uint256 _minReturnedTokens,     string calldata _memo   ) external virtual override returns (uint256 netLeftoverDistributionAmount) {     _token; // Prevents unused var compiler and natspec complaints. return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);  } /**     @notice     Allows a project to send funds from its overflow up to the preconfigured allowance. @dev Only a project's owner or a designated operator can use its allowance.  @dev Incurs the protocol fee.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency. @param _token The token being distributed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals. @param _beneficiary The address to send the funds to. @param _memo A memo to pass along to the emitted event.  @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.  */   function useAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     address _token,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)     returns (uint256 netDistributedAmount)   {     _token; // Prevents unused var compiler and natspec complaints. return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);  } /**     @notice     Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type. @dev Only a project's owner or a designated operator can migrate it.  @param _projectId The ID of the project being migrated. @param _to The terminal contract that will gain the project's funds.  @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.  */   function migrate(uint256 _projectId, IJBPaymentTerminal _to)     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)     returns (uint256 balance)   {     // The terminal being migrated to must accept the same token as this terminal.     if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE(); // Record the migration in the store. balance = store.recordMigration(_projectId);  // Transfer the balance if needed. if (balance &gt; 0) {   // Trigger any inherited pre-transfer logic.   _beforeTransferTo(address(_to), balance);    // If this terminal's token is ETH, send it in msg.value.   uint256 _payableValue = token == JBTokens.ETH ? balance : 0;    // Withdraw the balance to transfer to the new terminal;   _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes('')); }  emit Migrate(_projectId, _to, balance, msg.sender);  } /**     @notice     Receives funds belonging to the specified project. @param _projectId The ID of the project to which the funds received belong. @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead. @param _token The token being paid. This terminal ignores this property since it only manages one currency.  @param _memo A memo to pass along to the emitted event. @param _metadata Extra data to pass along to the emitted event.  */   function addToBalanceOf(     uint256 _projectId,     uint256 _amount,     address _token,     string calldata _memo,     bytes calldata _metadata   ) external payable virtual override isTerminalOf(_projectId) {     _token; // Prevents unused var compiler and natspec complaints. // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender. if (token != JBTokens.ETH) {   // Amount must be greater than 0.   if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();    // Transfer tokens to this terminal from the msg sender.   _transferFrom(msg.sender, payable(address(this)), _amount); } // If the terminal's token is ETH, override `_amount` with msg.value. else _amount = msg.value;  // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal. _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);  } /**     @notice     Process any fees that are being held for the project. @dev Only a project owner, an operator, or the contract's owner can process held fees.  @param _projectId The ID of the project whos held fees should be processed.  */   function processFees(uint256 _projectId)     external     virtual     override     requirePermissionAllowingOverride(       projects.ownerOf(_projectId),       _projectId,       JBOperations.PROCESS_FEES,       msg.sender == owner()     )   {     // Get a reference to the project's held fees.     JBFee[] memory _heldFees = _heldFeesOf[_projectId]; // Delete the held fees. delete _heldFeesOf[_projectId];  // Push array length in stack uint256 _heldFeeLength = _heldFees.length;  // Process each fee. for (uint256 _i = 0; _i &lt; _heldFeeLength; ) {   // Get the fee amount.   uint256 _amount = _feeAmount(     _heldFees[_i].amount,     _heldFees[_i].fee,     _heldFees[_i].feeDiscount   );    // Process the fee.   _processFee(_amount, _heldFees[_i].beneficiary);    emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);    unchecked {     ++_i;   } }  } /**     @notice     Allows the fee to be updated. @dev Only the owner of this contract can change the fee.  @param _fee The new fee, out of MAX_FEE.  */   function setFee(uint256 _fee) external virtual override onlyOwner {     // The provided fee must be within the max.     if (_fee &gt; _FEE_CAP) revert FEE_TOO_HIGH(); // Store the new fee. fee = _fee;  emit SetFee(_fee, msg.sender);  } /**     @notice     Allows the fee gauge to be updated. @dev Only the owner of this contract can change the fee gauge.  @dev If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.  @param _feeGauge The new fee gauge.  */   function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {     // Store the new fee gauge.     feeGauge = _feeGauge; emit SetFeeGauge(_feeGauge, msg.sender);  } /**     @notice     Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee. @dev Only the owner of this contract can set addresses as feeless.  @param _address The address that can be paid towards while still bypassing fees. @param _flag A flag indicating whether the terminal should be feeless or not.  */   function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {     // Set the flag value.     isFeelessAddress[_address] = _flag; emit SetFeelessAddress(_address, _flag, msg.sender);  } //***********//   // ---------------------- internal transactions ---------------------- //   //*************// /**      @notice     Transfers tokens. @param _from The address from which the transfer should originate. @param _to The address to which the transfer should go. @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.  */   function _transferFrom(     address _from,     address payable _to,     uint256 _amount   ) internal virtual; /**      @notice     Logic to be triggered before transferring tokens from this terminal. @param _to The address to which the transfer is going. @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.  */   function _beforeTransferTo(address _to, uint256 _amount) internal virtual; /**     @notice     Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source. @dev Only a token holder or a designated operator can redeem its tokens.  @param _holder The account to redeem tokens for. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal. @param _beneficiary The address to send the terminal tokens to. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.  */   function _redeemTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo,     bytes memory _metadata   ) internal returns (uint256 reclaimAmount) {     // Can't send reclaimed funds to the zero address.     if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS(); // Define variables that will be needed outside the scoped section below. // Keep a reference to the funding cycle during which the redemption is being made. JBFundingCycle memory _fundingCycle;  // Scoped section prevents stack too deep. `_delegate` only used within scope. {   IJBRedemptionDelegate _delegate;    // Record the redemption.   (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(     _holder,     _projectId,     _tokenCount,     _memo,     _metadata   );    // The amount being reclaimed must be at least as much as was expected.   if (reclaimAmount &lt; _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();    // Burn the project tokens.   if (_tokenCount &gt; 0)     IJBController(directory.controllerOf(_projectId)).burnTokensOf(       _holder,       _projectId,       _tokenCount,       '',       false     );    // If a delegate was returned by the data source, issue a callback to it.   if (_delegate != IJBRedemptionDelegate(address(0))) {     JBDidRedeemData memory _data = JBDidRedeemData(       _holder,       _projectId,       _fundingCycle.configuration,       _tokenCount,       JBTokenAmount(token, reclaimAmount, decimals, currency),       _beneficiary,       _memo,       _metadata     );     _delegate.didRedeem(_data);     emit DelegateDidRedeem(_delegate, _data, msg.sender);   } }  // Send the reclaimed funds to the beneficiary. if (reclaimAmount &gt; 0) _transferFrom(address(this), _beneficiary, reclaimAmount);  emit RedeemTokens(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _holder,   _beneficiary,   _tokenCount,   reclaimAmount,   _memo,   _metadata,   msg.sender );  } /**     @notice     Distributes payouts for a project with the distribution limit of its current funding cycle. @dev Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.  @dev Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.  @dev All funds distributed outside of this contract or any feeless terminals incure the protocol fee.  @param _projectId The ID of the project having its payouts distributed. @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency. @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal. @param _memo A memo to pass along to the emitted event.  @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.  */   function _distributePayoutsOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     uint256 _minReturnedTokens,     string calldata _memo   ) internal returns (uint256 netLeftoverDistributionAmount) {     // Record the distribution.     (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(       _projectId,       _amount,       _currency     ); // The amount being distributed must be at least as much as was expected. if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();  // Get a reference to the project owner, which will receive tokens from paying the platform fee // and receive any extra distributable funds not allocated to payout splits. address payable _projectOwner = payable(projects.ownerOf(_projectId));  // Define variables that will be needed outside the scoped section below. // Keep a reference to the fee amount that was paid. uint256 _fee;  // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope. {   // Get the amount of discount that should be applied to any fees taken.   // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.   uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]     ? JBConstants.MAX_FEE_DISCOUNT     : _currentFeeDiscount(_projectId);    // The amount distributed that is eligible for incurring fees.   uint256 _feeEligibleDistributionAmount;    // The amount leftover after distributing to the splits.   uint256 _leftoverDistributionAmount;    // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.   // Also get a reference to the amount that was distributed to splits from which fees should be taken.   (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(     _projectId,     _fundingCycle.configuration,     payoutSplitsGroup,     _distributedAmount,     _feeDiscount   );    // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.   unchecked {     _feeEligibleDistributionAmount += _leftoverDistributionAmount;   }    // Take the fee.   _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0     ? 0     : _takeFeeFrom(       _projectId,       _fundingCycle,       _feeEligibleDistributionAmount,       _projectOwner,       _feeDiscount     );    // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.    unchecked {     netLeftoverDistributionAmount = _leftoverDistributionAmount == 0       ? 0       : _leftoverDistributionAmount -         _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);   }    // Transfer any remaining balance to the project owner.   if (netLeftoverDistributionAmount &gt; 0)     _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount); }  emit DistributePayouts(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _projectOwner,   _amount,   _distributedAmount,   _fee,   netLeftoverDistributionAmount,   _memo,   msg.sender );  } /**     @notice     Allows a project to send funds from its overflow up to the preconfigured allowance. @dev Only a project's owner or a designated operator can use its allowance.  @dev Incurs the protocol fee.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency. @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals. @param _beneficiary The address to send the funds to. @param _memo A memo to pass along to the emitted event.  @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.  */   function _useAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo   ) internal returns (uint256 netDistributedAmount) {     // Record the use of the allowance.     (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(       _projectId,       _amount,       _currency     ); // The amount being withdrawn must be at least as much as was expected. if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();  // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope. {   // Keep a reference to the fee amount that was paid.   uint256 _fee;    // Get a reference to the project owner, which will receive tokens from paying the platform fee.   address _projectOwner = projects.ownerOf(_projectId);    // Get the amount of discount that should be applied to any fees taken.   // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.   uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]     ? JBConstants.MAX_FEE_DISCOUNT     : _currentFeeDiscount(_projectId);    // Take a fee from the `_distributedAmount`, if needed.   _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT     ? 0     : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);    unchecked {     // The net amount is the withdrawn amount without the fee.     netDistributedAmount = _distributedAmount - _fee;   }    // Transfer any remaining balance to the beneficiary.   if (netDistributedAmount &gt; 0)     _transferFrom(address(this), _beneficiary, netDistributedAmount); }  emit UseAllowance(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _beneficiary,   _amount,   _distributedAmount,   netDistributedAmount,   _memo,   msg.sender );  } /**     @notice     Pays out splits for a project's funding cycle configuration. @param _projectId The ID of the project for which payout splits are being distributed. @param _domain The domain of the splits to distribute the payout between. @param _group The group of the splits to distribute the payout between. @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal. @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.  @return leftoverAmount If the leftover amount if the splits don't add up to 100%. @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.  */   function _distributeToPayoutSplitsOf(     uint256 _projectId,     uint256 _domain,     uint256 _group,     uint256 _amount,     uint256 _feeDiscount   ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {     // Set the leftover amount to the initial amount.     leftoverAmount = _amount; // Get a reference to the project's payout splits. JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);  // Transfer between all splits. for (uint256 _i = 0; _i &lt; _splits.length; ) {   // Get a reference to the split being iterated on.   JBSplit memory _split = _splits[_i];    // The amount to send towards the split.   uint256 _payoutAmount = PRBMath.mulDiv(     _amount,     _split.percent,     JBConstants.SPLITS_TOTAL_PERCENT   );    // The payout amount substracting any applicable incurred fees.   uint256 _netPayoutAmount;    if (_payoutAmount &gt; 0) {     // Transfer tokens to the split.     // If there's an allocator set, transfer to its `allocate` function.     if (_split.allocator != IJBSplitAllocator(address(0))) {       // If the split allocator is set as feeless, this distribution is not eligible for a fee.       if (isFeelessAddress[address(_split.allocator)])         _netPayoutAmount = _payoutAmount;         // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.       else {         unchecked {           _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT             ? _payoutAmount             : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);         }          // This distribution is eligible for a fee since the funds are leaving the ecosystem.         feeEligibleDistributionAmount += _payoutAmount;       }        // Trigger any inherited pre-transfer logic.       _beforeTransferTo(address(_split.allocator), _netPayoutAmount);        // If this terminal's token is ETH, send it in msg.value.       uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;        // Create the data to send to the allocator.       JBSplitAllocationData memory _data = JBSplitAllocationData(         token,         _netPayoutAmount,         decimals,         _projectId,         _group,         _split       );        // Trigger the allocator's `allocate` function.       _split.allocator.allocate{value: _payableValue}(_data);        // Otherwise, if a project is specified, make a payment to it.     } else if (_split.projectId != 0) {       // Get a reference to the Juicebox terminal being used.       IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);        // The project must have a terminal to send funds to.       if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();        // Save gas if this contract is being used as the terminal.       if (_terminal == this) {         // This distribution does not incur a fee.         _netPayoutAmount = _payoutAmount;          // Send the projectId in the metadata.         bytes memory _projectMetadata = new bytes(32);         _projectMetadata = bytes(abi.encodePacked(_projectId));          // Add to balance if prefered.         if (_split.preferAddToBalance)           _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);         else           _pay(             _netPayoutAmount,             address(this),             _split.projectId,             (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,             0,             _split.preferClaimed,             '',             _projectMetadata           );       } else {         // If the terminal is set as feeless, this distribution is not eligible for a fee.         if (isFeelessAddress[address(_terminal)])           _netPayoutAmount = _payoutAmount;           // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.         else {           unchecked {             _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT               ? _payoutAmount               : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);           }            feeEligibleDistributionAmount += _payoutAmount;         }          // Trigger any inherited pre-transfer logic.         _beforeTransferTo(address(_terminal), _netPayoutAmount);          // If this terminal's token is ETH, send it in msg.value.         uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;          // Send the projectId in the metadata.         bytes memory _projectMetadata = new bytes(32);         _projectMetadata = bytes(abi.encodePacked(_projectId));          // Add to balance if prefered.         if (_split.preferAddToBalance)           _terminal.addToBalanceOf{value: _payableValue}(             _split.projectId,             _netPayoutAmount,             token,             '',             _projectMetadata           );         else           _terminal.pay{value: _payableValue}(             _split.projectId,             _netPayoutAmount,             token,             _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,             0,             _split.preferClaimed,             '',             _projectMetadata           );       }     } else {       unchecked {         _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT           ? _payoutAmount           : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);       }        // This distribution is eligible for a fee since the funds are leaving the ecosystem.       feeEligibleDistributionAmount += _payoutAmount;        // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.       _transferFrom(         address(this),         _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),         _netPayoutAmount       );     }      // Subtract from the amount to be sent to the beneficiary.     unchecked {       leftoverAmount = leftoverAmount - _payoutAmount;     }   }    emit DistributeToPayoutSplit(     _projectId,     _domain,     _group,     _split,     _netPayoutAmount,     msg.sender   );    unchecked {     ++_i;   } }  } /**     @notice     Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID. @param _projectId The ID of the project having fees taken from. @param _fundingCycle The funding cycle during which the fee is being taken. @param _amount The amount of the fee to take, as a floating point number with 18 decimals. @param _beneficiary The address to mint the platforms tokens for. @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.  @return feeAmount The amount of the fee taken.  */   function _takeFeeFrom(     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _amount,     address _beneficiary,     uint256 _feeDiscount   ) internal returns (uint256 feeAmount) {     feeAmount = _feeAmount(_amount, fee, _feeDiscount); if (_fundingCycle.shouldHoldFees()) {   // Store the held fee.   _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));    emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender); } else {   // Process the fee.   _processFee(feeAmount, _beneficiary); // Take the fee.    emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender); }  } /**     @notice     Process a fee of the specified amount. @param _amount The fee amount, as a floating point number with 18 decimals. @param _beneficiary The address to mint the platform's tokens for.  */   function _processFee(uint256 _amount, address _beneficiary) internal {     // Get the terminal for the protocol project.     IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token); // When processing the admin fee, save gas if the admin is using this contract as its terminal. if (_terminal == this)   _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call. else {   // Trigger any inherited pre-transfer logic.   _beforeTransferTo(address(_terminal), _amount);    // If this terminal's token is ETH, send it in msg.value.   uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;    // Send the payment.   _terminal.pay{value: _payableValue}(     _PROTOCOL_PROJECT_ID,     _amount,     token,     _beneficiary,     0,     false,     '',     bytes('')   ); // Use the external pay call of the correct terminal. }  } /**     @notice     Contribute tokens to a project. @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place. @param _payer The address making the payment. @param _projectId The ID of the project being paid. @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate. @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal. @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas. @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.  */   function _pay(     uint256 _amount,     address _payer,     uint256 _projectId,     address _beneficiary,     uint256 _minReturnedTokens,     bool _preferClaimedTokens,     string memory _memo,     bytes memory _metadata   ) internal returns (uint256 beneficiaryTokenCount) {     // Cant send tokens to the zero address.     if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS(); // Define variables that will be needed outside the scoped section below. // Keep a reference to the funding cycle during which the payment is being made. JBFundingCycle memory _fundingCycle;  // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope. {   IJBPayDelegate _delegate;   uint256 _tokenCount;    // Bundle the amount info into a JBTokenAmount struct.   JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);    // Record the payment.   (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(     _payer,     _bundledAmount,     _projectId,     baseWeightCurrency,     _beneficiary,     _memo,     _metadata   );    // Mint the tokens if needed.   if (_tokenCount &gt; 0)     // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.     beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(       _projectId,       _tokenCount,       _beneficiary,       '',       _preferClaimedTokens,       true     );    // The token count for the beneficiary must be greater than or equal to the minimum expected.   if (beneficiaryTokenCount &lt; _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();    // If a delegate was returned by the data source, issue a callback to it.   if (_delegate != IJBPayDelegate(address(0))) {     JBDidPayData memory _data = JBDidPayData(       _payer,       _projectId,       _fundingCycle.configuration,       _bundledAmount,       beneficiaryTokenCount,       _beneficiary,       _preferClaimedTokens,       _memo,       _metadata     );      _delegate.didPay(_data);     emit DelegateDidPay(_delegate, _data, msg.sender);   } }  emit Pay(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _payer,   _beneficiary,   _amount,   beneficiaryTokenCount,   _memo,   _metadata,   msg.sender );  } /**     @notice     Receives funds belonging to the specified project. @param _projectId The ID of the project to which the funds received belong. @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead. @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added. @param _memo A memo to pass along to the emitted event. @param _metadata Extra data to pass along to the emitted event.  */   function _addToBalanceOf(     uint256 _projectId,     uint256 _amount,     bool _shouldRefundHeldFees,     string memory _memo,     bytes memory _metadata   ) internal {     // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.     uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0; // Record the added funds with any refunded fees. store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);  emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);  } /**     @notice     Refund fees based on the specified amount. @param _projectId The project for which fees are being refunded. @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.  @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal  */   function _refundHeldFees(uint256 _projectId, uint256 _amount)     internal     returns (uint256 refundedFees)   {     // Get a reference to the project's held fees.     JBFee[] memory _heldFees = _heldFeesOf[_projectId]; // Delete the current held fees. delete _heldFeesOf[_projectId];  // Get a reference to the leftover amount once all fees have been settled. uint256 leftoverAmount = _amount;  // Push length in stack uint256 _heldFeesLength = _heldFees.length;  // Process each fee. for (uint256 _i = 0; _i &lt; _heldFeesLength; ) {   if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);   else if (leftoverAmount &gt;= _heldFees[_i].amount) {     unchecked {       leftoverAmount = leftoverAmount - _heldFees[_i].amount;       refundedFees += _feeAmount(         _heldFees[_i].amount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount       );     }   } else {     _heldFeesOf[_projectId].push(       JBFee(         _heldFees[_i].amount - leftoverAmount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount,         _heldFees[_i].beneficiary       )     );     unchecked {       refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);     }     leftoverAmount = 0;   }    unchecked {     ++_i;   } }  emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);  } /**      @notice      Returns the fee amount based on the provided amount for the specified project. @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal. @param _fee The percentage of the fee, out of MAX_FEE.  @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.  @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.  */   function _feeAmount(     uint256 _amount,     uint256 _fee,     uint256 _feeDiscount   ) internal pure returns (uint256) {     // Calculate the discounted fee.     uint256 _discountedFee = _fee -       PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT); // The amount of tokens from the `_amount` to pay as a fee. return   _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);  } /**      @notice     Get the fee discount from the fee gauge for the specified project. @param _projectId The ID of the project to get a fee discount for.  @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.  */   function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {     // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.     if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))       return JBConstants.MAX_FEE_DISCOUNT; // Get the fee discount. if (feeGauge == IJBFeeGauge(address(0)))   feeDiscount = 0;   // If the guage reverts, set the discount to 0. else   try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {     feeDiscount = discount;   } catch {     feeDiscount = 0;   }  // If the fee discount is greater than the max, nullify the discount. if (feeDiscount &gt; JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 17:17:43 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './../interfaces/IJBController.sol';
import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol';
import './../libraries/JBConstants.sol';
import './../libraries/JBCurrencies.sol';
import './../libraries/JBFixedPointNumber.sol';
import './../libraries/JBFundingCycleMetadataResolver.sol';
import './../libraries/JBOperations.sol';
import './../libraries/JBSplitsGroups.sol';
import './../libraries/JBTokens.sol';
import './../structs/JBTokenAmount.sol';
import './JBOperatable.sol';
import './JBSingleTokenPaymentTerminal.sol';

/**
  @notice
  Generic terminal managing all inflows and outflows of funds into the protocol ecosystem.

  @dev
  A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time.

  @dev
  Adheres to -
  IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.
  JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
abstract contract JBPayoutRedemptionPaymentTerminal is
  IJBPayoutRedemptionPaymentTerminal,
  JBSingleTokenPaymentTerminal,
  JBOperatable,
  Ownable,
  ReentrancyGuard
{
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error FEE_TOO_HIGH();
  error INADEQUATE_DISTRIBUTION_AMOUNT();
  error INADEQUATE_RECLAIM_AMOUNT();
  error INADEQUATE_TOKEN_COUNT();
  error NO_MSG_VALUE_ALLOWED();
  error PAY_TO_ZERO_ADDRESS();
  error PROJECT_TERMINAL_MISMATCH();
  error REDEEM_TO_ZERO_ADDRESS();
  error TERMINAL_IN_SPLIT_ZERO_ADDRESS();
  error TERMINAL_TOKENS_INCOMPATIBLE();

  //*********************************************************************//
  // ---------------------------- modifiers ---------------------------- //
  //*********************************************************************//

  /** 
    @notice 
    A modifier that verifies this terminal is a terminal of provided project ID.
  */
  modifier isTerminalOf(uint256 _projectId) {
    if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();
    _;
  }

  //*********************************************************************//
  // --------------------- internal stored constants ------------------- //
  //*********************************************************************//

  /**
    @notice
    Maximum fee that can be set for a funding cycle configuration.

    @dev
    Out of MAX_FEE (50_000_000 / 1_000_000_000).
  */
  uint256 internal constant _FEE_CAP = 50_000_000;

  /**
    @notice
    The protocol project ID is 1, as it should be the first project launched during the deployment process.
  */
  uint256 internal constant _PROTOCOL_PROJECT_ID = 1;

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    Fees that are being held to be processed later.

    _projectId The ID of the project for which fees are being held.
  */
  mapping(uint256 => JBFee[]) internal _heldFeesOf;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership and transfers.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  /**
    @notice
    The contract that stores and manages the terminal's data.
  */
  IJBSingleTokenPaymentTerminalStore public immutable override store;

  /**
    @notice
    The currency to base token issuance on.

    @dev
    If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.
  */
  uint256 public immutable override baseWeightCurrency;

  /**
    @notice
    The group that payout splits coming from this terminal are identified by.
  */
  uint256 public immutable override payoutSplitsGroup;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The platform fee percent.

    @dev
    Out of MAX_FEE (25_000_000 / 1_000_000_000)
  */
  uint256 public override fee = 25_000_000; // 2.5%

  /**
    @notice
    The data source that returns a discount to apply to a project's fee.
  */
  IJBFeeGauge public override feeGauge;

  /**
    @notice
    Addresses that can be paid towards from this terminal without incurring a fee.

    _address The address that can be paid toward.
  */
  mapping(address => bool) public override isFeelessAddress;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.

    @dev
    The current overflow is represented as a fixed point number with 18 decimals.

    @param _projectId The ID of the project to get overflow for.

    @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.
  */
  function currentEthOverflowOf(uint256 _projectId)
    external
    view
    virtual
    override
    returns (uint256)
  {
    // Get this terminal's current overflow.
    uint256 _overflow = store.currentOverflowOf(this, _projectId);

    // Adjust the decimals of the fixed point number if needed to have 18 decimals.
    uint256 _adjustedOverflow = (decimals == 18)
      ? _overflow
      : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);

    // Return the amount converted to ETH.
    return
      (currency == JBCurrencies.ETH)
        ? _adjustedOverflow
        : PRBMath.mulDiv(
          _adjustedOverflow,
          10**decimals,
          prices.priceFor(currency, JBCurrencies.ETH, decimals)
        );
  }

  /**
    @notice
    The fees that are currently being held to be processed later for each project.

    @param _projectId The ID of the project for which fees are being held.

    @return An array of fees that are being held.
  */
  function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {
    return _heldFeesOf[_projectId];
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(JBSingleTokenPaymentTerminal, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||
      _interfaceId == type(IJBPayoutTerminal).interfaceId ||
      _interfaceId == type(IJBAllowanceTerminal).interfaceId ||
      _interfaceId == type(IJBRedemptionTerminal).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _token The token that this terminal manages.
    @param _decimals The number of decimals the token fixed point amounts are expected to have.
    @param _currency The currency that this terminal's token adheres to for price feeds.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _splitsStore A contract that stores splits for each project.
    @param _prices A contract that exposes price feeds.
    @param _store A contract that stores the terminal's data.
    @param _owner The address that will own this contract.
  */
  constructor(
    // payable constructor save the gas used to check msg.value==0
    address _token,
    uint256 _decimals,
    uint256 _currency,
    uint256 _baseWeightCurrency,
    uint256 _payoutSplitsGroup,
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBSplitsStore _splitsStore,
    IJBPrices _prices,
    IJBSingleTokenPaymentTerminalStore _store,
    address _owner
  )
    payable
    JBSingleTokenPaymentTerminal(_token, _decimals, _currency)
    JBOperatable(_operatorStore)
  {
    baseWeightCurrency = _baseWeightCurrency;
    payoutSplitsGroup = _payoutSplitsGroup;
    projects = _projects;
    directory = _directory;
    splitsStore = _splitsStore;
    prices = _prices;
    store = _store;

    transferOwnership(_owner);
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Contribute tokens to a project.

    @param _projectId The ID of the project being paid.
    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _token The token being paid. This terminal ignores this property since it only manages one token. 
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function pay(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {
    _token; // Prevents unused var compiler and natspec complaints.

    // ETH shouldn't be sent if this terminal's token isn't ETH.
    if (token != JBTokens.ETH) {
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If this terminal's token is ETH, override _amount with msg.value.
    else _amount = msg.value;

    return
      _pay(
        _amount,
        msg.sender,
        _projectId,
        _beneficiary,
        _minReturnedTokens,
        _preferClaimedTokens,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _token The token being reclaimed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  )
    external
    virtual
    override
    requirePermission(_holder, _projectId, JBOperations.REDEEM)
    returns (uint256 reclaimAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return
      _redeemTokensOf(
        _holder,
        _projectId,
        _tokenCount,
        _minReturnedTokens,
        _beneficiary,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) external virtual override returns (uint256 netLeftoverDistributionAmount) {
    _token; // Prevents unused var compiler and natspec complaints.

    return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)
    returns (uint256 netDistributedAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);
  }

  /**
    @notice
    Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project being migrated.
    @param _to The terminal contract that will gain the project's funds.

    @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.
  */
  function migrate(uint256 _projectId, IJBPaymentTerminal _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)
    returns (uint256 balance)
  {
    // The terminal being migrated to must accept the same token as this terminal.
    if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE();

    // Record the migration in the store.
    balance = store.recordMigration(_projectId);

    // Transfer the balance if needed.
    if (balance > 0) {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_to), balance);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? balance : 0;

      // Withdraw the balance to transfer to the new terminal;
      _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes(''));
    }

    emit Migrate(_projectId, _to, balance, msg.sender);
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _token The token being paid. This terminal ignores this property since it only manages one currency. 
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) {
    _token; // Prevents unused var compiler and natspec complaints.

    // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender.
    if (token != JBTokens.ETH) {
      // Amount must be greater than 0.
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If the terminal's token is ETH, override `_amount` with msg.value.
    else _amount = msg.value;

    // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal.
    _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);
  }

  /**
    @notice
    Process any fees that are being held for the project.

    @dev
    Only a project owner, an operator, or the contract's owner can process held fees.

    @param _projectId The ID of the project whos held fees should be processed.
  */
  function processFees(uint256 _projectId)
    external
    virtual
    override
    requirePermissionAllowingOverride(
      projects.ownerOf(_projectId),
      _projectId,
      JBOperations.PROCESS_FEES,
      msg.sender == owner()
    )
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the held fees.
    delete _heldFeesOf[_projectId];

    // Push array length in stack
    uint256 _heldFeeLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeeLength; ) {
      // Get the fee amount.
      uint256 _amount = _feeAmount(
        _heldFees[_i].amount,
        _heldFees[_i].fee,
        _heldFees[_i].feeDiscount
      );

      // Process the fee.
      _processFee(_amount, _heldFees[_i].beneficiary);

      emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Allows the fee to be updated.

    @dev
    Only the owner of this contract can change the fee.

    @param _fee The new fee, out of MAX_FEE.
  */
  function setFee(uint256 _fee) external virtual override onlyOwner {
    // The provided fee must be within the max.
    if (_fee > _FEE_CAP) revert FEE_TOO_HIGH();

    // Store the new fee.
    fee = _fee;

    emit SetFee(_fee, msg.sender);
  }

  /**
    @notice
    Allows the fee gauge to be updated.

    @dev
    Only the owner of this contract can change the fee gauge.

    @dev
    If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.

    @param _feeGauge The new fee gauge.
  */
  function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {
    // Store the new fee gauge.
    feeGauge = _feeGauge;

    emit SetFeeGauge(_feeGauge, msg.sender);
  }

  /**
    @notice
    Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.

    @dev
    Only the owner of this contract can set addresses as feeless.

    @param _address The address that can be paid towards while still bypassing fees.
    @param _flag A flag indicating whether the terminal should be feeless or not.
  */
  function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {
    // Set the flag value.
    isFeelessAddress[_address] = _flag;

    emit SetFeelessAddress(_address, _flag, msg.sender);
  }

  //*********************************************************************//
  // ---------------------- internal transactions ---------------------- //
  //*********************************************************************//

  /** 
    @notice
    Transfers tokens.

    @param _from The address from which the transfer should originate.
    @param _to The address to which the transfer should go.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _transferFrom(
    address _from,
    address payable _to,
    uint256 _amount
  ) internal virtual;

  /** 
    @notice
    Logic to be triggered before transferring tokens from this terminal.

    @param _to The address to which the transfer is going.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _beforeTransferTo(address _to, uint256 _amount) internal virtual;

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function _redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 reclaimAmount) {
    // Can't send reclaimed funds to the zero address.
    if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the redemption is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` only used within scope.
    {
      IJBRedemptionDelegate _delegate;

      // Record the redemption.
      (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(
        _holder,
        _projectId,
        _tokenCount,
        _memo,
        _metadata
      );

      // The amount being reclaimed must be at least as much as was expected.
      if (reclaimAmount < _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();

      // Burn the project tokens.
      if (_tokenCount > 0)
        IJBController(directory.controllerOf(_projectId)).burnTokensOf(
          _holder,
          _projectId,
          _tokenCount,
          '',
          false
        );

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBRedemptionDelegate(address(0))) {
        JBDidRedeemData memory _data = JBDidRedeemData(
          _holder,
          _projectId,
          _fundingCycle.configuration,
          _tokenCount,
          JBTokenAmount(token, reclaimAmount, decimals, currency),
          _beneficiary,
          _memo,
          _metadata
        );
        _delegate.didRedeem(_data);
        emit DelegateDidRedeem(_delegate, _data, msg.sender);
      }
    }

    // Send the reclaimed funds to the beneficiary.
    if (reclaimAmount > 0) _transferFrom(address(this), _beneficiary, reclaimAmount);

    emit RedeemTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _holder,
      _beneficiary,
      _tokenCount,
      reclaimAmount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) internal returns (uint256 netLeftoverDistributionAmount) {
    // Record the distribution.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(
      _projectId,
      _amount,
      _currency
    );

    // The amount being distributed must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Get a reference to the project owner, which will receive tokens from paying the platform fee
    // and receive any extra distributable funds not allocated to payout splits.
    address payable _projectOwner = payable(projects.ownerOf(_projectId));

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the fee amount that was paid.
    uint256 _fee;

    // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope.
    {
      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // The amount distributed that is eligible for incurring fees.
      uint256 _feeEligibleDistributionAmount;

      // The amount leftover after distributing to the splits.
      uint256 _leftoverDistributionAmount;

      // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.
      // Also get a reference to the amount that was distributed to splits from which fees should be taken.
      (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        payoutSplitsGroup,
        _distributedAmount,
        _feeDiscount
      );

      // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.
      unchecked {
        _feeEligibleDistributionAmount += _leftoverDistributionAmount;
      }

      // Take the fee.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0
        ? 0
        : _takeFeeFrom(
          _projectId,
          _fundingCycle,
          _feeEligibleDistributionAmount,
          _projectOwner,
          _feeDiscount
        );

      // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.

      unchecked {
        netLeftoverDistributionAmount = _leftoverDistributionAmount == 0
          ? 0
          : _leftoverDistributionAmount -
            _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);
      }

      // Transfer any remaining balance to the project owner.
      if (netLeftoverDistributionAmount > 0)
        _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount);
    }

    emit DistributePayouts(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _projectOwner,
      _amount,
      _distributedAmount,
      _fee,
      netLeftoverDistributionAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function _useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  ) internal returns (uint256 netDistributedAmount) {
    // Record the use of the allowance.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(
      _projectId,
      _amount,
      _currency
    );

    // The amount being withdrawn must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope.
    {
      // Keep a reference to the fee amount that was paid.
      uint256 _fee;

      // Get a reference to the project owner, which will receive tokens from paying the platform fee.
      address _projectOwner = projects.ownerOf(_projectId);

      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // Take a fee from the `_distributedAmount`, if needed.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
        ? 0
        : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);

      unchecked {
        // The net amount is the withdrawn amount without the fee.
        netDistributedAmount = _distributedAmount - _fee;
      }

      // Transfer any remaining balance to the beneficiary.
      if (netDistributedAmount > 0)
        _transferFrom(address(this), _beneficiary, netDistributedAmount);
    }

    emit UseAllowance(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _beneficiary,
      _amount,
      _distributedAmount,
      netDistributedAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Pays out splits for a project's funding cycle configuration.

    @param _projectId The ID of the project for which payout splits are being distributed.
    @param _domain The domain of the splits to distribute the payout between.
    @param _group The group of the splits to distribute the payout between.
    @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return leftoverAmount If the leftover amount if the splits don't add up to 100%.
    @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.
  */
  function _distributeToPayoutSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount,
    uint256 _feeDiscount
  ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's payout splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    // Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; ) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _payoutAmount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // The payout amount substracting any applicable incurred fees.
      uint256 _netPayoutAmount;

      if (_payoutAmount > 0) {
        // Transfer tokens to the split.
        // If there's an allocator set, transfer to its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0))) {
          // If the split allocator is set as feeless, this distribution is not eligible for a fee.
          if (isFeelessAddress[address(_split.allocator)])
            _netPayoutAmount = _payoutAmount;
            // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.
          else {
            unchecked {
              _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                ? _payoutAmount
                : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
            }

            // This distribution is eligible for a fee since the funds are leaving the ecosystem.
            feeEligibleDistributionAmount += _payoutAmount;
          }

          // Trigger any inherited pre-transfer logic.
          _beforeTransferTo(address(_split.allocator), _netPayoutAmount);

          // If this terminal's token is ETH, send it in msg.value.
          uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

          // Create the data to send to the allocator.
          JBSplitAllocationData memory _data = JBSplitAllocationData(
            token,
            _netPayoutAmount,
            decimals,
            _projectId,
            _group,
            _split
          );

          // Trigger the allocator's `allocate` function.
          _split.allocator.allocate{value: _payableValue}(_data);

          // Otherwise, if a project is specified, make a payment to it.
        } else if (_split.projectId != 0) {
          // Get a reference to the Juicebox terminal being used.
          IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);

          // The project must have a terminal to send funds to.
          if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();

          // Save gas if this contract is being used as the terminal.
          if (_terminal == this) {
            // This distribution does not incur a fee.
            _netPayoutAmount = _payoutAmount;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);
            else
              _pay(
                _netPayoutAmount,
                address(this),
                _split.projectId,
                (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          } else {
            // If the terminal is set as feeless, this distribution is not eligible for a fee.
            if (isFeelessAddress[address(_terminal)])
              _netPayoutAmount = _payoutAmount;
              // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.
            else {
              unchecked {
                _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                  ? _payoutAmount
                  : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
              }

              feeEligibleDistributionAmount += _payoutAmount;
            }

            // Trigger any inherited pre-transfer logic.
            _beforeTransferTo(address(_terminal), _netPayoutAmount);

            // If this terminal's token is ETH, send it in msg.value.
            uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _terminal.addToBalanceOf{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                '',
                _projectMetadata
              );
            else
              _terminal.pay{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          }
        } else {
          unchecked {
            _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
              ? _payoutAmount
              : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
          }

          // This distribution is eligible for a fee since the funds are leaving the ecosystem.
          feeEligibleDistributionAmount += _payoutAmount;

          // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.
          _transferFrom(
            address(this),
            _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),
            _netPayoutAmount
          );
        }

        // Subtract from the amount to be sent to the beneficiary.
        unchecked {
          leftoverAmount = leftoverAmount - _payoutAmount;
        }
      }

      emit DistributeToPayoutSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _netPayoutAmount,
        msg.sender
      );

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID.

    @param _projectId The ID of the project having fees taken from.
    @param _fundingCycle The funding cycle during which the fee is being taken.
    @param _amount The amount of the fee to take, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platforms tokens for.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return feeAmount The amount of the fee taken.
  */
  function _takeFeeFrom(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _amount,
    address _beneficiary,
    uint256 _feeDiscount
  ) internal returns (uint256 feeAmount) {
    feeAmount = _feeAmount(_amount, fee, _feeDiscount);

    if (_fundingCycle.shouldHoldFees()) {
      // Store the held fee.
      _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));

      emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender);
    } else {
      // Process the fee.
      _processFee(feeAmount, _beneficiary); // Take the fee.

      emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender);
    }
  }

  /**
    @notice
    Process a fee of the specified amount.

    @param _amount The fee amount, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platform's tokens for.
  */
  function _processFee(uint256 _amount, address _beneficiary) internal {
    // Get the terminal for the protocol project.
    IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token);

    // When processing the admin fee, save gas if the admin is using this contract as its terminal.
    if (_terminal == this)
      _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call.
    else {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_terminal), _amount);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;

      // Send the payment.
      _terminal.pay{value: _payableValue}(
        _PROTOCOL_PROJECT_ID,
        _amount,
        token,
        _beneficiary,
        0,
        false,
        '',
        bytes('')
      ); // Use the external pay call of the correct terminal.
    }
  }

  /**
    @notice
    Contribute tokens to a project.

    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _payer The address making the payment.
    @param _projectId The ID of the project being paid.
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function _pay(
    uint256 _amount,
    address _payer,
    uint256 _projectId,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 beneficiaryTokenCount) {
    // Cant send tokens to the zero address.
    if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the payment is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope.
    {
      IJBPayDelegate _delegate;
      uint256 _tokenCount;

      // Bundle the amount info into a JBTokenAmount struct.
      JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);

      // Record the payment.
      (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(
        _payer,
        _bundledAmount,
        _projectId,
        baseWeightCurrency,
        _beneficiary,
        _memo,
        _metadata
      );

      // Mint the tokens if needed.
      if (_tokenCount > 0)
        // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.
        beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(
          _projectId,
          _tokenCount,
          _beneficiary,
          '',
          _preferClaimedTokens,
          true
        );

      // The token count for the beneficiary must be greater than or equal to the minimum expected.
      if (beneficiaryTokenCount < _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBPayDelegate(address(0))) {
        JBDidPayData memory _data = JBDidPayData(
          _payer,
          _projectId,
          _fundingCycle.configuration,
          _bundledAmount,
          beneficiaryTokenCount,
          _beneficiary,
          _preferClaimedTokens,
          _memo,
          _metadata
        );

        _delegate.didPay(_data);
        emit DelegateDidPay(_delegate, _data, msg.sender);
      }
    }

    emit Pay(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _payer,
      _beneficiary,
      _amount,
      beneficiaryTokenCount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function _addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    bool _shouldRefundHeldFees,
    string memory _memo,
    bytes memory _metadata
  ) internal {
    // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.
    uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0;

    // Record the added funds with any refunded fees.
    store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);

    emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);
  }

  /**
    @notice
    Refund fees based on the specified amount.

    @param _projectId The project for which fees are being refunded.
    @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.

    @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal
  */
  function _refundHeldFees(uint256 _projectId, uint256 _amount)
    internal
    returns (uint256 refundedFees)
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the current held fees.
    delete _heldFeesOf[_projectId];

    // Get a reference to the leftover amount once all fees have been settled.
    uint256 leftoverAmount = _amount;

    // Push length in stack
    uint256 _heldFeesLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeesLength; ) {
      if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);
      else if (leftoverAmount >= _heldFees[_i].amount) {
        unchecked {
          leftoverAmount = leftoverAmount - _heldFees[_i].amount;
          refundedFees += _feeAmount(
            _heldFees[_i].amount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount
          );
        }
      } else {
        _heldFeesOf[_projectId].push(
          JBFee(
            _heldFees[_i].amount - leftoverAmount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount,
            _heldFees[_i].beneficiary
          )
        );
        unchecked {
          refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);
        }
        leftoverAmount = 0;
      }

      unchecked {
        ++_i;
      }
    }

    emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);
  }

  /** 
    @notice 
    Returns the fee amount based on the provided amount for the specified project.

    @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal.
    @param _fee The percentage of the fee, out of MAX_FEE. 
    @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.

    @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _feeAmount(
    uint256 _amount,
    uint256 _fee,
    uint256 _feeDiscount
  ) internal pure returns (uint256) {
    // Calculate the discounted fee.
    uint256 _discountedFee = _fee -
      PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT);

    // The amount of tokens from the `_amount` to pay as a fee.
    return
      _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);
  }

  /** 
    @notice
    Get the fee discount from the fee gauge for the specified project.

    @param _projectId The ID of the project to get a fee discount for.
    
    @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.
  */
  function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {
    // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.
    if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))
      return JBConstants.MAX_FEE_DISCOUNT;

    // Get the fee discount.
    if (feeGauge == IJBFeeGauge(address(0)))
      feeDiscount = 0;
      // If the guage reverts, set the discount to 0.
    else
      try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {
        feeDiscount = discount;
      } catch {
        feeDiscount = 0;
      }

    // If the fee discount is greater than the max, nullify the discount.
    if (feeDiscount > JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;
  }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-01-09 17:17:56 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 17:17:56 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 12782
completion_tokens: 893
total_tokens: 13675
cost: $-1.000000


[2024-01-09 17:17:56 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './../interfaces/IJBController.sol';
import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol';
import './../libraries/JBConstants.sol';
import './../libraries/JBCurrencies.sol';
import './../libraries/JBFixedPointNumber.sol';
import './../libraries/JBFundingCycleMetadataResolver.sol';
import './../libraries/JBOperations.sol';
import './../libraries/JBSplitsGroups.sol';
import './../libraries/JBTokens.sol';
import './../structs/JBTokenAmount.sol';
import './JBOperatable.sol';
import './JBSingleTokenPaymentTerminal.sol';

/**
  @notice
  Generic terminal managing all inflows and outflows of funds into the protocol ecosystem.

  @dev
  A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time.

  @dev
  Adheres to -
  IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.
  JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
abstract contract JBPayoutRedemptionPaymentTerminal is
  IJBPayoutRedemptionPaymentTerminal,
  JBSingleTokenPaymentTerminal,
  JBOperatable,
  Ownable,
  ReentrancyGuard
{
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error FEE_TOO_HIGH();
  error INADEQUATE_DISTRIBUTION_AMOUNT();
  error INADEQUATE_RECLAIM_AMOUNT();
  error INADEQUATE_TOKEN_COUNT();
  error NO_MSG_VALUE_ALLOWED();
  error PAY_TO_ZERO_ADDRESS();
  error PROJECT_TERMINAL_MISMATCH();
  error REDEEM_TO_ZERO_ADDRESS();
  error TERMINAL_IN_SPLIT_ZERO_ADDRESS();
  error TERMINAL_TOKENS_INCOMPATIBLE();

  //*********************************************************************//
  // ---------------------------- modifiers ---------------------------- //
  //*********************************************************************//

  /** 
    @notice 
    A modifier that verifies this terminal is a terminal of provided project ID.
  */
  modifier isTerminalOf(uint256 _projectId) {
    if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();
    _;
  }

  //*********************************************************************//
  // --------------------- internal stored constants ------------------- //
  //*********************************************************************//

  /**
    @notice
    Maximum fee that can be set for a funding cycle configuration.

    @dev
    Out of MAX_FEE (50_000_000 / 1_000_000_000).
  */
  uint256 internal constant _FEE_CAP = 50_000_000;

  /**
    @notice
    The protocol project ID is 1, as it should be the first project launched during the deployment process.
  */
  uint256 internal constant _PROTOCOL_PROJECT_ID = 1;

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    Fees that are being held to be processed later.

    _projectId The ID of the project for which fees are being held.
  */
  mapping(uint256 => JBFee[]) internal _heldFeesOf;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership and transfers.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  /**
    @notice
    The contract that stores and manages the terminal's data.
  */
  IJBSingleTokenPaymentTerminalStore public immutable override store;

  /**
    @notice
    The currency to base token issuance on.

    @dev
    If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.
  */
  uint256 public immutable override baseWeightCurrency;

  /**
    @notice
    The group that payout splits coming from this terminal are identified by.
  */
  uint256 public immutable override payoutSplitsGroup;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The platform fee percent.

    @dev
    Out of MAX_FEE (25_000_000 / 1_000_000_000)
  */
  uint256 public override fee = 25_000_000; // 2.5%

  /**
    @notice
    The data source that returns a discount to apply to a project's fee.
  */
  IJBFeeGauge public override feeGauge;

  /**
    @notice
    Addresses that can be paid towards from this terminal without incurring a fee.

    _address The address that can be paid toward.
  */
  mapping(address => bool) public override isFeelessAddress;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.

    @dev
    The current overflow is represented as a fixed point number with 18 decimals.

    @param _projectId The ID of the project to get overflow for.

    @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.
  */
  function currentEthOverflowOf(uint256 _projectId)
    external
    view
    virtual
    override
    returns (uint256)
  {
    // Get this terminal's current overflow.
    uint256 _overflow = store.currentOverflowOf(this, _projectId);

    // Adjust the decimals of the fixed point number if needed to have 18 decimals.
    uint256 _adjustedOverflow = (decimals == 18)
      ? _overflow
      : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);

    // Return the amount converted to ETH.
    return
      (currency == JBCurrencies.ETH)
        ? _adjustedOverflow
        : PRBMath.mulDiv(
          _adjustedOverflow,
          10**decimals,
          prices.priceFor(currency, JBCurrencies.ETH, decimals)
        );
  }

  /**
    @notice
    The fees that are currently being held to be processed later for each project.

    @param _projectId The ID of the project for which fees are being held.

    @return An array of fees that are being held.
  */
  function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {
    return _heldFeesOf[_projectId];
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(JBSingleTokenPaymentTerminal, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||
      _interfaceId == type(IJBPayoutTerminal).interfaceId ||
      _interfaceId == type(IJBAllowanceTerminal).interfaceId ||
      _interfaceId == type(IJBRedemptionTerminal).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _token The token that this terminal manages.
    @param _decimals The number of decimals the token fixed point amounts are expected to have.
    @param _currency The currency that this terminal's token adheres to for price feeds.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _splitsStore A contract that stores splits for each project.
    @param _prices A contract that exposes price feeds.
    @param _store A contract that stores the terminal's data.
    @param _owner The address that will own this contract.
  */
  constructor(
    // payable constructor save the gas used to check msg.value==0
    address _token,
    uint256 _decimals,
    uint256 _currency,
    uint256 _baseWeightCurrency,
    uint256 _payoutSplitsGroup,
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBSplitsStore _splitsStore,
    IJBPrices _prices,
    IJBSingleTokenPaymentTerminalStore _store,
    address _owner
  )
    payable
    JBSingleTokenPaymentTerminal(_token, _decimals, _currency)
    JBOperatable(_operatorStore)
  {
    baseWeightCurrency = _baseWeightCurrency;
    payoutSplitsGroup = _payoutSplitsGroup;
    projects = _projects;
    directory = _directory;
    splitsStore = _splitsStore;
    prices = _prices;
    store = _store;

    transferOwnership(_owner);
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Contribute tokens to a project.

    @param _projectId The ID of the project being paid.
    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _token The token being paid. This terminal ignores this property since it only manages one token. 
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function pay(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {
    _token; // Prevents unused var compiler and natspec complaints.

    // ETH shouldn't be sent if this terminal's token isn't ETH.
    if (token != JBTokens.ETH) {
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If this terminal's token is ETH, override _amount with msg.value.
    else _amount = msg.value;

    return
      _pay(
        _amount,
        msg.sender,
        _projectId,
        _beneficiary,
        _minReturnedTokens,
        _preferClaimedTokens,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _token The token being reclaimed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  )
    external
    virtual
    override
    requirePermission(_holder, _projectId, JBOperations.REDEEM)
    returns (uint256 reclaimAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return
      _redeemTokensOf(
        _holder,
        _projectId,
        _tokenCount,
        _minReturnedTokens,
        _beneficiary,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) external virtual override returns (uint256 netLeftoverDistributionAmount) {
    _token; // Prevents unused var compiler and natspec complaints.

    return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)
    returns (uint256 netDistributedAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);
  }

  /**
    @notice
    Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project being migrated.
    @param _to The terminal contract that will gain the project's funds.

    @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.
  */
  function migrate(uint256 _projectId, IJBPaymentTerminal _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)
    returns (uint256 balance)
  {
    // The terminal being migrated to must accept the same token as this terminal.
    if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE();

    // Record the migration in the store.
    balance = store.recordMigration(_projectId);

    // Transfer the balance if needed.
    if (balance > 0) {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_to), balance);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? balance : 0;

      // Withdraw the balance to transfer to the new terminal;
      _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes(''));
    }

    emit Migrate(_projectId, _to, balance, msg.sender);
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _token The token being paid. This terminal ignores this property since it only manages one currency. 
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) {
    _token; // Prevents unused var compiler and natspec complaints.

    // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender.
    if (token != JBTokens.ETH) {
      // Amount must be greater than 0.
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If the terminal's token is ETH, override `_amount` with msg.value.
    else _amount = msg.value;

    // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal.
    _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);
  }

  /**
    @notice
    Process any fees that are being held for the project.

    @dev
    Only a project owner, an operator, or the contract's owner can process held fees.

    @param _projectId The ID of the project whos held fees should be processed.
  */
  function processFees(uint256 _projectId)
    external
    virtual
    override
    requirePermissionAllowingOverride(
      projects.ownerOf(_projectId),
      _projectId,
      JBOperations.PROCESS_FEES,
      msg.sender == owner()
    )
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the held fees.
    delete _heldFeesOf[_projectId];

    // Push array length in stack
    uint256 _heldFeeLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeeLength; ) {
      // Get the fee amount.
      uint256 _amount = _feeAmount(
        _heldFees[_i].amount,
        _heldFees[_i].fee,
        _heldFees[_i].feeDiscount
      );

      // Process the fee.
      _processFee(_amount, _heldFees[_i].beneficiary);

      emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Allows the fee to be updated.

    @dev
    Only the owner of this contract can change the fee.

    @param _fee The new fee, out of MAX_FEE.
  */
  function setFee(uint256 _fee) external virtual override onlyOwner {
    // The provided fee must be within the max.
    if (_fee > _FEE_CAP) revert FEE_TOO_HIGH();

    // Store the new fee.
    fee = _fee;

    emit SetFee(_fee, msg.sender);
  }

  /**
    @notice
    Allows the fee gauge to be updated.

    @dev
    Only the owner of this contract can change the fee gauge.

    @dev
    If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.

    @param _feeGauge The new fee gauge.
  */
  function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {
    // Store the new fee gauge.
    feeGauge = _feeGauge;

    emit SetFeeGauge(_feeGauge, msg.sender);
  }

  /**
    @notice
    Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.

    @dev
    Only the owner of this contract can set addresses as feeless.

    @param _address The address that can be paid towards while still bypassing fees.
    @param _flag A flag indicating whether the terminal should be feeless or not.
  */
  function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {
    // Set the flag value.
    isFeelessAddress[_address] = _flag;

    emit SetFeelessAddress(_address, _flag, msg.sender);
  }

  //*********************************************************************//
  // ---------------------- internal transactions ---------------------- //
  //*********************************************************************//

  /** 
    @notice
    Transfers tokens.

    @param _from The address from which the transfer should originate.
    @param _to The address to which the transfer should go.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _transferFrom(
    address _from,
    address payable _to,
    uint256 _amount
  ) internal virtual;

  /** 
    @notice
    Logic to be triggered before transferring tokens from this terminal.

    @param _to The address to which the transfer is going.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _beforeTransferTo(address _to, uint256 _amount) internal virtual;

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function _redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 reclaimAmount) {
    // Can't send reclaimed funds to the zero address.
    if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the redemption is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` only used within scope.
    {
      IJBRedemptionDelegate _delegate;

      // Record the redemption.
      (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(
        _holder,
        _projectId,
        _tokenCount,
        _memo,
        _metadata
      );

      // The amount being reclaimed must be at least as much as was expected.
      if (reclaimAmount < _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();

      // Burn the project tokens.
      if (_tokenCount > 0)
        IJBController(directory.controllerOf(_projectId)).burnTokensOf(
          _holder,
          _projectId,
          _tokenCount,
          '',
          false
        );

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBRedemptionDelegate(address(0))) {
        JBDidRedeemData memory _data = JBDidRedeemData(
          _holder,
          _projectId,
          _fundingCycle.configuration,
          _tokenCount,
          JBTokenAmount(token, reclaimAmount, decimals, currency),
          _beneficiary,
          _memo,
          _metadata
        );
        _delegate.didRedeem(_data);
        emit DelegateDidRedeem(_delegate, _data, msg.sender);
      }
    }

    // Send the reclaimed funds to the beneficiary.
    if (reclaimAmount > 0) _transferFrom(address(this), _beneficiary, reclaimAmount);

    emit RedeemTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _holder,
      _beneficiary,
      _tokenCount,
      reclaimAmount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) internal returns (uint256 netLeftoverDistributionAmount) {
    // Record the distribution.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(
      _projectId,
      _amount,
      _currency
    );

    // The amount being distributed must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Get a reference to the project owner, which will receive tokens from paying the platform fee
    // and receive any extra distributable funds not allocated to payout splits.
    address payable _projectOwner = payable(projects.ownerOf(_projectId));

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the fee amount that was paid.
    uint256 _fee;

    // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope.
    {
      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // The amount distributed that is eligible for incurring fees.
      uint256 _feeEligibleDistributionAmount;

      // The amount leftover after distributing to the splits.
      uint256 _leftoverDistributionAmount;

      // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.
      // Also get a reference to the amount that was distributed to splits from which fees should be taken.
      (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        payoutSplitsGroup,
        _distributedAmount,
        _feeDiscount
      );

      // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.
      unchecked {
        _feeEligibleDistributionAmount += _leftoverDistributionAmount;
      }

      // Take the fee.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0
        ? 0
        : _takeFeeFrom(
          _projectId,
          _fundingCycle,
          _feeEligibleDistributionAmount,
          _projectOwner,
          _feeDiscount
        );

      // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.

      unchecked {
        netLeftoverDistributionAmount = _leftoverDistributionAmount == 0
          ? 0
          : _leftoverDistributionAmount -
            _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);
      }

      // Transfer any remaining balance to the project owner.
      if (netLeftoverDistributionAmount > 0)
        _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount);
    }

    emit DistributePayouts(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _projectOwner,
      _amount,
      _distributedAmount,
      _fee,
      netLeftoverDistributionAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function _useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  ) internal returns (uint256 netDistributedAmount) {
    // Record the use of the allowance.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(
      _projectId,
      _amount,
      _currency
    );

    // The amount being withdrawn must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope.
    {
      // Keep a reference to the fee amount that was paid.
      uint256 _fee;

      // Get a reference to the project owner, which will receive tokens from paying the platform fee.
      address _projectOwner = projects.ownerOf(_projectId);

      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // Take a fee from the `_distributedAmount`, if needed.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
        ? 0
        : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);

      unchecked {
        // The net amount is the withdrawn amount without the fee.
        netDistributedAmount = _distributedAmount - _fee;
      }

      // Transfer any remaining balance to the beneficiary.
      if (netDistributedAmount > 0)
        _transferFrom(address(this), _beneficiary, netDistributedAmount);
    }

    emit UseAllowance(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _beneficiary,
      _amount,
      _distributedAmount,
      netDistributedAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Pays out splits for a project's funding cycle configuration.

    @param _projectId The ID of the project for which payout splits are being distributed.
    @param _domain The domain of the splits to distribute the payout between.
    @param _group The group of the splits to distribute the payout between.
    @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return leftoverAmount If the leftover amount if the splits don't add up to 100%.
    @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.
  */
  function _distributeToPayoutSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount,
    uint256 _feeDiscount
  ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's payout splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    // Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; ) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _payoutAmount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // The payout amount substracting any applicable incurred fees.
      uint256 _netPayoutAmount;

      if (_payoutAmount > 0) {
        // Transfer tokens to the split.
        // If there's an allocator set, transfer to its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0))) {
          // If the split allocator is set as feeless, this distribution is not eligible for a fee.
          if (isFeelessAddress[address(_split.allocator)])
            _netPayoutAmount = _payoutAmount;
            // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.
          else {
            unchecked {
              _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                ? _payoutAmount
                : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
            }

            // This distribution is eligible for a fee since the funds are leaving the ecosystem.
            feeEligibleDistributionAmount += _payoutAmount;
          }

          // Trigger any inherited pre-transfer logic.
          _beforeTransferTo(address(_split.allocator), _netPayoutAmount);

          // If this terminal's token is ETH, send it in msg.value.
          uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

          // Create the data to send to the allocator.
          JBSplitAllocationData memory _data = JBSplitAllocationData(
            token,
            _netPayoutAmount,
            decimals,
            _projectId,
            _group,
            _split
          );

          // Trigger the allocator's `allocate` function.
          _split.allocator.allocate{value: _payableValue}(_data);

          // Otherwise, if a project is specified, make a payment to it.
        } else if (_split.projectId != 0) {
          // Get a reference to the Juicebox terminal being used.
          IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);

          // The project must have a terminal to send funds to.
          if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();

          // Save gas if this contract is being used as the terminal.
          if (_terminal == this) {
            // This distribution does not incur a fee.
            _netPayoutAmount = _payoutAmount;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);
            else
              _pay(
                _netPayoutAmount,
                address(this),
                _split.projectId,
                (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          } else {
            // If the terminal is set as feeless, this distribution is not eligible for a fee.
            if (isFeelessAddress[address(_terminal)])
              _netPayoutAmount = _payoutAmount;
              // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.
            else {
              unchecked {
                _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                  ? _payoutAmount
                  : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
              }

              feeEligibleDistributionAmount += _payoutAmount;
            }

            // Trigger any inherited pre-transfer logic.
            _beforeTransferTo(address(_terminal), _netPayoutAmount);

            // If this terminal's token is ETH, send it in msg.value.
            uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _terminal.addToBalanceOf{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                '',
                _projectMetadata
              );
            else
              _terminal.pay{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          }
        } else {
          unchecked {
            _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
              ? _payoutAmount
              : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
          }

          // This distribution is eligible for a fee since the funds are leaving the ecosystem.
          feeEligibleDistributionAmount += _payoutAmount;

          // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.
          _transferFrom(
            address(this),
            _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),
            _netPayoutAmount
          );
        }

        // Subtract from the amount to be sent to the beneficiary.
        unchecked {
          leftoverAmount = leftoverAmount - _payoutAmount;
        }
      }

      emit DistributeToPayoutSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _netPayoutAmount,
        msg.sender
      );

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID.

    @param _projectId The ID of the project having fees taken from.
    @param _fundingCycle The funding cycle during which the fee is being taken.
    @param _amount The amount of the fee to take, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platforms tokens for.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return feeAmount The amount of the fee taken.
  */
  function _takeFeeFrom(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _amount,
    address _beneficiary,
    uint256 _feeDiscount
  ) internal returns (uint256 feeAmount) {
    feeAmount = _feeAmount(_amount, fee, _feeDiscount);

    if (_fundingCycle.shouldHoldFees()) {
      // Store the held fee.
      _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));

      emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender);
    } else {
      // Process the fee.
      _processFee(feeAmount, _beneficiary); // Take the fee.

      emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender);
    }
  }

  /**
    @notice
    Process a fee of the specified amount.

    @param _amount The fee amount, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platform's tokens for.
  */
  function _processFee(uint256 _amount, address _beneficiary) internal {
    // Get the terminal for the protocol project.
    IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token);

    // When processing the admin fee, save gas if the admin is using this contract as its terminal.
    if (_terminal == this)
      _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call.
    else {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_terminal), _amount);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;

      // Send the payment.
      _terminal.pay{value: _payableValue}(
        _PROTOCOL_PROJECT_ID,
        _amount,
        token,
        _beneficiary,
        0,
        false,
        '',
        bytes('')
      ); // Use the external pay call of the correct terminal.
    }
  }

  /**
    @notice
    Contribute tokens to a project.

    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _payer The address making the payment.
    @param _projectId The ID of the project being paid.
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function _pay(
    uint256 _amount,
    address _payer,
    uint256 _projectId,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 beneficiaryTokenCount) {
    // Cant send tokens to the zero address.
    if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the payment is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope.
    {
      IJBPayDelegate _delegate;
      uint256 _tokenCount;

      // Bundle the amount info into a JBTokenAmount struct.
      JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);

      // Record the payment.
      (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(
        _payer,
        _bundledAmount,
        _projectId,
        baseWeightCurrency,
        _beneficiary,
        _memo,
        _metadata
      );

      // Mint the tokens if needed.
      if (_tokenCount > 0)
        // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.
        beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(
          _projectId,
          _tokenCount,
          _beneficiary,
          '',
          _preferClaimedTokens,
          true
        );

      // The token count for the beneficiary must be greater than or equal to the minimum expected.
      if (beneficiaryTokenCount < _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBPayDelegate(address(0))) {
        JBDidPayData memory _data = JBDidPayData(
          _payer,
          _projectId,
          _fundingCycle.configuration,
          _bundledAmount,
          beneficiaryTokenCount,
          _beneficiary,
          _preferClaimedTokens,
          _memo,
          _metadata
        );

        _delegate.didPay(_data);
        emit DelegateDidPay(_delegate, _data, msg.sender);
      }
    }

    emit Pay(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _payer,
      _beneficiary,
      _amount,
      beneficiaryTokenCount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function _addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    bool _shouldRefundHeldFees,
    string memory _memo,
    bytes memory _metadata
  ) internal {
    // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.
    uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0;

    // Record the added funds with any refunded fees.
    store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);

    emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);
  }

  /**
    @notice
    Refund fees based on the specified amount.

    @param _projectId The project for which fees are being refunded.
    @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.

    @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal
  */
  function _refundHeldFees(uint256 _projectId, uint256 _amount)
    internal
    returns (uint256 refundedFees)
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the current held fees.
    delete _heldFeesOf[_projectId];

    // Get a reference to the leftover amount once all fees have been settled.
    uint256 leftoverAmount = _amount;

    // Push length in stack
    uint256 _heldFeesLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeesLength; ) {
      if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);
      else if (leftoverAmount >= _heldFees[_i].amount) {
        unchecked {
          leftoverAmount = leftoverAmount - _heldFees[_i].amount;
          refundedFees += _feeAmount(
            _heldFees[_i].amount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount
          );
        }
      } else {
        _heldFeesOf[_projectId].push(
          JBFee(
            _heldFees[_i].amount - leftoverAmount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount,
            _heldFees[_i].beneficiary
          )
        );
        unchecked {
          refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);
        }
        leftoverAmount = 0;
      }

      unchecked {
        ++_i;
      }
    }

    emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);
  }

  /** 
    @notice 
    Returns the fee amount based on the provided amount for the specified project.

    @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal.
    @param _fee The percentage of the fee, out of MAX_FEE. 
    @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.

    @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _feeAmount(
    uint256 _amount,
    uint256 _fee,
    uint256 _feeDiscount
  ) internal pure returns (uint256) {
    // Calculate the discounted fee.
    uint256 _discountedFee = _fee -
      PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT);

    // The amount of tokens from the `_amount` to pay as a fee.
    return
      _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);
  }

  /** 
    @notice
    Get the fee discount from the fee gauge for the specified project.

    @param _projectId The ID of the project to get a fee discount for.
    
    @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.
  */
  function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {
    // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.
    if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))
      return JBConstants.MAX_FEE_DISCOUNT;

    // Get the fee discount.
    if (feeGauge == IJBFeeGauge(address(0)))
      feeDiscount = 0;
      // If the guage reverts, set the discount to 0.
    else
      try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {
        feeDiscount = discount;
      } catch {
        feeDiscount = 0;
      }

    // If the fee discount is greater than the max, nullify the discount.
    if (feeDiscount > JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;
  }
}
.]

### Summary of Security Vulnerabilities in the Smart Contract

1. **Reentrancy Vulnerability**:
   - Although the contract inherits from `ReentrancyGuard`, which helps prevent reentrant calls, it is crucial to ensure that all external calls are made after state changes to avoid potential reentrancy attacks.

2. **Access Control Issues**:
   - The contract uses the `onlyOwner` modifier for several functions, which could lead to centralization risks. If the owner's private key is compromised, an attacker could gain full control over the contract.
   - The `requirePermission` modifier is used to check permissions for certain actions, but it is essential to ensure that the permission checks are robust and cannot be bypassed.

3. **Error Handling**:
   - The contract uses custom errors for various conditions, which is a good practice. However, it is important to ensure that all potential failure points are covered and that the errors provide sufficient context for debugging.

4. **Fee Management**:
   - The fee management system allows for fees to be set and processed, but there is a risk of setting fees too high. The `_FEE_CAP` is defined, but it is important to ensure that this cap is enforced consistently across all functions that deal with fees.

5. **Token Transfer Logic**:
   - The `_transferFrom` function is marked as internal and is responsible for transferring tokens. It is crucial to ensure that this function is implemented correctly to prevent unauthorized transfers or loss of funds.

6. **Zero Address Checks**:
   - The contract includes checks for zero addresses in several functions, which is a good practice. However, it is essential to ensure that all functions that involve address parameters include these checks to prevent sending funds to the zero address.

7. **Gas Limit Issues**:
   - The contract contains loops that process arrays (e.g., processing held fees). If the arrays become too large, this could lead to exceeding the gas limit, causing transactions to fail.

8. **Fallback Function**:
   - The contract does not explicitly define a fallback function to handle unexpected Ether transfers. This could lead to loss of funds if Ether is sent directly to the contract.

### Comprehensive Analysis Report

The `JBPayoutRedemptionPaymentTerminal` contract is a complex smart contract designed to manage inflows and outflows of funds within a protocol ecosystem. While it incorporates several best practices, such as using OpenZeppelin's `Ownable` and `ReentrancyGuard`, there are notable security vulnerabilities that need to be addressed.

1. **Reentrancy Protection**: The use of `ReentrancyGuard` is a positive aspect, but developers must ensure that all external calls are made after state changes to mitigate reentrancy risks effectively.

2. **Access Control**: The reliance on the `onlyOwner` modifier raises concerns about centralization. It is advisable to consider implementing a multi-signature wallet or a decentralized governance mechanism to enhance security.

3. **Error Handling and Logging**: The contract employs custom errors, which is beneficial for gas efficiency and clarity. However, developers should ensure comprehensive error handling to cover all potential failure scenarios.

4. **Fee Management**: The fee structure is crucial for the contract's operation. It is essential to enforce the `_FEE_CAP` consistently and consider implementing a mechanism for fee adjustments that involves community input or governance.

5. **Token Transfer Logic**: The implementation of the `_transferFrom` function must be scrutinized to ensure it is secure and does not allow unauthorized transfers.

6. **Zero Address Checks**: While checks for zero addresses are present, it is vital to ensure that all functions involving addresses are protected against this vulnerability.

7. **Gas Limit Considerations**: The potential for gas limit issues due to loops processing large arrays should be addressed, possibly by implementing pagination or limiting the size of arrays processed in a single transaction.

8. **Fallback Function**: The absence of a fallback function could lead to loss of funds if Ether is sent directly to the contract. Implementing a fallback function to handle such cases is recommended.

In conclusion, while the `JBPayoutRedemptionPaymentTerminal` contract demonstrates a solid foundation, addressing the identified vulnerabilities will significantly enhance its security posture. A thorough review and testing process, including audits and community feedback, should be conducted before deployment to ensure the contract operates securely and efficiently within the intended ecosystem.

[2024-01-09 17:17:56 INFO] **[Seminar Conclusion]**:

 ### Summary of Security Vulnerabilities in the Smart Contract

1. **Reentrancy Vulnerability**:
   - Although the contract inherits from `ReentrancyGuard`, which helps prevent reentrant calls, it is crucial to ensure that all external calls are made after state changes to avoid potential reentrancy attacks.

2. **Access Control Issues**:
   - The contract uses the `onlyOwner` modifier for several functions, which could lead to centralization risks. If the owner's private key is compromised, an attacker could gain full control over the contract.
   - The `requirePermission` modifier is used to check permissions for certain actions, but it is essential to ensure that the permission checks are robust and cannot be bypassed.

3. **Error Handling**:
   - The contract uses custom errors for various conditions, which is a good practice. However, it is important to ensure that all potential failure points are covered and that the errors provide sufficient context for debugging.

4. **Fee Management**:
   - The fee management system allows for fees to be set and processed, but there is a risk of setting fees too high. The `_FEE_CAP` is defined, but it is important to ensure that this cap is enforced consistently across all functions that deal with fees.

5. **Token Transfer Logic**:
   - The `_transferFrom` function is marked as internal and is responsible for transferring tokens. It is crucial to ensure that this function is implemented correctly to prevent unauthorized transfers or loss of funds.

6. **Zero Address Checks**:
   - The contract includes checks for zero addresses in several functions, which is a good practice. However, it is essential to ensure that all functions that involve address parameters include these checks to prevent sending funds to the zero address.

7. **Gas Limit Issues**:
   - The contract contains loops that process arrays (e.g., processing held fees). If the arrays become too large, this could lead to exceeding the gas limit, causing transactions to fail.

8. **Fallback Function**:
   - The contract does not explicitly define a fallback function to handle unexpected Ether transfers. This could lead to loss of funds if Ether is sent directly to the contract.

### Comprehensive Analysis Report

The `JBPayoutRedemptionPaymentTerminal` contract is a complex smart contract designed to manage inflows and outflows of funds within a protocol ecosystem. While it incorporates several best practices, such as using OpenZeppelin's `Ownable` and `ReentrancyGuard`, there are notable security vulnerabilities that need to be addressed.

1. **Reentrancy Protection**: The use of `ReentrancyGuard` is a positive aspect, but developers must ensure that all external calls are made after state changes to mitigate reentrancy risks effectively.

2. **Access Control**: The reliance on the `onlyOwner` modifier raises concerns about centralization. It is advisable to consider implementing a multi-signature wallet or a decentralized governance mechanism to enhance security.

3. **Error Handling and Logging**: The contract employs custom errors, which is beneficial for gas efficiency and clarity. However, developers should ensure comprehensive error handling to cover all potential failure scenarios.

4. **Fee Management**: The fee structure is crucial for the contract's operation. It is essential to enforce the `_FEE_CAP` consistently and consider implementing a mechanism for fee adjustments that involves community input or governance.

5. **Token Transfer Logic**: The implementation of the `_transferFrom` function must be scrutinized to ensure it is secure and does not allow unauthorized transfers.

6. **Zero Address Checks**: While checks for zero addresses are present, it is vital to ensure that all functions involving addresses are protected against this vulnerability.

7. **Gas Limit Considerations**: The potential for gas limit issues due to loops processing large arrays should be addressed, possibly by implementing pagination or limiting the size of arrays processed in a single transaction.

8. **Fallback Function**: The absence of a fallback function could lead to loss of funds if Ether is sent directly to the contract. Implementing a fallback function to handle such cases is recommended.

In conclusion, while the `JBPayoutRedemptionPaymentTerminal` contract demonstrates a solid foundation, addressing the identified vulnerabilities will significantly enhance its security posture. A thorough review and testing process, including audits and community feedback, should be conducted before deployment to ensure the contract operates securely and efficiently within the intended ecosystem.

[2024-01-09 17:17:56 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-01-09 17:17:56 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/security/ReentrancyGuard.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './../interfaces/IJBController.sol'; import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol'; import './../libraries/JBConstants.sol'; import './../libraries/JBCurrencies.sol'; import './../libraries/JBFixedPointNumber.sol'; import './../libraries/JBFundingCycleMetadataResolver.sol'; import './../libraries/JBOperations.sol'; import './../libraries/JBSplitsGroups.sol'; import './../libraries/JBTokens.sol'; import './../structs/JBTokenAmount.sol'; import './JBOperatable.sol'; import './JBSingleTokenPaymentTerminal.sol'; /**   @notice   Generic terminal managing all inflows and outflows of funds into the protocol ecosystem. @dev   A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time. @dev   Adheres to -   IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules. @dev   Inherits from -   JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.   JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.   Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.   ReentrancyGuard: Contract module that helps prevent reentrant calls to a function. */ abstract contract JBPayoutRedemptionPaymentTerminal is   IJBPayoutRedemptionPaymentTerminal,   JBSingleTokenPaymentTerminal,   JBOperatable,   Ownable,   ReentrancyGuard {   // A library that parses the packed funding cycle metadata into a friendlier format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error FEE_TOO_HIGH();   error INADEQUATE_DISTRIBUTION_AMOUNT();   error INADEQUATE_RECLAIM_AMOUNT();   error INADEQUATE_TOKEN_COUNT();   error NO_MSG_VALUE_ALLOWED();   error PAY_TO_ZERO_ADDRESS();   error PROJECT_TERMINAL_MISMATCH();   error REDEEM_TO_ZERO_ADDRESS();   error TERMINAL_IN_SPLIT_ZERO_ADDRESS();   error TERMINAL_TOKENS_INCOMPATIBLE(); //***********//   // ---------------------------- modifiers ---------------------------- //   //*************// /*      @notice      A modifier that verifies this terminal is a terminal of provided project ID.   /   modifier isTerminalOf(uint256 projectId) {     if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();     ;   } //***********//   // --------------------- internal stored constants ------------------- //   //*************// /**     @notice     Maximum fee that can be set for a funding cycle configuration. @dev Out of MAX_FEE (50_000_000 / 1_000_000_000).  */   uint256 internal constant _FEE_CAP = 50_000_000; /*     @notice     The protocol project ID is 1, as it should be the first project launched during the deployment process.   /   uint256 internal constant _PROTOCOL_PROJECT_ID = 1; //***********//   // --------------------- internal stored properties ------------------ //   //*************// /**     @notice     Fees that are being held to be processed later. _projectId The ID of the project for which fees are being held.  */   mapping(uint256 =&gt; JBFee[]) internal _heldFeesOf; //***********//   // ---------------- public immutable stored properties --------------- //   //*************// /*     @notice     Mints ERC-721's that represent project ownership and transfers.   /   IJBProjects public immutable override projects; /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; /*     @notice     The contract that stores splits for each project.   /   IJBSplitsStore public immutable override splitsStore; /*     @notice     The contract that exposes price feeds.   /   IJBPrices public immutable override prices; /*     @notice     The contract that stores and manages the terminal's data.   /   IJBSingleTokenPaymentTerminalStore public immutable override store; /**     @notice     The currency to base token issuance on. @dev If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.  */   uint256 public immutable override baseWeightCurrency; /*     @notice     The group that payout splits coming from this terminal are identified by.   /   uint256 public immutable override payoutSplitsGroup; //***********//   // --------------------- public stored properties -------------------- //   //*************// /**     @notice     The platform fee percent. @dev Out of MAX_FEE (25_000_000 / 1_000_000_000)  */   uint256 public override fee = 25_000_000; // 2.5% /*     @notice     The data source that returns a discount to apply to a project's fee.   /   IJBFeeGauge public override feeGauge; /**     @notice     Addresses that can be paid towards from this terminal without incurring a fee. _address The address that can be paid toward.  */   mapping(address =&gt; bool) public override isFeelessAddress; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     Gets the current overflowed amount in this terminal for a specified project, in terms of ETH. @dev The current overflow is represented as a fixed point number with 18 decimals.  @param _projectId The ID of the project to get overflow for.  @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.  */   function currentEthOverflowOf(uint256 _projectId)     external     view     virtual     override     returns (uint256)   {     // Get this terminal's current overflow.     uint256 _overflow = store.currentOverflowOf(this, _projectId); // Adjust the decimals of the fixed point number if needed to have 18 decimals. uint256 _adjustedOverflow = (decimals == 18)   ? _overflow   : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);  // Return the amount converted to ETH. return   (currency == JBCurrencies.ETH)     ? _adjustedOverflow     : PRBMath.mulDiv(       _adjustedOverflow,       10**decimals,       prices.priceFor(currency, JBCurrencies.ETH, decimals)     );  } /**     @notice     The fees that are currently being held to be processed later for each project. @param _projectId The ID of the project for which fees are being held.  @return An array of fees that are being held.  */   function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {     return _heldFeesOf[_projectId];   } //***********//   // -------------------------- public views --------------------------- //   //*************// /**     @notice     Indicates if this contract adheres to the specified interface. @dev  See {IERC165-supportsInterface}.  @param _interfaceId The ID of the interface to check for adherance to.  */   function supportsInterface(bytes4 _interfaceId)     public     view     virtual     override(JBSingleTokenPaymentTerminal, IERC165)     returns (bool)   {     return       _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||       _interfaceId == type(IJBPayoutTerminal).interfaceId ||       _interfaceId == type(IJBAllowanceTerminal).interfaceId ||       _interfaceId == type(IJBRedemptionTerminal).interfaceId ||       _interfaceId == type(IJBOperatable).interfaceId ||       super.supportsInterface(_interfaceId);   } //***********//   // -------------------------- constructor ---------------------------- //   //*************// /*     @param _token The token that this terminal manages.     @param _decimals The number of decimals the token fixed point amounts are expected to have.     @param _currency The currency that this terminal's token adheres to for price feeds.     @param _baseWeightCurrency The currency to base token issuance on.     @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.     @param _operatorStore A contract storing operator assignments.     @param _projects A contract which mints ERC-721's that represent project ownership and transfers.     @param _directory A contract storing directories of terminals and controllers for each project.     @param _splitsStore A contract that stores splits for each project.     @param _prices A contract that exposes price feeds.     @param _store A contract that stores the terminal's data.     @param _owner The address that will own this contract.   /   constructor(     // payable constructor save the gas used to check msg.value==0     address _token,     uint256 _decimals,     uint256 _currency,     uint256 _baseWeightCurrency,     uint256 _payoutSplitsGroup,     IJBOperatorStore _operatorStore,     IJBProjects _projects,     IJBDirectory _directory,     IJBSplitsStore _splitsStore,     IJBPrices _prices,     IJBSingleTokenPaymentTerminalStore _store,     address _owner   )     payable     JBSingleTokenPaymentTerminal(_token, _decimals, _currency)     JBOperatable(_operatorStore)   {     baseWeightCurrency = _baseWeightCurrency;     payoutSplitsGroup = _payoutSplitsGroup;     projects = _projects;     directory = _directory;     splitsStore = _splitsStore;     prices = _prices;     store = _store; transferOwnership(_owner);  } //***********//   // ---------------------- external transactions ---------------------- //   //*************// /**     @notice     Contribute tokens to a project. @param _projectId The ID of the project being paid. @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place. @param _token The token being paid. This terminal ignores this property since it only manages one token.  @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate. @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal. @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas. @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.  */   function pay(     uint256 _projectId,     uint256 _amount,     address _token,     address _beneficiary,     uint256 _minReturnedTokens,     bool _preferClaimedTokens,     string calldata _memo,     bytes calldata _metadata   ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {     _token; // Prevents unused var compiler and natspec complaints. // ETH shouldn't be sent if this terminal's token isn't ETH. if (token != JBTokens.ETH) {   if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();    // Transfer tokens to this terminal from the msg sender.   _transferFrom(msg.sender, payable(address(this)), _amount); } // If this terminal's token is ETH, override _amount with msg.value. else _amount = msg.value;  return   _pay(     _amount,     msg.sender,     _projectId,     _beneficiary,     _minReturnedTokens,     _preferClaimedTokens,     _memo,     _metadata   );  } /**     @notice     Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source. @dev Only a token holder or a designated operator can redeem its tokens.  @param _holder The account to redeem tokens for. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _token The token being reclaimed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal. @param _beneficiary The address to send the terminal tokens to. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.  */   function redeemTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     address _token,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo,     bytes memory _metadata   )     external     virtual     override     requirePermission(_holder, _projectId, JBOperations.REDEEM)     returns (uint256 reclaimAmount)   {     _token; // Prevents unused var compiler and natspec complaints. return   _redeemTokensOf(     _holder,     _projectId,     _tokenCount,     _minReturnedTokens,     _beneficiary,     _memo,     _metadata   );  } /**     @notice     Distributes payouts for a project with the distribution limit of its current funding cycle. @dev Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.  @dev Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.  @dev All funds distributed outside of this contract or any feeless terminals incure the protocol fee.  @param _projectId The ID of the project having its payouts distributed. @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency. @param _token The token being distributed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal. @param _memo A memo to pass along to the emitted event.  @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.  */   function distributePayoutsOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     address _token,     uint256 _minReturnedTokens,     string calldata _memo   ) external virtual override returns (uint256 netLeftoverDistributionAmount) {     _token; // Prevents unused var compiler and natspec complaints. return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);  } /**     @notice     Allows a project to send funds from its overflow up to the preconfigured allowance. @dev Only a project's owner or a designated operator can use its allowance.  @dev Incurs the protocol fee.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency. @param _token The token being distributed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals. @param _beneficiary The address to send the funds to. @param _memo A memo to pass along to the emitted event.  @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.  */   function useAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     address _token,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)     returns (uint256 netDistributedAmount)   {     _token; // Prevents unused var compiler and natspec complaints. return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);  } /**     @notice     Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type. @dev Only a project's owner or a designated operator can migrate it.  @param _projectId The ID of the project being migrated. @param _to The terminal contract that will gain the project's funds.  @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.  */   function migrate(uint256 _projectId, IJBPaymentTerminal _to)     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)     returns (uint256 balance)   {     // The terminal being migrated to must accept the same token as this terminal.     if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE(); // Record the migration in the store. balance = store.recordMigration(_projectId);  // Transfer the balance if needed. if (balance &gt; 0) {   // Trigger any inherited pre-transfer logic.   _beforeTransferTo(address(_to), balance);    // If this terminal's token is ETH, send it in msg.value.   uint256 _payableValue = token == JBTokens.ETH ? balance : 0;    // Withdraw the balance to transfer to the new terminal;   _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes('')); }  emit Migrate(_projectId, _to, balance, msg.sender);  } /**     @notice     Receives funds belonging to the specified project. @param _projectId The ID of the project to which the funds received belong. @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead. @param _token The token being paid. This terminal ignores this property since it only manages one currency.  @param _memo A memo to pass along to the emitted event. @param _metadata Extra data to pass along to the emitted event.  */   function addToBalanceOf(     uint256 _projectId,     uint256 _amount,     address _token,     string calldata _memo,     bytes calldata _metadata   ) external payable virtual override isTerminalOf(_projectId) {     _token; // Prevents unused var compiler and natspec complaints. // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender. if (token != JBTokens.ETH) {   // Amount must be greater than 0.   if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();    // Transfer tokens to this terminal from the msg sender.   _transferFrom(msg.sender, payable(address(this)), _amount); } // If the terminal's token is ETH, override `_amount` with msg.value. else _amount = msg.value;  // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal. _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);  } /**     @notice     Process any fees that are being held for the project. @dev Only a project owner, an operator, or the contract's owner can process held fees.  @param _projectId The ID of the project whos held fees should be processed.  */   function processFees(uint256 _projectId)     external     virtual     override     requirePermissionAllowingOverride(       projects.ownerOf(_projectId),       _projectId,       JBOperations.PROCESS_FEES,       msg.sender == owner()     )   {     // Get a reference to the project's held fees.     JBFee[] memory _heldFees = _heldFeesOf[_projectId]; // Delete the held fees. delete _heldFeesOf[_projectId];  // Push array length in stack uint256 _heldFeeLength = _heldFees.length;  // Process each fee. for (uint256 _i = 0; _i &lt; _heldFeeLength; ) {   // Get the fee amount.   uint256 _amount = _feeAmount(     _heldFees[_i].amount,     _heldFees[_i].fee,     _heldFees[_i].feeDiscount   );    // Process the fee.   _processFee(_amount, _heldFees[_i].beneficiary);    emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);    unchecked {     ++_i;   } }  } /**     @notice     Allows the fee to be updated. @dev Only the owner of this contract can change the fee.  @param _fee The new fee, out of MAX_FEE.  */   function setFee(uint256 _fee) external virtual override onlyOwner {     // The provided fee must be within the max.     if (_fee &gt; _FEE_CAP) revert FEE_TOO_HIGH(); // Store the new fee. fee = _fee;  emit SetFee(_fee, msg.sender);  } /**     @notice     Allows the fee gauge to be updated. @dev Only the owner of this contract can change the fee gauge.  @dev If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.  @param _feeGauge The new fee gauge.  */   function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {     // Store the new fee gauge.     feeGauge = _feeGauge; emit SetFeeGauge(_feeGauge, msg.sender);  } /**     @notice     Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee. @dev Only the owner of this contract can set addresses as feeless.  @param _address The address that can be paid towards while still bypassing fees. @param _flag A flag indicating whether the terminal should be feeless or not.  */   function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {     // Set the flag value.     isFeelessAddress[_address] = _flag; emit SetFeelessAddress(_address, _flag, msg.sender);  } //***********//   // ---------------------- internal transactions ---------------------- //   //*************// /**      @notice     Transfers tokens. @param _from The address from which the transfer should originate. @param _to The address to which the transfer should go. @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.  */   function _transferFrom(     address _from,     address payable _to,     uint256 _amount   ) internal virtual; /**      @notice     Logic to be triggered before transferring tokens from this terminal. @param _to The address to which the transfer is going. @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.  */   function _beforeTransferTo(address _to, uint256 _amount) internal virtual; /**     @notice     Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source. @dev Only a token holder or a designated operator can redeem its tokens.  @param _holder The account to redeem tokens for. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal. @param _beneficiary The address to send the terminal tokens to. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.  */   function _redeemTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo,     bytes memory _metadata   ) internal returns (uint256 reclaimAmount) {     // Can't send reclaimed funds to the zero address.     if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS(); // Define variables that will be needed outside the scoped section below. // Keep a reference to the funding cycle during which the redemption is being made. JBFundingCycle memory _fundingCycle;  // Scoped section prevents stack too deep. `_delegate` only used within scope. {   IJBRedemptionDelegate _delegate;    // Record the redemption.   (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(     _holder,     _projectId,     _tokenCount,     _memo,     _metadata   );    // The amount being reclaimed must be at least as much as was expected.   if (reclaimAmount &lt; _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();    // Burn the project tokens.   if (_tokenCount &gt; 0)     IJBController(directory.controllerOf(_projectId)).burnTokensOf(       _holder,       _projectId,       _tokenCount,       '',       false     );    // If a delegate was returned by the data source, issue a callback to it.   if (_delegate != IJBRedemptionDelegate(address(0))) {     JBDidRedeemData memory _data = JBDidRedeemData(       _holder,       _projectId,       _fundingCycle.configuration,       _tokenCount,       JBTokenAmount(token, reclaimAmount, decimals, currency),       _beneficiary,       _memo,       _metadata     );     _delegate.didRedeem(_data);     emit DelegateDidRedeem(_delegate, _data, msg.sender);   } }  // Send the reclaimed funds to the beneficiary. if (reclaimAmount &gt; 0) _transferFrom(address(this), _beneficiary, reclaimAmount);  emit RedeemTokens(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _holder,   _beneficiary,   _tokenCount,   reclaimAmount,   _memo,   _metadata,   msg.sender );  } /**     @notice     Distributes payouts for a project with the distribution limit of its current funding cycle. @dev Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.  @dev Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.  @dev All funds distributed outside of this contract or any feeless terminals incure the protocol fee.  @param _projectId The ID of the project having its payouts distributed. @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency. @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal. @param _memo A memo to pass along to the emitted event.  @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.  */   function _distributePayoutsOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     uint256 _minReturnedTokens,     string calldata _memo   ) internal returns (uint256 netLeftoverDistributionAmount) {     // Record the distribution.     (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(       _projectId,       _amount,       _currency     ); // The amount being distributed must be at least as much as was expected. if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();  // Get a reference to the project owner, which will receive tokens from paying the platform fee // and receive any extra distributable funds not allocated to payout splits. address payable _projectOwner = payable(projects.ownerOf(_projectId));  // Define variables that will be needed outside the scoped section below. // Keep a reference to the fee amount that was paid. uint256 _fee;  // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope. {   // Get the amount of discount that should be applied to any fees taken.   // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.   uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]     ? JBConstants.MAX_FEE_DISCOUNT     : _currentFeeDiscount(_projectId);    // The amount distributed that is eligible for incurring fees.   uint256 _feeEligibleDistributionAmount;    // The amount leftover after distributing to the splits.   uint256 _leftoverDistributionAmount;    // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.   // Also get a reference to the amount that was distributed to splits from which fees should be taken.   (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(     _projectId,     _fundingCycle.configuration,     payoutSplitsGroup,     _distributedAmount,     _feeDiscount   );    // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.   unchecked {     _feeEligibleDistributionAmount += _leftoverDistributionAmount;   }    // Take the fee.   _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0     ? 0     : _takeFeeFrom(       _projectId,       _fundingCycle,       _feeEligibleDistributionAmount,       _projectOwner,       _feeDiscount     );    // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.    unchecked {     netLeftoverDistributionAmount = _leftoverDistributionAmount == 0       ? 0       : _leftoverDistributionAmount -         _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);   }    // Transfer any remaining balance to the project owner.   if (netLeftoverDistributionAmount &gt; 0)     _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount); }  emit DistributePayouts(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _projectOwner,   _amount,   _distributedAmount,   _fee,   netLeftoverDistributionAmount,   _memo,   msg.sender );  } /**     @notice     Allows a project to send funds from its overflow up to the preconfigured allowance. @dev Only a project's owner or a designated operator can use its allowance.  @dev Incurs the protocol fee.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency. @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals. @param _beneficiary The address to send the funds to. @param _memo A memo to pass along to the emitted event.  @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.  */   function _useAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo   ) internal returns (uint256 netDistributedAmount) {     // Record the use of the allowance.     (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(       _projectId,       _amount,       _currency     ); // The amount being withdrawn must be at least as much as was expected. if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();  // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope. {   // Keep a reference to the fee amount that was paid.   uint256 _fee;    // Get a reference to the project owner, which will receive tokens from paying the platform fee.   address _projectOwner = projects.ownerOf(_projectId);    // Get the amount of discount that should be applied to any fees taken.   // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.   uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]     ? JBConstants.MAX_FEE_DISCOUNT     : _currentFeeDiscount(_projectId);    // Take a fee from the `_distributedAmount`, if needed.   _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT     ? 0     : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);    unchecked {     // The net amount is the withdrawn amount without the fee.     netDistributedAmount = _distributedAmount - _fee;   }    // Transfer any remaining balance to the beneficiary.   if (netDistributedAmount &gt; 0)     _transferFrom(address(this), _beneficiary, netDistributedAmount); }  emit UseAllowance(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _beneficiary,   _amount,   _distributedAmount,   netDistributedAmount,   _memo,   msg.sender );  } /**     @notice     Pays out splits for a project's funding cycle configuration. @param _projectId The ID of the project for which payout splits are being distributed. @param _domain The domain of the splits to distribute the payout between. @param _group The group of the splits to distribute the payout between. @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal. @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.  @return leftoverAmount If the leftover amount if the splits don't add up to 100%. @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.  */   function _distributeToPayoutSplitsOf(     uint256 _projectId,     uint256 _domain,     uint256 _group,     uint256 _amount,     uint256 _feeDiscount   ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {     // Set the leftover amount to the initial amount.     leftoverAmount = _amount; // Get a reference to the project's payout splits. JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);  // Transfer between all splits. for (uint256 _i = 0; _i &lt; _splits.length; ) {   // Get a reference to the split being iterated on.   JBSplit memory _split = _splits[_i];    // The amount to send towards the split.   uint256 _payoutAmount = PRBMath.mulDiv(     _amount,     _split.percent,     JBConstants.SPLITS_TOTAL_PERCENT   );    // The payout amount substracting any applicable incurred fees.   uint256 _netPayoutAmount;    if (_payoutAmount &gt; 0) {     // Transfer tokens to the split.     // If there's an allocator set, transfer to its `allocate` function.     if (_split.allocator != IJBSplitAllocator(address(0))) {       // If the split allocator is set as feeless, this distribution is not eligible for a fee.       if (isFeelessAddress[address(_split.allocator)])         _netPayoutAmount = _payoutAmount;         // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.       else {         unchecked {           _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT             ? _payoutAmount             : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);         }          // This distribution is eligible for a fee since the funds are leaving the ecosystem.         feeEligibleDistributionAmount += _payoutAmount;       }        // Trigger any inherited pre-transfer logic.       _beforeTransferTo(address(_split.allocator), _netPayoutAmount);        // If this terminal's token is ETH, send it in msg.value.       uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;        // Create the data to send to the allocator.       JBSplitAllocationData memory _data = JBSplitAllocationData(         token,         _netPayoutAmount,         decimals,         _projectId,         _group,         _split       );        // Trigger the allocator's `allocate` function.       _split.allocator.allocate{value: _payableValue}(_data);        // Otherwise, if a project is specified, make a payment to it.     } else if (_split.projectId != 0) {       // Get a reference to the Juicebox terminal being used.       IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);        // The project must have a terminal to send funds to.       if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();        // Save gas if this contract is being used as the terminal.       if (_terminal == this) {         // This distribution does not incur a fee.         _netPayoutAmount = _payoutAmount;          // Send the projectId in the metadata.         bytes memory _projectMetadata = new bytes(32);         _projectMetadata = bytes(abi.encodePacked(_projectId));          // Add to balance if prefered.         if (_split.preferAddToBalance)           _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);         else           _pay(             _netPayoutAmount,             address(this),             _split.projectId,             (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,             0,             _split.preferClaimed,             '',             _projectMetadata           );       } else {         // If the terminal is set as feeless, this distribution is not eligible for a fee.         if (isFeelessAddress[address(_terminal)])           _netPayoutAmount = _payoutAmount;           // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.         else {           unchecked {             _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT               ? _payoutAmount               : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);           }            feeEligibleDistributionAmount += _payoutAmount;         }          // Trigger any inherited pre-transfer logic.         _beforeTransferTo(address(_terminal), _netPayoutAmount);          // If this terminal's token is ETH, send it in msg.value.         uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;          // Send the projectId in the metadata.         bytes memory _projectMetadata = new bytes(32);         _projectMetadata = bytes(abi.encodePacked(_projectId));          // Add to balance if prefered.         if (_split.preferAddToBalance)           _terminal.addToBalanceOf{value: _payableValue}(             _split.projectId,             _netPayoutAmount,             token,             '',             _projectMetadata           );         else           _terminal.pay{value: _payableValue}(             _split.projectId,             _netPayoutAmount,             token,             _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,             0,             _split.preferClaimed,             '',             _projectMetadata           );       }     } else {       unchecked {         _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT           ? _payoutAmount           : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);       }        // This distribution is eligible for a fee since the funds are leaving the ecosystem.       feeEligibleDistributionAmount += _payoutAmount;        // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.       _transferFrom(         address(this),         _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),         _netPayoutAmount       );     }      // Subtract from the amount to be sent to the beneficiary.     unchecked {       leftoverAmount = leftoverAmount - _payoutAmount;     }   }    emit DistributeToPayoutSplit(     _projectId,     _domain,     _group,     _split,     _netPayoutAmount,     msg.sender   );    unchecked {     ++_i;   } }  } /**     @notice     Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID. @param _projectId The ID of the project having fees taken from. @param _fundingCycle The funding cycle during which the fee is being taken. @param _amount The amount of the fee to take, as a floating point number with 18 decimals. @param _beneficiary The address to mint the platforms tokens for. @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.  @return feeAmount The amount of the fee taken.  */   function _takeFeeFrom(     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _amount,     address _beneficiary,     uint256 _feeDiscount   ) internal returns (uint256 feeAmount) {     feeAmount = _feeAmount(_amount, fee, _feeDiscount); if (_fundingCycle.shouldHoldFees()) {   // Store the held fee.   _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));    emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender); } else {   // Process the fee.   _processFee(feeAmount, _beneficiary); // Take the fee.    emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender); }  } /**     @notice     Process a fee of the specified amount. @param _amount The fee amount, as a floating point number with 18 decimals. @param _beneficiary The address to mint the platform's tokens for.  */   function _processFee(uint256 _amount, address _beneficiary) internal {     // Get the terminal for the protocol project.     IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token); // When processing the admin fee, save gas if the admin is using this contract as its terminal. if (_terminal == this)   _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call. else {   // Trigger any inherited pre-transfer logic.   _beforeTransferTo(address(_terminal), _amount);    // If this terminal's token is ETH, send it in msg.value.   uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;    // Send the payment.   _terminal.pay{value: _payableValue}(     _PROTOCOL_PROJECT_ID,     _amount,     token,     _beneficiary,     0,     false,     '',     bytes('')   ); // Use the external pay call of the correct terminal. }  } /**     @notice     Contribute tokens to a project. @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place. @param _payer The address making the payment. @param _projectId The ID of the project being paid. @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate. @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal. @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas. @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.  */   function _pay(     uint256 _amount,     address _payer,     uint256 _projectId,     address _beneficiary,     uint256 _minReturnedTokens,     bool _preferClaimedTokens,     string memory _memo,     bytes memory _metadata   ) internal returns (uint256 beneficiaryTokenCount) {     // Cant send tokens to the zero address.     if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS(); // Define variables that will be needed outside the scoped section below. // Keep a reference to the funding cycle during which the payment is being made. JBFundingCycle memory _fundingCycle;  // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope. {   IJBPayDelegate _delegate;   uint256 _tokenCount;    // Bundle the amount info into a JBTokenAmount struct.   JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);    // Record the payment.   (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(     _payer,     _bundledAmount,     _projectId,     baseWeightCurrency,     _beneficiary,     _memo,     _metadata   );    // Mint the tokens if needed.   if (_tokenCount &gt; 0)     // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.     beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(       _projectId,       _tokenCount,       _beneficiary,       '',       _preferClaimedTokens,       true     );    // The token count for the beneficiary must be greater than or equal to the minimum expected.   if (beneficiaryTokenCount &lt; _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();    // If a delegate was returned by the data source, issue a callback to it.   if (_delegate != IJBPayDelegate(address(0))) {     JBDidPayData memory _data = JBDidPayData(       _payer,       _projectId,       _fundingCycle.configuration,       _bundledAmount,       beneficiaryTokenCount,       _beneficiary,       _preferClaimedTokens,       _memo,       _metadata     );      _delegate.didPay(_data);     emit DelegateDidPay(_delegate, _data, msg.sender);   } }  emit Pay(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _payer,   _beneficiary,   _amount,   beneficiaryTokenCount,   _memo,   _metadata,   msg.sender );  } /**     @notice     Receives funds belonging to the specified project. @param _projectId The ID of the project to which the funds received belong. @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead. @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added. @param _memo A memo to pass along to the emitted event. @param _metadata Extra data to pass along to the emitted event.  */   function _addToBalanceOf(     uint256 _projectId,     uint256 _amount,     bool _shouldRefundHeldFees,     string memory _memo,     bytes memory _metadata   ) internal {     // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.     uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0; // Record the added funds with any refunded fees. store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);  emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);  } /**     @notice     Refund fees based on the specified amount. @param _projectId The project for which fees are being refunded. @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.  @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal  */   function _refundHeldFees(uint256 _projectId, uint256 _amount)     internal     returns (uint256 refundedFees)   {     // Get a reference to the project's held fees.     JBFee[] memory _heldFees = _heldFeesOf[_projectId]; // Delete the current held fees. delete _heldFeesOf[_projectId];  // Get a reference to the leftover amount once all fees have been settled. uint256 leftoverAmount = _amount;  // Push length in stack uint256 _heldFeesLength = _heldFees.length;  // Process each fee. for (uint256 _i = 0; _i &lt; _heldFeesLength; ) {   if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);   else if (leftoverAmount &gt;= _heldFees[_i].amount) {     unchecked {       leftoverAmount = leftoverAmount - _heldFees[_i].amount;       refundedFees += _feeAmount(         _heldFees[_i].amount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount       );     }   } else {     _heldFeesOf[_projectId].push(       JBFee(         _heldFees[_i].amount - leftoverAmount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount,         _heldFees[_i].beneficiary       )     );     unchecked {       refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);     }     leftoverAmount = 0;   }    unchecked {     ++_i;   } }  emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);  } /**      @notice      Returns the fee amount based on the provided amount for the specified project. @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal. @param _fee The percentage of the fee, out of MAX_FEE.  @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.  @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.  */   function _feeAmount(     uint256 _amount,     uint256 _fee,     uint256 _feeDiscount   ) internal pure returns (uint256) {     // Calculate the discounted fee.     uint256 _discountedFee = _fee -       PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT); // The amount of tokens from the `_amount` to pay as a fee. return   _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);  } /**      @notice     Get the fee discount from the fee gauge for the specified project. @param _projectId The ID of the project to get a fee discount for.  @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.  */   function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {     // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.     if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))       return JBConstants.MAX_FEE_DISCOUNT; // Get the fee discount. if (feeGauge == IJBFeeGauge(address(0)))   feeDiscount = 0;   // If the guage reverts, set the discount to 0. else   try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {     feeDiscount = discount;   } catch {     feeDiscount = 0;   }  // If the fee discount is greater than the max, nullify the discount. if (feeDiscount &gt; JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;  } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@paulrberg/contracts/math/PRBMath.sol';\nimport './../interfaces/IJBController.sol';\nimport './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol';\nimport './../libraries/JBConstants.sol';\nimport './../libraries/JBCurrencies.sol';\nimport './../libraries/JBFixedPointNumber.sol';\nimport './../libraries/JBFundingCycleMetadataResolver.sol';\nimport './../libraries/JBOperations.sol';\nimport './../libraries/JBSplitsGroups.sol';\nimport './../libraries/JBTokens.sol';\nimport './../structs/JBTokenAmount.sol';\nimport './JBOperatable.sol';\nimport './JBSingleTokenPaymentTerminal.sol';\n\n/\n  @notice\n  Generic terminal managing all inflows and outflows of funds into the protocol ecosystem.\n\n  @dev\n  A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time.\n\n  @dev\n  Adheres to -\n  IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.\n\n  @dev\n  Inherits from -\n  JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.\n  JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.\n  Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.\n  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.\n/\nabstract contract JBPayoutRedemptionPaymentTerminal is\n  IJBPayoutRedemptionPaymentTerminal,\n  JBSingleTokenPaymentTerminal,\n  JBOperatable,\n  Ownable,\n  ReentrancyGuard\n{\n  // A library that parses the packed funding cycle metadata into a friendlier format.\n  using JBFundingCycleMetadataResolver for JBFundingCycle;\n\n  //*********//\n  // --------------------------- custom errors ------------------------- //\n  //*********//\n  error FEE_TOO_HIGH();\n  error INADEQUATE_DISTRIBUTION_AMOUNT();\n  error INADEQUATE_RECLAIM_AMOUNT();\n  error INADEQUATE_TOKEN_COUNT();\n  error NO_MSG_VALUE_ALLOWED();\n  error PAY_TO_ZERO_ADDRESS();\n  error PROJECT_TERMINAL_MISMATCH();\n  error REDEEM_TO_ZERO_ADDRESS();\n  error TERMINAL_IN_SPLIT_ZERO_ADDRESS();\n  error TERMINAL_TOKENS_INCOMPATIBLE();\n\n  //*********//\n  // ---------------------------- modifiers ---------------------------- //\n  //*********//\n\n  / \n    @notice \n    A modifier that verifies this terminal is a terminal of provided project ID.\n  /\n  modifier isTerminalOf(uint256 projectId) {\n    if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();\n    ;\n  }\n\n  //**********//\n  // --------------------- internal stored constants ------------------- //\n  //*********//\n\n  /\n    @notice\n    Maximum fee that can be set for a funding cycle configuration.\n\n    @dev\n    Out of MAX_FEE (50_000_000 / 1_000_000_000).\n  /\n  uint256 internal constant _FEE_CAP = 50_000_000;\n\n  /\n    @notice\n    The protocol project ID is 1, as it should be the first project launched during the deployment process.\n  /\n  uint256 internal constant _PROTOCOL_PROJECT_ID = 1;\n\n  //**********//\n  // --------------------- internal stored properties ------------------ //\n  //**********//\n\n  /\n    @notice\n    Fees that are being held to be processed later.\n\n    _projectId The ID of the project for which fees are being held.\n  /\n  mapping(uint256 =&gt; JBFee[]) internal _heldFeesOf;\n\n  //**********//\n  // ---------------- public immutable stored properties --------------- //\n  //*********//\n\n  /\n    @notice\n    Mints ERC-721's that represent project ownership and transfers.\n  /\n  IJBProjects public immutable override projects;\n\n  /\n    @notice\n    The directory of terminals and controllers for projects.\n  /\n  IJBDirectory public immutable override directory;\n\n  /\n    @notice\n    The contract that stores splits for each project.\n  /\n  IJBSplitsStore public immutable override splitsStore;\n\n  /\n    @notice\n    The contract that exposes price feeds.\n  /\n  IJBPrices public immutable override prices;\n\n  /\n    @notice\n    The contract that stores and manages the terminal's data.\n  */\n  IJBSingleTokenPaymentTerminalStore public immutable override store;\n\n  /\n    @notice\n    The currency to base token issuance on.\n\n    @dev\n    If this differs from currency, there must be a price feed available to convert currency to baseWeightCurrency.\n  /\n  uint256 public immutable override baseWeightCurrency;\n\n  /\n    @notice\n    The group that payout splits coming from this terminal are identified by.\n  /\n  uint256 public immutable override payoutSplitsGroup;\n\n  //*********//\n  // --------------------- public stored properties -------------------- //\n  //*********//\n\n  /\n    @notice\n    The platform fee percent.\n\n    @dev\n    Out of MAX_FEE (25_000_000 / 1_000_000_000)\n  /\n  uint256 public override fee = 25_000_000; // 2.5%\n\n  /\n    @notice\n    The data source that returns a discount to apply to a project's fee.\n  /\n  IJBFeeGauge public override feeGauge;\n\n  /\n    @notice\n    Addresses that can be paid towards from this terminal without incurring a fee.\n\n    _address The address that can be paid toward.\n  /\n  mapping(address =&gt; bool) public override isFeelessAddress;\n\n  //***********//\n  // ------------------------- external views -------------------------- //\n  //**********//\n\n  /\n    @notice\n    Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.\n\n    @dev\n    The current overflow is represented as a fixed point number with 18 decimals.\n\n    @param _projectId The ID of the project to get overflow for.\n\n    @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.\n  /\n  function currentEthOverflowOf(uint256 _projectId)\n    external\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    // Get this terminal's current overflow.\n    uint256 _overflow = store.currentOverflowOf(this, _projectId);\n\n    // Adjust the decimals of the fixed point number if needed to have 18 decimals.\n    uint256 _adjustedOverflow = (decimals == 18)\n      ? _overflow\n      : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);\n\n    // Return the amount converted to ETH.\n    return\n      (currency == JBCurrencies.ETH)\n        ? _adjustedOverflow\n        : PRBMath.mulDiv(\n          _adjustedOverflow,\n          10decimals,\n          prices.priceFor(currency, JBCurrencies.ETH, decimals)\n        );\n  }\n\n  /\n    @notice\n    The fees that are currently being held to be processed later for each project.\n\n    @param _projectId The ID of the project for which fees are being held.\n\n    @return An array of fees that are being held.\n  /\n  function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {\n    return _heldFeesOf[_projectId];\n  }\n\n  //*********//\n  // -------------------------- public views --------------------------- //\n  //*********//\n\n  /\n    @notice\n    Indicates if this contract adheres to the specified interface.\n\n    @dev \n    See {IERC165-supportsInterface}.\n\n    @param _interfaceId The ID of the interface to check for adherance to.\n  /\n  function supportsInterface(bytes4 _interfaceId)\n    public\n    view\n    virtual\n    override(JBSingleTokenPaymentTerminal, IERC165)\n    returns (bool)\n  {\n    return\n      _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||\n      _interfaceId == type(IJBPayoutTerminal).interfaceId ||\n      _interfaceId == type(IJBAllowanceTerminal).interfaceId ||\n      _interfaceId == type(IJBRedemptionTerminal).interfaceId ||\n      _interfaceId == type(IJBOperatable).interfaceId ||\n      super.supportsInterface(_interfaceId);\n  }\n\n  //**********//\n  // -------------------------- constructor ---------------------------- //\n  //*********//\n\n  /\n    @param _token The token that this terminal manages.\n    @param _decimals The number of decimals the token fixed point amounts are expected to have.\n    @param _currency The currency that this terminal's token adheres to for price feeds.\n    @param _baseWeightCurrency The currency to base token issuance on.\n    @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.\n    @param _operatorStore A contract storing operator assignments.\n    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.\n    @param _directory A contract storing directories of terminals and controllers for each project.\n    @param _splitsStore A contract that stores splits for each project.\n    @param _prices A contract that exposes price feeds.\n    @param _store A contract that stores the terminal's data.\n    @param _owner The address that will own this contract.\n  /\n  constructor(\n    // payable constructor save the gas used to check msg.value==0\n    address _token,\n    uint256 _decimals,\n    uint256 _currency,\n    uint256 _baseWeightCurrency,\n    uint256 _payoutSplitsGroup,\n    IJBOperatorStore _operatorStore,\n    IJBProjects _projects,\n    IJBDirectory _directory,\n    IJBSplitsStore _splitsStore,\n    IJBPrices _prices,\n    IJBSingleTokenPaymentTerminalStore _store,\n    address _owner\n  )\n    payable\n    JBSingleTokenPaymentTerminal(_token, _decimals, _currency)\n    JBOperatable(_operatorStore)\n  {\n    baseWeightCurrency = _baseWeightCurrency;\n    payoutSplitsGroup = _payoutSplitsGroup;\n    projects = _projects;\n    directory = _directory;\n    splitsStore = _splitsStore;\n    prices = _prices;\n    store = _store;\n\n    transferOwnership(_owner);\n  }\n\n  //**********//\n  // ---------------------- external transactions ---------------------- //\n  //*********//\n\n  /\n    @notice\n    Contribute tokens to a project.\n\n    @param _projectId The ID of the project being paid.\n    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.\n    @param _token The token being paid. This terminal ignores this property since it only manages one token. \n    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.\n    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.\n    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.\n    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.\n    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.\n\n    @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.\n  /\n  function pay(\n    uint256 _projectId,\n    uint256 _amount,\n    address _token,\n    address _beneficiary,\n    uint256 _minReturnedTokens,\n    bool _preferClaimedTokens,\n    string calldata _memo,\n    bytes calldata _metadata\n  ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {\n    _token; // Prevents unused var compiler and natspec complaints.\n\n    // ETH shouldn't be sent if this terminal's token isn't ETH.\n    if (token != JBTokens.ETH) {\n      if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();\n\n      // Transfer tokens to this terminal from the msg sender.\n      _transferFrom(msg.sender, payable(address(this)), _amount);\n    }\n    // If this terminal's token is ETH, override _amount with msg.value.\n    else _amount = msg.value;\n\n    return\n      _pay(\n        _amount,\n        msg.sender,\n        _projectId,\n        _beneficiary,\n        _minReturnedTokens,\n        _preferClaimedTokens,\n        _memo,\n        _metadata\n      );\n  }\n\n  /\n    @notice\n    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.\n\n    @dev\n    Only a token holder or a designated operator can redeem its tokens.\n\n    @param _holder The account to redeem tokens for.\n    @param _projectId The ID of the project to which the tokens being redeemed belong.\n    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.\n    @param _token The token being reclaimed. This terminal ignores this property since it only manages one token. \n    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.\n    @param _beneficiary The address to send the terminal tokens to.\n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.\n\n    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.\n  /\n  function redeemTokensOf(\n    address _holder,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    address _token,\n    uint256 _minReturnedTokens,\n    address payable _beneficiary,\n    string memory _memo,\n    bytes memory _metadata\n  )\n    external\n    virtual\n    override\n    requirePermission(_holder, _projectId, JBOperations.REDEEM)\n    returns (uint256 reclaimAmount)\n  {\n    _token; // Prevents unused var compiler and natspec complaints.\n\n    return\n      _redeemTokensOf(\n        _holder,\n        _projectId,\n        _tokenCount,\n        _minReturnedTokens,\n        _beneficiary,\n        _memo,\n        _metadata\n      );\n  }\n\n  /\n    @notice\n    Distributes payouts for a project with the distribution limit of its current funding cycle.\n\n    @dev\n    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.\n\n    @dev\n    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.\n\n    @dev\n    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.\n\n    @param _projectId The ID of the project having its payouts distributed.\n    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.\n    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.\n    @param _token The token being distributed. This terminal ignores this property since it only manages one token. \n    @param _minReturnedTokens The minimum number of terminal tokens that the _amount should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.\n  /\n  function distributePayoutsOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency,\n    address _token,\n    uint256 _minReturnedTokens,\n    string calldata _memo\n  ) external virtual override returns (uint256 netLeftoverDistributionAmount) {\n    _token; // Prevents unused var compiler and natspec complaints.\n\n    return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);\n  }\n\n  /\n    @notice\n    Allows a project to send funds from its overflow up to the preconfigured allowance.\n\n    @dev\n    Only a project's owner or a designated operator can use its allowance.\n\n    @dev\n    Incurs the protocol fee.\n\n    @param _projectId The ID of the project to use the allowance of.\n    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.\n    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.\n    @param _token The token being distributed. This terminal ignores this property since it only manages one token. \n    @param _minReturnedTokens The minimum number of tokens that the _amount should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.\n    @param _beneficiary The address to send the funds to.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.\n  /\n  function useAllowanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency,\n    address _token,\n    uint256 _minReturnedTokens,\n    address payable _beneficiary,\n    string memory _memo\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)\n    returns (uint256 netDistributedAmount)\n  {\n    _token; // Prevents unused var compiler and natspec complaints.\n\n    return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);\n  }\n\n  /\n    @notice\n    Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.\n\n    @dev\n    Only a project's owner or a designated operator can migrate it.\n\n    @param _projectId The ID of the project being migrated.\n    @param _to The terminal contract that will gain the project's funds.\n\n    @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.\n  */\n  function migrate(uint256 _projectId, IJBPaymentTerminal _to)\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)\n    returns (uint256 balance)\n  {\n    // The terminal being migrated to must accept the same token as this terminal.\n    if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE();\n\n    // Record the migration in the store.\n    balance = store.recordMigration(_projectId);\n\n    // Transfer the balance if needed.\n    if (balance &gt; 0) {\n      // Trigger any inherited pre-transfer logic.\n      _beforeTransferTo(address(_to), balance);\n\n      // If this terminal's token is ETH, send it in msg.value.\n      uint256 _payableValue = token == JBTokens.ETH ? balance : 0;\n\n      // Withdraw the balance to transfer to the new terminal;\n      _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes(''));\n    }\n\n    emit Migrate(_projectId, _to, balance, msg.sender);\n  }\n\n  /\n    @notice\n    Receives funds belonging to the specified project.\n\n    @param _projectId The ID of the project to which the funds received belong.\n    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.\n    @param _token The token being paid. This terminal ignores this property since it only manages one currency. \n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Extra data to pass along to the emitted event.\n  /\n  function addToBalanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    address _token,\n    string calldata _memo,\n    bytes calldata _metadata\n  ) external payable virtual override isTerminalOf(_projectId) {\n    _token; // Prevents unused var compiler and natspec complaints.\n\n    // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender.\n    if (token != JBTokens.ETH) {\n      // Amount must be greater than 0.\n      if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();\n\n      // Transfer tokens to this terminal from the msg sender.\n      _transferFrom(msg.sender, payable(address(this)), _amount);\n    }\n    // If the terminal's token is ETH, override _amount with msg.value.\n    else _amount = msg.value;\n\n    // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal.\n    _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);\n  }\n\n  /\n    @notice\n    Process any fees that are being held for the project.\n\n    @dev\n    Only a project owner, an operator, or the contract's owner can process held fees.\n\n    @param _projectId The ID of the project whos held fees should be processed.\n  /\n  function processFees(uint256 _projectId)\n    external\n    virtual\n    override\n    requirePermissionAllowingOverride(\n      projects.ownerOf(_projectId),\n      _projectId,\n      JBOperations.PROCESS_FEES,\n      msg.sender == owner()\n    )\n  {\n    // Get a reference to the project's held fees.\n    JBFee[] memory _heldFees = _heldFeesOf[_projectId];\n\n    // Delete the held fees.\n    delete _heldFeesOf[_projectId];\n\n    // Push array length in stack\n    uint256 _heldFeeLength = _heldFees.length;\n\n    // Process each fee.\n    for (uint256 _i = 0; _i &lt; _heldFeeLength; ) {\n      // Get the fee amount.\n      uint256 _amount = _feeAmount(\n        _heldFees[_i].amount,\n        _heldFees[_i].fee,\n        _heldFees[_i].feeDiscount\n      );\n\n      // Process the fee.\n      _processFee(_amount, _heldFees[_i].beneficiary);\n\n      emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /\n    @notice\n    Allows the fee to be updated.\n\n    @dev\n    Only the owner of this contract can change the fee.\n\n    @param _fee The new fee, out of MAX_FEE.\n  */\n  function setFee(uint256 _fee) external virtual override onlyOwner {\n    // The provided fee must be within the max.\n    if (_fee &gt; _FEE_CAP) revert FEE_TOO_HIGH();\n\n    // Store the new fee.\n    fee = _fee;\n\n    emit SetFee(_fee, msg.sender);\n  }\n\n  /\n    @notice\n    Allows the fee gauge to be updated.\n\n    @dev\n    Only the owner of this contract can change the fee gauge.\n\n    @dev\n    If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.\n\n    @param _feeGauge The new fee gauge.\n  /\n  function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {\n    // Store the new fee gauge.\n    feeGauge = _feeGauge;\n\n    emit SetFeeGauge(_feeGauge, msg.sender);\n  }\n\n  /\n    @notice\n    Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.\n\n    @dev\n    Only the owner of this contract can set addresses as feeless.\n\n    @param _address The address that can be paid towards while still bypassing fees.\n    @param _flag A flag indicating whether the terminal should be feeless or not.\n  /\n  function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {\n    // Set the flag value.\n    isFeelessAddress[_address] = _flag;\n\n    emit SetFeelessAddress(_address, _flag, msg.sender);\n  }\n\n  //*********//\n  // ---------------------- internal transactions ---------------------- //\n  //*********//\n\n  / \n    @notice\n    Transfers tokens.\n\n    @param _from The address from which the transfer should originate.\n    @param _to The address to which the transfer should go.\n    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.\n  /\n  function _transferFrom(\n    address _from,\n    address payable _to,\n    uint256 _amount\n  ) internal virtual;\n\n  / \n    @notice\n    Logic to be triggered before transferring tokens from this terminal.\n\n    @param _to The address to which the transfer is going.\n    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.\n  /\n  function _beforeTransferTo(address _to, uint256 _amount) internal virtual;\n\n  /\n    @notice\n    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.\n\n    @dev\n    Only a token holder or a designated operator can redeem its tokens.\n\n    @param _holder The account to redeem tokens for.\n    @param _projectId The ID of the project to which the tokens being redeemed belong.\n    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.\n    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.\n    @param _beneficiary The address to send the terminal tokens to.\n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.\n\n    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.\n  /\n  function _redeemTokensOf(\n    address _holder,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    uint256 _minReturnedTokens,\n    address payable _beneficiary,\n    string memory _memo,\n    bytes memory _metadata\n  ) internal returns (uint256 reclaimAmount) {\n    // Can't send reclaimed funds to the zero address.\n    if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS();\n\n    // Define variables that will be needed outside the scoped section below.\n    // Keep a reference to the funding cycle during which the redemption is being made.\n    JBFundingCycle memory _fundingCycle;\n\n    // Scoped section prevents stack too deep. _delegate only used within scope.\n    {\n      IJBRedemptionDelegate _delegate;\n\n      // Record the redemption.\n      (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(\n        _holder,\n        _projectId,\n        _tokenCount,\n        _memo,\n        _metadata\n      );\n\n      // The amount being reclaimed must be at least as much as was expected.\n      if (reclaimAmount &lt; _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();\n\n      // Burn the project tokens.\n      if (_tokenCount &gt; 0)\n        IJBController(directory.controllerOf(_projectId)).burnTokensOf(\n          _holder,\n          _projectId,\n          _tokenCount,\n          '',\n          false\n        );\n\n      // If a delegate was returned by the data source, issue a callback to it.\n      if (_delegate != IJBRedemptionDelegate(address(0))) {\n        JBDidRedeemData memory _data = JBDidRedeemData(\n          _holder,\n          _projectId,\n          _fundingCycle.configuration,\n          _tokenCount,\n          JBTokenAmount(token, reclaimAmount, decimals, currency),\n          _beneficiary,\n          _memo,\n          _metadata\n        );\n        _delegate.didRedeem(_data);\n        emit DelegateDidRedeem(_delegate, _data, msg.sender);\n      }\n    }\n\n    // Send the reclaimed funds to the beneficiary.\n    if (reclaimAmount &gt; 0) _transferFrom(address(this), _beneficiary, reclaimAmount);\n\n    emit RedeemTokens(\n      _fundingCycle.configuration,\n      _fundingCycle.number,\n      _projectId,\n      _holder,\n      _beneficiary,\n      _tokenCount,\n      reclaimAmount,\n      _memo,\n      _metadata,\n      msg.sender\n    );\n  }\n\n  /\n    @notice\n    Distributes payouts for a project with the distribution limit of its current funding cycle.\n\n    @dev\n    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.\n\n    @dev\n    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.\n\n    @dev\n    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.\n\n    @param _projectId The ID of the project having its payouts distributed.\n    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.\n    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.\n    @param _minReturnedTokens The minimum number of terminal tokens that the _amount should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.\n  */\n  function _distributePayoutsOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency,\n    uint256 _minReturnedTokens,\n    string calldata _memo\n  ) internal returns (uint256 netLeftoverDistributionAmount) {\n    // Record the distribution.\n    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(\n      _projectId,\n      _amount,\n      _currency\n    );\n\n    // The amount being distributed must be at least as much as was expected.\n    if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();\n\n    // Get a reference to the project owner, which will receive tokens from paying the platform fee\n    // and receive any extra distributable funds not allocated to payout splits.\n    address payable _projectOwner = payable(projects.ownerOf(_projectId));\n\n    // Define variables that will be needed outside the scoped section below.\n    // Keep a reference to the fee amount that was paid.\n    uint256 _fee;\n\n    // Scoped section prevents stack too deep. _feeDiscount, _feeEligibleDistributionAmount, and _leftoverDistributionAmount only used within scope.\n    {\n      // Get the amount of discount that should be applied to any fees taken.\n      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.\n      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]\n        ? JBConstants.MAX_FEE_DISCOUNT\n        : _currentFeeDiscount(_projectId);\n\n      // The amount distributed that is eligible for incurring fees.\n      uint256 _feeEligibleDistributionAmount;\n\n      // The amount leftover after distributing to the splits.\n      uint256 _leftoverDistributionAmount;\n\n      // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.\n      // Also get a reference to the amount that was distributed to splits from which fees should be taken.\n      (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(\n        _projectId,\n        _fundingCycle.configuration,\n        payoutSplitsGroup,\n        _distributedAmount,\n        _feeDiscount\n      );\n\n      // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.\n      unchecked {\n        _feeEligibleDistributionAmount += _leftoverDistributionAmount;\n      }\n\n      // Take the fee.\n      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0\n        ? 0\n        : _takeFeeFrom(\n          _projectId,\n          _fundingCycle,\n          _feeEligibleDistributionAmount,\n          _projectOwner,\n          _feeDiscount\n        );\n\n      // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.\n\n      unchecked {\n        netLeftoverDistributionAmount = _leftoverDistributionAmount == 0\n          ? 0\n          : _leftoverDistributionAmount -\n            _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);\n      }\n\n      // Transfer any remaining balance to the project owner.\n      if (netLeftoverDistributionAmount &gt; 0)\n        _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount);\n    }\n\n    emit DistributePayouts(\n      _fundingCycle.configuration,\n      _fundingCycle.number,\n      _projectId,\n      _projectOwner,\n      _amount,\n      _distributedAmount,\n      _fee,\n      netLeftoverDistributionAmount,\n      _memo,\n      msg.sender\n    );\n  }\n\n  /\n    @notice\n    Allows a project to send funds from its overflow up to the preconfigured allowance.\n\n    @dev\n    Only a project's owner or a designated operator can use its allowance.\n\n    @dev\n    Incurs the protocol fee.\n\n    @param _projectId The ID of the project to use the allowance of.\n    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.\n    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.\n    @param _minReturnedTokens The minimum number of tokens that the _amount should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.\n    @param _beneficiary The address to send the funds to.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.\n  /\n  function _useAllowanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency,\n    uint256 _minReturnedTokens,\n    address payable _beneficiary,\n    string memory _memo\n  ) internal returns (uint256 netDistributedAmount) {\n    // Record the use of the allowance.\n    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(\n      _projectId,\n      _amount,\n      _currency\n    );\n\n    // The amount being withdrawn must be at least as much as was expected.\n    if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();\n\n    // Scoped section prevents stack too deep. _fee, _projectOwner, _feeDiscount, and _netAmount only used within scope.\n    {\n      // Keep a reference to the fee amount that was paid.\n      uint256 _fee;\n\n      // Get a reference to the project owner, which will receive tokens from paying the platform fee.\n      address _projectOwner = projects.ownerOf(_projectId);\n\n      // Get the amount of discount that should be applied to any fees taken.\n      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.\n      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]\n        ? JBConstants.MAX_FEE_DISCOUNT\n        : _currentFeeDiscount(_projectId);\n\n      // Take a fee from the _distributedAmount, if needed.\n      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT\n        ? 0\n        : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);\n\n      unchecked {\n        // The net amount is the withdrawn amount without the fee.\n        netDistributedAmount = _distributedAmount - _fee;\n      }\n\n      // Transfer any remaining balance to the beneficiary.\n      if (netDistributedAmount &gt; 0)\n        _transferFrom(address(this), _beneficiary, netDistributedAmount);\n    }\n\n    emit UseAllowance(\n      _fundingCycle.configuration,\n      _fundingCycle.number,\n      _projectId,\n      _beneficiary,\n      _amount,\n      _distributedAmount,\n      netDistributedAmount,\n      _memo,\n      msg.sender\n    );\n  }\n\n  /\n    @notice\n    Pays out splits for a project's funding cycle configuration.\n\n    @param _projectId The ID of the project for which payout splits are being distributed.\n    @param _domain The domain of the splits to distribute the payout between.\n    @param _group The group of the splits to distribute the payout between.\n    @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal.\n    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.\n\n    @return leftoverAmount If the leftover amount if the splits don't add up to 100%.\n    @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.\n  /\n  function _distributeToPayoutSplitsOf(\n    uint256 _projectId,\n    uint256 _domain,\n    uint256 _group,\n    uint256 _amount,\n    uint256 _feeDiscount\n  ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {\n    // Set the leftover amount to the initial amount.\n    leftoverAmount = _amount;\n\n    // Get a reference to the project's payout splits.\n    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);\n\n    // Transfer between all splits.\n    for (uint256 _i = 0; _i &lt; _splits.length; ) {\n      // Get a reference to the split being iterated on.\n      JBSplit memory _split = _splits[_i];\n\n      // The amount to send towards the split.\n      uint256 _payoutAmount = PRBMath.mulDiv(\n        _amount,\n        _split.percent,\n        JBConstants.SPLITS_TOTAL_PERCENT\n      );\n\n      // The payout amount substracting any applicable incurred fees.\n      uint256 _netPayoutAmount;\n\n      if (_payoutAmount &gt; 0) {\n        // Transfer tokens to the split.\n        // If there's an allocator set, transfer to its allocate function.\n        if (_split.allocator != IJBSplitAllocator(address(0))) {\n          // If the split allocator is set as feeless, this distribution is not eligible for a fee.\n          if (isFeelessAddress[address(_split.allocator)])\n            _netPayoutAmount = _payoutAmount;\n            // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.\n          else {\n            unchecked {\n              _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT\n                ? _payoutAmount\n                : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);\n            }\n\n            // This distribution is eligible for a fee since the funds are leaving the ecosystem.\n            feeEligibleDistributionAmount += _payoutAmount;\n          }\n\n          // Trigger any inherited pre-transfer logic.\n          _beforeTransferTo(address(_split.allocator), _netPayoutAmount);\n\n          // If this terminal's token is ETH, send it in msg.value.\n          uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;\n\n          // Create the data to send to the allocator.\n          JBSplitAllocationData memory _data = JBSplitAllocationData(\n            token,\n            _netPayoutAmount,\n            decimals,\n            _projectId,\n            _group,\n            _split\n          );\n\n          // Trigger the allocator's allocate function.\n          _split.allocator.allocate{value: _payableValue}(_data);\n\n          // Otherwise, if a project is specified, make a payment to it.\n        } else if (_split.projectId != 0) {\n          // Get a reference to the Juicebox terminal being used.\n          IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);\n\n          // The project must have a terminal to send funds to.\n          if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();\n\n          // Save gas if this contract is being used as the terminal.\n          if (_terminal == this) {\n            // This distribution does not incur a fee.\n            _netPayoutAmount = _payoutAmount;\n\n            // Send the projectId in the metadata.\n            bytes memory _projectMetadata = new bytes(32);\n            _projectMetadata = bytes(abi.encodePacked(_projectId));\n\n            // Add to balance if prefered.\n            if (_split.preferAddToBalance)\n              _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);\n            else\n              _pay(\n                _netPayoutAmount,\n                address(this),\n                _split.projectId,\n                (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,\n                0,\n                _split.preferClaimed,\n                '',\n                _projectMetadata\n              );\n          } else {\n            // If the terminal is set as feeless, this distribution is not eligible for a fee.\n            if (isFeelessAddress[address(_terminal)])\n              _netPayoutAmount = _payoutAmount;\n              // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.\n            else {\n              unchecked {\n                _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT\n                  ? _payoutAmount\n                  : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);\n              }\n\n              feeEligibleDistributionAmount += _payoutAmount;\n            }\n\n            // Trigger any inherited pre-transfer logic.\n            _beforeTransferTo(address(_terminal), _netPayoutAmount);\n\n            // If this terminal's token is ETH, send it in msg.value.\n            uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;\n\n            // Send the projectId in the metadata.\n            bytes memory _projectMetadata = new bytes(32);\n            _projectMetadata = bytes(abi.encodePacked(_projectId));\n\n            // Add to balance if prefered.\n            if (_split.preferAddToBalance)\n              _terminal.addToBalanceOf{value: _payableValue}(\n                _split.projectId,\n                _netPayoutAmount,\n                token,\n                '',\n                _projectMetadata\n              );\n            else\n              _terminal.pay{value: _payableValue}(\n                _split.projectId,\n                _netPayoutAmount,\n                token,\n                _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,\n                0,\n                _split.preferClaimed,\n                '',\n                _projectMetadata\n              );\n          }\n        } else {\n          unchecked {\n            _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT\n              ? _payoutAmount\n              : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);\n          }\n\n          // This distribution is eligible for a fee since the funds are leaving the ecosystem.\n          feeEligibleDistributionAmount += _payoutAmount;\n\n          // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.\n          _transferFrom(\n            address(this),\n            _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),\n            _netPayoutAmount\n          );\n        }\n\n        // Subtract from the amount to be sent to the beneficiary.\n        unchecked {\n          leftoverAmount = leftoverAmount - _payoutAmount;\n        }\n      }\n\n      emit DistributeToPayoutSplit(\n        _projectId,\n        _domain,\n        _group,\n        _split,\n        _netPayoutAmount,\n        msg.sender\n      );\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /\n    @notice\n    Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID.\n\n    @param _projectId The ID of the project having fees taken from.\n    @param _fundingCycle The funding cycle during which the fee is being taken.\n    @param _amount The amount of the fee to take, as a floating point number with 18 decimals.\n    @param _beneficiary The address to mint the platforms tokens for.\n    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.\n\n    @return feeAmount The amount of the fee taken.\n  */\n  function _takeFeeFrom(\n    uint256 _projectId,\n    JBFundingCycle memory _fundingCycle,\n    uint256 _amount,\n    address _beneficiary,\n    uint256 _feeDiscount\n  ) internal returns (uint256 feeAmount) {\n    feeAmount = _feeAmount(_amount, fee, _feeDiscount);\n\n    if (_fundingCycle.shouldHoldFees()) {\n      // Store the held fee.\n      _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));\n\n      emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender);\n    } else {\n      // Process the fee.\n      _processFee(feeAmount, _beneficiary); // Take the fee.\n\n      emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender);\n    }\n  }\n\n  /\n    @notice\n    Process a fee of the specified amount.\n\n    @param _amount The fee amount, as a floating point number with 18 decimals.\n    @param _beneficiary The address to mint the platform's tokens for.\n  /\n  function _processFee(uint256 _amount, address _beneficiary) internal {\n    // Get the terminal for the protocol project.\n    IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token);\n\n    // When processing the admin fee, save gas if the admin is using this contract as its terminal.\n    if (_terminal == this)\n      _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call.\n    else {\n      // Trigger any inherited pre-transfer logic.\n      _beforeTransferTo(address(_terminal), _amount);\n\n      // If this terminal's token is ETH, send it in msg.value.\n      uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;\n\n      // Send the payment.\n      _terminal.pay{value: _payableValue}(\n        _PROTOCOL_PROJECT_ID,\n        _amount,\n        token,\n        _beneficiary,\n        0,\n        false,\n        '',\n        bytes('')\n      ); // Use the external pay call of the correct terminal.\n    }\n  }\n\n  /\n    @notice\n    Contribute tokens to a project.\n\n    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.\n    @param _payer The address making the payment.\n    @param _projectId The ID of the project being paid.\n    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.\n    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.\n    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.\n    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.\n    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.\n\n    @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.\n  /\n  function _pay(\n    uint256 _amount,\n    address _payer,\n    uint256 _projectId,\n    address _beneficiary,\n    uint256 _minReturnedTokens,\n    bool _preferClaimedTokens,\n    string memory _memo,\n    bytes memory _metadata\n  ) internal returns (uint256 beneficiaryTokenCount) {\n    // Cant send tokens to the zero address.\n    if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS();\n\n    // Define variables that will be needed outside the scoped section below.\n    // Keep a reference to the funding cycle during which the payment is being made.\n    JBFundingCycle memory _fundingCycle;\n\n    // Scoped section prevents stack too deep. _delegate and _tokenCount only used within scope.\n    {\n      IJBPayDelegate _delegate;\n      uint256 _tokenCount;\n\n      // Bundle the amount info into a JBTokenAmount struct.\n      JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);\n\n      // Record the payment.\n      (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(\n        _payer,\n        _bundledAmount,\n        _projectId,\n        baseWeightCurrency,\n        _beneficiary,\n        _memo,\n        _metadata\n      );\n\n      // Mint the tokens if needed.\n      if (_tokenCount &gt; 0)\n        // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.\n        beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(\n          _projectId,\n          _tokenCount,\n          _beneficiary,\n          '',\n          _preferClaimedTokens,\n          true\n        );\n\n      // The token count for the beneficiary must be greater than or equal to the minimum expected.\n      if (beneficiaryTokenCount &lt; _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();\n\n      // If a delegate was returned by the data source, issue a callback to it.\n      if (_delegate != IJBPayDelegate(address(0))) {\n        JBDidPayData memory _data = JBDidPayData(\n          _payer,\n          _projectId,\n          _fundingCycle.configuration,\n          _bundledAmount,\n          beneficiaryTokenCount,\n          _beneficiary,\n          _preferClaimedTokens,\n          _memo,\n          _metadata\n        );\n\n        _delegate.didPay(_data);\n        emit DelegateDidPay(_delegate, _data, msg.sender);\n      }\n    }\n\n    emit Pay(\n      _fundingCycle.configuration,\n      _fundingCycle.number,\n      _projectId,\n      _payer,\n      _beneficiary,\n      _amount,\n      beneficiaryTokenCount,\n      _memo,\n      _metadata,\n      msg.sender\n    );\n  }\n\n  /\n    @notice\n    Receives funds belonging to the specified project.\n\n    @param _projectId The ID of the project to which the funds received belong.\n    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.\n    @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added.\n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Extra data to pass along to the emitted event.\n  */\n  function _addToBalanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    bool _shouldRefundHeldFees,\n    string memory _memo,\n    bytes memory _metadata\n  ) internal {\n    // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.\n    uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0;\n\n    // Record the added funds with any refunded fees.\n    store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);\n\n    emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);\n  }\n\n  /\n    @notice\n    Refund fees based on the specified amount.\n\n    @param _projectId The project for which fees are being refunded.\n    @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.\n\n    @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal\n  /\n  function _refundHeldFees(uint256 _projectId, uint256 _amount)\n    internal\n    returns (uint256 refundedFees)\n  {\n    // Get a reference to the project's held fees.\n    JBFee[] memory _heldFees = _heldFeesOf[_projectId];\n\n    // Delete the current held fees.\n    delete _heldFeesOf[_projectId];\n\n    // Get a reference to the leftover amount once all fees have been settled.\n    uint256 leftoverAmount = _amount;\n\n    // Push length in stack\n    uint256 _heldFeesLength = _heldFees.length;\n\n    // Process each fee.\n    for (uint256 _i = 0; _i &lt; _heldFeesLength; ) {\n      if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);\n      else if (leftoverAmount &gt;= _heldFees[_i].amount) {\n        unchecked {\n          leftoverAmount = leftoverAmount - _heldFees[_i].amount;\n          refundedFees += _feeAmount(\n            _heldFees[_i].amount,\n            _heldFees[_i].fee,\n            _heldFees[_i].feeDiscount\n          );\n        }\n      } else {\n        _heldFeesOf[_projectId].push(\n          JBFee(\n            _heldFees[_i].amount - leftoverAmount,\n            _heldFees[_i].fee,\n            _heldFees[_i].feeDiscount,\n            _heldFees[_i].beneficiary\n          )\n        );\n        unchecked {\n          refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);\n        }\n        leftoverAmount = 0;\n      }\n\n      unchecked {\n        ++_i;\n      }\n    }\n\n    emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);\n  }\n\n  / \n    @notice \n    Returns the fee amount based on the provided amount for the specified project.\n\n    @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal.\n    @param _fee The percentage of the fee, out of MAX_FEE. \n    @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.\n\n    @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.\n  /\n  function _feeAmount(\n    uint256 _amount,\n    uint256 _fee,\n    uint256 _feeDiscount\n  ) internal pure returns (uint256) {\n    // Calculate the discounted fee.\n    uint256 _discountedFee = _fee -\n      PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT);\n\n    // The amount of tokens from the _amount to pay as a fee.\n    return\n      _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);\n  }\n\n  /* \n    @notice\n    Get the fee discount from the fee gauge for the specified project.\n\n    @param _projectId The ID of the project to get a fee discount for.\n    \n    @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.\n  /\n  function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {\n    // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.\n    if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))\n      return JBConstants.MAX_FEE_DISCOUNT;\n\n    // Get the fee discount.\n    if (feeGauge == IJBFeeGauge(address(0)))\n      feeDiscount = 0;\n      // If the guage reverts, set the discount to 0.\n    else\n      try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {\n        feeDiscount = discount;\n      } catch {\n        feeDiscount = 0;\n      }\n\n    // If the fee discount is greater than the max, nullify the discount.\n    if (feeDiscount &gt; JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;\n  }\n}\n", 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 17:17:56 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/security/ReentrancyGuard.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './../interfaces/IJBController.sol'; import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol'; import './../libraries/JBConstants.sol'; import './../libraries/JBCurrencies.sol'; import './../libraries/JBFixedPointNumber.sol'; import './../libraries/JBFundingCycleMetadataResolver.sol'; import './../libraries/JBOperations.sol'; import './../libraries/JBSplitsGroups.sol'; import './../libraries/JBTokens.sol'; import './../structs/JBTokenAmount.sol'; import './JBOperatable.sol'; import './JBSingleTokenPaymentTerminal.sol'; /**   @notice   Generic terminal managing all inflows and outflows of funds into the protocol ecosystem. @dev   A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time. @dev   Adheres to -   IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules. @dev   Inherits from -   JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.   JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.   Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.   ReentrancyGuard: Contract module that helps prevent reentrant calls to a function. */ abstract contract JBPayoutRedemptionPaymentTerminal is   IJBPayoutRedemptionPaymentTerminal,   JBSingleTokenPaymentTerminal,   JBOperatable,   Ownable,   ReentrancyGuard {   // A library that parses the packed funding cycle metadata into a friendlier format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error FEE_TOO_HIGH();   error INADEQUATE_DISTRIBUTION_AMOUNT();   error INADEQUATE_RECLAIM_AMOUNT();   error INADEQUATE_TOKEN_COUNT();   error NO_MSG_VALUE_ALLOWED();   error PAY_TO_ZERO_ADDRESS();   error PROJECT_TERMINAL_MISMATCH();   error REDEEM_TO_ZERO_ADDRESS();   error TERMINAL_IN_SPLIT_ZERO_ADDRESS();   error TERMINAL_TOKENS_INCOMPATIBLE(); //***********//   // ---------------------------- modifiers ---------------------------- //   //*************// /*      @notice      A modifier that verifies this terminal is a terminal of provided project ID.   /   modifier isTerminalOf(uint256 projectId) {     if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();     ;   } //***********//   // --------------------- internal stored constants ------------------- //   //*************// /**     @notice     Maximum fee that can be set for a funding cycle configuration. @dev Out of MAX_FEE (50_000_000 / 1_000_000_000).  */   uint256 internal constant _FEE_CAP = 50_000_000; /*     @notice     The protocol project ID is 1, as it should be the first project launched during the deployment process.   /   uint256 internal constant _PROTOCOL_PROJECT_ID = 1; //***********//   // --------------------- internal stored properties ------------------ //   //*************// /**     @notice     Fees that are being held to be processed later. _projectId The ID of the project for which fees are being held.  */   mapping(uint256 =&gt; JBFee[]) internal _heldFeesOf; //***********//   // ---------------- public immutable stored properties --------------- //   //*************// /*     @notice     Mints ERC-721's that represent project ownership and transfers.   /   IJBProjects public immutable override projects; /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; /*     @notice     The contract that stores splits for each project.   /   IJBSplitsStore public immutable override splitsStore; /*     @notice     The contract that exposes price feeds.   /   IJBPrices public immutable override prices; /*     @notice     The contract that stores and manages the terminal's data.   /   IJBSingleTokenPaymentTerminalStore public immutable override store; /**     @notice     The currency to base token issuance on. @dev If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.  */   uint256 public immutable override baseWeightCurrency; /*     @notice     The group that payout splits coming from this terminal are identified by.   /   uint256 public immutable override payoutSplitsGroup; //***********//   // --------------------- public stored properties -------------------- //   //*************// /**     @notice     The platform fee percent. @dev Out of MAX_FEE (25_000_000 / 1_000_000_000)  */   uint256 public override fee = 25_000_000; // 2.5% /*     @notice     The data source that returns a discount to apply to a project's fee.   /   IJBFeeGauge public override feeGauge; /**     @notice     Addresses that can be paid towards from this terminal without incurring a fee. _address The address that can be paid toward.  */   mapping(address =&gt; bool) public override isFeelessAddress; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     Gets the current overflowed amount in this terminal for a specified project, in terms of ETH. @dev The current overflow is represented as a fixed point number with 18 decimals.  @param _projectId The ID of the project to get overflow for.  @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.  */   function currentEthOverflowOf(uint256 _projectId)     external     view     virtual     override     returns (uint256)   {     // Get this terminal's current overflow.     uint256 _overflow = store.currentOverflowOf(this, _projectId); // Adjust the decimals of the fixed point number if needed to have 18 decimals. uint256 _adjustedOverflow = (decimals == 18)   ? _overflow   : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);  // Return the amount converted to ETH. return   (currency == JBCurrencies.ETH)     ? _adjustedOverflow     : PRBMath.mulDiv(       _adjustedOverflow,       10**decimals,       prices.priceFor(currency, JBCurrencies.ETH, decimals)     );  } /**     @notice     The fees that are currently being held to be processed later for each project. @param _projectId The ID of the project for which fees are being held.  @return An array of fees that are being held.  */   function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {     return _heldFeesOf[_projectId];   } //***********//   // -------------------------- public views --------------------------- //   //*************// /**     @notice     Indicates if this contract adheres to the specified interface. @dev  See {IERC165-supportsInterface}.  @param _interfaceId The ID of the interface to check for adherance to.  */   function supportsInterface(bytes4 _interfaceId)     public     view     virtual     override(JBSingleTokenPaymentTerminal, IERC165)     returns (bool)   {     return       _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||       _interfaceId == type(IJBPayoutTerminal).interfaceId ||       _interfaceId == type(IJBAllowanceTerminal).interfaceId ||       _interfaceId == type(IJBRedemptionTerminal).interfaceId ||       _interfaceId == type(IJBOperatable).interfaceId ||       super.supportsInterface(_interfaceId);   } //***********//   // -------------------------- constructor ---------------------------- //   //*************// /*     @param _token The token that this terminal manages.     @param _decimals The number of decimals the token fixed point amounts are expected to have.     @param _currency The currency that this terminal's token adheres to for price feeds.     @param _baseWeightCurrency The currency to base token issuance on.     @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.     @param _operatorStore A contract storing operator assignments.     @param _projects A contract which mints ERC-721's that represent project ownership and transfers.     @param _directory A contract storing directories of terminals and controllers for each project.     @param _splitsStore A contract that stores splits for each project.     @param _prices A contract that exposes price feeds.     @param _store A contract that stores the terminal's data.     @param _owner The address that will own this contract.   /   constructor(     // payable constructor save the gas used to check msg.value==0     address _token,     uint256 _decimals,     uint256 _currency,     uint256 _baseWeightCurrency,     uint256 _payoutSplitsGroup,     IJBOperatorStore _operatorStore,     IJBProjects _projects,     IJBDirectory _directory,     IJBSplitsStore _splitsStore,     IJBPrices _prices,     IJBSingleTokenPaymentTerminalStore _store,     address _owner   )     payable     JBSingleTokenPaymentTerminal(_token, _decimals, _currency)     JBOperatable(_operatorStore)   {     baseWeightCurrency = _baseWeightCurrency;     payoutSplitsGroup = _payoutSplitsGroup;     projects = _projects;     directory = _directory;     splitsStore = _splitsStore;     prices = _prices;     store = _store; transferOwnership(_owner);  } //***********//   // ---------------------- external transactions ---------------------- //   //*************// /**     @notice     Contribute tokens to a project. @param _projectId The ID of the project being paid. @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place. @param _token The token being paid. This terminal ignores this property since it only manages one token.  @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate. @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal. @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas. @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.  */   function pay(     uint256 _projectId,     uint256 _amount,     address _token,     address _beneficiary,     uint256 _minReturnedTokens,     bool _preferClaimedTokens,     string calldata _memo,     bytes calldata _metadata   ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {     _token; // Prevents unused var compiler and natspec complaints. // ETH shouldn't be sent if this terminal's token isn't ETH. if (token != JBTokens.ETH) {   if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();    // Transfer tokens to this terminal from the msg sender.   _transferFrom(msg.sender, payable(address(this)), _amount); } // If this terminal's token is ETH, override _amount with msg.value. else _amount = msg.value;  return   _pay(     _amount,     msg.sender,     _projectId,     _beneficiary,     _minReturnedTokens,     _preferClaimedTokens,     _memo,     _metadata   );  } /**     @notice     Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source. @dev Only a token holder or a designated operator can redeem its tokens.  @param _holder The account to redeem tokens for. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _token The token being reclaimed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal. @param _beneficiary The address to send the terminal tokens to. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.  */   function redeemTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     address _token,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo,     bytes memory _metadata   )     external     virtual     override     requirePermission(_holder, _projectId, JBOperations.REDEEM)     returns (uint256 reclaimAmount)   {     _token; // Prevents unused var compiler and natspec complaints. return   _redeemTokensOf(     _holder,     _projectId,     _tokenCount,     _minReturnedTokens,     _beneficiary,     _memo,     _metadata   );  } /**     @notice     Distributes payouts for a project with the distribution limit of its current funding cycle. @dev Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.  @dev Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.  @dev All funds distributed outside of this contract or any feeless terminals incure the protocol fee.  @param _projectId The ID of the project having its payouts distributed. @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency. @param _token The token being distributed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal. @param _memo A memo to pass along to the emitted event.  @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.  */   function distributePayoutsOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     address _token,     uint256 _minReturnedTokens,     string calldata _memo   ) external virtual override returns (uint256 netLeftoverDistributionAmount) {     _token; // Prevents unused var compiler and natspec complaints. return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);  } /**     @notice     Allows a project to send funds from its overflow up to the preconfigured allowance. @dev Only a project's owner or a designated operator can use its allowance.  @dev Incurs the protocol fee.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency. @param _token The token being distributed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals. @param _beneficiary The address to send the funds to. @param _memo A memo to pass along to the emitted event.  @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.  */   function useAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     address _token,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)     returns (uint256 netDistributedAmount)   {     _token; // Prevents unused var compiler and natspec complaints. return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);  } /**     @notice     Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type. @dev Only a project's owner or a designated operator can migrate it.  @param _projectId The ID of the project being migrated. @param _to The terminal contract that will gain the project's funds.  @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.  */   function migrate(uint256 _projectId, IJBPaymentTerminal _to)     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)     returns (uint256 balance)   {     // The terminal being migrated to must accept the same token as this terminal.     if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE(); // Record the migration in the store. balance = store.recordMigration(_projectId);  // Transfer the balance if needed. if (balance &gt; 0) {   // Trigger any inherited pre-transfer logic.   _beforeTransferTo(address(_to), balance);    // If this terminal's token is ETH, send it in msg.value.   uint256 _payableValue = token == JBTokens.ETH ? balance : 0;    // Withdraw the balance to transfer to the new terminal;   _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes('')); }  emit Migrate(_projectId, _to, balance, msg.sender);  } /**     @notice     Receives funds belonging to the specified project. @param _projectId The ID of the project to which the funds received belong. @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead. @param _token The token being paid. This terminal ignores this property since it only manages one currency.  @param _memo A memo to pass along to the emitted event. @param _metadata Extra data to pass along to the emitted event.  */   function addToBalanceOf(     uint256 _projectId,     uint256 _amount,     address _token,     string calldata _memo,     bytes calldata _metadata   ) external payable virtual override isTerminalOf(_projectId) {     _token; // Prevents unused var compiler and natspec complaints. // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender. if (token != JBTokens.ETH) {   // Amount must be greater than 0.   if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();    // Transfer tokens to this terminal from the msg sender.   _transferFrom(msg.sender, payable(address(this)), _amount); } // If the terminal's token is ETH, override `_amount` with msg.value. else _amount = msg.value;  // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal. _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);  } /**     @notice     Process any fees that are being held for the project. @dev Only a project owner, an operator, or the contract's owner can process held fees.  @param _projectId The ID of the project whos held fees should be processed.  */   function processFees(uint256 _projectId)     external     virtual     override     requirePermissionAllowingOverride(       projects.ownerOf(_projectId),       _projectId,       JBOperations.PROCESS_FEES,       msg.sender == owner()     )   {     // Get a reference to the project's held fees.     JBFee[] memory _heldFees = _heldFeesOf[_projectId]; // Delete the held fees. delete _heldFeesOf[_projectId];  // Push array length in stack uint256 _heldFeeLength = _heldFees.length;  // Process each fee. for (uint256 _i = 0; _i &lt; _heldFeeLength; ) {   // Get the fee amount.   uint256 _amount = _feeAmount(     _heldFees[_i].amount,     _heldFees[_i].fee,     _heldFees[_i].feeDiscount   );    // Process the fee.   _processFee(_amount, _heldFees[_i].beneficiary);    emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);    unchecked {     ++_i;   } }  } /**     @notice     Allows the fee to be updated. @dev Only the owner of this contract can change the fee.  @param _fee The new fee, out of MAX_FEE.  */   function setFee(uint256 _fee) external virtual override onlyOwner {     // The provided fee must be within the max.     if (_fee &gt; _FEE_CAP) revert FEE_TOO_HIGH(); // Store the new fee. fee = _fee;  emit SetFee(_fee, msg.sender);  } /**     @notice     Allows the fee gauge to be updated. @dev Only the owner of this contract can change the fee gauge.  @dev If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.  @param _feeGauge The new fee gauge.  */   function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {     // Store the new fee gauge.     feeGauge = _feeGauge; emit SetFeeGauge(_feeGauge, msg.sender);  } /**     @notice     Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee. @dev Only the owner of this contract can set addresses as feeless.  @param _address The address that can be paid towards while still bypassing fees. @param _flag A flag indicating whether the terminal should be feeless or not.  */   function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {     // Set the flag value.     isFeelessAddress[_address] = _flag; emit SetFeelessAddress(_address, _flag, msg.sender);  } //***********//   // ---------------------- internal transactions ---------------------- //   //*************// /**      @notice     Transfers tokens. @param _from The address from which the transfer should originate. @param _to The address to which the transfer should go. @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.  */   function _transferFrom(     address _from,     address payable _to,     uint256 _amount   ) internal virtual; /**      @notice     Logic to be triggered before transferring tokens from this terminal. @param _to The address to which the transfer is going. @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.  */   function _beforeTransferTo(address _to, uint256 _amount) internal virtual; /**     @notice     Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source. @dev Only a token holder or a designated operator can redeem its tokens.  @param _holder The account to redeem tokens for. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal. @param _beneficiary The address to send the terminal tokens to. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.  */   function _redeemTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo,     bytes memory _metadata   ) internal returns (uint256 reclaimAmount) {     // Can't send reclaimed funds to the zero address.     if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS(); // Define variables that will be needed outside the scoped section below. // Keep a reference to the funding cycle during which the redemption is being made. JBFundingCycle memory _fundingCycle;  // Scoped section prevents stack too deep. `_delegate` only used within scope. {   IJBRedemptionDelegate _delegate;    // Record the redemption.   (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(     _holder,     _projectId,     _tokenCount,     _memo,     _metadata   );    // The amount being reclaimed must be at least as much as was expected.   if (reclaimAmount &lt; _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();    // Burn the project tokens.   if (_tokenCount &gt; 0)     IJBController(directory.controllerOf(_projectId)).burnTokensOf(       _holder,       _projectId,       _tokenCount,       '',       false     );    // If a delegate was returned by the data source, issue a callback to it.   if (_delegate != IJBRedemptionDelegate(address(0))) {     JBDidRedeemData memory _data = JBDidRedeemData(       _holder,       _projectId,       _fundingCycle.configuration,       _tokenCount,       JBTokenAmount(token, reclaimAmount, decimals, currency),       _beneficiary,       _memo,       _metadata     );     _delegate.didRedeem(_data);     emit DelegateDidRedeem(_delegate, _data, msg.sender);   } }  // Send the reclaimed funds to the beneficiary. if (reclaimAmount &gt; 0) _transferFrom(address(this), _beneficiary, reclaimAmount);  emit RedeemTokens(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _holder,   _beneficiary,   _tokenCount,   reclaimAmount,   _memo,   _metadata,   msg.sender );  } /**     @notice     Distributes payouts for a project with the distribution limit of its current funding cycle. @dev Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.  @dev Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.  @dev All funds distributed outside of this contract or any feeless terminals incure the protocol fee.  @param _projectId The ID of the project having its payouts distributed. @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency. @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal. @param _memo A memo to pass along to the emitted event.  @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.  */   function _distributePayoutsOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     uint256 _minReturnedTokens,     string calldata _memo   ) internal returns (uint256 netLeftoverDistributionAmount) {     // Record the distribution.     (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(       _projectId,       _amount,       _currency     ); // The amount being distributed must be at least as much as was expected. if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();  // Get a reference to the project owner, which will receive tokens from paying the platform fee // and receive any extra distributable funds not allocated to payout splits. address payable _projectOwner = payable(projects.ownerOf(_projectId));  // Define variables that will be needed outside the scoped section below. // Keep a reference to the fee amount that was paid. uint256 _fee;  // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope. {   // Get the amount of discount that should be applied to any fees taken.   // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.   uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]     ? JBConstants.MAX_FEE_DISCOUNT     : _currentFeeDiscount(_projectId);    // The amount distributed that is eligible for incurring fees.   uint256 _feeEligibleDistributionAmount;    // The amount leftover after distributing to the splits.   uint256 _leftoverDistributionAmount;    // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.   // Also get a reference to the amount that was distributed to splits from which fees should be taken.   (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(     _projectId,     _fundingCycle.configuration,     payoutSplitsGroup,     _distributedAmount,     _feeDiscount   );    // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.   unchecked {     _feeEligibleDistributionAmount += _leftoverDistributionAmount;   }    // Take the fee.   _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0     ? 0     : _takeFeeFrom(       _projectId,       _fundingCycle,       _feeEligibleDistributionAmount,       _projectOwner,       _feeDiscount     );    // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.    unchecked {     netLeftoverDistributionAmount = _leftoverDistributionAmount == 0       ? 0       : _leftoverDistributionAmount -         _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);   }    // Transfer any remaining balance to the project owner.   if (netLeftoverDistributionAmount &gt; 0)     _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount); }  emit DistributePayouts(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _projectOwner,   _amount,   _distributedAmount,   _fee,   netLeftoverDistributionAmount,   _memo,   msg.sender );  } /**     @notice     Allows a project to send funds from its overflow up to the preconfigured allowance. @dev Only a project's owner or a designated operator can use its allowance.  @dev Incurs the protocol fee.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency. @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals. @param _beneficiary The address to send the funds to. @param _memo A memo to pass along to the emitted event.  @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.  */   function _useAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo   ) internal returns (uint256 netDistributedAmount) {     // Record the use of the allowance.     (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(       _projectId,       _amount,       _currency     ); // The amount being withdrawn must be at least as much as was expected. if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();  // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope. {   // Keep a reference to the fee amount that was paid.   uint256 _fee;    // Get a reference to the project owner, which will receive tokens from paying the platform fee.   address _projectOwner = projects.ownerOf(_projectId);    // Get the amount of discount that should be applied to any fees taken.   // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.   uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]     ? JBConstants.MAX_FEE_DISCOUNT     : _currentFeeDiscount(_projectId);    // Take a fee from the `_distributedAmount`, if needed.   _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT     ? 0     : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);    unchecked {     // The net amount is the withdrawn amount without the fee.     netDistributedAmount = _distributedAmount - _fee;   }    // Transfer any remaining balance to the beneficiary.   if (netDistributedAmount &gt; 0)     _transferFrom(address(this), _beneficiary, netDistributedAmount); }  emit UseAllowance(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _beneficiary,   _amount,   _distributedAmount,   netDistributedAmount,   _memo,   msg.sender );  } /**     @notice     Pays out splits for a project's funding cycle configuration. @param _projectId The ID of the project for which payout splits are being distributed. @param _domain The domain of the splits to distribute the payout between. @param _group The group of the splits to distribute the payout between. @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal. @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.  @return leftoverAmount If the leftover amount if the splits don't add up to 100%. @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.  */   function _distributeToPayoutSplitsOf(     uint256 _projectId,     uint256 _domain,     uint256 _group,     uint256 _amount,     uint256 _feeDiscount   ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {     // Set the leftover amount to the initial amount.     leftoverAmount = _amount; // Get a reference to the project's payout splits. JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);  // Transfer between all splits. for (uint256 _i = 0; _i &lt; _splits.length; ) {   // Get a reference to the split being iterated on.   JBSplit memory _split = _splits[_i];    // The amount to send towards the split.   uint256 _payoutAmount = PRBMath.mulDiv(     _amount,     _split.percent,     JBConstants.SPLITS_TOTAL_PERCENT   );    // The payout amount substracting any applicable incurred fees.   uint256 _netPayoutAmount;    if (_payoutAmount &gt; 0) {     // Transfer tokens to the split.     // If there's an allocator set, transfer to its `allocate` function.     if (_split.allocator != IJBSplitAllocator(address(0))) {       // If the split allocator is set as feeless, this distribution is not eligible for a fee.       if (isFeelessAddress[address(_split.allocator)])         _netPayoutAmount = _payoutAmount;         // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.       else {         unchecked {           _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT             ? _payoutAmount             : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);         }          // This distribution is eligible for a fee since the funds are leaving the ecosystem.         feeEligibleDistributionAmount += _payoutAmount;       }        // Trigger any inherited pre-transfer logic.       _beforeTransferTo(address(_split.allocator), _netPayoutAmount);        // If this terminal's token is ETH, send it in msg.value.       uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;        // Create the data to send to the allocator.       JBSplitAllocationData memory _data = JBSplitAllocationData(         token,         _netPayoutAmount,         decimals,         _projectId,         _group,         _split       );        // Trigger the allocator's `allocate` function.       _split.allocator.allocate{value: _payableValue}(_data);        // Otherwise, if a project is specified, make a payment to it.     } else if (_split.projectId != 0) {       // Get a reference to the Juicebox terminal being used.       IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);        // The project must have a terminal to send funds to.       if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();        // Save gas if this contract is being used as the terminal.       if (_terminal == this) {         // This distribution does not incur a fee.         _netPayoutAmount = _payoutAmount;          // Send the projectId in the metadata.         bytes memory _projectMetadata = new bytes(32);         _projectMetadata = bytes(abi.encodePacked(_projectId));          // Add to balance if prefered.         if (_split.preferAddToBalance)           _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);         else           _pay(             _netPayoutAmount,             address(this),             _split.projectId,             (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,             0,             _split.preferClaimed,             '',             _projectMetadata           );       } else {         // If the terminal is set as feeless, this distribution is not eligible for a fee.         if (isFeelessAddress[address(_terminal)])           _netPayoutAmount = _payoutAmount;           // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.         else {           unchecked {             _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT               ? _payoutAmount               : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);           }            feeEligibleDistributionAmount += _payoutAmount;         }          // Trigger any inherited pre-transfer logic.         _beforeTransferTo(address(_terminal), _netPayoutAmount);          // If this terminal's token is ETH, send it in msg.value.         uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;          // Send the projectId in the metadata.         bytes memory _projectMetadata = new bytes(32);         _projectMetadata = bytes(abi.encodePacked(_projectId));          // Add to balance if prefered.         if (_split.preferAddToBalance)           _terminal.addToBalanceOf{value: _payableValue}(             _split.projectId,             _netPayoutAmount,             token,             '',             _projectMetadata           );         else           _terminal.pay{value: _payableValue}(             _split.projectId,             _netPayoutAmount,             token,             _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,             0,             _split.preferClaimed,             '',             _projectMetadata           );       }     } else {       unchecked {         _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT           ? _payoutAmount           : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);       }        // This distribution is eligible for a fee since the funds are leaving the ecosystem.       feeEligibleDistributionAmount += _payoutAmount;        // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.       _transferFrom(         address(this),         _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),         _netPayoutAmount       );     }      // Subtract from the amount to be sent to the beneficiary.     unchecked {       leftoverAmount = leftoverAmount - _payoutAmount;     }   }    emit DistributeToPayoutSplit(     _projectId,     _domain,     _group,     _split,     _netPayoutAmount,     msg.sender   );    unchecked {     ++_i;   } }  } /**     @notice     Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID. @param _projectId The ID of the project having fees taken from. @param _fundingCycle The funding cycle during which the fee is being taken. @param _amount The amount of the fee to take, as a floating point number with 18 decimals. @param _beneficiary The address to mint the platforms tokens for. @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.  @return feeAmount The amount of the fee taken.  */   function _takeFeeFrom(     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _amount,     address _beneficiary,     uint256 _feeDiscount   ) internal returns (uint256 feeAmount) {     feeAmount = _feeAmount(_amount, fee, _feeDiscount); if (_fundingCycle.shouldHoldFees()) {   // Store the held fee.   _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));    emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender); } else {   // Process the fee.   _processFee(feeAmount, _beneficiary); // Take the fee.    emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender); }  } /**     @notice     Process a fee of the specified amount. @param _amount The fee amount, as a floating point number with 18 decimals. @param _beneficiary The address to mint the platform's tokens for.  */   function _processFee(uint256 _amount, address _beneficiary) internal {     // Get the terminal for the protocol project.     IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token); // When processing the admin fee, save gas if the admin is using this contract as its terminal. if (_terminal == this)   _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call. else {   // Trigger any inherited pre-transfer logic.   _beforeTransferTo(address(_terminal), _amount);    // If this terminal's token is ETH, send it in msg.value.   uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;    // Send the payment.   _terminal.pay{value: _payableValue}(     _PROTOCOL_PROJECT_ID,     _amount,     token,     _beneficiary,     0,     false,     '',     bytes('')   ); // Use the external pay call of the correct terminal. }  } /**     @notice     Contribute tokens to a project. @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place. @param _payer The address making the payment. @param _projectId The ID of the project being paid. @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate. @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal. @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas. @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.  */   function _pay(     uint256 _amount,     address _payer,     uint256 _projectId,     address _beneficiary,     uint256 _minReturnedTokens,     bool _preferClaimedTokens,     string memory _memo,     bytes memory _metadata   ) internal returns (uint256 beneficiaryTokenCount) {     // Cant send tokens to the zero address.     if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS(); // Define variables that will be needed outside the scoped section below. // Keep a reference to the funding cycle during which the payment is being made. JBFundingCycle memory _fundingCycle;  // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope. {   IJBPayDelegate _delegate;   uint256 _tokenCount;    // Bundle the amount info into a JBTokenAmount struct.   JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);    // Record the payment.   (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(     _payer,     _bundledAmount,     _projectId,     baseWeightCurrency,     _beneficiary,     _memo,     _metadata   );    // Mint the tokens if needed.   if (_tokenCount &gt; 0)     // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.     beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(       _projectId,       _tokenCount,       _beneficiary,       '',       _preferClaimedTokens,       true     );    // The token count for the beneficiary must be greater than or equal to the minimum expected.   if (beneficiaryTokenCount &lt; _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();    // If a delegate was returned by the data source, issue a callback to it.   if (_delegate != IJBPayDelegate(address(0))) {     JBDidPayData memory _data = JBDidPayData(       _payer,       _projectId,       _fundingCycle.configuration,       _bundledAmount,       beneficiaryTokenCount,       _beneficiary,       _preferClaimedTokens,       _memo,       _metadata     );      _delegate.didPay(_data);     emit DelegateDidPay(_delegate, _data, msg.sender);   } }  emit Pay(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _payer,   _beneficiary,   _amount,   beneficiaryTokenCount,   _memo,   _metadata,   msg.sender );  } /**     @notice     Receives funds belonging to the specified project. @param _projectId The ID of the project to which the funds received belong. @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead. @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added. @param _memo A memo to pass along to the emitted event. @param _metadata Extra data to pass along to the emitted event.  */   function _addToBalanceOf(     uint256 _projectId,     uint256 _amount,     bool _shouldRefundHeldFees,     string memory _memo,     bytes memory _metadata   ) internal {     // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.     uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0; // Record the added funds with any refunded fees. store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);  emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);  } /**     @notice     Refund fees based on the specified amount. @param _projectId The project for which fees are being refunded. @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.  @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal  */   function _refundHeldFees(uint256 _projectId, uint256 _amount)     internal     returns (uint256 refundedFees)   {     // Get a reference to the project's held fees.     JBFee[] memory _heldFees = _heldFeesOf[_projectId]; // Delete the current held fees. delete _heldFeesOf[_projectId];  // Get a reference to the leftover amount once all fees have been settled. uint256 leftoverAmount = _amount;  // Push length in stack uint256 _heldFeesLength = _heldFees.length;  // Process each fee. for (uint256 _i = 0; _i &lt; _heldFeesLength; ) {   if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);   else if (leftoverAmount &gt;= _heldFees[_i].amount) {     unchecked {       leftoverAmount = leftoverAmount - _heldFees[_i].amount;       refundedFees += _feeAmount(         _heldFees[_i].amount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount       );     }   } else {     _heldFeesOf[_projectId].push(       JBFee(         _heldFees[_i].amount - leftoverAmount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount,         _heldFees[_i].beneficiary       )     );     unchecked {       refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);     }     leftoverAmount = 0;   }    unchecked {     ++_i;   } }  emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);  } /**      @notice      Returns the fee amount based on the provided amount for the specified project. @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal. @param _fee The percentage of the fee, out of MAX_FEE.  @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.  @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.  */   function _feeAmount(     uint256 _amount,     uint256 _fee,     uint256 _feeDiscount   ) internal pure returns (uint256) {     // Calculate the discounted fee.     uint256 _discountedFee = _fee -       PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT); // The amount of tokens from the `_amount` to pay as a fee. return   _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);  } /**      @notice     Get the fee discount from the fee gauge for the specified project. @param _projectId The ID of the project to get a fee discount for.  @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.  */   function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {     // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.     if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))       return JBConstants.MAX_FEE_DISCOUNT; // Get the fee discount. if (feeGauge == IJBFeeGauge(address(0)))   feeDiscount = 0;   // If the guage reverts, set the discount to 0. else   try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {     feeDiscount = discount;   } catch {     feeDiscount = 0;   }  // If the fee discount is greater than the max, nullify the discount. if (feeDiscount &gt; JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 17:17:56 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './../interfaces/IJBController.sol';
import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol';
import './../libraries/JBConstants.sol';
import './../libraries/JBCurrencies.sol';
import './../libraries/JBFixedPointNumber.sol';
import './../libraries/JBFundingCycleMetadataResolver.sol';
import './../libraries/JBOperations.sol';
import './../libraries/JBSplitsGroups.sol';
import './../libraries/JBTokens.sol';
import './../structs/JBTokenAmount.sol';
import './JBOperatable.sol';
import './JBSingleTokenPaymentTerminal.sol';

/**
  @notice
  Generic terminal managing all inflows and outflows of funds into the protocol ecosystem.

  @dev
  A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time.

  @dev
  Adheres to -
  IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.
  JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
abstract contract JBPayoutRedemptionPaymentTerminal is
  IJBPayoutRedemptionPaymentTerminal,
  JBSingleTokenPaymentTerminal,
  JBOperatable,
  Ownable,
  ReentrancyGuard
{
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error FEE_TOO_HIGH();
  error INADEQUATE_DISTRIBUTION_AMOUNT();
  error INADEQUATE_RECLAIM_AMOUNT();
  error INADEQUATE_TOKEN_COUNT();
  error NO_MSG_VALUE_ALLOWED();
  error PAY_TO_ZERO_ADDRESS();
  error PROJECT_TERMINAL_MISMATCH();
  error REDEEM_TO_ZERO_ADDRESS();
  error TERMINAL_IN_SPLIT_ZERO_ADDRESS();
  error TERMINAL_TOKENS_INCOMPATIBLE();

  //*********************************************************************//
  // ---------------------------- modifiers ---------------------------- //
  //*********************************************************************//

  /** 
    @notice 
    A modifier that verifies this terminal is a terminal of provided project ID.
  */
  modifier isTerminalOf(uint256 _projectId) {
    if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();
    _;
  }

  //*********************************************************************//
  // --------------------- internal stored constants ------------------- //
  //*********************************************************************//

  /**
    @notice
    Maximum fee that can be set for a funding cycle configuration.

    @dev
    Out of MAX_FEE (50_000_000 / 1_000_000_000).
  */
  uint256 internal constant _FEE_CAP = 50_000_000;

  /**
    @notice
    The protocol project ID is 1, as it should be the first project launched during the deployment process.
  */
  uint256 internal constant _PROTOCOL_PROJECT_ID = 1;

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    Fees that are being held to be processed later.

    _projectId The ID of the project for which fees are being held.
  */
  mapping(uint256 => JBFee[]) internal _heldFeesOf;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership and transfers.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  /**
    @notice
    The contract that stores and manages the terminal's data.
  */
  IJBSingleTokenPaymentTerminalStore public immutable override store;

  /**
    @notice
    The currency to base token issuance on.

    @dev
    If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.
  */
  uint256 public immutable override baseWeightCurrency;

  /**
    @notice
    The group that payout splits coming from this terminal are identified by.
  */
  uint256 public immutable override payoutSplitsGroup;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The platform fee percent.

    @dev
    Out of MAX_FEE (25_000_000 / 1_000_000_000)
  */
  uint256 public override fee = 25_000_000; // 2.5%

  /**
    @notice
    The data source that returns a discount to apply to a project's fee.
  */
  IJBFeeGauge public override feeGauge;

  /**
    @notice
    Addresses that can be paid towards from this terminal without incurring a fee.

    _address The address that can be paid toward.
  */
  mapping(address => bool) public override isFeelessAddress;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.

    @dev
    The current overflow is represented as a fixed point number with 18 decimals.

    @param _projectId The ID of the project to get overflow for.

    @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.
  */
  function currentEthOverflowOf(uint256 _projectId)
    external
    view
    virtual
    override
    returns (uint256)
  {
    // Get this terminal's current overflow.
    uint256 _overflow = store.currentOverflowOf(this, _projectId);

    // Adjust the decimals of the fixed point number if needed to have 18 decimals.
    uint256 _adjustedOverflow = (decimals == 18)
      ? _overflow
      : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);

    // Return the amount converted to ETH.
    return
      (currency == JBCurrencies.ETH)
        ? _adjustedOverflow
        : PRBMath.mulDiv(
          _adjustedOverflow,
          10**decimals,
          prices.priceFor(currency, JBCurrencies.ETH, decimals)
        );
  }

  /**
    @notice
    The fees that are currently being held to be processed later for each project.

    @param _projectId The ID of the project for which fees are being held.

    @return An array of fees that are being held.
  */
  function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {
    return _heldFeesOf[_projectId];
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(JBSingleTokenPaymentTerminal, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||
      _interfaceId == type(IJBPayoutTerminal).interfaceId ||
      _interfaceId == type(IJBAllowanceTerminal).interfaceId ||
      _interfaceId == type(IJBRedemptionTerminal).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _token The token that this terminal manages.
    @param _decimals The number of decimals the token fixed point amounts are expected to have.
    @param _currency The currency that this terminal's token adheres to for price feeds.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _splitsStore A contract that stores splits for each project.
    @param _prices A contract that exposes price feeds.
    @param _store A contract that stores the terminal's data.
    @param _owner The address that will own this contract.
  */
  constructor(
    // payable constructor save the gas used to check msg.value==0
    address _token,
    uint256 _decimals,
    uint256 _currency,
    uint256 _baseWeightCurrency,
    uint256 _payoutSplitsGroup,
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBSplitsStore _splitsStore,
    IJBPrices _prices,
    IJBSingleTokenPaymentTerminalStore _store,
    address _owner
  )
    payable
    JBSingleTokenPaymentTerminal(_token, _decimals, _currency)
    JBOperatable(_operatorStore)
  {
    baseWeightCurrency = _baseWeightCurrency;
    payoutSplitsGroup = _payoutSplitsGroup;
    projects = _projects;
    directory = _directory;
    splitsStore = _splitsStore;
    prices = _prices;
    store = _store;

    transferOwnership(_owner);
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Contribute tokens to a project.

    @param _projectId The ID of the project being paid.
    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _token The token being paid. This terminal ignores this property since it only manages one token. 
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function pay(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {
    _token; // Prevents unused var compiler and natspec complaints.

    // ETH shouldn't be sent if this terminal's token isn't ETH.
    if (token != JBTokens.ETH) {
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If this terminal's token is ETH, override _amount with msg.value.
    else _amount = msg.value;

    return
      _pay(
        _amount,
        msg.sender,
        _projectId,
        _beneficiary,
        _minReturnedTokens,
        _preferClaimedTokens,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _token The token being reclaimed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  )
    external
    virtual
    override
    requirePermission(_holder, _projectId, JBOperations.REDEEM)
    returns (uint256 reclaimAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return
      _redeemTokensOf(
        _holder,
        _projectId,
        _tokenCount,
        _minReturnedTokens,
        _beneficiary,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) external virtual override returns (uint256 netLeftoverDistributionAmount) {
    _token; // Prevents unused var compiler and natspec complaints.

    return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)
    returns (uint256 netDistributedAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);
  }

  /**
    @notice
    Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project being migrated.
    @param _to The terminal contract that will gain the project's funds.

    @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.
  */
  function migrate(uint256 _projectId, IJBPaymentTerminal _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)
    returns (uint256 balance)
  {
    // The terminal being migrated to must accept the same token as this terminal.
    if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE();

    // Record the migration in the store.
    balance = store.recordMigration(_projectId);

    // Transfer the balance if needed.
    if (balance > 0) {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_to), balance);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? balance : 0;

      // Withdraw the balance to transfer to the new terminal;
      _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes(''));
    }

    emit Migrate(_projectId, _to, balance, msg.sender);
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _token The token being paid. This terminal ignores this property since it only manages one currency. 
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) {
    _token; // Prevents unused var compiler and natspec complaints.

    // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender.
    if (token != JBTokens.ETH) {
      // Amount must be greater than 0.
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If the terminal's token is ETH, override `_amount` with msg.value.
    else _amount = msg.value;

    // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal.
    _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);
  }

  /**
    @notice
    Process any fees that are being held for the project.

    @dev
    Only a project owner, an operator, or the contract's owner can process held fees.

    @param _projectId The ID of the project whos held fees should be processed.
  */
  function processFees(uint256 _projectId)
    external
    virtual
    override
    requirePermissionAllowingOverride(
      projects.ownerOf(_projectId),
      _projectId,
      JBOperations.PROCESS_FEES,
      msg.sender == owner()
    )
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the held fees.
    delete _heldFeesOf[_projectId];

    // Push array length in stack
    uint256 _heldFeeLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeeLength; ) {
      // Get the fee amount.
      uint256 _amount = _feeAmount(
        _heldFees[_i].amount,
        _heldFees[_i].fee,
        _heldFees[_i].feeDiscount
      );

      // Process the fee.
      _processFee(_amount, _heldFees[_i].beneficiary);

      emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Allows the fee to be updated.

    @dev
    Only the owner of this contract can change the fee.

    @param _fee The new fee, out of MAX_FEE.
  */
  function setFee(uint256 _fee) external virtual override onlyOwner {
    // The provided fee must be within the max.
    if (_fee > _FEE_CAP) revert FEE_TOO_HIGH();

    // Store the new fee.
    fee = _fee;

    emit SetFee(_fee, msg.sender);
  }

  /**
    @notice
    Allows the fee gauge to be updated.

    @dev
    Only the owner of this contract can change the fee gauge.

    @dev
    If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.

    @param _feeGauge The new fee gauge.
  */
  function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {
    // Store the new fee gauge.
    feeGauge = _feeGauge;

    emit SetFeeGauge(_feeGauge, msg.sender);
  }

  /**
    @notice
    Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.

    @dev
    Only the owner of this contract can set addresses as feeless.

    @param _address The address that can be paid towards while still bypassing fees.
    @param _flag A flag indicating whether the terminal should be feeless or not.
  */
  function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {
    // Set the flag value.
    isFeelessAddress[_address] = _flag;

    emit SetFeelessAddress(_address, _flag, msg.sender);
  }

  //*********************************************************************//
  // ---------------------- internal transactions ---------------------- //
  //*********************************************************************//

  /** 
    @notice
    Transfers tokens.

    @param _from The address from which the transfer should originate.
    @param _to The address to which the transfer should go.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _transferFrom(
    address _from,
    address payable _to,
    uint256 _amount
  ) internal virtual;

  /** 
    @notice
    Logic to be triggered before transferring tokens from this terminal.

    @param _to The address to which the transfer is going.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _beforeTransferTo(address _to, uint256 _amount) internal virtual;

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function _redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 reclaimAmount) {
    // Can't send reclaimed funds to the zero address.
    if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the redemption is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` only used within scope.
    {
      IJBRedemptionDelegate _delegate;

      // Record the redemption.
      (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(
        _holder,
        _projectId,
        _tokenCount,
        _memo,
        _metadata
      );

      // The amount being reclaimed must be at least as much as was expected.
      if (reclaimAmount < _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();

      // Burn the project tokens.
      if (_tokenCount > 0)
        IJBController(directory.controllerOf(_projectId)).burnTokensOf(
          _holder,
          _projectId,
          _tokenCount,
          '',
          false
        );

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBRedemptionDelegate(address(0))) {
        JBDidRedeemData memory _data = JBDidRedeemData(
          _holder,
          _projectId,
          _fundingCycle.configuration,
          _tokenCount,
          JBTokenAmount(token, reclaimAmount, decimals, currency),
          _beneficiary,
          _memo,
          _metadata
        );
        _delegate.didRedeem(_data);
        emit DelegateDidRedeem(_delegate, _data, msg.sender);
      }
    }

    // Send the reclaimed funds to the beneficiary.
    if (reclaimAmount > 0) _transferFrom(address(this), _beneficiary, reclaimAmount);

    emit RedeemTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _holder,
      _beneficiary,
      _tokenCount,
      reclaimAmount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) internal returns (uint256 netLeftoverDistributionAmount) {
    // Record the distribution.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(
      _projectId,
      _amount,
      _currency
    );

    // The amount being distributed must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Get a reference to the project owner, which will receive tokens from paying the platform fee
    // and receive any extra distributable funds not allocated to payout splits.
    address payable _projectOwner = payable(projects.ownerOf(_projectId));

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the fee amount that was paid.
    uint256 _fee;

    // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope.
    {
      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // The amount distributed that is eligible for incurring fees.
      uint256 _feeEligibleDistributionAmount;

      // The amount leftover after distributing to the splits.
      uint256 _leftoverDistributionAmount;

      // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.
      // Also get a reference to the amount that was distributed to splits from which fees should be taken.
      (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        payoutSplitsGroup,
        _distributedAmount,
        _feeDiscount
      );

      // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.
      unchecked {
        _feeEligibleDistributionAmount += _leftoverDistributionAmount;
      }

      // Take the fee.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0
        ? 0
        : _takeFeeFrom(
          _projectId,
          _fundingCycle,
          _feeEligibleDistributionAmount,
          _projectOwner,
          _feeDiscount
        );

      // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.

      unchecked {
        netLeftoverDistributionAmount = _leftoverDistributionAmount == 0
          ? 0
          : _leftoverDistributionAmount -
            _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);
      }

      // Transfer any remaining balance to the project owner.
      if (netLeftoverDistributionAmount > 0)
        _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount);
    }

    emit DistributePayouts(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _projectOwner,
      _amount,
      _distributedAmount,
      _fee,
      netLeftoverDistributionAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function _useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  ) internal returns (uint256 netDistributedAmount) {
    // Record the use of the allowance.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(
      _projectId,
      _amount,
      _currency
    );

    // The amount being withdrawn must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope.
    {
      // Keep a reference to the fee amount that was paid.
      uint256 _fee;

      // Get a reference to the project owner, which will receive tokens from paying the platform fee.
      address _projectOwner = projects.ownerOf(_projectId);

      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // Take a fee from the `_distributedAmount`, if needed.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
        ? 0
        : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);

      unchecked {
        // The net amount is the withdrawn amount without the fee.
        netDistributedAmount = _distributedAmount - _fee;
      }

      // Transfer any remaining balance to the beneficiary.
      if (netDistributedAmount > 0)
        _transferFrom(address(this), _beneficiary, netDistributedAmount);
    }

    emit UseAllowance(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _beneficiary,
      _amount,
      _distributedAmount,
      netDistributedAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Pays out splits for a project's funding cycle configuration.

    @param _projectId The ID of the project for which payout splits are being distributed.
    @param _domain The domain of the splits to distribute the payout between.
    @param _group The group of the splits to distribute the payout between.
    @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return leftoverAmount If the leftover amount if the splits don't add up to 100%.
    @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.
  */
  function _distributeToPayoutSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount,
    uint256 _feeDiscount
  ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's payout splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    // Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; ) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _payoutAmount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // The payout amount substracting any applicable incurred fees.
      uint256 _netPayoutAmount;

      if (_payoutAmount > 0) {
        // Transfer tokens to the split.
        // If there's an allocator set, transfer to its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0))) {
          // If the split allocator is set as feeless, this distribution is not eligible for a fee.
          if (isFeelessAddress[address(_split.allocator)])
            _netPayoutAmount = _payoutAmount;
            // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.
          else {
            unchecked {
              _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                ? _payoutAmount
                : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
            }

            // This distribution is eligible for a fee since the funds are leaving the ecosystem.
            feeEligibleDistributionAmount += _payoutAmount;
          }

          // Trigger any inherited pre-transfer logic.
          _beforeTransferTo(address(_split.allocator), _netPayoutAmount);

          // If this terminal's token is ETH, send it in msg.value.
          uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

          // Create the data to send to the allocator.
          JBSplitAllocationData memory _data = JBSplitAllocationData(
            token,
            _netPayoutAmount,
            decimals,
            _projectId,
            _group,
            _split
          );

          // Trigger the allocator's `allocate` function.
          _split.allocator.allocate{value: _payableValue}(_data);

          // Otherwise, if a project is specified, make a payment to it.
        } else if (_split.projectId != 0) {
          // Get a reference to the Juicebox terminal being used.
          IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);

          // The project must have a terminal to send funds to.
          if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();

          // Save gas if this contract is being used as the terminal.
          if (_terminal == this) {
            // This distribution does not incur a fee.
            _netPayoutAmount = _payoutAmount;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);
            else
              _pay(
                _netPayoutAmount,
                address(this),
                _split.projectId,
                (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          } else {
            // If the terminal is set as feeless, this distribution is not eligible for a fee.
            if (isFeelessAddress[address(_terminal)])
              _netPayoutAmount = _payoutAmount;
              // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.
            else {
              unchecked {
                _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                  ? _payoutAmount
                  : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
              }

              feeEligibleDistributionAmount += _payoutAmount;
            }

            // Trigger any inherited pre-transfer logic.
            _beforeTransferTo(address(_terminal), _netPayoutAmount);

            // If this terminal's token is ETH, send it in msg.value.
            uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _terminal.addToBalanceOf{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                '',
                _projectMetadata
              );
            else
              _terminal.pay{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          }
        } else {
          unchecked {
            _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
              ? _payoutAmount
              : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
          }

          // This distribution is eligible for a fee since the funds are leaving the ecosystem.
          feeEligibleDistributionAmount += _payoutAmount;

          // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.
          _transferFrom(
            address(this),
            _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),
            _netPayoutAmount
          );
        }

        // Subtract from the amount to be sent to the beneficiary.
        unchecked {
          leftoverAmount = leftoverAmount - _payoutAmount;
        }
      }

      emit DistributeToPayoutSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _netPayoutAmount,
        msg.sender
      );

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID.

    @param _projectId The ID of the project having fees taken from.
    @param _fundingCycle The funding cycle during which the fee is being taken.
    @param _amount The amount of the fee to take, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platforms tokens for.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return feeAmount The amount of the fee taken.
  */
  function _takeFeeFrom(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _amount,
    address _beneficiary,
    uint256 _feeDiscount
  ) internal returns (uint256 feeAmount) {
    feeAmount = _feeAmount(_amount, fee, _feeDiscount);

    if (_fundingCycle.shouldHoldFees()) {
      // Store the held fee.
      _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));

      emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender);
    } else {
      // Process the fee.
      _processFee(feeAmount, _beneficiary); // Take the fee.

      emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender);
    }
  }

  /**
    @notice
    Process a fee of the specified amount.

    @param _amount The fee amount, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platform's tokens for.
  */
  function _processFee(uint256 _amount, address _beneficiary) internal {
    // Get the terminal for the protocol project.
    IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token);

    // When processing the admin fee, save gas if the admin is using this contract as its terminal.
    if (_terminal == this)
      _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call.
    else {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_terminal), _amount);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;

      // Send the payment.
      _terminal.pay{value: _payableValue}(
        _PROTOCOL_PROJECT_ID,
        _amount,
        token,
        _beneficiary,
        0,
        false,
        '',
        bytes('')
      ); // Use the external pay call of the correct terminal.
    }
  }

  /**
    @notice
    Contribute tokens to a project.

    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _payer The address making the payment.
    @param _projectId The ID of the project being paid.
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function _pay(
    uint256 _amount,
    address _payer,
    uint256 _projectId,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 beneficiaryTokenCount) {
    // Cant send tokens to the zero address.
    if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the payment is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope.
    {
      IJBPayDelegate _delegate;
      uint256 _tokenCount;

      // Bundle the amount info into a JBTokenAmount struct.
      JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);

      // Record the payment.
      (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(
        _payer,
        _bundledAmount,
        _projectId,
        baseWeightCurrency,
        _beneficiary,
        _memo,
        _metadata
      );

      // Mint the tokens if needed.
      if (_tokenCount > 0)
        // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.
        beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(
          _projectId,
          _tokenCount,
          _beneficiary,
          '',
          _preferClaimedTokens,
          true
        );

      // The token count for the beneficiary must be greater than or equal to the minimum expected.
      if (beneficiaryTokenCount < _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBPayDelegate(address(0))) {
        JBDidPayData memory _data = JBDidPayData(
          _payer,
          _projectId,
          _fundingCycle.configuration,
          _bundledAmount,
          beneficiaryTokenCount,
          _beneficiary,
          _preferClaimedTokens,
          _memo,
          _metadata
        );

        _delegate.didPay(_data);
        emit DelegateDidPay(_delegate, _data, msg.sender);
      }
    }

    emit Pay(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _payer,
      _beneficiary,
      _amount,
      beneficiaryTokenCount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function _addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    bool _shouldRefundHeldFees,
    string memory _memo,
    bytes memory _metadata
  ) internal {
    // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.
    uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0;

    // Record the added funds with any refunded fees.
    store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);

    emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);
  }

  /**
    @notice
    Refund fees based on the specified amount.

    @param _projectId The project for which fees are being refunded.
    @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.

    @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal
  */
  function _refundHeldFees(uint256 _projectId, uint256 _amount)
    internal
    returns (uint256 refundedFees)
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the current held fees.
    delete _heldFeesOf[_projectId];

    // Get a reference to the leftover amount once all fees have been settled.
    uint256 leftoverAmount = _amount;

    // Push length in stack
    uint256 _heldFeesLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeesLength; ) {
      if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);
      else if (leftoverAmount >= _heldFees[_i].amount) {
        unchecked {
          leftoverAmount = leftoverAmount - _heldFees[_i].amount;
          refundedFees += _feeAmount(
            _heldFees[_i].amount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount
          );
        }
      } else {
        _heldFeesOf[_projectId].push(
          JBFee(
            _heldFees[_i].amount - leftoverAmount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount,
            _heldFees[_i].beneficiary
          )
        );
        unchecked {
          refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);
        }
        leftoverAmount = 0;
      }

      unchecked {
        ++_i;
      }
    }

    emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);
  }

  /** 
    @notice 
    Returns the fee amount based on the provided amount for the specified project.

    @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal.
    @param _fee The percentage of the fee, out of MAX_FEE. 
    @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.

    @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _feeAmount(
    uint256 _amount,
    uint256 _fee,
    uint256 _feeDiscount
  ) internal pure returns (uint256) {
    // Calculate the discounted fee.
    uint256 _discountedFee = _fee -
      PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT);

    // The amount of tokens from the `_amount` to pay as a fee.
    return
      _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);
  }

  /** 
    @notice
    Get the fee discount from the fee gauge for the specified project.

    @param _projectId The ID of the project to get a fee discount for.
    
    @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.
  */
  function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {
    // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.
    if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))
      return JBConstants.MAX_FEE_DISCOUNT;

    // Get the fee discount.
    if (feeGauge == IJBFeeGauge(address(0)))
      feeDiscount = 0;
      // If the guage reverts, set the discount to 0.
    else
      try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {
        feeDiscount = discount;
      } catch {
        feeDiscount = 0;
      }

    // If the fee discount is greater than the max, nullify the discount.
    if (feeDiscount > JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;
  }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './../interfaces/IJBController.sol';
import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol';
import './../libraries/JBConstants.sol';
import './../libraries/JBCurrencies.sol';
import './../libraries/JBFixedPointNumber.sol';
import './../libraries/JBFundingCycleMetadataResolver.sol';
import './../libraries/JBOperations.sol';
import './../libraries/JBSplitsGroups.sol';
import './../libraries/JBTokens.sol';
import './../structs/JBTokenAmount.sol';
import './JBOperatable.sol';
import './JBSingleTokenPaymentTerminal.sol';

/**
  @notice
  Generic terminal managing all inflows and outflows of funds into the protocol ecosystem.

  @dev
  A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time.

  @dev
  Adheres to -
  IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.
  JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
abstract contract JBPayoutRedemptionPaymentTerminal is
  IJBPayoutRedemptionPaymentTerminal,
  JBSingleTokenPaymentTerminal,
  JBOperatable,
  Ownable,
  ReentrancyGuard
{
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error FEE_TOO_HIGH();
  error INADEQUATE_DISTRIBUTION_AMOUNT();
  error INADEQUATE_RECLAIM_AMOUNT();
  error INADEQUATE_TOKEN_COUNT();
  error NO_MSG_VALUE_ALLOWED();
  error PAY_TO_ZERO_ADDRESS();
  error PROJECT_TERMINAL_MISMATCH();
  error REDEEM_TO_ZERO_ADDRESS();
  error TERMINAL_IN_SPLIT_ZERO_ADDRESS();
  error TERMINAL_TOKENS_INCOMPATIBLE();

  //*********************************************************************//
  // ---------------------------- modifiers ---------------------------- //
  //*********************************************************************//

  /** 
    @notice 
    A modifier that verifies this terminal is a terminal of provided project ID.
  */
  modifier isTerminalOf(uint256 _projectId) {
    if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();
    _;
  }

  //*********************************************************************//
  // --------------------- internal stored constants ------------------- //
  //*********************************************************************//

  /**
    @notice
    Maximum fee that can be set for a funding cycle configuration.

    @dev
    Out of MAX_FEE (50_000_000 / 1_000_000_000).
  */
  uint256 internal constant _FEE_CAP = 50_000_000;

  /**
    @notice
    The protocol project ID is 1, as it should be the first project launched during the deployment process.
  */
  uint256 internal constant _PROTOCOL_PROJECT_ID = 1;

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    Fees that are being held to be processed later.

    _projectId The ID of the project for which fees are being held.
  */
  mapping(uint256 => JBFee[]) internal _heldFeesOf;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership and transfers.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  /**
    @notice
    The contract that stores and manages the terminal's data.
  */
  IJBSingleTokenPaymentTerminalStore public immutable override store;

  /**
    @notice
    The currency to base token issuance on.

    @dev
    If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.
  */
  uint256 public immutable override baseWeightCurrency;

  /**
    @notice
    The group that payout splits coming from this terminal are identified by.
  */
  uint256 public immutable override payoutSplitsGroup;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The platform fee percent.

    @dev
    Out of MAX_FEE (25_000_000 / 1_000_000_000)
  */
  uint256 public override fee = 25_000_000; // 2.5%

  /**
    @notice
    The data source that returns a discount to apply to a project's fee.
  */
  IJBFeeGauge public override feeGauge;

  /**
    @notice
    Addresses that can be paid towards from this terminal without incurring a fee.

    _address The address that can be paid toward.
  */
  mapping(address => bool) public override isFeelessAddress;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.

    @dev
    The current overflow is represented as a fixed point number with 18 decimals.

    @param _projectId The ID of the project to get overflow for.

    @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.
  */
  function currentEthOverflowOf(uint256 _projectId)
    external
    view
    virtual
    override
    returns (uint256)
  {
    // Get this terminal's current overflow.
    uint256 _overflow = store.currentOverflowOf(this, _projectId);

    // Adjust the decimals of the fixed point number if needed to have 18 decimals.
    uint256 _adjustedOverflow = (decimals == 18)
      ? _overflow
      : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);

    // Return the amount converted to ETH.
    return
      (currency == JBCurrencies.ETH)
        ? _adjustedOverflow
        : PRBMath.mulDiv(
          _adjustedOverflow,
          10**decimals,
          prices.priceFor(currency, JBCurrencies.ETH, decimals)
        );
  }

  /**
    @notice
    The fees that are currently being held to be processed later for each project.

    @param _projectId The ID of the project for which fees are being held.

    @return An array of fees that are being held.
  */
  function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {
    return _heldFeesOf[_projectId];
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(JBSingleTokenPaymentTerminal, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||
      _interfaceId == type(IJBPayoutTerminal).interfaceId ||
      _interfaceId == type(IJBAllowanceTerminal).interfaceId ||
      _interfaceId == type(IJBRedemptionTerminal).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _token The token that this terminal manages.
    @param _decimals The number of decimals the token fixed point amounts are expected to have.
    @param _currency The currency that this terminal's token adheres to for price feeds.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _splitsStore A contract that stores splits for each project.
    @param _prices A contract that exposes price feeds.
    @param _store A contract that stores the terminal's data.
    @param _owner The address that will own this contract.
  */
  constructor(
    // payable constructor save the gas used to check msg.value==0
    address _token,
    uint256 _decimals,
    uint256 _currency,
    uint256 _baseWeightCurrency,
    uint256 _payoutSplitsGroup,
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBSplitsStore _splitsStore,
    IJBPrices _prices,
    IJBSingleTokenPaymentTerminalStore _store,
    address _owner
  )
    payable
    JBSingleTokenPaymentTerminal(_token, _decimals, _currency)
    JBOperatable(_operatorStore)
  {
    baseWeightCurrency = _baseWeightCurrency;
    payoutSplitsGroup = _payoutSplitsGroup;
    projects = _projects;
    directory = _directory;
    splitsStore = _splitsStore;
    prices = _prices;
    store = _store;

    transferOwnership(_owner);
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Contribute tokens to a project.

    @param _projectId The ID of the project being paid.
    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _token The token being paid. This terminal ignores this property since it only manages one token. 
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function pay(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {
    _token; // Prevents unused var compiler and natspec complaints.

    // ETH shouldn't be sent if this terminal's token isn't ETH.
    if (token != JBTokens.ETH) {
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If this terminal's token is ETH, override _amount with msg.value.
    else _amount = msg.value;

    return
      _pay(
        _amount,
        msg.sender,
        _projectId,
        _beneficiary,
        _minReturnedTokens,
        _preferClaimedTokens,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _token The token being reclaimed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  )
    external
    virtual
    override
    requirePermission(_holder, _projectId, JBOperations.REDEEM)
    returns (uint256 reclaimAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return
      _redeemTokensOf(
        _holder,
        _projectId,
        _tokenCount,
        _minReturnedTokens,
        _beneficiary,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) external virtual override returns (uint256 netLeftoverDistributionAmount) {
    _token; // Prevents unused var compiler and natspec complaints.

    return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)
    returns (uint256 netDistributedAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);
  }

  /**
    @notice
    Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project being migrated.
    @param _to The terminal contract that will gain the project's funds.

    @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.
  */
  function migrate(uint256 _projectId, IJBPaymentTerminal _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)
    returns (uint256 balance)
  {
    // The terminal being migrated to must accept the same token as this terminal.
    if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE();

    // Record the migration in the store.
    balance = store.recordMigration(_projectId);

    // Transfer the balance if needed.
    if (balance > 0) {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_to), balance);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? balance : 0;

      // Withdraw the balance to transfer to the new terminal;
      _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes(''));
    }

    emit Migrate(_projectId, _to, balance, msg.sender);
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _token The token being paid. This terminal ignores this property since it only manages one currency. 
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) {
    _token; // Prevents unused var compiler and natspec complaints.

    // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender.
    if (token != JBTokens.ETH) {
      // Amount must be greater than 0.
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If the terminal's token is ETH, override `_amount` with msg.value.
    else _amount = msg.value;

    // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal.
    _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);
  }

  /**
    @notice
    Process any fees that are being held for the project.

    @dev
    Only a project owner, an operator, or the contract's owner can process held fees.

    @param _projectId The ID of the project whos held fees should be processed.
  */
  function processFees(uint256 _projectId)
    external
    virtual
    override
    requirePermissionAllowingOverride(
      projects.ownerOf(_projectId),
      _projectId,
      JBOperations.PROCESS_FEES,
      msg.sender == owner()
    )
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the held fees.
    delete _heldFeesOf[_projectId];

    // Push array length in stack
    uint256 _heldFeeLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeeLength; ) {
      // Get the fee amount.
      uint256 _amount = _feeAmount(
        _heldFees[_i].amount,
        _heldFees[_i].fee,
        _heldFees[_i].feeDiscount
      );

      // Process the fee.
      _processFee(_amount, _heldFees[_i].beneficiary);

      emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Allows the fee to be updated.

    @dev
    Only the owner of this contract can change the fee.

    @param _fee The new fee, out of MAX_FEE.
  */
  function setFee(uint256 _fee) external virtual override onlyOwner {
    // The provided fee must be within the max.
    if (_fee > _FEE_CAP) revert FEE_TOO_HIGH();

    // Store the new fee.
    fee = _fee;

    emit SetFee(_fee, msg.sender);
  }

  /**
    @notice
    Allows the fee gauge to be updated.

    @dev
    Only the owner of this contract can change the fee gauge.

    @dev
    If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.

    @param _feeGauge The new fee gauge.
  */
  function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {
    // Store the new fee gauge.
    feeGauge = _feeGauge;

    emit SetFeeGauge(_feeGauge, msg.sender);
  }

  /**
    @notice
    Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.

    @dev
    Only the owner of this contract can set addresses as feeless.

    @param _address The address that can be paid towards while still bypassing fees.
    @param _flag A flag indicating whether the terminal should be feeless or not.
  */
  function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {
    // Set the flag value.
    isFeelessAddress[_address] = _flag;

    emit SetFeelessAddress(_address, _flag, msg.sender);
  }

  //*********************************************************************//
  // ---------------------- internal transactions ---------------------- //
  //*********************************************************************//

  /** 
    @notice
    Transfers tokens.

    @param _from The address from which the transfer should originate.
    @param _to The address to which the transfer should go.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _transferFrom(
    address _from,
    address payable _to,
    uint256 _amount
  ) internal virtual;

  /** 
    @notice
    Logic to be triggered before transferring tokens from this terminal.

    @param _to The address to which the transfer is going.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _beforeTransferTo(address _to, uint256 _amount) internal virtual;

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function _redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 reclaimAmount) {
    // Can't send reclaimed funds to the zero address.
    if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the redemption is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` only used within scope.
    {
      IJBRedemptionDelegate _delegate;

      // Record the redemption.
      (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(
        _holder,
        _projectId,
        _tokenCount,
        _memo,
        _metadata
      );

      // The amount being reclaimed must be at least as much as was expected.
      if (reclaimAmount < _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();

      // Burn the project tokens.
      if (_tokenCount > 0)
        IJBController(directory.controllerOf(_projectId)).burnTokensOf(
          _holder,
          _projectId,
          _tokenCount,
          '',
          false
        );

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBRedemptionDelegate(address(0))) {
        JBDidRedeemData memory _data = JBDidRedeemData(
          _holder,
          _projectId,
          _fundingCycle.configuration,
          _tokenCount,
          JBTokenAmount(token, reclaimAmount, decimals, currency),
          _beneficiary,
          _memo,
          _metadata
        );
        _delegate.didRedeem(_data);
        emit DelegateDidRedeem(_delegate, _data, msg.sender);
      }
    }

    // Send the reclaimed funds to the beneficiary.
    if (reclaimAmount > 0) _transferFrom(address(this), _beneficiary, reclaimAmount);

    emit RedeemTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _holder,
      _beneficiary,
      _tokenCount,
      reclaimAmount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) internal returns (uint256 netLeftoverDistributionAmount) {
    // Record the distribution.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(
      _projectId,
      _amount,
      _currency
    );

    // The amount being distributed must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Get a reference to the project owner, which will receive tokens from paying the platform fee
    // and receive any extra distributable funds not allocated to payout splits.
    address payable _projectOwner = payable(projects.ownerOf(_projectId));

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the fee amount that was paid.
    uint256 _fee;

    // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope.
    {
      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // The amount distributed that is eligible for incurring fees.
      uint256 _feeEligibleDistributionAmount;

      // The amount leftover after distributing to the splits.
      uint256 _leftoverDistributionAmount;

      // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.
      // Also get a reference to the amount that was distributed to splits from which fees should be taken.
      (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        payoutSplitsGroup,
        _distributedAmount,
        _feeDiscount
      );

      // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.
      unchecked {
        _feeEligibleDistributionAmount += _leftoverDistributionAmount;
      }

      // Take the fee.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0
        ? 0
        : _takeFeeFrom(
          _projectId,
          _fundingCycle,
          _feeEligibleDistributionAmount,
          _projectOwner,
          _feeDiscount
        );

      // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.

      unchecked {
        netLeftoverDistributionAmount = _leftoverDistributionAmount == 0
          ? 0
          : _leftoverDistributionAmount -
            _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);
      }

      // Transfer any remaining balance to the project owner.
      if (netLeftoverDistributionAmount > 0)
        _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount);
    }

    emit DistributePayouts(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _projectOwner,
      _amount,
      _distributedAmount,
      _fee,
      netLeftoverDistributionAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function _useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  ) internal returns (uint256 netDistributedAmount) {
    // Record the use of the allowance.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(
      _projectId,
      _amount,
      _currency
    );

    // The amount being withdrawn must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope.
    {
      // Keep a reference to the fee amount that was paid.
      uint256 _fee;

      // Get a reference to the project owner, which will receive tokens from paying the platform fee.
      address _projectOwner = projects.ownerOf(_projectId);

      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // Take a fee from the `_distributedAmount`, if needed.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
        ? 0
        : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);

      unchecked {
        // The net amount is the withdrawn amount without the fee.
        netDistributedAmount = _distributedAmount - _fee;
      }

      // Transfer any remaining balance to the beneficiary.
      if (netDistributedAmount > 0)
        _transferFrom(address(this), _beneficiary, netDistributedAmount);
    }

    emit UseAllowance(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _beneficiary,
      _amount,
      _distributedAmount,
      netDistributedAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Pays out splits for a project's funding cycle configuration.

    @param _projectId The ID of the project for which payout splits are being distributed.
    @param _domain The domain of the splits to distribute the payout between.
    @param _group The group of the splits to distribute the payout between.
    @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return leftoverAmount If the leftover amount if the splits don't add up to 100%.
    @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.
  */
  function _distributeToPayoutSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount,
    uint256 _feeDiscount
  ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's payout splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    // Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; ) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _payoutAmount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // The payout amount substracting any applicable incurred fees.
      uint256 _netPayoutAmount;

      if (_payoutAmount > 0) {
        // Transfer tokens to the split.
        // If there's an allocator set, transfer to its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0))) {
          // If the split allocator is set as feeless, this distribution is not eligible for a fee.
          if (isFeelessAddress[address(_split.allocator)])
            _netPayoutAmount = _payoutAmount;
            // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.
          else {
            unchecked {
              _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                ? _payoutAmount
                : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
            }

            // This distribution is eligible for a fee since the funds are leaving the ecosystem.
            feeEligibleDistributionAmount += _payoutAmount;
          }

          // Trigger any inherited pre-transfer logic.
          _beforeTransferTo(address(_split.allocator), _netPayoutAmount);

          // If this terminal's token is ETH, send it in msg.value.
          uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

          // Create the data to send to the allocator.
          JBSplitAllocationData memory _data = JBSplitAllocationData(
            token,
            _netPayoutAmount,
            decimals,
            _projectId,
            _group,
            _split
          );

          // Trigger the allocator's `allocate` function.
          _split.allocator.allocate{value: _payableValue}(_data);

          // Otherwise, if a project is specified, make a payment to it.
        } else if (_split.projectId != 0) {
          // Get a reference to the Juicebox terminal being used.
          IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);

          // The project must have a terminal to send funds to.
          if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();

          // Save gas if this contract is being used as the terminal.
          if (_terminal == this) {
            // This distribution does not incur a fee.
            _netPayoutAmount = _payoutAmount;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);
            else
              _pay(
                _netPayoutAmount,
                address(this),
                _split.projectId,
                (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          } else {
            // If the terminal is set as feeless, this distribution is not eligible for a fee.
            if (isFeelessAddress[address(_terminal)])
              _netPayoutAmount = _payoutAmount;
              // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.
            else {
              unchecked {
                _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                  ? _payoutAmount
                  : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
              }

              feeEligibleDistributionAmount += _payoutAmount;
            }

            // Trigger any inherited pre-transfer logic.
            _beforeTransferTo(address(_terminal), _netPayoutAmount);

            // If this terminal's token is ETH, send it in msg.value.
            uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _terminal.addToBalanceOf{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                '',
                _projectMetadata
              );
            else
              _terminal.pay{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          }
        } else {
          unchecked {
            _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
              ? _payoutAmount
              : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
          }

          // This distribution is eligible for a fee since the funds are leaving the ecosystem.
          feeEligibleDistributionAmount += _payoutAmount;

          // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.
          _transferFrom(
            address(this),
            _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),
            _netPayoutAmount
          );
        }

        // Subtract from the amount to be sent to the beneficiary.
        unchecked {
          leftoverAmount = leftoverAmount - _payoutAmount;
        }
      }

      emit DistributeToPayoutSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _netPayoutAmount,
        msg.sender
      );

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID.

    @param _projectId The ID of the project having fees taken from.
    @param _fundingCycle The funding cycle during which the fee is being taken.
    @param _amount The amount of the fee to take, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platforms tokens for.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return feeAmount The amount of the fee taken.
  */
  function _takeFeeFrom(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _amount,
    address _beneficiary,
    uint256 _feeDiscount
  ) internal returns (uint256 feeAmount) {
    feeAmount = _feeAmount(_amount, fee, _feeDiscount);

    if (_fundingCycle.shouldHoldFees()) {
      // Store the held fee.
      _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));

      emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender);
    } else {
      // Process the fee.
      _processFee(feeAmount, _beneficiary); // Take the fee.

      emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender);
    }
  }

  /**
    @notice
    Process a fee of the specified amount.

    @param _amount The fee amount, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platform's tokens for.
  */
  function _processFee(uint256 _amount, address _beneficiary) internal {
    // Get the terminal for the protocol project.
    IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token);

    // When processing the admin fee, save gas if the admin is using this contract as its terminal.
    if (_terminal == this)
      _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call.
    else {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_terminal), _amount);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;

      // Send the payment.
      _terminal.pay{value: _payableValue}(
        _PROTOCOL_PROJECT_ID,
        _amount,
        token,
        _beneficiary,
        0,
        false,
        '',
        bytes('')
      ); // Use the external pay call of the correct terminal.
    }
  }

  /**
    @notice
    Contribute tokens to a project.

    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _payer The address making the payment.
    @param _projectId The ID of the project being paid.
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function _pay(
    uint256 _amount,
    address _payer,
    uint256 _projectId,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 beneficiaryTokenCount) {
    // Cant send tokens to the zero address.
    if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the payment is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope.
    {
      IJBPayDelegate _delegate;
      uint256 _tokenCount;

      // Bundle the amount info into a JBTokenAmount struct.
      JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);

      // Record the payment.
      (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(
        _payer,
        _bundledAmount,
        _projectId,
        baseWeightCurrency,
        _beneficiary,
        _memo,
        _metadata
      );

      // Mint the tokens if needed.
      if (_tokenCount > 0)
        // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.
        beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(
          _projectId,
          _tokenCount,
          _beneficiary,
          '',
          _preferClaimedTokens,
          true
        );

      // The token count for the beneficiary must be greater than or equal to the minimum expected.
      if (beneficiaryTokenCount < _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBPayDelegate(address(0))) {
        JBDidPayData memory _data = JBDidPayData(
          _payer,
          _projectId,
          _fundingCycle.configuration,
          _bundledAmount,
          beneficiaryTokenCount,
          _beneficiary,
          _preferClaimedTokens,
          _memo,
          _metadata
        );

        _delegate.didPay(_data);
        emit DelegateDidPay(_delegate, _data, msg.sender);
      }
    }

    emit Pay(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _payer,
      _beneficiary,
      _amount,
      beneficiaryTokenCount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function _addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    bool _shouldRefundHeldFees,
    string memory _memo,
    bytes memory _metadata
  ) internal {
    // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.
    uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0;

    // Record the added funds with any refunded fees.
    store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);

    emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);
  }

  /**
    @notice
    Refund fees based on the specified amount.

    @param _projectId The project for which fees are being refunded.
    @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.

    @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal
  */
  function _refundHeldFees(uint256 _projectId, uint256 _amount)
    internal
    returns (uint256 refundedFees)
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the current held fees.
    delete _heldFeesOf[_projectId];

    // Get a reference to the leftover amount once all fees have been settled.
    uint256 leftoverAmount = _amount;

    // Push length in stack
    uint256 _heldFeesLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeesLength; ) {
      if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);
      else if (leftoverAmount >= _heldFees[_i].amount) {
        unchecked {
          leftoverAmount = leftoverAmount - _heldFees[_i].amount;
          refundedFees += _feeAmount(
            _heldFees[_i].amount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount
          );
        }
      } else {
        _heldFeesOf[_projectId].push(
          JBFee(
            _heldFees[_i].amount - leftoverAmount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount,
            _heldFees[_i].beneficiary
          )
        );
        unchecked {
          refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);
        }
        leftoverAmount = 0;
      }

      unchecked {
        ++_i;
      }
    }

    emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);
  }

  /** 
    @notice 
    Returns the fee amount based on the provided amount for the specified project.

    @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal.
    @param _fee The percentage of the fee, out of MAX_FEE. 
    @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.

    @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _feeAmount(
    uint256 _amount,
    uint256 _fee,
    uint256 _feeDiscount
  ) internal pure returns (uint256) {
    // Calculate the discounted fee.
    uint256 _discountedFee = _fee -
      PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT);

    // The amount of tokens from the `_amount` to pay as a fee.
    return
      _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);
  }

  /** 
    @notice
    Get the fee discount from the fee gauge for the specified project.

    @param _projectId The ID of the project to get a fee discount for.
    
    @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.
  */
  function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {
    // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.
    if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))
      return JBConstants.MAX_FEE_DISCOUNT;

    // Get the fee discount.
    if (feeGauge == IJBFeeGauge(address(0)))
      feeDiscount = 0;
      // If the guage reverts, set the discount to 0.
    else
      try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {
        feeDiscount = discount;
      } catch {
        feeDiscount = 0;
      }

    // If the fee discount is greater than the max, nullify the discount.
    if (feeDiscount > JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;
  }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-01-09 17:17:59 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 17:17:59 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 25445
completion_tokens: 1
total_tokens: 25446
cost: $-1.000000


[2024-01-09 17:17:59 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './../interfaces/IJBController.sol';
import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol';
import './../libraries/JBConstants.sol';
import './../libraries/JBCurrencies.sol';
import './../libraries/JBFixedPointNumber.sol';
import './../libraries/JBFundingCycleMetadataResolver.sol';
import './../libraries/JBOperations.sol';
import './../libraries/JBSplitsGroups.sol';
import './../libraries/JBTokens.sol';
import './../structs/JBTokenAmount.sol';
import './JBOperatable.sol';
import './JBSingleTokenPaymentTerminal.sol';

/**
  @notice
  Generic terminal managing all inflows and outflows of funds into the protocol ecosystem.

  @dev
  A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time.

  @dev
  Adheres to -
  IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.
  JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
abstract contract JBPayoutRedemptionPaymentTerminal is
  IJBPayoutRedemptionPaymentTerminal,
  JBSingleTokenPaymentTerminal,
  JBOperatable,
  Ownable,
  ReentrancyGuard
{
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error FEE_TOO_HIGH();
  error INADEQUATE_DISTRIBUTION_AMOUNT();
  error INADEQUATE_RECLAIM_AMOUNT();
  error INADEQUATE_TOKEN_COUNT();
  error NO_MSG_VALUE_ALLOWED();
  error PAY_TO_ZERO_ADDRESS();
  error PROJECT_TERMINAL_MISMATCH();
  error REDEEM_TO_ZERO_ADDRESS();
  error TERMINAL_IN_SPLIT_ZERO_ADDRESS();
  error TERMINAL_TOKENS_INCOMPATIBLE();

  //*********************************************************************//
  // ---------------------------- modifiers ---------------------------- //
  //*********************************************************************//

  /** 
    @notice 
    A modifier that verifies this terminal is a terminal of provided project ID.
  */
  modifier isTerminalOf(uint256 _projectId) {
    if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();
    _;
  }

  //*********************************************************************//
  // --------------------- internal stored constants ------------------- //
  //*********************************************************************//

  /**
    @notice
    Maximum fee that can be set for a funding cycle configuration.

    @dev
    Out of MAX_FEE (50_000_000 / 1_000_000_000).
  */
  uint256 internal constant _FEE_CAP = 50_000_000;

  /**
    @notice
    The protocol project ID is 1, as it should be the first project launched during the deployment process.
  */
  uint256 internal constant _PROTOCOL_PROJECT_ID = 1;

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    Fees that are being held to be processed later.

    _projectId The ID of the project for which fees are being held.
  */
  mapping(uint256 => JBFee[]) internal _heldFeesOf;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership and transfers.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  /**
    @notice
    The contract that stores and manages the terminal's data.
  */
  IJBSingleTokenPaymentTerminalStore public immutable override store;

  /**
    @notice
    The currency to base token issuance on.

    @dev
    If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.
  */
  uint256 public immutable override baseWeightCurrency;

  /**
    @notice
    The group that payout splits coming from this terminal are identified by.
  */
  uint256 public immutable override payoutSplitsGroup;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The platform fee percent.

    @dev
    Out of MAX_FEE (25_000_000 / 1_000_000_000)
  */
  uint256 public override fee = 25_000_000; // 2.5%

  /**
    @notice
    The data source that returns a discount to apply to a project's fee.
  */
  IJBFeeGauge public override feeGauge;

  /**
    @notice
    Addresses that can be paid towards from this terminal without incurring a fee.

    _address The address that can be paid toward.
  */
  mapping(address => bool) public override isFeelessAddress;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.

    @dev
    The current overflow is represented as a fixed point number with 18 decimals.

    @param _projectId The ID of the project to get overflow for.

    @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.
  */
  function currentEthOverflowOf(uint256 _projectId)
    external
    view
    virtual
    override
    returns (uint256)
  {
    // Get this terminal's current overflow.
    uint256 _overflow = store.currentOverflowOf(this, _projectId);

    // Adjust the decimals of the fixed point number if needed to have 18 decimals.
    uint256 _adjustedOverflow = (decimals == 18)
      ? _overflow
      : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);

    // Return the amount converted to ETH.
    return
      (currency == JBCurrencies.ETH)
        ? _adjustedOverflow
        : PRBMath.mulDiv(
          _adjustedOverflow,
          10**decimals,
          prices.priceFor(currency, JBCurrencies.ETH, decimals)
        );
  }

  /**
    @notice
    The fees that are currently being held to be processed later for each project.

    @param _projectId The ID of the project for which fees are being held.

    @return An array of fees that are being held.
  */
  function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {
    return _heldFeesOf[_projectId];
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(JBSingleTokenPaymentTerminal, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||
      _interfaceId == type(IJBPayoutTerminal).interfaceId ||
      _interfaceId == type(IJBAllowanceTerminal).interfaceId ||
      _interfaceId == type(IJBRedemptionTerminal).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _token The token that this terminal manages.
    @param _decimals The number of decimals the token fixed point amounts are expected to have.
    @param _currency The currency that this terminal's token adheres to for price feeds.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _splitsStore A contract that stores splits for each project.
    @param _prices A contract that exposes price feeds.
    @param _store A contract that stores the terminal's data.
    @param _owner The address that will own this contract.
  */
  constructor(
    // payable constructor save the gas used to check msg.value==0
    address _token,
    uint256 _decimals,
    uint256 _currency,
    uint256 _baseWeightCurrency,
    uint256 _payoutSplitsGroup,
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBSplitsStore _splitsStore,
    IJBPrices _prices,
    IJBSingleTokenPaymentTerminalStore _store,
    address _owner
  )
    payable
    JBSingleTokenPaymentTerminal(_token, _decimals, _currency)
    JBOperatable(_operatorStore)
  {
    baseWeightCurrency = _baseWeightCurrency;
    payoutSplitsGroup = _payoutSplitsGroup;
    projects = _projects;
    directory = _directory;
    splitsStore = _splitsStore;
    prices = _prices;
    store = _store;

    transferOwnership(_owner);
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Contribute tokens to a project.

    @param _projectId The ID of the project being paid.
    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _token The token being paid. This terminal ignores this property since it only manages one token. 
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function pay(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {
    _token; // Prevents unused var compiler and natspec complaints.

    // ETH shouldn't be sent if this terminal's token isn't ETH.
    if (token != JBTokens.ETH) {
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If this terminal's token is ETH, override _amount with msg.value.
    else _amount = msg.value;

    return
      _pay(
        _amount,
        msg.sender,
        _projectId,
        _beneficiary,
        _minReturnedTokens,
        _preferClaimedTokens,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _token The token being reclaimed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  )
    external
    virtual
    override
    requirePermission(_holder, _projectId, JBOperations.REDEEM)
    returns (uint256 reclaimAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return
      _redeemTokensOf(
        _holder,
        _projectId,
        _tokenCount,
        _minReturnedTokens,
        _beneficiary,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) external virtual override returns (uint256 netLeftoverDistributionAmount) {
    _token; // Prevents unused var compiler and natspec complaints.

    return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)
    returns (uint256 netDistributedAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);
  }

  /**
    @notice
    Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project being migrated.
    @param _to The terminal contract that will gain the project's funds.

    @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.
  */
  function migrate(uint256 _projectId, IJBPaymentTerminal _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)
    returns (uint256 balance)
  {
    // The terminal being migrated to must accept the same token as this terminal.
    if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE();

    // Record the migration in the store.
    balance = store.recordMigration(_projectId);

    // Transfer the balance if needed.
    if (balance > 0) {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_to), balance);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? balance : 0;

      // Withdraw the balance to transfer to the new terminal;
      _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes(''));
    }

    emit Migrate(_projectId, _to, balance, msg.sender);
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _token The token being paid. This terminal ignores this property since it only manages one currency. 
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) {
    _token; // Prevents unused var compiler and natspec complaints.

    // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender.
    if (token != JBTokens.ETH) {
      // Amount must be greater than 0.
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If the terminal's token is ETH, override `_amount` with msg.value.
    else _amount = msg.value;

    // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal.
    _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);
  }

  /**
    @notice
    Process any fees that are being held for the project.

    @dev
    Only a project owner, an operator, or the contract's owner can process held fees.

    @param _projectId The ID of the project whos held fees should be processed.
  */
  function processFees(uint256 _projectId)
    external
    virtual
    override
    requirePermissionAllowingOverride(
      projects.ownerOf(_projectId),
      _projectId,
      JBOperations.PROCESS_FEES,
      msg.sender == owner()
    )
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the held fees.
    delete _heldFeesOf[_projectId];

    // Push array length in stack
    uint256 _heldFeeLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeeLength; ) {
      // Get the fee amount.
      uint256 _amount = _feeAmount(
        _heldFees[_i].amount,
        _heldFees[_i].fee,
        _heldFees[_i].feeDiscount
      );

      // Process the fee.
      _processFee(_amount, _heldFees[_i].beneficiary);

      emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Allows the fee to be updated.

    @dev
    Only the owner of this contract can change the fee.

    @param _fee The new fee, out of MAX_FEE.
  */
  function setFee(uint256 _fee) external virtual override onlyOwner {
    // The provided fee must be within the max.
    if (_fee > _FEE_CAP) revert FEE_TOO_HIGH();

    // Store the new fee.
    fee = _fee;

    emit SetFee(_fee, msg.sender);
  }

  /**
    @notice
    Allows the fee gauge to be updated.

    @dev
    Only the owner of this contract can change the fee gauge.

    @dev
    If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.

    @param _feeGauge The new fee gauge.
  */
  function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {
    // Store the new fee gauge.
    feeGauge = _feeGauge;

    emit SetFeeGauge(_feeGauge, msg.sender);
  }

  /**
    @notice
    Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.

    @dev
    Only the owner of this contract can set addresses as feeless.

    @param _address The address that can be paid towards while still bypassing fees.
    @param _flag A flag indicating whether the terminal should be feeless or not.
  */
  function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {
    // Set the flag value.
    isFeelessAddress[_address] = _flag;

    emit SetFeelessAddress(_address, _flag, msg.sender);
  }

  //*********************************************************************//
  // ---------------------- internal transactions ---------------------- //
  //*********************************************************************//

  /** 
    @notice
    Transfers tokens.

    @param _from The address from which the transfer should originate.
    @param _to The address to which the transfer should go.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _transferFrom(
    address _from,
    address payable _to,
    uint256 _amount
  ) internal virtual;

  /** 
    @notice
    Logic to be triggered before transferring tokens from this terminal.

    @param _to The address to which the transfer is going.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _beforeTransferTo(address _to, uint256 _amount) internal virtual;

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function _redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 reclaimAmount) {
    // Can't send reclaimed funds to the zero address.
    if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the redemption is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` only used within scope.
    {
      IJBRedemptionDelegate _delegate;

      // Record the redemption.
      (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(
        _holder,
        _projectId,
        _tokenCount,
        _memo,
        _metadata
      );

      // The amount being reclaimed must be at least as much as was expected.
      if (reclaimAmount < _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();

      // Burn the project tokens.
      if (_tokenCount > 0)
        IJBController(directory.controllerOf(_projectId)).burnTokensOf(
          _holder,
          _projectId,
          _tokenCount,
          '',
          false
        );

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBRedemptionDelegate(address(0))) {
        JBDidRedeemData memory _data = JBDidRedeemData(
          _holder,
          _projectId,
          _fundingCycle.configuration,
          _tokenCount,
          JBTokenAmount(token, reclaimAmount, decimals, currency),
          _beneficiary,
          _memo,
          _metadata
        );
        _delegate.didRedeem(_data);
        emit DelegateDidRedeem(_delegate, _data, msg.sender);
      }
    }

    // Send the reclaimed funds to the beneficiary.
    if (reclaimAmount > 0) _transferFrom(address(this), _beneficiary, reclaimAmount);

    emit RedeemTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _holder,
      _beneficiary,
      _tokenCount,
      reclaimAmount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) internal returns (uint256 netLeftoverDistributionAmount) {
    // Record the distribution.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(
      _projectId,
      _amount,
      _currency
    );

    // The amount being distributed must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Get a reference to the project owner, which will receive tokens from paying the platform fee
    // and receive any extra distributable funds not allocated to payout splits.
    address payable _projectOwner = payable(projects.ownerOf(_projectId));

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the fee amount that was paid.
    uint256 _fee;

    // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope.
    {
      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // The amount distributed that is eligible for incurring fees.
      uint256 _feeEligibleDistributionAmount;

      // The amount leftover after distributing to the splits.
      uint256 _leftoverDistributionAmount;

      // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.
      // Also get a reference to the amount that was distributed to splits from which fees should be taken.
      (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        payoutSplitsGroup,
        _distributedAmount,
        _feeDiscount
      );

      // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.
      unchecked {
        _feeEligibleDistributionAmount += _leftoverDistributionAmount;
      }

      // Take the fee.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0
        ? 0
        : _takeFeeFrom(
          _projectId,
          _fundingCycle,
          _feeEligibleDistributionAmount,
          _projectOwner,
          _feeDiscount
        );

      // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.

      unchecked {
        netLeftoverDistributionAmount = _leftoverDistributionAmount == 0
          ? 0
          : _leftoverDistributionAmount -
            _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);
      }

      // Transfer any remaining balance to the project owner.
      if (netLeftoverDistributionAmount > 0)
        _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount);
    }

    emit DistributePayouts(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _projectOwner,
      _amount,
      _distributedAmount,
      _fee,
      netLeftoverDistributionAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function _useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  ) internal returns (uint256 netDistributedAmount) {
    // Record the use of the allowance.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(
      _projectId,
      _amount,
      _currency
    );

    // The amount being withdrawn must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope.
    {
      // Keep a reference to the fee amount that was paid.
      uint256 _fee;

      // Get a reference to the project owner, which will receive tokens from paying the platform fee.
      address _projectOwner = projects.ownerOf(_projectId);

      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // Take a fee from the `_distributedAmount`, if needed.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
        ? 0
        : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);

      unchecked {
        // The net amount is the withdrawn amount without the fee.
        netDistributedAmount = _distributedAmount - _fee;
      }

      // Transfer any remaining balance to the beneficiary.
      if (netDistributedAmount > 0)
        _transferFrom(address(this), _beneficiary, netDistributedAmount);
    }

    emit UseAllowance(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _beneficiary,
      _amount,
      _distributedAmount,
      netDistributedAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Pays out splits for a project's funding cycle configuration.

    @param _projectId The ID of the project for which payout splits are being distributed.
    @param _domain The domain of the splits to distribute the payout between.
    @param _group The group of the splits to distribute the payout between.
    @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return leftoverAmount If the leftover amount if the splits don't add up to 100%.
    @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.
  */
  function _distributeToPayoutSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount,
    uint256 _feeDiscount
  ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's payout splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    // Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; ) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _payoutAmount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // The payout amount substracting any applicable incurred fees.
      uint256 _netPayoutAmount;

      if (_payoutAmount > 0) {
        // Transfer tokens to the split.
        // If there's an allocator set, transfer to its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0))) {
          // If the split allocator is set as feeless, this distribution is not eligible for a fee.
          if (isFeelessAddress[address(_split.allocator)])
            _netPayoutAmount = _payoutAmount;
            // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.
          else {
            unchecked {
              _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                ? _payoutAmount
                : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
            }

            // This distribution is eligible for a fee since the funds are leaving the ecosystem.
            feeEligibleDistributionAmount += _payoutAmount;
          }

          // Trigger any inherited pre-transfer logic.
          _beforeTransferTo(address(_split.allocator), _netPayoutAmount);

          // If this terminal's token is ETH, send it in msg.value.
          uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

          // Create the data to send to the allocator.
          JBSplitAllocationData memory _data = JBSplitAllocationData(
            token,
            _netPayoutAmount,
            decimals,
            _projectId,
            _group,
            _split
          );

          // Trigger the allocator's `allocate` function.
          _split.allocator.allocate{value: _payableValue}(_data);

          // Otherwise, if a project is specified, make a payment to it.
        } else if (_split.projectId != 0) {
          // Get a reference to the Juicebox terminal being used.
          IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);

          // The project must have a terminal to send funds to.
          if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();

          // Save gas if this contract is being used as the terminal.
          if (_terminal == this) {
            // This distribution does not incur a fee.
            _netPayoutAmount = _payoutAmount;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);
            else
              _pay(
                _netPayoutAmount,
                address(this),
                _split.projectId,
                (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          } else {
            // If the terminal is set as feeless, this distribution is not eligible for a fee.
            if (isFeelessAddress[address(_terminal)])
              _netPayoutAmount = _payoutAmount;
              // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.
            else {
              unchecked {
                _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                  ? _payoutAmount
                  : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
              }

              feeEligibleDistributionAmount += _payoutAmount;
            }

            // Trigger any inherited pre-transfer logic.
            _beforeTransferTo(address(_terminal), _netPayoutAmount);

            // If this terminal's token is ETH, send it in msg.value.
            uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _terminal.addToBalanceOf{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                '',
                _projectMetadata
              );
            else
              _terminal.pay{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          }
        } else {
          unchecked {
            _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
              ? _payoutAmount
              : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
          }

          // This distribution is eligible for a fee since the funds are leaving the ecosystem.
          feeEligibleDistributionAmount += _payoutAmount;

          // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.
          _transferFrom(
            address(this),
            _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),
            _netPayoutAmount
          );
        }

        // Subtract from the amount to be sent to the beneficiary.
        unchecked {
          leftoverAmount = leftoverAmount - _payoutAmount;
        }
      }

      emit DistributeToPayoutSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _netPayoutAmount,
        msg.sender
      );

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID.

    @param _projectId The ID of the project having fees taken from.
    @param _fundingCycle The funding cycle during which the fee is being taken.
    @param _amount The amount of the fee to take, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platforms tokens for.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return feeAmount The amount of the fee taken.
  */
  function _takeFeeFrom(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _amount,
    address _beneficiary,
    uint256 _feeDiscount
  ) internal returns (uint256 feeAmount) {
    feeAmount = _feeAmount(_amount, fee, _feeDiscount);

    if (_fundingCycle.shouldHoldFees()) {
      // Store the held fee.
      _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));

      emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender);
    } else {
      // Process the fee.
      _processFee(feeAmount, _beneficiary); // Take the fee.

      emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender);
    }
  }

  /**
    @notice
    Process a fee of the specified amount.

    @param _amount The fee amount, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platform's tokens for.
  */
  function _processFee(uint256 _amount, address _beneficiary) internal {
    // Get the terminal for the protocol project.
    IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token);

    // When processing the admin fee, save gas if the admin is using this contract as its terminal.
    if (_terminal == this)
      _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call.
    else {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_terminal), _amount);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;

      // Send the payment.
      _terminal.pay{value: _payableValue}(
        _PROTOCOL_PROJECT_ID,
        _amount,
        token,
        _beneficiary,
        0,
        false,
        '',
        bytes('')
      ); // Use the external pay call of the correct terminal.
    }
  }

  /**
    @notice
    Contribute tokens to a project.

    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _payer The address making the payment.
    @param _projectId The ID of the project being paid.
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function _pay(
    uint256 _amount,
    address _payer,
    uint256 _projectId,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 beneficiaryTokenCount) {
    // Cant send tokens to the zero address.
    if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the payment is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope.
    {
      IJBPayDelegate _delegate;
      uint256 _tokenCount;

      // Bundle the amount info into a JBTokenAmount struct.
      JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);

      // Record the payment.
      (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(
        _payer,
        _bundledAmount,
        _projectId,
        baseWeightCurrency,
        _beneficiary,
        _memo,
        _metadata
      );

      // Mint the tokens if needed.
      if (_tokenCount > 0)
        // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.
        beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(
          _projectId,
          _tokenCount,
          _beneficiary,
          '',
          _preferClaimedTokens,
          true
        );

      // The token count for the beneficiary must be greater than or equal to the minimum expected.
      if (beneficiaryTokenCount < _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBPayDelegate(address(0))) {
        JBDidPayData memory _data = JBDidPayData(
          _payer,
          _projectId,
          _fundingCycle.configuration,
          _bundledAmount,
          beneficiaryTokenCount,
          _beneficiary,
          _preferClaimedTokens,
          _memo,
          _metadata
        );

        _delegate.didPay(_data);
        emit DelegateDidPay(_delegate, _data, msg.sender);
      }
    }

    emit Pay(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _payer,
      _beneficiary,
      _amount,
      beneficiaryTokenCount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function _addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    bool _shouldRefundHeldFees,
    string memory _memo,
    bytes memory _metadata
  ) internal {
    // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.
    uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0;

    // Record the added funds with any refunded fees.
    store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);

    emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);
  }

  /**
    @notice
    Refund fees based on the specified amount.

    @param _projectId The project for which fees are being refunded.
    @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.

    @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal
  */
  function _refundHeldFees(uint256 _projectId, uint256 _amount)
    internal
    returns (uint256 refundedFees)
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the current held fees.
    delete _heldFeesOf[_projectId];

    // Get a reference to the leftover amount once all fees have been settled.
    uint256 leftoverAmount = _amount;

    // Push length in stack
    uint256 _heldFeesLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeesLength; ) {
      if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);
      else if (leftoverAmount >= _heldFees[_i].amount) {
        unchecked {
          leftoverAmount = leftoverAmount - _heldFees[_i].amount;
          refundedFees += _feeAmount(
            _heldFees[_i].amount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount
          );
        }
      } else {
        _heldFeesOf[_projectId].push(
          JBFee(
            _heldFees[_i].amount - leftoverAmount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount,
            _heldFees[_i].beneficiary
          )
        );
        unchecked {
          refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);
        }
        leftoverAmount = 0;
      }

      unchecked {
        ++_i;
      }
    }

    emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);
  }

  /** 
    @notice 
    Returns the fee amount based on the provided amount for the specified project.

    @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal.
    @param _fee The percentage of the fee, out of MAX_FEE. 
    @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.

    @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _feeAmount(
    uint256 _amount,
    uint256 _fee,
    uint256 _feeDiscount
  ) internal pure returns (uint256) {
    // Calculate the discounted fee.
    uint256 _discountedFee = _fee -
      PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT);

    // The amount of tokens from the `_amount` to pay as a fee.
    return
      _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);
  }

  /** 
    @notice
    Get the fee discount from the fee gauge for the specified project.

    @param _projectId The ID of the project to get a fee discount for.
    
    @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.
  */
  function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {
    // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.
    if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))
      return JBConstants.MAX_FEE_DISCOUNT;

    // Get the fee discount.
    if (feeGauge == IJBFeeGauge(address(0)))
      feeDiscount = 0;
      // If the guage reverts, set the discount to 0.
    else
      try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {
        feeDiscount = discount;
      } catch {
        feeDiscount = 0;
      }

    // If the fee discount is greater than the max, nullify the discount.
    if (feeDiscount > JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;
  }
}
.]

###

[2024-01-09 17:17:59 INFO] **[Seminar Conclusion]**:

 ###

[2024-01-09 17:17:59 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-01-09 17:17:59 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/security/ReentrancyGuard.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './../interfaces/IJBController.sol'; import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol'; import './../libraries/JBConstants.sol'; import './../libraries/JBCurrencies.sol'; import './../libraries/JBFixedPointNumber.sol'; import './../libraries/JBFundingCycleMetadataResolver.sol'; import './../libraries/JBOperations.sol'; import './../libraries/JBSplitsGroups.sol'; import './../libraries/JBTokens.sol'; import './../structs/JBTokenAmount.sol'; import './JBOperatable.sol'; import './JBSingleTokenPaymentTerminal.sol'; /**   @notice   Generic terminal managing all inflows and outflows of funds into the protocol ecosystem. @dev   A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time. @dev   Adheres to -   IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules. @dev   Inherits from -   JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.   JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.   Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.   ReentrancyGuard: Contract module that helps prevent reentrant calls to a function. */ abstract contract JBPayoutRedemptionPaymentTerminal is   IJBPayoutRedemptionPaymentTerminal,   JBSingleTokenPaymentTerminal,   JBOperatable,   Ownable,   ReentrancyGuard {   // A library that parses the packed funding cycle metadata into a friendlier format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error FEE_TOO_HIGH();   error INADEQUATE_DISTRIBUTION_AMOUNT();   error INADEQUATE_RECLAIM_AMOUNT();   error INADEQUATE_TOKEN_COUNT();   error NO_MSG_VALUE_ALLOWED();   error PAY_TO_ZERO_ADDRESS();   error PROJECT_TERMINAL_MISMATCH();   error REDEEM_TO_ZERO_ADDRESS();   error TERMINAL_IN_SPLIT_ZERO_ADDRESS();   error TERMINAL_TOKENS_INCOMPATIBLE(); //***********//   // ---------------------------- modifiers ---------------------------- //   //*************// /*      @notice      A modifier that verifies this terminal is a terminal of provided project ID.   /   modifier isTerminalOf(uint256 projectId) {     if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();     ;   } //***********//   // --------------------- internal stored constants ------------------- //   //*************// /**     @notice     Maximum fee that can be set for a funding cycle configuration. @dev Out of MAX_FEE (50_000_000 / 1_000_000_000).  */   uint256 internal constant _FEE_CAP = 50_000_000; /*     @notice     The protocol project ID is 1, as it should be the first project launched during the deployment process.   /   uint256 internal constant _PROTOCOL_PROJECT_ID = 1; //***********//   // --------------------- internal stored properties ------------------ //   //*************// /**     @notice     Fees that are being held to be processed later. _projectId The ID of the project for which fees are being held.  */   mapping(uint256 =&gt; JBFee[]) internal _heldFeesOf; //***********//   // ---------------- public immutable stored properties --------------- //   //*************// /*     @notice     Mints ERC-721's that represent project ownership and transfers.   /   IJBProjects public immutable override projects; /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; /*     @notice     The contract that stores splits for each project.   /   IJBSplitsStore public immutable override splitsStore; /*     @notice     The contract that exposes price feeds.   /   IJBPrices public immutable override prices; /*     @notice     The contract that stores and manages the terminal's data.   /   IJBSingleTokenPaymentTerminalStore public immutable override store; /**     @notice     The currency to base token issuance on. @dev If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.  */   uint256 public immutable override baseWeightCurrency; /*     @notice     The group that payout splits coming from this terminal are identified by.   /   uint256 public immutable override payoutSplitsGroup; //***********//   // --------------------- public stored properties -------------------- //   //*************// /**     @notice     The platform fee percent. @dev Out of MAX_FEE (25_000_000 / 1_000_000_000)  */   uint256 public override fee = 25_000_000; // 2.5% /*     @notice     The data source that returns a discount to apply to a project's fee.   /   IJBFeeGauge public override feeGauge; /**     @notice     Addresses that can be paid towards from this terminal without incurring a fee. _address The address that can be paid toward.  */   mapping(address =&gt; bool) public override isFeelessAddress; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     Gets the current overflowed amount in this terminal for a specified project, in terms of ETH. @dev The current overflow is represented as a fixed point number with 18 decimals.  @param _projectId The ID of the project to get overflow for.  @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.  */   function currentEthOverflowOf(uint256 _projectId)     external     view     virtual     override     returns (uint256)   {     // Get this terminal's current overflow.     uint256 _overflow = store.currentOverflowOf(this, _projectId); // Adjust the decimals of the fixed point number if needed to have 18 decimals. uint256 _adjustedOverflow = (decimals == 18)   ? _overflow   : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);  // Return the amount converted to ETH. return   (currency == JBCurrencies.ETH)     ? _adjustedOverflow     : PRBMath.mulDiv(       _adjustedOverflow,       10**decimals,       prices.priceFor(currency, JBCurrencies.ETH, decimals)     );  } /**     @notice     The fees that are currently being held to be processed later for each project. @param _projectId The ID of the project for which fees are being held.  @return An array of fees that are being held.  */   function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {     return _heldFeesOf[_projectId];   } //***********//   // -------------------------- public views --------------------------- //   //*************// /**     @notice     Indicates if this contract adheres to the specified interface. @dev  See {IERC165-supportsInterface}.  @param _interfaceId The ID of the interface to check for adherance to.  */   function supportsInterface(bytes4 _interfaceId)     public     view     virtual     override(JBSingleTokenPaymentTerminal, IERC165)     returns (bool)   {     return       _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||       _interfaceId == type(IJBPayoutTerminal).interfaceId ||       _interfaceId == type(IJBAllowanceTerminal).interfaceId ||       _interfaceId == type(IJBRedemptionTerminal).interfaceId ||       _interfaceId == type(IJBOperatable).interfaceId ||       super.supportsInterface(_interfaceId);   } //***********//   // -------------------------- constructor ---------------------------- //   //*************// /*     @param _token The token that this terminal manages.     @param _decimals The number of decimals the token fixed point amounts are expected to have.     @param _currency The currency that this terminal's token adheres to for price feeds.     @param _baseWeightCurrency The currency to base token issuance on.     @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.     @param _operatorStore A contract storing operator assignments.     @param _projects A contract which mints ERC-721's that represent project ownership and transfers.     @param _directory A contract storing directories of terminals and controllers for each project.     @param _splitsStore A contract that stores splits for each project.     @param _prices A contract that exposes price feeds.     @param _store A contract that stores the terminal's data.     @param _owner The address that will own this contract.   /   constructor(     // payable constructor save the gas used to check msg.value==0     address _token,     uint256 _decimals,     uint256 _currency,     uint256 _baseWeightCurrency,     uint256 _payoutSplitsGroup,     IJBOperatorStore _operatorStore,     IJBProjects _projects,     IJBDirectory _directory,     IJBSplitsStore _splitsStore,     IJBPrices _prices,     IJBSingleTokenPaymentTerminalStore _store,     address _owner   )     payable     JBSingleTokenPaymentTerminal(_token, _decimals, _currency)     JBOperatable(_operatorStore)   {     baseWeightCurrency = _baseWeightCurrency;     payoutSplitsGroup = _payoutSplitsGroup;     projects = _projects;     directory = _directory;     splitsStore = _splitsStore;     prices = _prices;     store = _store; transferOwnership(_owner);  } //***********//   // ---------------------- external transactions ---------------------- //   //*************// /**     @notice     Contribute tokens to a project. @param _projectId The ID of the project being paid. @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place. @param _token The token being paid. This terminal ignores this property since it only manages one token.  @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate. @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal. @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas. @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.  */   function pay(     uint256 _projectId,     uint256 _amount,     address _token,     address _beneficiary,     uint256 _minReturnedTokens,     bool _preferClaimedTokens,     string calldata _memo,     bytes calldata _metadata   ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {     _token; // Prevents unused var compiler and natspec complaints. // ETH shouldn't be sent if this terminal's token isn't ETH. if (token != JBTokens.ETH) {   if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();    // Transfer tokens to this terminal from the msg sender.   _transferFrom(msg.sender, payable(address(this)), _amount); } // If this terminal's token is ETH, override _amount with msg.value. else _amount = msg.value;  return   _pay(     _amount,     msg.sender,     _projectId,     _beneficiary,     _minReturnedTokens,     _preferClaimedTokens,     _memo,     _metadata   );  } /**     @notice     Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source. @dev Only a token holder or a designated operator can redeem its tokens.  @param _holder The account to redeem tokens for. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _token The token being reclaimed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal. @param _beneficiary The address to send the terminal tokens to. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.  */   function redeemTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     address _token,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo,     bytes memory _metadata   )     external     virtual     override     requirePermission(_holder, _projectId, JBOperations.REDEEM)     returns (uint256 reclaimAmount)   {     _token; // Prevents unused var compiler and natspec complaints. return   _redeemTokensOf(     _holder,     _projectId,     _tokenCount,     _minReturnedTokens,     _beneficiary,     _memo,     _metadata   );  } /**     @notice     Distributes payouts for a project with the distribution limit of its current funding cycle. @dev Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.  @dev Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.  @dev All funds distributed outside of this contract or any feeless terminals incure the protocol fee.  @param _projectId The ID of the project having its payouts distributed. @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency. @param _token The token being distributed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal. @param _memo A memo to pass along to the emitted event.  @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.  */   function distributePayoutsOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     address _token,     uint256 _minReturnedTokens,     string calldata _memo   ) external virtual override returns (uint256 netLeftoverDistributionAmount) {     _token; // Prevents unused var compiler and natspec complaints. return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);  } /**     @notice     Allows a project to send funds from its overflow up to the preconfigured allowance. @dev Only a project's owner or a designated operator can use its allowance.  @dev Incurs the protocol fee.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency. @param _token The token being distributed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals. @param _beneficiary The address to send the funds to. @param _memo A memo to pass along to the emitted event.  @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.  */   function useAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     address _token,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)     returns (uint256 netDistributedAmount)   {     _token; // Prevents unused var compiler and natspec complaints. return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);  } /**     @notice     Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type. @dev Only a project's owner or a designated operator can migrate it.  @param _projectId The ID of the project being migrated. @param _to The terminal contract that will gain the project's funds.  @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.  */   function migrate(uint256 _projectId, IJBPaymentTerminal _to)     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)     returns (uint256 balance)   {     // The terminal being migrated to must accept the same token as this terminal.     if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE(); // Record the migration in the store. balance = store.recordMigration(_projectId);  // Transfer the balance if needed. if (balance &gt; 0) {   // Trigger any inherited pre-transfer logic.   _beforeTransferTo(address(_to), balance);    // If this terminal's token is ETH, send it in msg.value.   uint256 _payableValue = token == JBTokens.ETH ? balance : 0;    // Withdraw the balance to transfer to the new terminal;   _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes('')); }  emit Migrate(_projectId, _to, balance, msg.sender);  } /**     @notice     Receives funds belonging to the specified project. @param _projectId The ID of the project to which the funds received belong. @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead. @param _token The token being paid. This terminal ignores this property since it only manages one currency.  @param _memo A memo to pass along to the emitted event. @param _metadata Extra data to pass along to the emitted event.  */   function addToBalanceOf(     uint256 _projectId,     uint256 _amount,     address _token,     string calldata _memo,     bytes calldata _metadata   ) external payable virtual override isTerminalOf(_projectId) {     _token; // Prevents unused var compiler and natspec complaints. // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender. if (token != JBTokens.ETH) {   // Amount must be greater than 0.   if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();    // Transfer tokens to this terminal from the msg sender.   _transferFrom(msg.sender, payable(address(this)), _amount); } // If the terminal's token is ETH, override `_amount` with msg.value. else _amount = msg.value;  // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal. _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);  } /**     @notice     Process any fees that are being held for the project. @dev Only a project owner, an operator, or the contract's owner can process held fees.  @param _projectId The ID of the project whos held fees should be processed.  */   function processFees(uint256 _projectId)     external     virtual     override     requirePermissionAllowingOverride(       projects.ownerOf(_projectId),       _projectId,       JBOperations.PROCESS_FEES,       msg.sender == owner()     )   {     // Get a reference to the project's held fees.     JBFee[] memory _heldFees = _heldFeesOf[_projectId]; // Delete the held fees. delete _heldFeesOf[_projectId];  // Push array length in stack uint256 _heldFeeLength = _heldFees.length;  // Process each fee. for (uint256 _i = 0; _i &lt; _heldFeeLength; ) {   // Get the fee amount.   uint256 _amount = _feeAmount(     _heldFees[_i].amount,     _heldFees[_i].fee,     _heldFees[_i].feeDiscount   );    // Process the fee.   _processFee(_amount, _heldFees[_i].beneficiary);    emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);    unchecked {     ++_i;   } }  } /**     @notice     Allows the fee to be updated. @dev Only the owner of this contract can change the fee.  @param _fee The new fee, out of MAX_FEE.  */   function setFee(uint256 _fee) external virtual override onlyOwner {     // The provided fee must be within the max.     if (_fee &gt; _FEE_CAP) revert FEE_TOO_HIGH(); // Store the new fee. fee = _fee;  emit SetFee(_fee, msg.sender);  } /**     @notice     Allows the fee gauge to be updated. @dev Only the owner of this contract can change the fee gauge.  @dev If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.  @param _feeGauge The new fee gauge.  */   function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {     // Store the new fee gauge.     feeGauge = _feeGauge; emit SetFeeGauge(_feeGauge, msg.sender);  } /**     @notice     Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee. @dev Only the owner of this contract can set addresses as feeless.  @param _address The address that can be paid towards while still bypassing fees. @param _flag A flag indicating whether the terminal should be feeless or not.  */   function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {     // Set the flag value.     isFeelessAddress[_address] = _flag; emit SetFeelessAddress(_address, _flag, msg.sender);  } //***********//   // ---------------------- internal transactions ---------------------- //   //*************// /**      @notice     Transfers tokens. @param _from The address from which the transfer should originate. @param _to The address to which the transfer should go. @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.  */   function _transferFrom(     address _from,     address payable _to,     uint256 _amount   ) internal virtual; /**      @notice     Logic to be triggered before transferring tokens from this terminal. @param _to The address to which the transfer is going. @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.  */   function _beforeTransferTo(address _to, uint256 _amount) internal virtual; /**     @notice     Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source. @dev Only a token holder or a designated operator can redeem its tokens.  @param _holder The account to redeem tokens for. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal. @param _beneficiary The address to send the terminal tokens to. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.  */   function _redeemTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo,     bytes memory _metadata   ) internal returns (uint256 reclaimAmount) {     // Can't send reclaimed funds to the zero address.     if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS(); // Define variables that will be needed outside the scoped section below. // Keep a reference to the funding cycle during which the redemption is being made. JBFundingCycle memory _fundingCycle;  // Scoped section prevents stack too deep. `_delegate` only used within scope. {   IJBRedemptionDelegate _delegate;    // Record the redemption.   (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(     _holder,     _projectId,     _tokenCount,     _memo,     _metadata   );    // The amount being reclaimed must be at least as much as was expected.   if (reclaimAmount &lt; _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();    // Burn the project tokens.   if (_tokenCount &gt; 0)     IJBController(directory.controllerOf(_projectId)).burnTokensOf(       _holder,       _projectId,       _tokenCount,       '',       false     );    // If a delegate was returned by the data source, issue a callback to it.   if (_delegate != IJBRedemptionDelegate(address(0))) {     JBDidRedeemData memory _data = JBDidRedeemData(       _holder,       _projectId,       _fundingCycle.configuration,       _tokenCount,       JBTokenAmount(token, reclaimAmount, decimals, currency),       _beneficiary,       _memo,       _metadata     );     _delegate.didRedeem(_data);     emit DelegateDidRedeem(_delegate, _data, msg.sender);   } }  // Send the reclaimed funds to the beneficiary. if (reclaimAmount &gt; 0) _transferFrom(address(this), _beneficiary, reclaimAmount);  emit RedeemTokens(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _holder,   _beneficiary,   _tokenCount,   reclaimAmount,   _memo,   _metadata,   msg.sender );  } /**     @notice     Distributes payouts for a project with the distribution limit of its current funding cycle. @dev Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.  @dev Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.  @dev All funds distributed outside of this contract or any feeless terminals incure the protocol fee.  @param _projectId The ID of the project having its payouts distributed. @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency. @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal. @param _memo A memo to pass along to the emitted event.  @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.  */   function _distributePayoutsOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     uint256 _minReturnedTokens,     string calldata _memo   ) internal returns (uint256 netLeftoverDistributionAmount) {     // Record the distribution.     (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(       _projectId,       _amount,       _currency     ); // The amount being distributed must be at least as much as was expected. if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();  // Get a reference to the project owner, which will receive tokens from paying the platform fee // and receive any extra distributable funds not allocated to payout splits. address payable _projectOwner = payable(projects.ownerOf(_projectId));  // Define variables that will be needed outside the scoped section below. // Keep a reference to the fee amount that was paid. uint256 _fee;  // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope. {   // Get the amount of discount that should be applied to any fees taken.   // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.   uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]     ? JBConstants.MAX_FEE_DISCOUNT     : _currentFeeDiscount(_projectId);    // The amount distributed that is eligible for incurring fees.   uint256 _feeEligibleDistributionAmount;    // The amount leftover after distributing to the splits.   uint256 _leftoverDistributionAmount;    // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.   // Also get a reference to the amount that was distributed to splits from which fees should be taken.   (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(     _projectId,     _fundingCycle.configuration,     payoutSplitsGroup,     _distributedAmount,     _feeDiscount   );    // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.   unchecked {     _feeEligibleDistributionAmount += _leftoverDistributionAmount;   }    // Take the fee.   _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0     ? 0     : _takeFeeFrom(       _projectId,       _fundingCycle,       _feeEligibleDistributionAmount,       _projectOwner,       _feeDiscount     );    // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.    unchecked {     netLeftoverDistributionAmount = _leftoverDistributionAmount == 0       ? 0       : _leftoverDistributionAmount -         _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);   }    // Transfer any remaining balance to the project owner.   if (netLeftoverDistributionAmount &gt; 0)     _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount); }  emit DistributePayouts(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _projectOwner,   _amount,   _distributedAmount,   _fee,   netLeftoverDistributionAmount,   _memo,   msg.sender );  } /**     @notice     Allows a project to send funds from its overflow up to the preconfigured allowance. @dev Only a project's owner or a designated operator can use its allowance.  @dev Incurs the protocol fee.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency. @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals. @param _beneficiary The address to send the funds to. @param _memo A memo to pass along to the emitted event.  @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.  */   function _useAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo   ) internal returns (uint256 netDistributedAmount) {     // Record the use of the allowance.     (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(       _projectId,       _amount,       _currency     ); // The amount being withdrawn must be at least as much as was expected. if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();  // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope. {   // Keep a reference to the fee amount that was paid.   uint256 _fee;    // Get a reference to the project owner, which will receive tokens from paying the platform fee.   address _projectOwner = projects.ownerOf(_projectId);    // Get the amount of discount that should be applied to any fees taken.   // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.   uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]     ? JBConstants.MAX_FEE_DISCOUNT     : _currentFeeDiscount(_projectId);    // Take a fee from the `_distributedAmount`, if needed.   _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT     ? 0     : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);    unchecked {     // The net amount is the withdrawn amount without the fee.     netDistributedAmount = _distributedAmount - _fee;   }    // Transfer any remaining balance to the beneficiary.   if (netDistributedAmount &gt; 0)     _transferFrom(address(this), _beneficiary, netDistributedAmount); }  emit UseAllowance(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _beneficiary,   _amount,   _distributedAmount,   netDistributedAmount,   _memo,   msg.sender );  } /**     @notice     Pays out splits for a project's funding cycle configuration. @param _projectId The ID of the project for which payout splits are being distributed. @param _domain The domain of the splits to distribute the payout between. @param _group The group of the splits to distribute the payout between. @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal. @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.  @return leftoverAmount If the leftover amount if the splits don't add up to 100%. @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.  */   function _distributeToPayoutSplitsOf(     uint256 _projectId,     uint256 _domain,     uint256 _group,     uint256 _amount,     uint256 _feeDiscount   ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {     // Set the leftover amount to the initial amount.     leftoverAmount = _amount; // Get a reference to the project's payout splits. JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);  // Transfer between all splits. for (uint256 _i = 0; _i &lt; _splits.length; ) {   // Get a reference to the split being iterated on.   JBSplit memory _split = _splits[_i];    // The amount to send towards the split.   uint256 _payoutAmount = PRBMath.mulDiv(     _amount,     _split.percent,     JBConstants.SPLITS_TOTAL_PERCENT   );    // The payout amount substracting any applicable incurred fees.   uint256 _netPayoutAmount;    if (_payoutAmount &gt; 0) {     // Transfer tokens to the split.     // If there's an allocator set, transfer to its `allocate` function.     if (_split.allocator != IJBSplitAllocator(address(0))) {       // If the split allocator is set as feeless, this distribution is not eligible for a fee.       if (isFeelessAddress[address(_split.allocator)])         _netPayoutAmount = _payoutAmount;         // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.       else {         unchecked {           _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT             ? _payoutAmount             : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);         }          // This distribution is eligible for a fee since the funds are leaving the ecosystem.         feeEligibleDistributionAmount += _payoutAmount;       }        // Trigger any inherited pre-transfer logic.       _beforeTransferTo(address(_split.allocator), _netPayoutAmount);        // If this terminal's token is ETH, send it in msg.value.       uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;        // Create the data to send to the allocator.       JBSplitAllocationData memory _data = JBSplitAllocationData(         token,         _netPayoutAmount,         decimals,         _projectId,         _group,         _split       );        // Trigger the allocator's `allocate` function.       _split.allocator.allocate{value: _payableValue}(_data);        // Otherwise, if a project is specified, make a payment to it.     } else if (_split.projectId != 0) {       // Get a reference to the Juicebox terminal being used.       IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);        // The project must have a terminal to send funds to.       if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();        // Save gas if this contract is being used as the terminal.       if (_terminal == this) {         // This distribution does not incur a fee.         _netPayoutAmount = _payoutAmount;          // Send the projectId in the metadata.         bytes memory _projectMetadata = new bytes(32);         _projectMetadata = bytes(abi.encodePacked(_projectId));          // Add to balance if prefered.         if (_split.preferAddToBalance)           _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);         else           _pay(             _netPayoutAmount,             address(this),             _split.projectId,             (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,             0,             _split.preferClaimed,             '',             _projectMetadata           );       } else {         // If the terminal is set as feeless, this distribution is not eligible for a fee.         if (isFeelessAddress[address(_terminal)])           _netPayoutAmount = _payoutAmount;           // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.         else {           unchecked {             _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT               ? _payoutAmount               : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);           }            feeEligibleDistributionAmount += _payoutAmount;         }          // Trigger any inherited pre-transfer logic.         _beforeTransferTo(address(_terminal), _netPayoutAmount);          // If this terminal's token is ETH, send it in msg.value.         uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;          // Send the projectId in the metadata.         bytes memory _projectMetadata = new bytes(32);         _projectMetadata = bytes(abi.encodePacked(_projectId));          // Add to balance if prefered.         if (_split.preferAddToBalance)           _terminal.addToBalanceOf{value: _payableValue}(             _split.projectId,             _netPayoutAmount,             token,             '',             _projectMetadata           );         else           _terminal.pay{value: _payableValue}(             _split.projectId,             _netPayoutAmount,             token,             _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,             0,             _split.preferClaimed,             '',             _projectMetadata           );       }     } else {       unchecked {         _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT           ? _payoutAmount           : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);       }        // This distribution is eligible for a fee since the funds are leaving the ecosystem.       feeEligibleDistributionAmount += _payoutAmount;        // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.       _transferFrom(         address(this),         _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),         _netPayoutAmount       );     }      // Subtract from the amount to be sent to the beneficiary.     unchecked {       leftoverAmount = leftoverAmount - _payoutAmount;     }   }    emit DistributeToPayoutSplit(     _projectId,     _domain,     _group,     _split,     _netPayoutAmount,     msg.sender   );    unchecked {     ++_i;   } }  } /**     @notice     Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID. @param _projectId The ID of the project having fees taken from. @param _fundingCycle The funding cycle during which the fee is being taken. @param _amount The amount of the fee to take, as a floating point number with 18 decimals. @param _beneficiary The address to mint the platforms tokens for. @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.  @return feeAmount The amount of the fee taken.  */   function _takeFeeFrom(     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _amount,     address _beneficiary,     uint256 _feeDiscount   ) internal returns (uint256 feeAmount) {     feeAmount = _feeAmount(_amount, fee, _feeDiscount); if (_fundingCycle.shouldHoldFees()) {   // Store the held fee.   _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));    emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender); } else {   // Process the fee.   _processFee(feeAmount, _beneficiary); // Take the fee.    emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender); }  } /**     @notice     Process a fee of the specified amount. @param _amount The fee amount, as a floating point number with 18 decimals. @param _beneficiary The address to mint the platform's tokens for.  */   function _processFee(uint256 _amount, address _beneficiary) internal {     // Get the terminal for the protocol project.     IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token); // When processing the admin fee, save gas if the admin is using this contract as its terminal. if (_terminal == this)   _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call. else {   // Trigger any inherited pre-transfer logic.   _beforeTransferTo(address(_terminal), _amount);    // If this terminal's token is ETH, send it in msg.value.   uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;    // Send the payment.   _terminal.pay{value: _payableValue}(     _PROTOCOL_PROJECT_ID,     _amount,     token,     _beneficiary,     0,     false,     '',     bytes('')   ); // Use the external pay call of the correct terminal. }  } /**     @notice     Contribute tokens to a project. @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place. @param _payer The address making the payment. @param _projectId The ID of the project being paid. @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate. @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal. @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas. @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.  */   function _pay(     uint256 _amount,     address _payer,     uint256 _projectId,     address _beneficiary,     uint256 _minReturnedTokens,     bool _preferClaimedTokens,     string memory _memo,     bytes memory _metadata   ) internal returns (uint256 beneficiaryTokenCount) {     // Cant send tokens to the zero address.     if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS(); // Define variables that will be needed outside the scoped section below. // Keep a reference to the funding cycle during which the payment is being made. JBFundingCycle memory _fundingCycle;  // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope. {   IJBPayDelegate _delegate;   uint256 _tokenCount;    // Bundle the amount info into a JBTokenAmount struct.   JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);    // Record the payment.   (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(     _payer,     _bundledAmount,     _projectId,     baseWeightCurrency,     _beneficiary,     _memo,     _metadata   );    // Mint the tokens if needed.   if (_tokenCount &gt; 0)     // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.     beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(       _projectId,       _tokenCount,       _beneficiary,       '',       _preferClaimedTokens,       true     );    // The token count for the beneficiary must be greater than or equal to the minimum expected.   if (beneficiaryTokenCount &lt; _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();    // If a delegate was returned by the data source, issue a callback to it.   if (_delegate != IJBPayDelegate(address(0))) {     JBDidPayData memory _data = JBDidPayData(       _payer,       _projectId,       _fundingCycle.configuration,       _bundledAmount,       beneficiaryTokenCount,       _beneficiary,       _preferClaimedTokens,       _memo,       _metadata     );      _delegate.didPay(_data);     emit DelegateDidPay(_delegate, _data, msg.sender);   } }  emit Pay(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _payer,   _beneficiary,   _amount,   beneficiaryTokenCount,   _memo,   _metadata,   msg.sender );  } /**     @notice     Receives funds belonging to the specified project. @param _projectId The ID of the project to which the funds received belong. @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead. @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added. @param _memo A memo to pass along to the emitted event. @param _metadata Extra data to pass along to the emitted event.  */   function _addToBalanceOf(     uint256 _projectId,     uint256 _amount,     bool _shouldRefundHeldFees,     string memory _memo,     bytes memory _metadata   ) internal {     // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.     uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0; // Record the added funds with any refunded fees. store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);  emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);  } /**     @notice     Refund fees based on the specified amount. @param _projectId The project for which fees are being refunded. @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.  @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal  */   function _refundHeldFees(uint256 _projectId, uint256 _amount)     internal     returns (uint256 refundedFees)   {     // Get a reference to the project's held fees.     JBFee[] memory _heldFees = _heldFeesOf[_projectId]; // Delete the current held fees. delete _heldFeesOf[_projectId];  // Get a reference to the leftover amount once all fees have been settled. uint256 leftoverAmount = _amount;  // Push length in stack uint256 _heldFeesLength = _heldFees.length;  // Process each fee. for (uint256 _i = 0; _i &lt; _heldFeesLength; ) {   if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);   else if (leftoverAmount &gt;= _heldFees[_i].amount) {     unchecked {       leftoverAmount = leftoverAmount - _heldFees[_i].amount;       refundedFees += _feeAmount(         _heldFees[_i].amount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount       );     }   } else {     _heldFeesOf[_projectId].push(       JBFee(         _heldFees[_i].amount - leftoverAmount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount,         _heldFees[_i].beneficiary       )     );     unchecked {       refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);     }     leftoverAmount = 0;   }    unchecked {     ++_i;   } }  emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);  } /**      @notice      Returns the fee amount based on the provided amount for the specified project. @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal. @param _fee The percentage of the fee, out of MAX_FEE.  @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.  @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.  */   function _feeAmount(     uint256 _amount,     uint256 _fee,     uint256 _feeDiscount   ) internal pure returns (uint256) {     // Calculate the discounted fee.     uint256 _discountedFee = _fee -       PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT); // The amount of tokens from the `_amount` to pay as a fee. return   _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);  } /**      @notice     Get the fee discount from the fee gauge for the specified project. @param _projectId The ID of the project to get a fee discount for.  @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.  */   function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {     // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.     if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))       return JBConstants.MAX_FEE_DISCOUNT; // Get the fee discount. if (feeGauge == IJBFeeGauge(address(0)))   feeDiscount = 0;   // If the guage reverts, set the discount to 0. else   try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {     feeDiscount = discount;   } catch {     feeDiscount = 0;   }  // If the fee discount is greater than the max, nullify the discount. if (feeDiscount &gt; JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;  } } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 17:18:00 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/security/ReentrancyGuard.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './../interfaces/IJBController.sol'; import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol'; import './../libraries/JBConstants.sol'; import './../libraries/JBCurrencies.sol'; import './../libraries/JBFixedPointNumber.sol'; import './../libraries/JBFundingCycleMetadataResolver.sol'; import './../libraries/JBOperations.sol'; import './../libraries/JBSplitsGroups.sol'; import './../libraries/JBTokens.sol'; import './../structs/JBTokenAmount.sol'; import './JBOperatable.sol'; import './JBSingleTokenPaymentTerminal.sol'; /**   @notice   Generic terminal managing all inflows and outflows of funds into the protocol ecosystem. @dev   A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time. @dev   Adheres to -   IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules. @dev   Inherits from -   JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.   JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.   Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.   ReentrancyGuard: Contract module that helps prevent reentrant calls to a function. */ abstract contract JBPayoutRedemptionPaymentTerminal is   IJBPayoutRedemptionPaymentTerminal,   JBSingleTokenPaymentTerminal,   JBOperatable,   Ownable,   ReentrancyGuard {   // A library that parses the packed funding cycle metadata into a friendlier format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error FEE_TOO_HIGH();   error INADEQUATE_DISTRIBUTION_AMOUNT();   error INADEQUATE_RECLAIM_AMOUNT();   error INADEQUATE_TOKEN_COUNT();   error NO_MSG_VALUE_ALLOWED();   error PAY_TO_ZERO_ADDRESS();   error PROJECT_TERMINAL_MISMATCH();   error REDEEM_TO_ZERO_ADDRESS();   error TERMINAL_IN_SPLIT_ZERO_ADDRESS();   error TERMINAL_TOKENS_INCOMPATIBLE(); //***********//   // ---------------------------- modifiers ---------------------------- //   //*************// /*      @notice      A modifier that verifies this terminal is a terminal of provided project ID.   /   modifier isTerminalOf(uint256 projectId) {     if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();     ;   } //***********//   // --------------------- internal stored constants ------------------- //   //*************// /**     @notice     Maximum fee that can be set for a funding cycle configuration. @dev Out of MAX_FEE (50_000_000 / 1_000_000_000).  */   uint256 internal constant _FEE_CAP = 50_000_000; /*     @notice     The protocol project ID is 1, as it should be the first project launched during the deployment process.   /   uint256 internal constant _PROTOCOL_PROJECT_ID = 1; //***********//   // --------------------- internal stored properties ------------------ //   //*************// /**     @notice     Fees that are being held to be processed later. _projectId The ID of the project for which fees are being held.  */   mapping(uint256 =&gt; JBFee[]) internal _heldFeesOf; //***********//   // ---------------- public immutable stored properties --------------- //   //*************// /*     @notice     Mints ERC-721's that represent project ownership and transfers.   /   IJBProjects public immutable override projects; /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; /*     @notice     The contract that stores splits for each project.   /   IJBSplitsStore public immutable override splitsStore; /*     @notice     The contract that exposes price feeds.   /   IJBPrices public immutable override prices; /*     @notice     The contract that stores and manages the terminal's data.   /   IJBSingleTokenPaymentTerminalStore public immutable override store; /**     @notice     The currency to base token issuance on. @dev If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.  */   uint256 public immutable override baseWeightCurrency; /*     @notice     The group that payout splits coming from this terminal are identified by.   /   uint256 public immutable override payoutSplitsGroup; //***********//   // --------------------- public stored properties -------------------- //   //*************// /**     @notice     The platform fee percent. @dev Out of MAX_FEE (25_000_000 / 1_000_000_000)  */   uint256 public override fee = 25_000_000; // 2.5% /*     @notice     The data source that returns a discount to apply to a project's fee.   /   IJBFeeGauge public override feeGauge; /**     @notice     Addresses that can be paid towards from this terminal without incurring a fee. _address The address that can be paid toward.  */   mapping(address =&gt; bool) public override isFeelessAddress; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     Gets the current overflowed amount in this terminal for a specified project, in terms of ETH. @dev The current overflow is represented as a fixed point number with 18 decimals.  @param _projectId The ID of the project to get overflow for.  @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.  */   function currentEthOverflowOf(uint256 _projectId)     external     view     virtual     override     returns (uint256)   {     // Get this terminal's current overflow.     uint256 _overflow = store.currentOverflowOf(this, _projectId); // Adjust the decimals of the fixed point number if needed to have 18 decimals. uint256 _adjustedOverflow = (decimals == 18)   ? _overflow   : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);  // Return the amount converted to ETH. return   (currency == JBCurrencies.ETH)     ? _adjustedOverflow     : PRBMath.mulDiv(       _adjustedOverflow,       10**decimals,       prices.priceFor(currency, JBCurrencies.ETH, decimals)     );  } /**     @notice     The fees that are currently being held to be processed later for each project. @param _projectId The ID of the project for which fees are being held.  @return An array of fees that are being held.  */   function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {     return _heldFeesOf[_projectId];   } //***********//   // -------------------------- public views --------------------------- //   //*************// /**     @notice     Indicates if this contract adheres to the specified interface. @dev  See {IERC165-supportsInterface}.  @param _interfaceId The ID of the interface to check for adherance to.  */   function supportsInterface(bytes4 _interfaceId)     public     view     virtual     override(JBSingleTokenPaymentTerminal, IERC165)     returns (bool)   {     return       _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||       _interfaceId == type(IJBPayoutTerminal).interfaceId ||       _interfaceId == type(IJBAllowanceTerminal).interfaceId ||       _interfaceId == type(IJBRedemptionTerminal).interfaceId ||       _interfaceId == type(IJBOperatable).interfaceId ||       super.supportsInterface(_interfaceId);   } //***********//   // -------------------------- constructor ---------------------------- //   //*************// /*     @param _token The token that this terminal manages.     @param _decimals The number of decimals the token fixed point amounts are expected to have.     @param _currency The currency that this terminal's token adheres to for price feeds.     @param _baseWeightCurrency The currency to base token issuance on.     @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.     @param _operatorStore A contract storing operator assignments.     @param _projects A contract which mints ERC-721's that represent project ownership and transfers.     @param _directory A contract storing directories of terminals and controllers for each project.     @param _splitsStore A contract that stores splits for each project.     @param _prices A contract that exposes price feeds.     @param _store A contract that stores the terminal's data.     @param _owner The address that will own this contract.   /   constructor(     // payable constructor save the gas used to check msg.value==0     address _token,     uint256 _decimals,     uint256 _currency,     uint256 _baseWeightCurrency,     uint256 _payoutSplitsGroup,     IJBOperatorStore _operatorStore,     IJBProjects _projects,     IJBDirectory _directory,     IJBSplitsStore _splitsStore,     IJBPrices _prices,     IJBSingleTokenPaymentTerminalStore _store,     address _owner   )     payable     JBSingleTokenPaymentTerminal(_token, _decimals, _currency)     JBOperatable(_operatorStore)   {     baseWeightCurrency = _baseWeightCurrency;     payoutSplitsGroup = _payoutSplitsGroup;     projects = _projects;     directory = _directory;     splitsStore = _splitsStore;     prices = _prices;     store = _store; transferOwnership(_owner);  } //***********//   // ---------------------- external transactions ---------------------- //   //*************// /**     @notice     Contribute tokens to a project. @param _projectId The ID of the project being paid. @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place. @param _token The token being paid. This terminal ignores this property since it only manages one token.  @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate. @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal. @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas. @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.  */   function pay(     uint256 _projectId,     uint256 _amount,     address _token,     address _beneficiary,     uint256 _minReturnedTokens,     bool _preferClaimedTokens,     string calldata _memo,     bytes calldata _metadata   ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {     _token; // Prevents unused var compiler and natspec complaints. // ETH shouldn't be sent if this terminal's token isn't ETH. if (token != JBTokens.ETH) {   if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();    // Transfer tokens to this terminal from the msg sender.   _transferFrom(msg.sender, payable(address(this)), _amount); } // If this terminal's token is ETH, override _amount with msg.value. else _amount = msg.value;  return   _pay(     _amount,     msg.sender,     _projectId,     _beneficiary,     _minReturnedTokens,     _preferClaimedTokens,     _memo,     _metadata   );  } /**     @notice     Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source. @dev Only a token holder or a designated operator can redeem its tokens.  @param _holder The account to redeem tokens for. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _token The token being reclaimed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal. @param _beneficiary The address to send the terminal tokens to. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.  */   function redeemTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     address _token,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo,     bytes memory _metadata   )     external     virtual     override     requirePermission(_holder, _projectId, JBOperations.REDEEM)     returns (uint256 reclaimAmount)   {     _token; // Prevents unused var compiler and natspec complaints. return   _redeemTokensOf(     _holder,     _projectId,     _tokenCount,     _minReturnedTokens,     _beneficiary,     _memo,     _metadata   );  } /**     @notice     Distributes payouts for a project with the distribution limit of its current funding cycle. @dev Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.  @dev Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.  @dev All funds distributed outside of this contract or any feeless terminals incure the protocol fee.  @param _projectId The ID of the project having its payouts distributed. @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency. @param _token The token being distributed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal. @param _memo A memo to pass along to the emitted event.  @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.  */   function distributePayoutsOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     address _token,     uint256 _minReturnedTokens,     string calldata _memo   ) external virtual override returns (uint256 netLeftoverDistributionAmount) {     _token; // Prevents unused var compiler and natspec complaints. return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);  } /**     @notice     Allows a project to send funds from its overflow up to the preconfigured allowance. @dev Only a project's owner or a designated operator can use its allowance.  @dev Incurs the protocol fee.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency. @param _token The token being distributed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals. @param _beneficiary The address to send the funds to. @param _memo A memo to pass along to the emitted event.  @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.  */   function useAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     address _token,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)     returns (uint256 netDistributedAmount)   {     _token; // Prevents unused var compiler and natspec complaints. return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);  } /**     @notice     Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type. @dev Only a project's owner or a designated operator can migrate it.  @param _projectId The ID of the project being migrated. @param _to The terminal contract that will gain the project's funds.  @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.  */   function migrate(uint256 _projectId, IJBPaymentTerminal _to)     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)     returns (uint256 balance)   {     // The terminal being migrated to must accept the same token as this terminal.     if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE(); // Record the migration in the store. balance = store.recordMigration(_projectId);  // Transfer the balance if needed. if (balance &gt; 0) {   // Trigger any inherited pre-transfer logic.   _beforeTransferTo(address(_to), balance);    // If this terminal's token is ETH, send it in msg.value.   uint256 _payableValue = token == JBTokens.ETH ? balance : 0;    // Withdraw the balance to transfer to the new terminal;   _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes('')); }  emit Migrate(_projectId, _to, balance, msg.sender);  } /**     @notice     Receives funds belonging to the specified project. @param _projectId The ID of the project to which the funds received belong. @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead. @param _token The token being paid. This terminal ignores this property since it only manages one currency.  @param _memo A memo to pass along to the emitted event. @param _metadata Extra data to pass along to the emitted event.  */   function addToBalanceOf(     uint256 _projectId,     uint256 _amount,     address _token,     string calldata _memo,     bytes calldata _metadata   ) external payable virtual override isTerminalOf(_projectId) {     _token; // Prevents unused var compiler and natspec complaints. // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender. if (token != JBTokens.ETH) {   // Amount must be greater than 0.   if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();    // Transfer tokens to this terminal from the msg sender.   _transferFrom(msg.sender, payable(address(this)), _amount); } // If the terminal's token is ETH, override `_amount` with msg.value. else _amount = msg.value;  // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal. _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);  } /**     @notice     Process any fees that are being held for the project. @dev Only a project owner, an operator, or the contract's owner can process held fees.  @param _projectId The ID of the project whos held fees should be processed.  */   function processFees(uint256 _projectId)     external     virtual     override     requirePermissionAllowingOverride(       projects.ownerOf(_projectId),       _projectId,       JBOperations.PROCESS_FEES,       msg.sender == owner()     )   {     // Get a reference to the project's held fees.     JBFee[] memory _heldFees = _heldFeesOf[_projectId]; // Delete the held fees. delete _heldFeesOf[_projectId];  // Push array length in stack uint256 _heldFeeLength = _heldFees.length;  // Process each fee. for (uint256 _i = 0; _i &lt; _heldFeeLength; ) {   // Get the fee amount.   uint256 _amount = _feeAmount(     _heldFees[_i].amount,     _heldFees[_i].fee,     _heldFees[_i].feeDiscount   );    // Process the fee.   _processFee(_amount, _heldFees[_i].beneficiary);    emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);    unchecked {     ++_i;   } }  } /**     @notice     Allows the fee to be updated. @dev Only the owner of this contract can change the fee.  @param _fee The new fee, out of MAX_FEE.  */   function setFee(uint256 _fee) external virtual override onlyOwner {     // The provided fee must be within the max.     if (_fee &gt; _FEE_CAP) revert FEE_TOO_HIGH(); // Store the new fee. fee = _fee;  emit SetFee(_fee, msg.sender);  } /**     @notice     Allows the fee gauge to be updated. @dev Only the owner of this contract can change the fee gauge.  @dev If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.  @param _feeGauge The new fee gauge.  */   function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {     // Store the new fee gauge.     feeGauge = _feeGauge; emit SetFeeGauge(_feeGauge, msg.sender);  } /**     @notice     Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee. @dev Only the owner of this contract can set addresses as feeless.  @param _address The address that can be paid towards while still bypassing fees. @param _flag A flag indicating whether the terminal should be feeless or not.  */   function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {     // Set the flag value.     isFeelessAddress[_address] = _flag; emit SetFeelessAddress(_address, _flag, msg.sender);  } //***********//   // ---------------------- internal transactions ---------------------- //   //*************// /**      @notice     Transfers tokens. @param _from The address from which the transfer should originate. @param _to The address to which the transfer should go. @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.  */   function _transferFrom(     address _from,     address payable _to,     uint256 _amount   ) internal virtual; /**      @notice     Logic to be triggered before transferring tokens from this terminal. @param _to The address to which the transfer is going. @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.  */   function _beforeTransferTo(address _to, uint256 _amount) internal virtual; /**     @notice     Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source. @dev Only a token holder or a designated operator can redeem its tokens.  @param _holder The account to redeem tokens for. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal. @param _beneficiary The address to send the terminal tokens to. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.  */   function _redeemTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo,     bytes memory _metadata   ) internal returns (uint256 reclaimAmount) {     // Can't send reclaimed funds to the zero address.     if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS(); // Define variables that will be needed outside the scoped section below. // Keep a reference to the funding cycle during which the redemption is being made. JBFundingCycle memory _fundingCycle;  // Scoped section prevents stack too deep. `_delegate` only used within scope. {   IJBRedemptionDelegate _delegate;    // Record the redemption.   (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(     _holder,     _projectId,     _tokenCount,     _memo,     _metadata   );    // The amount being reclaimed must be at least as much as was expected.   if (reclaimAmount &lt; _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();    // Burn the project tokens.   if (_tokenCount &gt; 0)     IJBController(directory.controllerOf(_projectId)).burnTokensOf(       _holder,       _projectId,       _tokenCount,       '',       false     );    // If a delegate was returned by the data source, issue a callback to it.   if (_delegate != IJBRedemptionDelegate(address(0))) {     JBDidRedeemData memory _data = JBDidRedeemData(       _holder,       _projectId,       _fundingCycle.configuration,       _tokenCount,       JBTokenAmount(token, reclaimAmount, decimals, currency),       _beneficiary,       _memo,       _metadata     );     _delegate.didRedeem(_data);     emit DelegateDidRedeem(_delegate, _data, msg.sender);   } }  // Send the reclaimed funds to the beneficiary. if (reclaimAmount &gt; 0) _transferFrom(address(this), _beneficiary, reclaimAmount);  emit RedeemTokens(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _holder,   _beneficiary,   _tokenCount,   reclaimAmount,   _memo,   _metadata,   msg.sender );  } /**     @notice     Distributes payouts for a project with the distribution limit of its current funding cycle. @dev Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.  @dev Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.  @dev All funds distributed outside of this contract or any feeless terminals incure the protocol fee.  @param _projectId The ID of the project having its payouts distributed. @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency. @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal. @param _memo A memo to pass along to the emitted event.  @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.  */   function _distributePayoutsOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     uint256 _minReturnedTokens,     string calldata _memo   ) internal returns (uint256 netLeftoverDistributionAmount) {     // Record the distribution.     (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(       _projectId,       _amount,       _currency     ); // The amount being distributed must be at least as much as was expected. if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();  // Get a reference to the project owner, which will receive tokens from paying the platform fee // and receive any extra distributable funds not allocated to payout splits. address payable _projectOwner = payable(projects.ownerOf(_projectId));  // Define variables that will be needed outside the scoped section below. // Keep a reference to the fee amount that was paid. uint256 _fee;  // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope. {   // Get the amount of discount that should be applied to any fees taken.   // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.   uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]     ? JBConstants.MAX_FEE_DISCOUNT     : _currentFeeDiscount(_projectId);    // The amount distributed that is eligible for incurring fees.   uint256 _feeEligibleDistributionAmount;    // The amount leftover after distributing to the splits.   uint256 _leftoverDistributionAmount;    // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.   // Also get a reference to the amount that was distributed to splits from which fees should be taken.   (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(     _projectId,     _fundingCycle.configuration,     payoutSplitsGroup,     _distributedAmount,     _feeDiscount   );    // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.   unchecked {     _feeEligibleDistributionAmount += _leftoverDistributionAmount;   }    // Take the fee.   _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0     ? 0     : _takeFeeFrom(       _projectId,       _fundingCycle,       _feeEligibleDistributionAmount,       _projectOwner,       _feeDiscount     );    // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.    unchecked {     netLeftoverDistributionAmount = _leftoverDistributionAmount == 0       ? 0       : _leftoverDistributionAmount -         _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);   }    // Transfer any remaining balance to the project owner.   if (netLeftoverDistributionAmount &gt; 0)     _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount); }  emit DistributePayouts(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _projectOwner,   _amount,   _distributedAmount,   _fee,   netLeftoverDistributionAmount,   _memo,   msg.sender );  } /**     @notice     Allows a project to send funds from its overflow up to the preconfigured allowance. @dev Only a project's owner or a designated operator can use its allowance.  @dev Incurs the protocol fee.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency. @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals. @param _beneficiary The address to send the funds to. @param _memo A memo to pass along to the emitted event.  @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.  */   function _useAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo   ) internal returns (uint256 netDistributedAmount) {     // Record the use of the allowance.     (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(       _projectId,       _amount,       _currency     ); // The amount being withdrawn must be at least as much as was expected. if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();  // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope. {   // Keep a reference to the fee amount that was paid.   uint256 _fee;    // Get a reference to the project owner, which will receive tokens from paying the platform fee.   address _projectOwner = projects.ownerOf(_projectId);    // Get the amount of discount that should be applied to any fees taken.   // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.   uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]     ? JBConstants.MAX_FEE_DISCOUNT     : _currentFeeDiscount(_projectId);    // Take a fee from the `_distributedAmount`, if needed.   _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT     ? 0     : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);    unchecked {     // The net amount is the withdrawn amount without the fee.     netDistributedAmount = _distributedAmount - _fee;   }    // Transfer any remaining balance to the beneficiary.   if (netDistributedAmount &gt; 0)     _transferFrom(address(this), _beneficiary, netDistributedAmount); }  emit UseAllowance(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _beneficiary,   _amount,   _distributedAmount,   netDistributedAmount,   _memo,   msg.sender );  } /**     @notice     Pays out splits for a project's funding cycle configuration. @param _projectId The ID of the project for which payout splits are being distributed. @param _domain The domain of the splits to distribute the payout between. @param _group The group of the splits to distribute the payout between. @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal. @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.  @return leftoverAmount If the leftover amount if the splits don't add up to 100%. @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.  */   function _distributeToPayoutSplitsOf(     uint256 _projectId,     uint256 _domain,     uint256 _group,     uint256 _amount,     uint256 _feeDiscount   ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {     // Set the leftover amount to the initial amount.     leftoverAmount = _amount; // Get a reference to the project's payout splits. JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);  // Transfer between all splits. for (uint256 _i = 0; _i &lt; _splits.length; ) {   // Get a reference to the split being iterated on.   JBSplit memory _split = _splits[_i];    // The amount to send towards the split.   uint256 _payoutAmount = PRBMath.mulDiv(     _amount,     _split.percent,     JBConstants.SPLITS_TOTAL_PERCENT   );    // The payout amount substracting any applicable incurred fees.   uint256 _netPayoutAmount;    if (_payoutAmount &gt; 0) {     // Transfer tokens to the split.     // If there's an allocator set, transfer to its `allocate` function.     if (_split.allocator != IJBSplitAllocator(address(0))) {       // If the split allocator is set as feeless, this distribution is not eligible for a fee.       if (isFeelessAddress[address(_split.allocator)])         _netPayoutAmount = _payoutAmount;         // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.       else {         unchecked {           _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT             ? _payoutAmount             : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);         }          // This distribution is eligible for a fee since the funds are leaving the ecosystem.         feeEligibleDistributionAmount += _payoutAmount;       }        // Trigger any inherited pre-transfer logic.       _beforeTransferTo(address(_split.allocator), _netPayoutAmount);        // If this terminal's token is ETH, send it in msg.value.       uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;        // Create the data to send to the allocator.       JBSplitAllocationData memory _data = JBSplitAllocationData(         token,         _netPayoutAmount,         decimals,         _projectId,         _group,         _split       );        // Trigger the allocator's `allocate` function.       _split.allocator.allocate{value: _payableValue}(_data);        // Otherwise, if a project is specified, make a payment to it.     } else if (_split.projectId != 0) {       // Get a reference to the Juicebox terminal being used.       IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);        // The project must have a terminal to send funds to.       if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();        // Save gas if this contract is being used as the terminal.       if (_terminal == this) {         // This distribution does not incur a fee.         _netPayoutAmount = _payoutAmount;          // Send the projectId in the metadata.         bytes memory _projectMetadata = new bytes(32);         _projectMetadata = bytes(abi.encodePacked(_projectId));          // Add to balance if prefered.         if (_split.preferAddToBalance)           _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);         else           _pay(             _netPayoutAmount,             address(this),             _split.projectId,             (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,             0,             _split.preferClaimed,             '',             _projectMetadata           );       } else {         // If the terminal is set as feeless, this distribution is not eligible for a fee.         if (isFeelessAddress[address(_terminal)])           _netPayoutAmount = _payoutAmount;           // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.         else {           unchecked {             _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT               ? _payoutAmount               : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);           }            feeEligibleDistributionAmount += _payoutAmount;         }          // Trigger any inherited pre-transfer logic.         _beforeTransferTo(address(_terminal), _netPayoutAmount);          // If this terminal's token is ETH, send it in msg.value.         uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;          // Send the projectId in the metadata.         bytes memory _projectMetadata = new bytes(32);         _projectMetadata = bytes(abi.encodePacked(_projectId));          // Add to balance if prefered.         if (_split.preferAddToBalance)           _terminal.addToBalanceOf{value: _payableValue}(             _split.projectId,             _netPayoutAmount,             token,             '',             _projectMetadata           );         else           _terminal.pay{value: _payableValue}(             _split.projectId,             _netPayoutAmount,             token,             _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,             0,             _split.preferClaimed,             '',             _projectMetadata           );       }     } else {       unchecked {         _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT           ? _payoutAmount           : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);       }        // This distribution is eligible for a fee since the funds are leaving the ecosystem.       feeEligibleDistributionAmount += _payoutAmount;        // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.       _transferFrom(         address(this),         _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),         _netPayoutAmount       );     }      // Subtract from the amount to be sent to the beneficiary.     unchecked {       leftoverAmount = leftoverAmount - _payoutAmount;     }   }    emit DistributeToPayoutSplit(     _projectId,     _domain,     _group,     _split,     _netPayoutAmount,     msg.sender   );    unchecked {     ++_i;   } }  } /**     @notice     Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID. @param _projectId The ID of the project having fees taken from. @param _fundingCycle The funding cycle during which the fee is being taken. @param _amount The amount of the fee to take, as a floating point number with 18 decimals. @param _beneficiary The address to mint the platforms tokens for. @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.  @return feeAmount The amount of the fee taken.  */   function _takeFeeFrom(     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _amount,     address _beneficiary,     uint256 _feeDiscount   ) internal returns (uint256 feeAmount) {     feeAmount = _feeAmount(_amount, fee, _feeDiscount); if (_fundingCycle.shouldHoldFees()) {   // Store the held fee.   _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));    emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender); } else {   // Process the fee.   _processFee(feeAmount, _beneficiary); // Take the fee.    emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender); }  } /**     @notice     Process a fee of the specified amount. @param _amount The fee amount, as a floating point number with 18 decimals. @param _beneficiary The address to mint the platform's tokens for.  */   function _processFee(uint256 _amount, address _beneficiary) internal {     // Get the terminal for the protocol project.     IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token); // When processing the admin fee, save gas if the admin is using this contract as its terminal. if (_terminal == this)   _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call. else {   // Trigger any inherited pre-transfer logic.   _beforeTransferTo(address(_terminal), _amount);    // If this terminal's token is ETH, send it in msg.value.   uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;    // Send the payment.   _terminal.pay{value: _payableValue}(     _PROTOCOL_PROJECT_ID,     _amount,     token,     _beneficiary,     0,     false,     '',     bytes('')   ); // Use the external pay call of the correct terminal. }  } /**     @notice     Contribute tokens to a project. @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place. @param _payer The address making the payment. @param _projectId The ID of the project being paid. @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate. @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal. @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas. @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.  */   function _pay(     uint256 _amount,     address _payer,     uint256 _projectId,     address _beneficiary,     uint256 _minReturnedTokens,     bool _preferClaimedTokens,     string memory _memo,     bytes memory _metadata   ) internal returns (uint256 beneficiaryTokenCount) {     // Cant send tokens to the zero address.     if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS(); // Define variables that will be needed outside the scoped section below. // Keep a reference to the funding cycle during which the payment is being made. JBFundingCycle memory _fundingCycle;  // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope. {   IJBPayDelegate _delegate;   uint256 _tokenCount;    // Bundle the amount info into a JBTokenAmount struct.   JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);    // Record the payment.   (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(     _payer,     _bundledAmount,     _projectId,     baseWeightCurrency,     _beneficiary,     _memo,     _metadata   );    // Mint the tokens if needed.   if (_tokenCount &gt; 0)     // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.     beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(       _projectId,       _tokenCount,       _beneficiary,       '',       _preferClaimedTokens,       true     );    // The token count for the beneficiary must be greater than or equal to the minimum expected.   if (beneficiaryTokenCount &lt; _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();    // If a delegate was returned by the data source, issue a callback to it.   if (_delegate != IJBPayDelegate(address(0))) {     JBDidPayData memory _data = JBDidPayData(       _payer,       _projectId,       _fundingCycle.configuration,       _bundledAmount,       beneficiaryTokenCount,       _beneficiary,       _preferClaimedTokens,       _memo,       _metadata     );      _delegate.didPay(_data);     emit DelegateDidPay(_delegate, _data, msg.sender);   } }  emit Pay(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _payer,   _beneficiary,   _amount,   beneficiaryTokenCount,   _memo,   _metadata,   msg.sender );  } /**     @notice     Receives funds belonging to the specified project. @param _projectId The ID of the project to which the funds received belong. @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead. @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added. @param _memo A memo to pass along to the emitted event. @param _metadata Extra data to pass along to the emitted event.  */   function _addToBalanceOf(     uint256 _projectId,     uint256 _amount,     bool _shouldRefundHeldFees,     string memory _memo,     bytes memory _metadata   ) internal {     // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.     uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0; // Record the added funds with any refunded fees. store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);  emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);  } /**     @notice     Refund fees based on the specified amount. @param _projectId The project for which fees are being refunded. @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.  @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal  */   function _refundHeldFees(uint256 _projectId, uint256 _amount)     internal     returns (uint256 refundedFees)   {     // Get a reference to the project's held fees.     JBFee[] memory _heldFees = _heldFeesOf[_projectId]; // Delete the current held fees. delete _heldFeesOf[_projectId];  // Get a reference to the leftover amount once all fees have been settled. uint256 leftoverAmount = _amount;  // Push length in stack uint256 _heldFeesLength = _heldFees.length;  // Process each fee. for (uint256 _i = 0; _i &lt; _heldFeesLength; ) {   if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);   else if (leftoverAmount &gt;= _heldFees[_i].amount) {     unchecked {       leftoverAmount = leftoverAmount - _heldFees[_i].amount;       refundedFees += _feeAmount(         _heldFees[_i].amount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount       );     }   } else {     _heldFeesOf[_projectId].push(       JBFee(         _heldFees[_i].amount - leftoverAmount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount,         _heldFees[_i].beneficiary       )     );     unchecked {       refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);     }     leftoverAmount = 0;   }    unchecked {     ++_i;   } }  emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);  } /**      @notice      Returns the fee amount based on the provided amount for the specified project. @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal. @param _fee The percentage of the fee, out of MAX_FEE.  @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.  @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.  */   function _feeAmount(     uint256 _amount,     uint256 _fee,     uint256 _feeDiscount   ) internal pure returns (uint256) {     // Calculate the discounted fee.     uint256 _discountedFee = _fee -       PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT); // The amount of tokens from the `_amount` to pay as a fee. return   _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);  } /**      @notice     Get the fee discount from the fee gauge for the specified project. @param _projectId The ID of the project to get a fee discount for.  @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.  */   function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {     // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.     if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))       return JBConstants.MAX_FEE_DISCOUNT; // Get the fee discount. if (feeGauge == IJBFeeGauge(address(0)))   feeDiscount = 0;   // If the guage reverts, set the discount to 0. else   try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {     feeDiscount = discount;   } catch {     feeDiscount = 0;   }  // If the fee discount is greater than the max, nullify the discount. if (feeDiscount &gt; JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 17:18:00 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './../interfaces/IJBController.sol';
import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol';
import './../libraries/JBConstants.sol';
import './../libraries/JBCurrencies.sol';
import './../libraries/JBFixedPointNumber.sol';
import './../libraries/JBFundingCycleMetadataResolver.sol';
import './../libraries/JBOperations.sol';
import './../libraries/JBSplitsGroups.sol';
import './../libraries/JBTokens.sol';
import './../structs/JBTokenAmount.sol';
import './JBOperatable.sol';
import './JBSingleTokenPaymentTerminal.sol';

/**
  @notice
  Generic terminal managing all inflows and outflows of funds into the protocol ecosystem.

  @dev
  A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time.

  @dev
  Adheres to -
  IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.
  JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
abstract contract JBPayoutRedemptionPaymentTerminal is
  IJBPayoutRedemptionPaymentTerminal,
  JBSingleTokenPaymentTerminal,
  JBOperatable,
  Ownable,
  ReentrancyGuard
{
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error FEE_TOO_HIGH();
  error INADEQUATE_DISTRIBUTION_AMOUNT();
  error INADEQUATE_RECLAIM_AMOUNT();
  error INADEQUATE_TOKEN_COUNT();
  error NO_MSG_VALUE_ALLOWED();
  error PAY_TO_ZERO_ADDRESS();
  error PROJECT_TERMINAL_MISMATCH();
  error REDEEM_TO_ZERO_ADDRESS();
  error TERMINAL_IN_SPLIT_ZERO_ADDRESS();
  error TERMINAL_TOKENS_INCOMPATIBLE();

  //*********************************************************************//
  // ---------------------------- modifiers ---------------------------- //
  //*********************************************************************//

  /** 
    @notice 
    A modifier that verifies this terminal is a terminal of provided project ID.
  */
  modifier isTerminalOf(uint256 _projectId) {
    if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();
    _;
  }

  //*********************************************************************//
  // --------------------- internal stored constants ------------------- //
  //*********************************************************************//

  /**
    @notice
    Maximum fee that can be set for a funding cycle configuration.

    @dev
    Out of MAX_FEE (50_000_000 / 1_000_000_000).
  */
  uint256 internal constant _FEE_CAP = 50_000_000;

  /**
    @notice
    The protocol project ID is 1, as it should be the first project launched during the deployment process.
  */
  uint256 internal constant _PROTOCOL_PROJECT_ID = 1;

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    Fees that are being held to be processed later.

    _projectId The ID of the project for which fees are being held.
  */
  mapping(uint256 => JBFee[]) internal _heldFeesOf;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership and transfers.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  /**
    @notice
    The contract that stores and manages the terminal's data.
  */
  IJBSingleTokenPaymentTerminalStore public immutable override store;

  /**
    @notice
    The currency to base token issuance on.

    @dev
    If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.
  */
  uint256 public immutable override baseWeightCurrency;

  /**
    @notice
    The group that payout splits coming from this terminal are identified by.
  */
  uint256 public immutable override payoutSplitsGroup;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The platform fee percent.

    @dev
    Out of MAX_FEE (25_000_000 / 1_000_000_000)
  */
  uint256 public override fee = 25_000_000; // 2.5%

  /**
    @notice
    The data source that returns a discount to apply to a project's fee.
  */
  IJBFeeGauge public override feeGauge;

  /**
    @notice
    Addresses that can be paid towards from this terminal without incurring a fee.

    _address The address that can be paid toward.
  */
  mapping(address => bool) public override isFeelessAddress;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.

    @dev
    The current overflow is represented as a fixed point number with 18 decimals.

    @param _projectId The ID of the project to get overflow for.

    @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.
  */
  function currentEthOverflowOf(uint256 _projectId)
    external
    view
    virtual
    override
    returns (uint256)
  {
    // Get this terminal's current overflow.
    uint256 _overflow = store.currentOverflowOf(this, _projectId);

    // Adjust the decimals of the fixed point number if needed to have 18 decimals.
    uint256 _adjustedOverflow = (decimals == 18)
      ? _overflow
      : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);

    // Return the amount converted to ETH.
    return
      (currency == JBCurrencies.ETH)
        ? _adjustedOverflow
        : PRBMath.mulDiv(
          _adjustedOverflow,
          10**decimals,
          prices.priceFor(currency, JBCurrencies.ETH, decimals)
        );
  }

  /**
    @notice
    The fees that are currently being held to be processed later for each project.

    @param _projectId The ID of the project for which fees are being held.

    @return An array of fees that are being held.
  */
  function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {
    return _heldFeesOf[_projectId];
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(JBSingleTokenPaymentTerminal, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||
      _interfaceId == type(IJBPayoutTerminal).interfaceId ||
      _interfaceId == type(IJBAllowanceTerminal).interfaceId ||
      _interfaceId == type(IJBRedemptionTerminal).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _token The token that this terminal manages.
    @param _decimals The number of decimals the token fixed point amounts are expected to have.
    @param _currency The currency that this terminal's token adheres to for price feeds.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _splitsStore A contract that stores splits for each project.
    @param _prices A contract that exposes price feeds.
    @param _store A contract that stores the terminal's data.
    @param _owner The address that will own this contract.
  */
  constructor(
    // payable constructor save the gas used to check msg.value==0
    address _token,
    uint256 _decimals,
    uint256 _currency,
    uint256 _baseWeightCurrency,
    uint256 _payoutSplitsGroup,
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBSplitsStore _splitsStore,
    IJBPrices _prices,
    IJBSingleTokenPaymentTerminalStore _store,
    address _owner
  )
    payable
    JBSingleTokenPaymentTerminal(_token, _decimals, _currency)
    JBOperatable(_operatorStore)
  {
    baseWeightCurrency = _baseWeightCurrency;
    payoutSplitsGroup = _payoutSplitsGroup;
    projects = _projects;
    directory = _directory;
    splitsStore = _splitsStore;
    prices = _prices;
    store = _store;

    transferOwnership(_owner);
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Contribute tokens to a project.

    @param _projectId The ID of the project being paid.
    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _token The token being paid. This terminal ignores this property since it only manages one token. 
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function pay(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {
    _token; // Prevents unused var compiler and natspec complaints.

    // ETH shouldn't be sent if this terminal's token isn't ETH.
    if (token != JBTokens.ETH) {
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If this terminal's token is ETH, override _amount with msg.value.
    else _amount = msg.value;

    return
      _pay(
        _amount,
        msg.sender,
        _projectId,
        _beneficiary,
        _minReturnedTokens,
        _preferClaimedTokens,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _token The token being reclaimed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  )
    external
    virtual
    override
    requirePermission(_holder, _projectId, JBOperations.REDEEM)
    returns (uint256 reclaimAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return
      _redeemTokensOf(
        _holder,
        _projectId,
        _tokenCount,
        _minReturnedTokens,
        _beneficiary,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) external virtual override returns (uint256 netLeftoverDistributionAmount) {
    _token; // Prevents unused var compiler and natspec complaints.

    return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)
    returns (uint256 netDistributedAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);
  }

  /**
    @notice
    Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project being migrated.
    @param _to The terminal contract that will gain the project's funds.

    @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.
  */
  function migrate(uint256 _projectId, IJBPaymentTerminal _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)
    returns (uint256 balance)
  {
    // The terminal being migrated to must accept the same token as this terminal.
    if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE();

    // Record the migration in the store.
    balance = store.recordMigration(_projectId);

    // Transfer the balance if needed.
    if (balance > 0) {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_to), balance);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? balance : 0;

      // Withdraw the balance to transfer to the new terminal;
      _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes(''));
    }

    emit Migrate(_projectId, _to, balance, msg.sender);
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _token The token being paid. This terminal ignores this property since it only manages one currency. 
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) {
    _token; // Prevents unused var compiler and natspec complaints.

    // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender.
    if (token != JBTokens.ETH) {
      // Amount must be greater than 0.
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If the terminal's token is ETH, override `_amount` with msg.value.
    else _amount = msg.value;

    // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal.
    _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);
  }

  /**
    @notice
    Process any fees that are being held for the project.

    @dev
    Only a project owner, an operator, or the contract's owner can process held fees.

    @param _projectId The ID of the project whos held fees should be processed.
  */
  function processFees(uint256 _projectId)
    external
    virtual
    override
    requirePermissionAllowingOverride(
      projects.ownerOf(_projectId),
      _projectId,
      JBOperations.PROCESS_FEES,
      msg.sender == owner()
    )
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the held fees.
    delete _heldFeesOf[_projectId];

    // Push array length in stack
    uint256 _heldFeeLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeeLength; ) {
      // Get the fee amount.
      uint256 _amount = _feeAmount(
        _heldFees[_i].amount,
        _heldFees[_i].fee,
        _heldFees[_i].feeDiscount
      );

      // Process the fee.
      _processFee(_amount, _heldFees[_i].beneficiary);

      emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Allows the fee to be updated.

    @dev
    Only the owner of this contract can change the fee.

    @param _fee The new fee, out of MAX_FEE.
  */
  function setFee(uint256 _fee) external virtual override onlyOwner {
    // The provided fee must be within the max.
    if (_fee > _FEE_CAP) revert FEE_TOO_HIGH();

    // Store the new fee.
    fee = _fee;

    emit SetFee(_fee, msg.sender);
  }

  /**
    @notice
    Allows the fee gauge to be updated.

    @dev
    Only the owner of this contract can change the fee gauge.

    @dev
    If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.

    @param _feeGauge The new fee gauge.
  */
  function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {
    // Store the new fee gauge.
    feeGauge = _feeGauge;

    emit SetFeeGauge(_feeGauge, msg.sender);
  }

  /**
    @notice
    Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.

    @dev
    Only the owner of this contract can set addresses as feeless.

    @param _address The address that can be paid towards while still bypassing fees.
    @param _flag A flag indicating whether the terminal should be feeless or not.
  */
  function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {
    // Set the flag value.
    isFeelessAddress[_address] = _flag;

    emit SetFeelessAddress(_address, _flag, msg.sender);
  }

  //*********************************************************************//
  // ---------------------- internal transactions ---------------------- //
  //*********************************************************************//

  /** 
    @notice
    Transfers tokens.

    @param _from The address from which the transfer should originate.
    @param _to The address to which the transfer should go.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _transferFrom(
    address _from,
    address payable _to,
    uint256 _amount
  ) internal virtual;

  /** 
    @notice
    Logic to be triggered before transferring tokens from this terminal.

    @param _to The address to which the transfer is going.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _beforeTransferTo(address _to, uint256 _amount) internal virtual;

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function _redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 reclaimAmount) {
    // Can't send reclaimed funds to the zero address.
    if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the redemption is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` only used within scope.
    {
      IJBRedemptionDelegate _delegate;

      // Record the redemption.
      (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(
        _holder,
        _projectId,
        _tokenCount,
        _memo,
        _metadata
      );

      // The amount being reclaimed must be at least as much as was expected.
      if (reclaimAmount < _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();

      // Burn the project tokens.
      if (_tokenCount > 0)
        IJBController(directory.controllerOf(_projectId)).burnTokensOf(
          _holder,
          _projectId,
          _tokenCount,
          '',
          false
        );

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBRedemptionDelegate(address(0))) {
        JBDidRedeemData memory _data = JBDidRedeemData(
          _holder,
          _projectId,
          _fundingCycle.configuration,
          _tokenCount,
          JBTokenAmount(token, reclaimAmount, decimals, currency),
          _beneficiary,
          _memo,
          _metadata
        );
        _delegate.didRedeem(_data);
        emit DelegateDidRedeem(_delegate, _data, msg.sender);
      }
    }

    // Send the reclaimed funds to the beneficiary.
    if (reclaimAmount > 0) _transferFrom(address(this), _beneficiary, reclaimAmount);

    emit RedeemTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _holder,
      _beneficiary,
      _tokenCount,
      reclaimAmount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) internal returns (uint256 netLeftoverDistributionAmount) {
    // Record the distribution.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(
      _projectId,
      _amount,
      _currency
    );

    // The amount being distributed must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Get a reference to the project owner, which will receive tokens from paying the platform fee
    // and receive any extra distributable funds not allocated to payout splits.
    address payable _projectOwner = payable(projects.ownerOf(_projectId));

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the fee amount that was paid.
    uint256 _fee;

    // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope.
    {
      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // The amount distributed that is eligible for incurring fees.
      uint256 _feeEligibleDistributionAmount;

      // The amount leftover after distributing to the splits.
      uint256 _leftoverDistributionAmount;

      // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.
      // Also get a reference to the amount that was distributed to splits from which fees should be taken.
      (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        payoutSplitsGroup,
        _distributedAmount,
        _feeDiscount
      );

      // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.
      unchecked {
        _feeEligibleDistributionAmount += _leftoverDistributionAmount;
      }

      // Take the fee.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0
        ? 0
        : _takeFeeFrom(
          _projectId,
          _fundingCycle,
          _feeEligibleDistributionAmount,
          _projectOwner,
          _feeDiscount
        );

      // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.

      unchecked {
        netLeftoverDistributionAmount = _leftoverDistributionAmount == 0
          ? 0
          : _leftoverDistributionAmount -
            _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);
      }

      // Transfer any remaining balance to the project owner.
      if (netLeftoverDistributionAmount > 0)
        _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount);
    }

    emit DistributePayouts(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _projectOwner,
      _amount,
      _distributedAmount,
      _fee,
      netLeftoverDistributionAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function _useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  ) internal returns (uint256 netDistributedAmount) {
    // Record the use of the allowance.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(
      _projectId,
      _amount,
      _currency
    );

    // The amount being withdrawn must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope.
    {
      // Keep a reference to the fee amount that was paid.
      uint256 _fee;

      // Get a reference to the project owner, which will receive tokens from paying the platform fee.
      address _projectOwner = projects.ownerOf(_projectId);

      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // Take a fee from the `_distributedAmount`, if needed.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
        ? 0
        : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);

      unchecked {
        // The net amount is the withdrawn amount without the fee.
        netDistributedAmount = _distributedAmount - _fee;
      }

      // Transfer any remaining balance to the beneficiary.
      if (netDistributedAmount > 0)
        _transferFrom(address(this), _beneficiary, netDistributedAmount);
    }

    emit UseAllowance(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _beneficiary,
      _amount,
      _distributedAmount,
      netDistributedAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Pays out splits for a project's funding cycle configuration.

    @param _projectId The ID of the project for which payout splits are being distributed.
    @param _domain The domain of the splits to distribute the payout between.
    @param _group The group of the splits to distribute the payout between.
    @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return leftoverAmount If the leftover amount if the splits don't add up to 100%.
    @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.
  */
  function _distributeToPayoutSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount,
    uint256 _feeDiscount
  ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's payout splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    // Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; ) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _payoutAmount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // The payout amount substracting any applicable incurred fees.
      uint256 _netPayoutAmount;

      if (_payoutAmount > 0) {
        // Transfer tokens to the split.
        // If there's an allocator set, transfer to its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0))) {
          // If the split allocator is set as feeless, this distribution is not eligible for a fee.
          if (isFeelessAddress[address(_split.allocator)])
            _netPayoutAmount = _payoutAmount;
            // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.
          else {
            unchecked {
              _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                ? _payoutAmount
                : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
            }

            // This distribution is eligible for a fee since the funds are leaving the ecosystem.
            feeEligibleDistributionAmount += _payoutAmount;
          }

          // Trigger any inherited pre-transfer logic.
          _beforeTransferTo(address(_split.allocator), _netPayoutAmount);

          // If this terminal's token is ETH, send it in msg.value.
          uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

          // Create the data to send to the allocator.
          JBSplitAllocationData memory _data = JBSplitAllocationData(
            token,
            _netPayoutAmount,
            decimals,
            _projectId,
            _group,
            _split
          );

          // Trigger the allocator's `allocate` function.
          _split.allocator.allocate{value: _payableValue}(_data);

          // Otherwise, if a project is specified, make a payment to it.
        } else if (_split.projectId != 0) {
          // Get a reference to the Juicebox terminal being used.
          IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);

          // The project must have a terminal to send funds to.
          if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();

          // Save gas if this contract is being used as the terminal.
          if (_terminal == this) {
            // This distribution does not incur a fee.
            _netPayoutAmount = _payoutAmount;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);
            else
              _pay(
                _netPayoutAmount,
                address(this),
                _split.projectId,
                (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          } else {
            // If the terminal is set as feeless, this distribution is not eligible for a fee.
            if (isFeelessAddress[address(_terminal)])
              _netPayoutAmount = _payoutAmount;
              // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.
            else {
              unchecked {
                _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                  ? _payoutAmount
                  : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
              }

              feeEligibleDistributionAmount += _payoutAmount;
            }

            // Trigger any inherited pre-transfer logic.
            _beforeTransferTo(address(_terminal), _netPayoutAmount);

            // If this terminal's token is ETH, send it in msg.value.
            uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _terminal.addToBalanceOf{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                '',
                _projectMetadata
              );
            else
              _terminal.pay{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          }
        } else {
          unchecked {
            _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
              ? _payoutAmount
              : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
          }

          // This distribution is eligible for a fee since the funds are leaving the ecosystem.
          feeEligibleDistributionAmount += _payoutAmount;

          // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.
          _transferFrom(
            address(this),
            _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),
            _netPayoutAmount
          );
        }

        // Subtract from the amount to be sent to the beneficiary.
        unchecked {
          leftoverAmount = leftoverAmount - _payoutAmount;
        }
      }

      emit DistributeToPayoutSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _netPayoutAmount,
        msg.sender
      );

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID.

    @param _projectId The ID of the project having fees taken from.
    @param _fundingCycle The funding cycle during which the fee is being taken.
    @param _amount The amount of the fee to take, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platforms tokens for.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return feeAmount The amount of the fee taken.
  */
  function _takeFeeFrom(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _amount,
    address _beneficiary,
    uint256 _feeDiscount
  ) internal returns (uint256 feeAmount) {
    feeAmount = _feeAmount(_amount, fee, _feeDiscount);

    if (_fundingCycle.shouldHoldFees()) {
      // Store the held fee.
      _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));

      emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender);
    } else {
      // Process the fee.
      _processFee(feeAmount, _beneficiary); // Take the fee.

      emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender);
    }
  }

  /**
    @notice
    Process a fee of the specified amount.

    @param _amount The fee amount, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platform's tokens for.
  */
  function _processFee(uint256 _amount, address _beneficiary) internal {
    // Get the terminal for the protocol project.
    IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token);

    // When processing the admin fee, save gas if the admin is using this contract as its terminal.
    if (_terminal == this)
      _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call.
    else {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_terminal), _amount);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;

      // Send the payment.
      _terminal.pay{value: _payableValue}(
        _PROTOCOL_PROJECT_ID,
        _amount,
        token,
        _beneficiary,
        0,
        false,
        '',
        bytes('')
      ); // Use the external pay call of the correct terminal.
    }
  }

  /**
    @notice
    Contribute tokens to a project.

    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _payer The address making the payment.
    @param _projectId The ID of the project being paid.
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function _pay(
    uint256 _amount,
    address _payer,
    uint256 _projectId,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 beneficiaryTokenCount) {
    // Cant send tokens to the zero address.
    if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the payment is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope.
    {
      IJBPayDelegate _delegate;
      uint256 _tokenCount;

      // Bundle the amount info into a JBTokenAmount struct.
      JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);

      // Record the payment.
      (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(
        _payer,
        _bundledAmount,
        _projectId,
        baseWeightCurrency,
        _beneficiary,
        _memo,
        _metadata
      );

      // Mint the tokens if needed.
      if (_tokenCount > 0)
        // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.
        beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(
          _projectId,
          _tokenCount,
          _beneficiary,
          '',
          _preferClaimedTokens,
          true
        );

      // The token count for the beneficiary must be greater than or equal to the minimum expected.
      if (beneficiaryTokenCount < _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBPayDelegate(address(0))) {
        JBDidPayData memory _data = JBDidPayData(
          _payer,
          _projectId,
          _fundingCycle.configuration,
          _bundledAmount,
          beneficiaryTokenCount,
          _beneficiary,
          _preferClaimedTokens,
          _memo,
          _metadata
        );

        _delegate.didPay(_data);
        emit DelegateDidPay(_delegate, _data, msg.sender);
      }
    }

    emit Pay(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _payer,
      _beneficiary,
      _amount,
      beneficiaryTokenCount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function _addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    bool _shouldRefundHeldFees,
    string memory _memo,
    bytes memory _metadata
  ) internal {
    // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.
    uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0;

    // Record the added funds with any refunded fees.
    store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);

    emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);
  }

  /**
    @notice
    Refund fees based on the specified amount.

    @param _projectId The project for which fees are being refunded.
    @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.

    @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal
  */
  function _refundHeldFees(uint256 _projectId, uint256 _amount)
    internal
    returns (uint256 refundedFees)
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the current held fees.
    delete _heldFeesOf[_projectId];

    // Get a reference to the leftover amount once all fees have been settled.
    uint256 leftoverAmount = _amount;

    // Push length in stack
    uint256 _heldFeesLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeesLength; ) {
      if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);
      else if (leftoverAmount >= _heldFees[_i].amount) {
        unchecked {
          leftoverAmount = leftoverAmount - _heldFees[_i].amount;
          refundedFees += _feeAmount(
            _heldFees[_i].amount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount
          );
        }
      } else {
        _heldFeesOf[_projectId].push(
          JBFee(
            _heldFees[_i].amount - leftoverAmount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount,
            _heldFees[_i].beneficiary
          )
        );
        unchecked {
          refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);
        }
        leftoverAmount = 0;
      }

      unchecked {
        ++_i;
      }
    }

    emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);
  }

  /** 
    @notice 
    Returns the fee amount based on the provided amount for the specified project.

    @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal.
    @param _fee The percentage of the fee, out of MAX_FEE. 
    @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.

    @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _feeAmount(
    uint256 _amount,
    uint256 _fee,
    uint256 _feeDiscount
  ) internal pure returns (uint256) {
    // Calculate the discounted fee.
    uint256 _discountedFee = _fee -
      PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT);

    // The amount of tokens from the `_amount` to pay as a fee.
    return
      _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);
  }

  /** 
    @notice
    Get the fee discount from the fee gauge for the specified project.

    @param _projectId The ID of the project to get a fee discount for.
    
    @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.
  */
  function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {
    // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.
    if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))
      return JBConstants.MAX_FEE_DISCOUNT;

    // Get the fee discount.
    if (feeGauge == IJBFeeGauge(address(0)))
      feeDiscount = 0;
      // If the guage reverts, set the discount to 0.
    else
      try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {
        feeDiscount = discount;
      } catch {
        feeDiscount = 0;
      }

    // If the fee discount is greater than the max, nullify the discount.
    if (feeDiscount > JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;
  }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-01-09 17:18:09 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 17:18:09 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 12782
completion_tokens: 670
total_tokens: 13452
cost: $-1.000000


[2024-01-09 17:18:09 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './../interfaces/IJBController.sol';
import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol';
import './../libraries/JBConstants.sol';
import './../libraries/JBCurrencies.sol';
import './../libraries/JBFixedPointNumber.sol';
import './../libraries/JBFundingCycleMetadataResolver.sol';
import './../libraries/JBOperations.sol';
import './../libraries/JBSplitsGroups.sol';
import './../libraries/JBTokens.sol';
import './../structs/JBTokenAmount.sol';
import './JBOperatable.sol';
import './JBSingleTokenPaymentTerminal.sol';

/**
  @notice
  Generic terminal managing all inflows and outflows of funds into the protocol ecosystem.

  @dev
  A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time.

  @dev
  Adheres to -
  IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.
  JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
abstract contract JBPayoutRedemptionPaymentTerminal is
  IJBPayoutRedemptionPaymentTerminal,
  JBSingleTokenPaymentTerminal,
  JBOperatable,
  Ownable,
  ReentrancyGuard
{
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error FEE_TOO_HIGH();
  error INADEQUATE_DISTRIBUTION_AMOUNT();
  error INADEQUATE_RECLAIM_AMOUNT();
  error INADEQUATE_TOKEN_COUNT();
  error NO_MSG_VALUE_ALLOWED();
  error PAY_TO_ZERO_ADDRESS();
  error PROJECT_TERMINAL_MISMATCH();
  error REDEEM_TO_ZERO_ADDRESS();
  error TERMINAL_IN_SPLIT_ZERO_ADDRESS();
  error TERMINAL_TOKENS_INCOMPATIBLE();

  //*********************************************************************//
  // ---------------------------- modifiers ---------------------------- //
  //*********************************************************************//

  /** 
    @notice 
    A modifier that verifies this terminal is a terminal of provided project ID.
  */
  modifier isTerminalOf(uint256 _projectId) {
    if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();
    _;
  }

  //*********************************************************************//
  // --------------------- internal stored constants ------------------- //
  //*********************************************************************//

  /**
    @notice
    Maximum fee that can be set for a funding cycle configuration.

    @dev
    Out of MAX_FEE (50_000_000 / 1_000_000_000).
  */
  uint256 internal constant _FEE_CAP = 50_000_000;

  /**
    @notice
    The protocol project ID is 1, as it should be the first project launched during the deployment process.
  */
  uint256 internal constant _PROTOCOL_PROJECT_ID = 1;

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    Fees that are being held to be processed later.

    _projectId The ID of the project for which fees are being held.
  */
  mapping(uint256 => JBFee[]) internal _heldFeesOf;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership and transfers.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  /**
    @notice
    The contract that stores and manages the terminal's data.
  */
  IJBSingleTokenPaymentTerminalStore public immutable override store;

  /**
    @notice
    The currency to base token issuance on.

    @dev
    If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.
  */
  uint256 public immutable override baseWeightCurrency;

  /**
    @notice
    The group that payout splits coming from this terminal are identified by.
  */
  uint256 public immutable override payoutSplitsGroup;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The platform fee percent.

    @dev
    Out of MAX_FEE (25_000_000 / 1_000_000_000)
  */
  uint256 public override fee = 25_000_000; // 2.5%

  /**
    @notice
    The data source that returns a discount to apply to a project's fee.
  */
  IJBFeeGauge public override feeGauge;

  /**
    @notice
    Addresses that can be paid towards from this terminal without incurring a fee.

    _address The address that can be paid toward.
  */
  mapping(address => bool) public override isFeelessAddress;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.

    @dev
    The current overflow is represented as a fixed point number with 18 decimals.

    @param _projectId The ID of the project to get overflow for.

    @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.
  */
  function currentEthOverflowOf(uint256 _projectId)
    external
    view
    virtual
    override
    returns (uint256)
  {
    // Get this terminal's current overflow.
    uint256 _overflow = store.currentOverflowOf(this, _projectId);

    // Adjust the decimals of the fixed point number if needed to have 18 decimals.
    uint256 _adjustedOverflow = (decimals == 18)
      ? _overflow
      : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);

    // Return the amount converted to ETH.
    return
      (currency == JBCurrencies.ETH)
        ? _adjustedOverflow
        : PRBMath.mulDiv(
          _adjustedOverflow,
          10**decimals,
          prices.priceFor(currency, JBCurrencies.ETH, decimals)
        );
  }

  /**
    @notice
    The fees that are currently being held to be processed later for each project.

    @param _projectId The ID of the project for which fees are being held.

    @return An array of fees that are being held.
  */
  function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {
    return _heldFeesOf[_projectId];
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(JBSingleTokenPaymentTerminal, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||
      _interfaceId == type(IJBPayoutTerminal).interfaceId ||
      _interfaceId == type(IJBAllowanceTerminal).interfaceId ||
      _interfaceId == type(IJBRedemptionTerminal).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _token The token that this terminal manages.
    @param _decimals The number of decimals the token fixed point amounts are expected to have.
    @param _currency The currency that this terminal's token adheres to for price feeds.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _splitsStore A contract that stores splits for each project.
    @param _prices A contract that exposes price feeds.
    @param _store A contract that stores the terminal's data.
    @param _owner The address that will own this contract.
  */
  constructor(
    // payable constructor save the gas used to check msg.value==0
    address _token,
    uint256 _decimals,
    uint256 _currency,
    uint256 _baseWeightCurrency,
    uint256 _payoutSplitsGroup,
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBSplitsStore _splitsStore,
    IJBPrices _prices,
    IJBSingleTokenPaymentTerminalStore _store,
    address _owner
  )
    payable
    JBSingleTokenPaymentTerminal(_token, _decimals, _currency)
    JBOperatable(_operatorStore)
  {
    baseWeightCurrency = _baseWeightCurrency;
    payoutSplitsGroup = _payoutSplitsGroup;
    projects = _projects;
    directory = _directory;
    splitsStore = _splitsStore;
    prices = _prices;
    store = _store;

    transferOwnership(_owner);
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Contribute tokens to a project.

    @param _projectId The ID of the project being paid.
    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _token The token being paid. This terminal ignores this property since it only manages one token. 
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function pay(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {
    _token; // Prevents unused var compiler and natspec complaints.

    // ETH shouldn't be sent if this terminal's token isn't ETH.
    if (token != JBTokens.ETH) {
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If this terminal's token is ETH, override _amount with msg.value.
    else _amount = msg.value;

    return
      _pay(
        _amount,
        msg.sender,
        _projectId,
        _beneficiary,
        _minReturnedTokens,
        _preferClaimedTokens,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _token The token being reclaimed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  )
    external
    virtual
    override
    requirePermission(_holder, _projectId, JBOperations.REDEEM)
    returns (uint256 reclaimAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return
      _redeemTokensOf(
        _holder,
        _projectId,
        _tokenCount,
        _minReturnedTokens,
        _beneficiary,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) external virtual override returns (uint256 netLeftoverDistributionAmount) {
    _token; // Prevents unused var compiler and natspec complaints.

    return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)
    returns (uint256 netDistributedAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);
  }

  /**
    @notice
    Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project being migrated.
    @param _to The terminal contract that will gain the project's funds.

    @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.
  */
  function migrate(uint256 _projectId, IJBPaymentTerminal _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)
    returns (uint256 balance)
  {
    // The terminal being migrated to must accept the same token as this terminal.
    if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE();

    // Record the migration in the store.
    balance = store.recordMigration(_projectId);

    // Transfer the balance if needed.
    if (balance > 0) {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_to), balance);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? balance : 0;

      // Withdraw the balance to transfer to the new terminal;
      _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes(''));
    }

    emit Migrate(_projectId, _to, balance, msg.sender);
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _token The token being paid. This terminal ignores this property since it only manages one currency. 
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) {
    _token; // Prevents unused var compiler and natspec complaints.

    // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender.
    if (token != JBTokens.ETH) {
      // Amount must be greater than 0.
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If the terminal's token is ETH, override `_amount` with msg.value.
    else _amount = msg.value;

    // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal.
    _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);
  }

  /**
    @notice
    Process any fees that are being held for the project.

    @dev
    Only a project owner, an operator, or the contract's owner can process held fees.

    @param _projectId The ID of the project whos held fees should be processed.
  */
  function processFees(uint256 _projectId)
    external
    virtual
    override
    requirePermissionAllowingOverride(
      projects.ownerOf(_projectId),
      _projectId,
      JBOperations.PROCESS_FEES,
      msg.sender == owner()
    )
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the held fees.
    delete _heldFeesOf[_projectId];

    // Push array length in stack
    uint256 _heldFeeLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeeLength; ) {
      // Get the fee amount.
      uint256 _amount = _feeAmount(
        _heldFees[_i].amount,
        _heldFees[_i].fee,
        _heldFees[_i].feeDiscount
      );

      // Process the fee.
      _processFee(_amount, _heldFees[_i].beneficiary);

      emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Allows the fee to be updated.

    @dev
    Only the owner of this contract can change the fee.

    @param _fee The new fee, out of MAX_FEE.
  */
  function setFee(uint256 _fee) external virtual override onlyOwner {
    // The provided fee must be within the max.
    if (_fee > _FEE_CAP) revert FEE_TOO_HIGH();

    // Store the new fee.
    fee = _fee;

    emit SetFee(_fee, msg.sender);
  }

  /**
    @notice
    Allows the fee gauge to be updated.

    @dev
    Only the owner of this contract can change the fee gauge.

    @dev
    If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.

    @param _feeGauge The new fee gauge.
  */
  function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {
    // Store the new fee gauge.
    feeGauge = _feeGauge;

    emit SetFeeGauge(_feeGauge, msg.sender);
  }

  /**
    @notice
    Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.

    @dev
    Only the owner of this contract can set addresses as feeless.

    @param _address The address that can be paid towards while still bypassing fees.
    @param _flag A flag indicating whether the terminal should be feeless or not.
  */
  function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {
    // Set the flag value.
    isFeelessAddress[_address] = _flag;

    emit SetFeelessAddress(_address, _flag, msg.sender);
  }

  //*********************************************************************//
  // ---------------------- internal transactions ---------------------- //
  //*********************************************************************//

  /** 
    @notice
    Transfers tokens.

    @param _from The address from which the transfer should originate.
    @param _to The address to which the transfer should go.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _transferFrom(
    address _from,
    address payable _to,
    uint256 _amount
  ) internal virtual;

  /** 
    @notice
    Logic to be triggered before transferring tokens from this terminal.

    @param _to The address to which the transfer is going.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _beforeTransferTo(address _to, uint256 _amount) internal virtual;

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function _redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 reclaimAmount) {
    // Can't send reclaimed funds to the zero address.
    if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the redemption is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` only used within scope.
    {
      IJBRedemptionDelegate _delegate;

      // Record the redemption.
      (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(
        _holder,
        _projectId,
        _tokenCount,
        _memo,
        _metadata
      );

      // The amount being reclaimed must be at least as much as was expected.
      if (reclaimAmount < _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();

      // Burn the project tokens.
      if (_tokenCount > 0)
        IJBController(directory.controllerOf(_projectId)).burnTokensOf(
          _holder,
          _projectId,
          _tokenCount,
          '',
          false
        );

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBRedemptionDelegate(address(0))) {
        JBDidRedeemData memory _data = JBDidRedeemData(
          _holder,
          _projectId,
          _fundingCycle.configuration,
          _tokenCount,
          JBTokenAmount(token, reclaimAmount, decimals, currency),
          _beneficiary,
          _memo,
          _metadata
        );
        _delegate.didRedeem(_data);
        emit DelegateDidRedeem(_delegate, _data, msg.sender);
      }
    }

    // Send the reclaimed funds to the beneficiary.
    if (reclaimAmount > 0) _transferFrom(address(this), _beneficiary, reclaimAmount);

    emit RedeemTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _holder,
      _beneficiary,
      _tokenCount,
      reclaimAmount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) internal returns (uint256 netLeftoverDistributionAmount) {
    // Record the distribution.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(
      _projectId,
      _amount,
      _currency
    );

    // The amount being distributed must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Get a reference to the project owner, which will receive tokens from paying the platform fee
    // and receive any extra distributable funds not allocated to payout splits.
    address payable _projectOwner = payable(projects.ownerOf(_projectId));

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the fee amount that was paid.
    uint256 _fee;

    // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope.
    {
      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // The amount distributed that is eligible for incurring fees.
      uint256 _feeEligibleDistributionAmount;

      // The amount leftover after distributing to the splits.
      uint256 _leftoverDistributionAmount;

      // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.
      // Also get a reference to the amount that was distributed to splits from which fees should be taken.
      (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        payoutSplitsGroup,
        _distributedAmount,
        _feeDiscount
      );

      // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.
      unchecked {
        _feeEligibleDistributionAmount += _leftoverDistributionAmount;
      }

      // Take the fee.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0
        ? 0
        : _takeFeeFrom(
          _projectId,
          _fundingCycle,
          _feeEligibleDistributionAmount,
          _projectOwner,
          _feeDiscount
        );

      // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.

      unchecked {
        netLeftoverDistributionAmount = _leftoverDistributionAmount == 0
          ? 0
          : _leftoverDistributionAmount -
            _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);
      }

      // Transfer any remaining balance to the project owner.
      if (netLeftoverDistributionAmount > 0)
        _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount);
    }

    emit DistributePayouts(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _projectOwner,
      _amount,
      _distributedAmount,
      _fee,
      netLeftoverDistributionAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function _useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  ) internal returns (uint256 netDistributedAmount) {
    // Record the use of the allowance.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(
      _projectId,
      _amount,
      _currency
    );

    // The amount being withdrawn must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope.
    {
      // Keep a reference to the fee amount that was paid.
      uint256 _fee;

      // Get a reference to the project owner, which will receive tokens from paying the platform fee.
      address _projectOwner = projects.ownerOf(_projectId);

      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // Take a fee from the `_distributedAmount`, if needed.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
        ? 0
        : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);

      unchecked {
        // The net amount is the withdrawn amount without the fee.
        netDistributedAmount = _distributedAmount - _fee;
      }

      // Transfer any remaining balance to the beneficiary.
      if (netDistributedAmount > 0)
        _transferFrom(address(this), _beneficiary, netDistributedAmount);
    }

    emit UseAllowance(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _beneficiary,
      _amount,
      _distributedAmount,
      netDistributedAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Pays out splits for a project's funding cycle configuration.

    @param _projectId The ID of the project for which payout splits are being distributed.
    @param _domain The domain of the splits to distribute the payout between.
    @param _group The group of the splits to distribute the payout between.
    @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return leftoverAmount If the leftover amount if the splits don't add up to 100%.
    @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.
  */
  function _distributeToPayoutSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount,
    uint256 _feeDiscount
  ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's payout splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    // Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; ) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _payoutAmount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // The payout amount substracting any applicable incurred fees.
      uint256 _netPayoutAmount;

      if (_payoutAmount > 0) {
        // Transfer tokens to the split.
        // If there's an allocator set, transfer to its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0))) {
          // If the split allocator is set as feeless, this distribution is not eligible for a fee.
          if (isFeelessAddress[address(_split.allocator)])
            _netPayoutAmount = _payoutAmount;
            // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.
          else {
            unchecked {
              _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                ? _payoutAmount
                : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
            }

            // This distribution is eligible for a fee since the funds are leaving the ecosystem.
            feeEligibleDistributionAmount += _payoutAmount;
          }

          // Trigger any inherited pre-transfer logic.
          _beforeTransferTo(address(_split.allocator), _netPayoutAmount);

          // If this terminal's token is ETH, send it in msg.value.
          uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

          // Create the data to send to the allocator.
          JBSplitAllocationData memory _data = JBSplitAllocationData(
            token,
            _netPayoutAmount,
            decimals,
            _projectId,
            _group,
            _split
          );

          // Trigger the allocator's `allocate` function.
          _split.allocator.allocate{value: _payableValue}(_data);

          // Otherwise, if a project is specified, make a payment to it.
        } else if (_split.projectId != 0) {
          // Get a reference to the Juicebox terminal being used.
          IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);

          // The project must have a terminal to send funds to.
          if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();

          // Save gas if this contract is being used as the terminal.
          if (_terminal == this) {
            // This distribution does not incur a fee.
            _netPayoutAmount = _payoutAmount;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);
            else
              _pay(
                _netPayoutAmount,
                address(this),
                _split.projectId,
                (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          } else {
            // If the terminal is set as feeless, this distribution is not eligible for a fee.
            if (isFeelessAddress[address(_terminal)])
              _netPayoutAmount = _payoutAmount;
              // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.
            else {
              unchecked {
                _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                  ? _payoutAmount
                  : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
              }

              feeEligibleDistributionAmount += _payoutAmount;
            }

            // Trigger any inherited pre-transfer logic.
            _beforeTransferTo(address(_terminal), _netPayoutAmount);

            // If this terminal's token is ETH, send it in msg.value.
            uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _terminal.addToBalanceOf{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                '',
                _projectMetadata
              );
            else
              _terminal.pay{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          }
        } else {
          unchecked {
            _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
              ? _payoutAmount
              : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
          }

          // This distribution is eligible for a fee since the funds are leaving the ecosystem.
          feeEligibleDistributionAmount += _payoutAmount;

          // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.
          _transferFrom(
            address(this),
            _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),
            _netPayoutAmount
          );
        }

        // Subtract from the amount to be sent to the beneficiary.
        unchecked {
          leftoverAmount = leftoverAmount - _payoutAmount;
        }
      }

      emit DistributeToPayoutSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _netPayoutAmount,
        msg.sender
      );

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID.

    @param _projectId The ID of the project having fees taken from.
    @param _fundingCycle The funding cycle during which the fee is being taken.
    @param _amount The amount of the fee to take, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platforms tokens for.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return feeAmount The amount of the fee taken.
  */
  function _takeFeeFrom(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _amount,
    address _beneficiary,
    uint256 _feeDiscount
  ) internal returns (uint256 feeAmount) {
    feeAmount = _feeAmount(_amount, fee, _feeDiscount);

    if (_fundingCycle.shouldHoldFees()) {
      // Store the held fee.
      _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));

      emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender);
    } else {
      // Process the fee.
      _processFee(feeAmount, _beneficiary); // Take the fee.

      emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender);
    }
  }

  /**
    @notice
    Process a fee of the specified amount.

    @param _amount The fee amount, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platform's tokens for.
  */
  function _processFee(uint256 _amount, address _beneficiary) internal {
    // Get the terminal for the protocol project.
    IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token);

    // When processing the admin fee, save gas if the admin is using this contract as its terminal.
    if (_terminal == this)
      _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call.
    else {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_terminal), _amount);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;

      // Send the payment.
      _terminal.pay{value: _payableValue}(
        _PROTOCOL_PROJECT_ID,
        _amount,
        token,
        _beneficiary,
        0,
        false,
        '',
        bytes('')
      ); // Use the external pay call of the correct terminal.
    }
  }

  /**
    @notice
    Contribute tokens to a project.

    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _payer The address making the payment.
    @param _projectId The ID of the project being paid.
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function _pay(
    uint256 _amount,
    address _payer,
    uint256 _projectId,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 beneficiaryTokenCount) {
    // Cant send tokens to the zero address.
    if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the payment is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope.
    {
      IJBPayDelegate _delegate;
      uint256 _tokenCount;

      // Bundle the amount info into a JBTokenAmount struct.
      JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);

      // Record the payment.
      (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(
        _payer,
        _bundledAmount,
        _projectId,
        baseWeightCurrency,
        _beneficiary,
        _memo,
        _metadata
      );

      // Mint the tokens if needed.
      if (_tokenCount > 0)
        // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.
        beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(
          _projectId,
          _tokenCount,
          _beneficiary,
          '',
          _preferClaimedTokens,
          true
        );

      // The token count for the beneficiary must be greater than or equal to the minimum expected.
      if (beneficiaryTokenCount < _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBPayDelegate(address(0))) {
        JBDidPayData memory _data = JBDidPayData(
          _payer,
          _projectId,
          _fundingCycle.configuration,
          _bundledAmount,
          beneficiaryTokenCount,
          _beneficiary,
          _preferClaimedTokens,
          _memo,
          _metadata
        );

        _delegate.didPay(_data);
        emit DelegateDidPay(_delegate, _data, msg.sender);
      }
    }

    emit Pay(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _payer,
      _beneficiary,
      _amount,
      beneficiaryTokenCount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function _addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    bool _shouldRefundHeldFees,
    string memory _memo,
    bytes memory _metadata
  ) internal {
    // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.
    uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0;

    // Record the added funds with any refunded fees.
    store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);

    emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);
  }

  /**
    @notice
    Refund fees based on the specified amount.

    @param _projectId The project for which fees are being refunded.
    @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.

    @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal
  */
  function _refundHeldFees(uint256 _projectId, uint256 _amount)
    internal
    returns (uint256 refundedFees)
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the current held fees.
    delete _heldFeesOf[_projectId];

    // Get a reference to the leftover amount once all fees have been settled.
    uint256 leftoverAmount = _amount;

    // Push length in stack
    uint256 _heldFeesLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeesLength; ) {
      if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);
      else if (leftoverAmount >= _heldFees[_i].amount) {
        unchecked {
          leftoverAmount = leftoverAmount - _heldFees[_i].amount;
          refundedFees += _feeAmount(
            _heldFees[_i].amount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount
          );
        }
      } else {
        _heldFeesOf[_projectId].push(
          JBFee(
            _heldFees[_i].amount - leftoverAmount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount,
            _heldFees[_i].beneficiary
          )
        );
        unchecked {
          refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);
        }
        leftoverAmount = 0;
      }

      unchecked {
        ++_i;
      }
    }

    emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);
  }

  /** 
    @notice 
    Returns the fee amount based on the provided amount for the specified project.

    @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal.
    @param _fee The percentage of the fee, out of MAX_FEE. 
    @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.

    @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _feeAmount(
    uint256 _amount,
    uint256 _fee,
    uint256 _feeDiscount
  ) internal pure returns (uint256) {
    // Calculate the discounted fee.
    uint256 _discountedFee = _fee -
      PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT);

    // The amount of tokens from the `_amount` to pay as a fee.
    return
      _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);
  }

  /** 
    @notice
    Get the fee discount from the fee gauge for the specified project.

    @param _projectId The ID of the project to get a fee discount for.
    
    @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.
  */
  function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {
    // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.
    if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))
      return JBConstants.MAX_FEE_DISCOUNT;

    // Get the fee discount.
    if (feeGauge == IJBFeeGauge(address(0)))
      feeDiscount = 0;
      // If the guage reverts, set the discount to 0.
    else
      try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {
        feeDiscount = discount;
      } catch {
        feeDiscount = 0;
      }

    // If the fee discount is greater than the max, nullify the discount.
    if (feeDiscount > JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;
  }
}
.]

Based on the provided smart contract code for the `JBPayoutRedemptionPaymentTerminal`, the following security vulnerabilities and concerns have been identified:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - Although the contract inherits from `ReentrancyGuard`, there are multiple external calls (e.g., `_transferFrom`, `_pay`, `_redeemTokensOf`, etc.) that could potentially lead to reentrancy attacks if not properly managed. It is crucial to ensure that state changes occur before any external calls.

2. **Access Control Issues**:
   - The use of `onlyOwner` and `requirePermission` modifiers is present, but there may be scenarios where unauthorized users could exploit functions if the access control is not strictly enforced. For example, functions like `setFee`, `setFeeGauge`, and `setFeelessAddress` should be carefully monitored to prevent unauthorized changes.

3. **Zero Address Checks**:
   - There are several instances where the contract does not adequately check for zero addresses (e.g., `_beneficiary` in `_pay`, `_redeemTokensOf`, etc.). Sending funds to a zero address could lead to loss of funds.

4. **Fee Handling Logic**:
   - The fee calculation and processing logic could be susceptible to manipulation. If the fee gauge reverts during fee processing, it could lock a project's funds, leading to potential denial of service.

5. **Error Handling**:
   - The contract uses custom errors, which is a good practice, but there are areas where revert messages could be more descriptive to aid in debugging and understanding the failure reasons.

6. **Gas Limit Issues**:
   - Functions that process arrays (like `processFees`) could run into gas limit issues if the number of fees held is large. This could lead to failed transactions.

7. **Lack of Input Validation**:
   - There are insufficient checks for input parameters in several functions, such as ensuring that amounts are positive or within expected ranges. This could lead to unexpected behavior or vulnerabilities.

8. **Potential for Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow/underflow checks, any arithmetic operations should still be carefully reviewed to ensure they do not lead to unexpected results, especially in fee calculations.

### Comprehensive Analysis Report:

The `JBPayoutRedemptionPaymentTerminal` contract exhibits a robust structure with several built-in security features, including access control and reentrancy protection. However, it is not without its vulnerabilities. The potential for reentrancy attacks remains a concern, particularly in functions that involve external calls. Access control mechanisms must be rigorously enforced to prevent unauthorized access to critical functions.

Moreover, the handling of zero addresses and the logic surrounding fee processing require careful attention to avoid loss of funds and service interruptions. The contract should implement more rigorous input validation to ensure that all parameters are within acceptable limits.

Overall, while the contract is designed with several security measures, it is essential to conduct thorough testing and audits, particularly focusing on the identified vulnerabilities. Implementing additional safeguards, such as more descriptive error messages and enhanced input validation, will further strengthen the contract's security posture. Regular updates and audits should be part of the contract's lifecycle to adapt to evolving security best practices and potential threats.

[2024-01-09 17:18:09 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for the `JBPayoutRedemptionPaymentTerminal`, the following security vulnerabilities and concerns have been identified:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - Although the contract inherits from `ReentrancyGuard`, there are multiple external calls (e.g., `_transferFrom`, `_pay`, `_redeemTokensOf`, etc.) that could potentially lead to reentrancy attacks if not properly managed. It is crucial to ensure that state changes occur before any external calls.

2. **Access Control Issues**:
   - The use of `onlyOwner` and `requirePermission` modifiers is present, but there may be scenarios where unauthorized users could exploit functions if the access control is not strictly enforced. For example, functions like `setFee`, `setFeeGauge`, and `setFeelessAddress` should be carefully monitored to prevent unauthorized changes.

3. **Zero Address Checks**:
   - There are several instances where the contract does not adequately check for zero addresses (e.g., `_beneficiary` in `_pay`, `_redeemTokensOf`, etc.). Sending funds to a zero address could lead to loss of funds.

4. **Fee Handling Logic**:
   - The fee calculation and processing logic could be susceptible to manipulation. If the fee gauge reverts during fee processing, it could lock a project's funds, leading to potential denial of service.

5. **Error Handling**:
   - The contract uses custom errors, which is a good practice, but there are areas where revert messages could be more descriptive to aid in debugging and understanding the failure reasons.

6. **Gas Limit Issues**:
   - Functions that process arrays (like `processFees`) could run into gas limit issues if the number of fees held is large. This could lead to failed transactions.

7. **Lack of Input Validation**:
   - There are insufficient checks for input parameters in several functions, such as ensuring that amounts are positive or within expected ranges. This could lead to unexpected behavior or vulnerabilities.

8. **Potential for Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow/underflow checks, any arithmetic operations should still be carefully reviewed to ensure they do not lead to unexpected results, especially in fee calculations.

### Comprehensive Analysis Report:

The `JBPayoutRedemptionPaymentTerminal` contract exhibits a robust structure with several built-in security features, including access control and reentrancy protection. However, it is not without its vulnerabilities. The potential for reentrancy attacks remains a concern, particularly in functions that involve external calls. Access control mechanisms must be rigorously enforced to prevent unauthorized access to critical functions.

Moreover, the handling of zero addresses and the logic surrounding fee processing require careful attention to avoid loss of funds and service interruptions. The contract should implement more rigorous input validation to ensure that all parameters are within acceptable limits.

Overall, while the contract is designed with several security measures, it is essential to conduct thorough testing and audits, particularly focusing on the identified vulnerabilities. Implementing additional safeguards, such as more descriptive error messages and enhanced input validation, will further strengthen the contract's security posture. Regular updates and audits should be part of the contract's lifecycle to adapt to evolving security best practices and potential threats.

[2024-01-09 17:18:09 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-01-09 17:18:09 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/security/ReentrancyGuard.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './../interfaces/IJBController.sol'; import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol'; import './../libraries/JBConstants.sol'; import './../libraries/JBCurrencies.sol'; import './../libraries/JBFixedPointNumber.sol'; import './../libraries/JBFundingCycleMetadataResolver.sol'; import './../libraries/JBOperations.sol'; import './../libraries/JBSplitsGroups.sol'; import './../libraries/JBTokens.sol'; import './../structs/JBTokenAmount.sol'; import './JBOperatable.sol'; import './JBSingleTokenPaymentTerminal.sol'; /**   @notice   Generic terminal managing all inflows and outflows of funds into the protocol ecosystem. @dev   A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time. @dev   Adheres to -   IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules. @dev   Inherits from -   JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.   JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.   Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.   ReentrancyGuard: Contract module that helps prevent reentrant calls to a function. */ abstract contract JBPayoutRedemptionPaymentTerminal is   IJBPayoutRedemptionPaymentTerminal,   JBSingleTokenPaymentTerminal,   JBOperatable,   Ownable,   ReentrancyGuard {   // A library that parses the packed funding cycle metadata into a friendlier format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error FEE_TOO_HIGH();   error INADEQUATE_DISTRIBUTION_AMOUNT();   error INADEQUATE_RECLAIM_AMOUNT();   error INADEQUATE_TOKEN_COUNT();   error NO_MSG_VALUE_ALLOWED();   error PAY_TO_ZERO_ADDRESS();   error PROJECT_TERMINAL_MISMATCH();   error REDEEM_TO_ZERO_ADDRESS();   error TERMINAL_IN_SPLIT_ZERO_ADDRESS();   error TERMINAL_TOKENS_INCOMPATIBLE(); //***********//   // ---------------------------- modifiers ---------------------------- //   //*************// /*      @notice      A modifier that verifies this terminal is a terminal of provided project ID.   /   modifier isTerminalOf(uint256 projectId) {     if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();     ;   } //***********//   // --------------------- internal stored constants ------------------- //   //*************// /**     @notice     Maximum fee that can be set for a funding cycle configuration. @dev Out of MAX_FEE (50_000_000 / 1_000_000_000).  */   uint256 internal constant _FEE_CAP = 50_000_000; /*     @notice     The protocol project ID is 1, as it should be the first project launched during the deployment process.   /   uint256 internal constant _PROTOCOL_PROJECT_ID = 1; //***********//   // --------------------- internal stored properties ------------------ //   //*************// /**     @notice     Fees that are being held to be processed later. _projectId The ID of the project for which fees are being held.  */   mapping(uint256 =&gt; JBFee[]) internal _heldFeesOf; //***********//   // ---------------- public immutable stored properties --------------- //   //*************// /*     @notice     Mints ERC-721's that represent project ownership and transfers.   /   IJBProjects public immutable override projects; /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; /*     @notice     The contract that stores splits for each project.   /   IJBSplitsStore public immutable override splitsStore; /*     @notice     The contract that exposes price feeds.   /   IJBPrices public immutable override prices; /*     @notice     The contract that stores and manages the terminal's data.   /   IJBSingleTokenPaymentTerminalStore public immutable override store; /**     @notice     The currency to base token issuance on. @dev If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.  */   uint256 public immutable override baseWeightCurrency; /*     @notice     The group that payout splits coming from this terminal are identified by.   /   uint256 public immutable override payoutSplitsGroup; //***********//   // --------------------- public stored properties -------------------- //   //*************// /**     @notice     The platform fee percent. @dev Out of MAX_FEE (25_000_000 / 1_000_000_000)  */   uint256 public override fee = 25_000_000; // 2.5% /*     @notice     The data source that returns a discount to apply to a project's fee.   /   IJBFeeGauge public override feeGauge; /**     @notice     Addresses that can be paid towards from this terminal without incurring a fee. _address The address that can be paid toward.  */   mapping(address =&gt; bool) public override isFeelessAddress; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     Gets the current overflowed amount in this terminal for a specified project, in terms of ETH. @dev The current overflow is represented as a fixed point number with 18 decimals.  @param _projectId The ID of the project to get overflow for.  @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.  */   function currentEthOverflowOf(uint256 _projectId)     external     view     virtual     override     returns (uint256)   {     // Get this terminal's current overflow.     uint256 _overflow = store.currentOverflowOf(this, _projectId); // Adjust the decimals of the fixed point number if needed to have 18 decimals. uint256 _adjustedOverflow = (decimals == 18)   ? _overflow   : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);  // Return the amount converted to ETH. return   (currency == JBCurrencies.ETH)     ? _adjustedOverflow     : PRBMath.mulDiv(       _adjustedOverflow,       10**decimals,       prices.priceFor(currency, JBCurrencies.ETH, decimals)     );  } /**     @notice     The fees that are currently being held to be processed later for each project. @param _projectId The ID of the project for which fees are being held.  @return An array of fees that are being held.  */   function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {     return _heldFeesOf[_projectId];   } //***********//   // -------------------------- public views --------------------------- //   //*************// /**     @notice     Indicates if this contract adheres to the specified interface. @dev  See {IERC165-supportsInterface}.  @param _interfaceId The ID of the interface to check for adherance to.  */   function supportsInterface(bytes4 _interfaceId)     public     view     virtual     override(JBSingleTokenPaymentTerminal, IERC165)     returns (bool)   {     return       _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||       _interfaceId == type(IJBPayoutTerminal).interfaceId ||       _interfaceId == type(IJBAllowanceTerminal).interfaceId ||       _interfaceId == type(IJBRedemptionTerminal).interfaceId ||       _interfaceId == type(IJBOperatable).interfaceId ||       super.supportsInterface(_interfaceId);   } //***********//   // -------------------------- constructor ---------------------------- //   //*************// /*     @param _token The token that this terminal manages.     @param _decimals The number of decimals the token fixed point amounts are expected to have.     @param _currency The currency that this terminal's token adheres to for price feeds.     @param _baseWeightCurrency The currency to base token issuance on.     @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.     @param _operatorStore A contract storing operator assignments.     @param _projects A contract which mints ERC-721's that represent project ownership and transfers.     @param _directory A contract storing directories of terminals and controllers for each project.     @param _splitsStore A contract that stores splits for each project.     @param _prices A contract that exposes price feeds.     @param _store A contract that stores the terminal's data.     @param _owner The address that will own this contract.   /   constructor(     // payable constructor save the gas used to check msg.value==0     address _token,     uint256 _decimals,     uint256 _currency,     uint256 _baseWeightCurrency,     uint256 _payoutSplitsGroup,     IJBOperatorStore _operatorStore,     IJBProjects _projects,     IJBDirectory _directory,     IJBSplitsStore _splitsStore,     IJBPrices _prices,     IJBSingleTokenPaymentTerminalStore _store,     address _owner   )     payable     JBSingleTokenPaymentTerminal(_token, _decimals, _currency)     JBOperatable(_operatorStore)   {     baseWeightCurrency = _baseWeightCurrency;     payoutSplitsGroup = _payoutSplitsGroup;     projects = _projects;     directory = _directory;     splitsStore = _splitsStore;     prices = _prices;     store = _store; transferOwnership(_owner);  } //***********//   // ---------------------- external transactions ---------------------- //   //*************// /**     @notice     Contribute tokens to a project. @param _projectId The ID of the project being paid. @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place. @param _token The token being paid. This terminal ignores this property since it only manages one token.  @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate. @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal. @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas. @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.  */   function pay(     uint256 _projectId,     uint256 _amount,     address _token,     address _beneficiary,     uint256 _minReturnedTokens,     bool _preferClaimedTokens,     string calldata _memo,     bytes calldata _metadata   ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {     _token; // Prevents unused var compiler and natspec complaints. // ETH shouldn't be sent if this terminal's token isn't ETH. if (token != JBTokens.ETH) {   if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();    // Transfer tokens to this terminal from the msg sender.   _transferFrom(msg.sender, payable(address(this)), _amount); } // If this terminal's token is ETH, override _amount with msg.value. else _amount = msg.value;  return   _pay(     _amount,     msg.sender,     _projectId,     _beneficiary,     _minReturnedTokens,     _preferClaimedTokens,     _memo,     _metadata   );  } /**     @notice     Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source. @dev Only a token holder or a designated operator can redeem its tokens.  @param _holder The account to redeem tokens for. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _token The token being reclaimed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal. @param _beneficiary The address to send the terminal tokens to. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.  */   function redeemTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     address _token,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo,     bytes memory _metadata   )     external     virtual     override     requirePermission(_holder, _projectId, JBOperations.REDEEM)     returns (uint256 reclaimAmount)   {     _token; // Prevents unused var compiler and natspec complaints. return   _redeemTokensOf(     _holder,     _projectId,     _tokenCount,     _minReturnedTokens,     _beneficiary,     _memo,     _metadata   );  } /**     @notice     Distributes payouts for a project with the distribution limit of its current funding cycle. @dev Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.  @dev Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.  @dev All funds distributed outside of this contract or any feeless terminals incure the protocol fee.  @param _projectId The ID of the project having its payouts distributed. @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency. @param _token The token being distributed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal. @param _memo A memo to pass along to the emitted event.  @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.  */   function distributePayoutsOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     address _token,     uint256 _minReturnedTokens,     string calldata _memo   ) external virtual override returns (uint256 netLeftoverDistributionAmount) {     _token; // Prevents unused var compiler and natspec complaints. return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);  } /**     @notice     Allows a project to send funds from its overflow up to the preconfigured allowance. @dev Only a project's owner or a designated operator can use its allowance.  @dev Incurs the protocol fee.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency. @param _token The token being distributed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals. @param _beneficiary The address to send the funds to. @param _memo A memo to pass along to the emitted event.  @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.  */   function useAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     address _token,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)     returns (uint256 netDistributedAmount)   {     _token; // Prevents unused var compiler and natspec complaints. return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);  } /**     @notice     Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type. @dev Only a project's owner or a designated operator can migrate it.  @param _projectId The ID of the project being migrated. @param _to The terminal contract that will gain the project's funds.  @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.  */   function migrate(uint256 _projectId, IJBPaymentTerminal _to)     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)     returns (uint256 balance)   {     // The terminal being migrated to must accept the same token as this terminal.     if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE(); // Record the migration in the store. balance = store.recordMigration(_projectId);  // Transfer the balance if needed. if (balance &gt; 0) {   // Trigger any inherited pre-transfer logic.   _beforeTransferTo(address(_to), balance);    // If this terminal's token is ETH, send it in msg.value.   uint256 _payableValue = token == JBTokens.ETH ? balance : 0;    // Withdraw the balance to transfer to the new terminal;   _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes('')); }  emit Migrate(_projectId, _to, balance, msg.sender);  } /**     @notice     Receives funds belonging to the specified project. @param _projectId The ID of the project to which the funds received belong. @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead. @param _token The token being paid. This terminal ignores this property since it only manages one currency.  @param _memo A memo to pass along to the emitted event. @param _metadata Extra data to pass along to the emitted event.  */   function addToBalanceOf(     uint256 _projectId,     uint256 _amount,     address _token,     string calldata _memo,     bytes calldata _metadata   ) external payable virtual override isTerminalOf(_projectId) {     _token; // Prevents unused var compiler and natspec complaints. // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender. if (token != JBTokens.ETH) {   // Amount must be greater than 0.   if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();    // Transfer tokens to this terminal from the msg sender.   _transferFrom(msg.sender, payable(address(this)), _amount); } // If the terminal's token is ETH, override `_amount` with msg.value. else _amount = msg.value;  // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal. _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);  } /**     @notice     Process any fees that are being held for the project. @dev Only a project owner, an operator, or the contract's owner can process held fees.  @param _projectId The ID of the project whos held fees should be processed.  */   function processFees(uint256 _projectId)     external     virtual     override     requirePermissionAllowingOverride(       projects.ownerOf(_projectId),       _projectId,       JBOperations.PROCESS_FEES,       msg.sender == owner()     )   {     // Get a reference to the project's held fees.     JBFee[] memory _heldFees = _heldFeesOf[_projectId]; // Delete the held fees. delete _heldFeesOf[_projectId];  // Push array length in stack uint256 _heldFeeLength = _heldFees.length;  // Process each fee. for (uint256 _i = 0; _i &lt; _heldFeeLength; ) {   // Get the fee amount.   uint256 _amount = _feeAmount(     _heldFees[_i].amount,     _heldFees[_i].fee,     _heldFees[_i].feeDiscount   );    // Process the fee.   _processFee(_amount, _heldFees[_i].beneficiary);    emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);    unchecked {     ++_i;   } }  } /**     @notice     Allows the fee to be updated. @dev Only the owner of this contract can change the fee.  @param _fee The new fee, out of MAX_FEE.  */   function setFee(uint256 _fee) external virtual override onlyOwner {     // The provided fee must be within the max.     if (_fee &gt; _FEE_CAP) revert FEE_TOO_HIGH(); // Store the new fee. fee = _fee;  emit SetFee(_fee, msg.sender);  } /**     @notice     Allows the fee gauge to be updated. @dev Only the owner of this contract can change the fee gauge.  @dev If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.  @param _feeGauge The new fee gauge.  */   function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {     // Store the new fee gauge.     feeGauge = _feeGauge; emit SetFeeGauge(_feeGauge, msg.sender);  } /**     @notice     Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee. @dev Only the owner of this contract can set addresses as feeless.  @param _address The address that can be paid towards while still bypassing fees. @param _flag A flag indicating whether the terminal should be feeless or not.  */   function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {     // Set the flag value.     isFeelessAddress[_address] = _flag; emit SetFeelessAddress(_address, _flag, msg.sender);  } //***********//   // ---------------------- internal transactions ---------------------- //   //*************// /**      @notice     Transfers tokens. @param _from The address from which the transfer should originate. @param _to The address to which the transfer should go. @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.  */   function _transferFrom(     address _from,     address payable _to,     uint256 _amount   ) internal virtual; /**      @notice     Logic to be triggered before transferring tokens from this terminal. @param _to The address to which the transfer is going. @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.  */   function _beforeTransferTo(address _to, uint256 _amount) internal virtual; /**     @notice     Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source. @dev Only a token holder or a designated operator can redeem its tokens.  @param _holder The account to redeem tokens for. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal. @param _beneficiary The address to send the terminal tokens to. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.  */   function _redeemTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo,     bytes memory _metadata   ) internal returns (uint256 reclaimAmount) {     // Can't send reclaimed funds to the zero address.     if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS(); // Define variables that will be needed outside the scoped section below. // Keep a reference to the funding cycle during which the redemption is being made. JBFundingCycle memory _fundingCycle;  // Scoped section prevents stack too deep. `_delegate` only used within scope. {   IJBRedemptionDelegate _delegate;    // Record the redemption.   (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(     _holder,     _projectId,     _tokenCount,     _memo,     _metadata   );    // The amount being reclaimed must be at least as much as was expected.   if (reclaimAmount &lt; _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();    // Burn the project tokens.   if (_tokenCount &gt; 0)     IJBController(directory.controllerOf(_projectId)).burnTokensOf(       _holder,       _projectId,       _tokenCount,       '',       false     );    // If a delegate was returned by the data source, issue a callback to it.   if (_delegate != IJBRedemptionDelegate(address(0))) {     JBDidRedeemData memory _data = JBDidRedeemData(       _holder,       _projectId,       _fundingCycle.configuration,       _tokenCount,       JBTokenAmount(token, reclaimAmount, decimals, currency),       _beneficiary,       _memo,       _metadata     );     _delegate.didRedeem(_data);     emit DelegateDidRedeem(_delegate, _data, msg.sender);   } }  // Send the reclaimed funds to the beneficiary. if (reclaimAmount &gt; 0) _transferFrom(address(this), _beneficiary, reclaimAmount);  emit RedeemTokens(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _holder,   _beneficiary,   _tokenCount,   reclaimAmount,   _memo,   _metadata,   msg.sender );  } /**     @notice     Distributes payouts for a project with the distribution limit of its current funding cycle. @dev Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.  @dev Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.  @dev All funds distributed outside of this contract or any feeless terminals incure the protocol fee.  @param _projectId The ID of the project having its payouts distributed. @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency. @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal. @param _memo A memo to pass along to the emitted event.  @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.  */   function _distributePayoutsOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     uint256 _minReturnedTokens,     string calldata _memo   ) internal returns (uint256 netLeftoverDistributionAmount) {     // Record the distribution.     (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(       _projectId,       _amount,       _currency     ); // The amount being distributed must be at least as much as was expected. if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();  // Get a reference to the project owner, which will receive tokens from paying the platform fee // and receive any extra distributable funds not allocated to payout splits. address payable _projectOwner = payable(projects.ownerOf(_projectId));  // Define variables that will be needed outside the scoped section below. // Keep a reference to the fee amount that was paid. uint256 _fee;  // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope. {   // Get the amount of discount that should be applied to any fees taken.   // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.   uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]     ? JBConstants.MAX_FEE_DISCOUNT     : _currentFeeDiscount(_projectId);    // The amount distributed that is eligible for incurring fees.   uint256 _feeEligibleDistributionAmount;    // The amount leftover after distributing to the splits.   uint256 _leftoverDistributionAmount;    // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.   // Also get a reference to the amount that was distributed to splits from which fees should be taken.   (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(     _projectId,     _fundingCycle.configuration,     payoutSplitsGroup,     _distributedAmount,     _feeDiscount   );    // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.   unchecked {     _feeEligibleDistributionAmount += _leftoverDistributionAmount;   }    // Take the fee.   _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0     ? 0     : _takeFeeFrom(       _projectId,       _fundingCycle,       _feeEligibleDistributionAmount,       _projectOwner,       _feeDiscount     );    // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.    unchecked {     netLeftoverDistributionAmount = _leftoverDistributionAmount == 0       ? 0       : _leftoverDistributionAmount -         _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);   }    // Transfer any remaining balance to the project owner.   if (netLeftoverDistributionAmount &gt; 0)     _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount); }  emit DistributePayouts(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _projectOwner,   _amount,   _distributedAmount,   _fee,   netLeftoverDistributionAmount,   _memo,   msg.sender );  } /**     @notice     Allows a project to send funds from its overflow up to the preconfigured allowance. @dev Only a project's owner or a designated operator can use its allowance.  @dev Incurs the protocol fee.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency. @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals. @param _beneficiary The address to send the funds to. @param _memo A memo to pass along to the emitted event.  @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.  */   function _useAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo   ) internal returns (uint256 netDistributedAmount) {     // Record the use of the allowance.     (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(       _projectId,       _amount,       _currency     ); // The amount being withdrawn must be at least as much as was expected. if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();  // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope. {   // Keep a reference to the fee amount that was paid.   uint256 _fee;    // Get a reference to the project owner, which will receive tokens from paying the platform fee.   address _projectOwner = projects.ownerOf(_projectId);    // Get the amount of discount that should be applied to any fees taken.   // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.   uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]     ? JBConstants.MAX_FEE_DISCOUNT     : _currentFeeDiscount(_projectId);    // Take a fee from the `_distributedAmount`, if needed.   _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT     ? 0     : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);    unchecked {     // The net amount is the withdrawn amount without the fee.     netDistributedAmount = _distributedAmount - _fee;   }    // Transfer any remaining balance to the beneficiary.   if (netDistributedAmount &gt; 0)     _transferFrom(address(this), _beneficiary, netDistributedAmount); }  emit UseAllowance(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _beneficiary,   _amount,   _distributedAmount,   netDistributedAmount,   _memo,   msg.sender );  } /**     @notice     Pays out splits for a project's funding cycle configuration. @param _projectId The ID of the project for which payout splits are being distributed. @param _domain The domain of the splits to distribute the payout between. @param _group The group of the splits to distribute the payout between. @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal. @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.  @return leftoverAmount If the leftover amount if the splits don't add up to 100%. @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.  */   function _distributeToPayoutSplitsOf(     uint256 _projectId,     uint256 _domain,     uint256 _group,     uint256 _amount,     uint256 _feeDiscount   ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {     // Set the leftover amount to the initial amount.     leftoverAmount = _amount; // Get a reference to the project's payout splits. JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);  // Transfer between all splits. for (uint256 _i = 0; _i &lt; _splits.length; ) {   // Get a reference to the split being iterated on.   JBSplit memory _split = _splits[_i];    // The amount to send towards the split.   uint256 _payoutAmount = PRBMath.mulDiv(     _amount,     _split.percent,     JBConstants.SPLITS_TOTAL_PERCENT   );    // The payout amount substracting any applicable incurred fees.   uint256 _netPayoutAmount;    if (_payoutAmount &gt; 0) {     // Transfer tokens to the split.     // If there's an allocator set, transfer to its `allocate` function.     if (_split.allocator != IJBSplitAllocator(address(0))) {       // If the split allocator is set as feeless, this distribution is not eligible for a fee.       if (isFeelessAddress[address(_split.allocator)])         _netPayoutAmount = _payoutAmount;         // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.       else {         unchecked {           _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT             ? _payoutAmount             : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);         }          // This distribution is eligible for a fee since the funds are leaving the ecosystem.         feeEligibleDistributionAmount += _payoutAmount;       }        // Trigger any inherited pre-transfer logic.       _beforeTransferTo(address(_split.allocator), _netPayoutAmount);        // If this terminal's token is ETH, send it in msg.value.       uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;        // Create the data to send to the allocator.       JBSplitAllocationData memory _data = JBSplitAllocationData(         token,         _netPayoutAmount,         decimals,         _projectId,         _group,         _split       );        // Trigger the allocator's `allocate` function.       _split.allocator.allocate{value: _payableValue}(_data);        // Otherwise, if a project is specified, make a payment to it.     } else if (_split.projectId != 0) {       // Get a reference to the Juicebox terminal being used.       IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);        // The project must have a terminal to send funds to.       if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();        // Save gas if this contract is being used as the terminal.       if (_terminal == this) {         // This distribution does not incur a fee.         _netPayoutAmount = _payoutAmount;          // Send the projectId in the metadata.         bytes memory _projectMetadata = new bytes(32);         _projectMetadata = bytes(abi.encodePacked(_projectId));          // Add to balance if prefered.         if (_split.preferAddToBalance)           _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);         else           _pay(             _netPayoutAmount,             address(this),             _split.projectId,             (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,             0,             _split.preferClaimed,             '',             _projectMetadata           );       } else {         // If the terminal is set as feeless, this distribution is not eligible for a fee.         if (isFeelessAddress[address(_terminal)])           _netPayoutAmount = _payoutAmount;           // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.         else {           unchecked {             _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT               ? _payoutAmount               : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);           }            feeEligibleDistributionAmount += _payoutAmount;         }          // Trigger any inherited pre-transfer logic.         _beforeTransferTo(address(_terminal), _netPayoutAmount);          // If this terminal's token is ETH, send it in msg.value.         uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;          // Send the projectId in the metadata.         bytes memory _projectMetadata = new bytes(32);         _projectMetadata = bytes(abi.encodePacked(_projectId));          // Add to balance if prefered.         if (_split.preferAddToBalance)           _terminal.addToBalanceOf{value: _payableValue}(             _split.projectId,             _netPayoutAmount,             token,             '',             _projectMetadata           );         else           _terminal.pay{value: _payableValue}(             _split.projectId,             _netPayoutAmount,             token,             _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,             0,             _split.preferClaimed,             '',             _projectMetadata           );       }     } else {       unchecked {         _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT           ? _payoutAmount           : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);       }        // This distribution is eligible for a fee since the funds are leaving the ecosystem.       feeEligibleDistributionAmount += _payoutAmount;        // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.       _transferFrom(         address(this),         _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),         _netPayoutAmount       );     }      // Subtract from the amount to be sent to the beneficiary.     unchecked {       leftoverAmount = leftoverAmount - _payoutAmount;     }   }    emit DistributeToPayoutSplit(     _projectId,     _domain,     _group,     _split,     _netPayoutAmount,     msg.sender   );    unchecked {     ++_i;   } }  } /**     @notice     Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID. @param _projectId The ID of the project having fees taken from. @param _fundingCycle The funding cycle during which the fee is being taken. @param _amount The amount of the fee to take, as a floating point number with 18 decimals. @param _beneficiary The address to mint the platforms tokens for. @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.  @return feeAmount The amount of the fee taken.  */   function _takeFeeFrom(     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _amount,     address _beneficiary,     uint256 _feeDiscount   ) internal returns (uint256 feeAmount) {     feeAmount = _feeAmount(_amount, fee, _feeDiscount); if (_fundingCycle.shouldHoldFees()) {   // Store the held fee.   _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));    emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender); } else {   // Process the fee.   _processFee(feeAmount, _beneficiary); // Take the fee.    emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender); }  } /**     @notice     Process a fee of the specified amount. @param _amount The fee amount, as a floating point number with 18 decimals. @param _beneficiary The address to mint the platform's tokens for.  */   function _processFee(uint256 _amount, address _beneficiary) internal {     // Get the terminal for the protocol project.     IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token); // When processing the admin fee, save gas if the admin is using this contract as its terminal. if (_terminal == this)   _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call. else {   // Trigger any inherited pre-transfer logic.   _beforeTransferTo(address(_terminal), _amount);    // If this terminal's token is ETH, send it in msg.value.   uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;    // Send the payment.   _terminal.pay{value: _payableValue}(     _PROTOCOL_PROJECT_ID,     _amount,     token,     _beneficiary,     0,     false,     '',     bytes('')   ); // Use the external pay call of the correct terminal. }  } /**     @notice     Contribute tokens to a project. @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place. @param _payer The address making the payment. @param _projectId The ID of the project being paid. @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate. @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal. @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas. @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.  */   function _pay(     uint256 _amount,     address _payer,     uint256 _projectId,     address _beneficiary,     uint256 _minReturnedTokens,     bool _preferClaimedTokens,     string memory _memo,     bytes memory _metadata   ) internal returns (uint256 beneficiaryTokenCount) {     // Cant send tokens to the zero address.     if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS(); // Define variables that will be needed outside the scoped section below. // Keep a reference to the funding cycle during which the payment is being made. JBFundingCycle memory _fundingCycle;  // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope. {   IJBPayDelegate _delegate;   uint256 _tokenCount;    // Bundle the amount info into a JBTokenAmount struct.   JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);    // Record the payment.   (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(     _payer,     _bundledAmount,     _projectId,     baseWeightCurrency,     _beneficiary,     _memo,     _metadata   );    // Mint the tokens if needed.   if (_tokenCount &gt; 0)     // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.     beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(       _projectId,       _tokenCount,       _beneficiary,       '',       _preferClaimedTokens,       true     );    // The token count for the beneficiary must be greater than or equal to the minimum expected.   if (beneficiaryTokenCount &lt; _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();    // If a delegate was returned by the data source, issue a callback to it.   if (_delegate != IJBPayDelegate(address(0))) {     JBDidPayData memory _data = JBDidPayData(       _payer,       _projectId,       _fundingCycle.configuration,       _bundledAmount,       beneficiaryTokenCount,       _beneficiary,       _preferClaimedTokens,       _memo,       _metadata     );      _delegate.didPay(_data);     emit DelegateDidPay(_delegate, _data, msg.sender);   } }  emit Pay(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _payer,   _beneficiary,   _amount,   beneficiaryTokenCount,   _memo,   _metadata,   msg.sender );  } /**     @notice     Receives funds belonging to the specified project. @param _projectId The ID of the project to which the funds received belong. @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead. @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added. @param _memo A memo to pass along to the emitted event. @param _metadata Extra data to pass along to the emitted event.  */   function _addToBalanceOf(     uint256 _projectId,     uint256 _amount,     bool _shouldRefundHeldFees,     string memory _memo,     bytes memory _metadata   ) internal {     // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.     uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0; // Record the added funds with any refunded fees. store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);  emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);  } /**     @notice     Refund fees based on the specified amount. @param _projectId The project for which fees are being refunded. @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.  @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal  */   function _refundHeldFees(uint256 _projectId, uint256 _amount)     internal     returns (uint256 refundedFees)   {     // Get a reference to the project's held fees.     JBFee[] memory _heldFees = _heldFeesOf[_projectId]; // Delete the current held fees. delete _heldFeesOf[_projectId];  // Get a reference to the leftover amount once all fees have been settled. uint256 leftoverAmount = _amount;  // Push length in stack uint256 _heldFeesLength = _heldFees.length;  // Process each fee. for (uint256 _i = 0; _i &lt; _heldFeesLength; ) {   if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);   else if (leftoverAmount &gt;= _heldFees[_i].amount) {     unchecked {       leftoverAmount = leftoverAmount - _heldFees[_i].amount;       refundedFees += _feeAmount(         _heldFees[_i].amount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount       );     }   } else {     _heldFeesOf[_projectId].push(       JBFee(         _heldFees[_i].amount - leftoverAmount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount,         _heldFees[_i].beneficiary       )     );     unchecked {       refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);     }     leftoverAmount = 0;   }    unchecked {     ++_i;   } }  emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);  } /**      @notice      Returns the fee amount based on the provided amount for the specified project. @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal. @param _fee The percentage of the fee, out of MAX_FEE.  @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.  @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.  */   function _feeAmount(     uint256 _amount,     uint256 _fee,     uint256 _feeDiscount   ) internal pure returns (uint256) {     // Calculate the discounted fee.     uint256 _discountedFee = _fee -       PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT); // The amount of tokens from the `_amount` to pay as a fee. return   _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);  } /**      @notice     Get the fee discount from the fee gauge for the specified project. @param _projectId The ID of the project to get a fee discount for.  @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.  */   function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {     // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.     if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))       return JBConstants.MAX_FEE_DISCOUNT; // Get the fee discount. if (feeGauge == IJBFeeGauge(address(0)))   feeDiscount = 0;   // If the guage reverts, set the discount to 0. else   try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {     feeDiscount = discount;   } catch {     feeDiscount = 0;   }  // If the fee discount is greater than the max, nullify the discount. if (feeDiscount &gt; JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;  } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@paulrberg/contracts/math/PRBMath.sol';\nimport './../interfaces/IJBController.sol';\nimport './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol';\nimport './../libraries/JBConstants.sol';\nimport './../libraries/JBCurrencies.sol';\nimport './../libraries/JBFixedPointNumber.sol';\nimport './../libraries/JBFundingCycleMetadataResolver.sol';\nimport './../libraries/JBOperations.sol';\nimport './../libraries/JBSplitsGroups.sol';\nimport './../libraries/JBTokens.sol';\nimport './../structs/JBTokenAmount.sol';\nimport './JBOperatable.sol';\nimport './JBSingleTokenPaymentTerminal.sol';\n\n/\n  @notice\n  Generic terminal managing all inflows and outflows of funds into the protocol ecosystem.\n\n  @dev\n  A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time.\n\n  @dev\n  Adheres to -\n  IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.\n\n  @dev\n  Inherits from -\n  JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.\n  JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.\n  Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.\n  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.\n/\nabstract contract JBPayoutRedemptionPaymentTerminal is\n  IJBPayoutRedemptionPaymentTerminal,\n  JBSingleTokenPaymentTerminal,\n  JBOperatable,\n  Ownable,\n  ReentrancyGuard\n{\n  // A library that parses the packed funding cycle metadata into a friendlier format.\n  using JBFundingCycleMetadataResolver for JBFundingCycle;\n\n  //*********//\n  // --------------------------- custom errors ------------------------- //\n  //*********//\n  error FEE_TOO_HIGH();\n  error INADEQUATE_DISTRIBUTION_AMOUNT();\n  error INADEQUATE_RECLAIM_AMOUNT();\n  error INADEQUATE_TOKEN_COUNT();\n  error NO_MSG_VALUE_ALLOWED();\n  error PAY_TO_ZERO_ADDRESS();\n  error PROJECT_TERMINAL_MISMATCH();\n  error REDEEM_TO_ZERO_ADDRESS();\n  error TERMINAL_IN_SPLIT_ZERO_ADDRESS();\n  error TERMINAL_TOKENS_INCOMPATIBLE();\n\n  //*********//\n  // ---------------------------- modifiers ---------------------------- //\n  //*********//\n\n  / \n    @notice \n    A modifier that verifies this terminal is a terminal of provided project ID.\n  /\n  modifier isTerminalOf(uint256 projectId) {\n    if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();\n    ;\n  }\n\n  //**********//\n  // --------------------- internal stored constants ------------------- //\n  //*********//\n\n  /\n    @notice\n    Maximum fee that can be set for a funding cycle configuration.\n\n    @dev\n    Out of MAX_FEE (50_000_000 / 1_000_000_000).\n  /\n  uint256 internal constant _FEE_CAP = 50_000_000;\n\n  /\n    @notice\n    The protocol project ID is 1, as it should be the first project launched during the deployment process.\n  /\n  uint256 internal constant _PROTOCOL_PROJECT_ID = 1;\n\n  //**********//\n  // --------------------- internal stored properties ------------------ //\n  //**********//\n\n  /\n    @notice\n    Fees that are being held to be processed later.\n\n    _projectId The ID of the project for which fees are being held.\n  /\n  mapping(uint256 =&gt; JBFee[]) internal _heldFeesOf;\n\n  //**********//\n  // ---------------- public immutable stored properties --------------- //\n  //*********//\n\n  /\n    @notice\n    Mints ERC-721's that represent project ownership and transfers.\n  /\n  IJBProjects public immutable override projects;\n\n  /\n    @notice\n    The directory of terminals and controllers for projects.\n  /\n  IJBDirectory public immutable override directory;\n\n  /\n    @notice\n    The contract that stores splits for each project.\n  /\n  IJBSplitsStore public immutable override splitsStore;\n\n  /\n    @notice\n    The contract that exposes price feeds.\n  /\n  IJBPrices public immutable override prices;\n\n  /\n    @notice\n    The contract that stores and manages the terminal's data.\n  */\n  IJBSingleTokenPaymentTerminalStore public immutable override store;\n\n  /\n    @notice\n    The currency to base token issuance on.\n\n    @dev\n    If this differs from currency, there must be a price feed available to convert currency to baseWeightCurrency.\n  /\n  uint256 public immutable override baseWeightCurrency;\n\n  /\n    @notice\n    The group that payout splits coming from this terminal are identified by.\n  /\n  uint256 public immutable override payoutSplitsGroup;\n\n  //*********//\n  // --------------------- public stored properties -------------------- //\n  //*********//\n\n  /\n    @notice\n    The platform fee percent.\n\n    @dev\n    Out of MAX_FEE (25_000_000 / 1_000_000_000)\n  /\n  uint256 public override fee = 25_000_000; // 2.5%\n\n  /\n    @notice\n    The data source that returns a discount to apply to a project's fee.\n  /\n  IJBFeeGauge public override feeGauge;\n\n  /\n    @notice\n    Addresses that can be paid towards from this terminal without incurring a fee.\n\n    _address The address that can be paid toward.\n  /\n  mapping(address =&gt; bool) public override isFeelessAddress;\n\n  //***********//\n  // ------------------------- external views -------------------------- //\n  //**********//\n\n  /\n    @notice\n    Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.\n\n    @dev\n    The current overflow is represented as a fixed point number with 18 decimals.\n\n    @param _projectId The ID of the project to get overflow for.\n\n    @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.\n  /\n  function currentEthOverflowOf(uint256 _projectId)\n    external\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    // Get this terminal's current overflow.\n    uint256 _overflow = store.currentOverflowOf(this, _projectId);\n\n    // Adjust the decimals of the fixed point number if needed to have 18 decimals.\n    uint256 _adjustedOverflow = (decimals == 18)\n      ? _overflow\n      : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);\n\n    // Return the amount converted to ETH.\n    return\n      (currency == JBCurrencies.ETH)\n        ? _adjustedOverflow\n        : PRBMath.mulDiv(\n          _adjustedOverflow,\n          10decimals,\n          prices.priceFor(currency, JBCurrencies.ETH, decimals)\n        );\n  }\n\n  /\n    @notice\n    The fees that are currently being held to be processed later for each project.\n\n    @param _projectId The ID of the project for which fees are being held.\n\n    @return An array of fees that are being held.\n  /\n  function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {\n    return _heldFeesOf[_projectId];\n  }\n\n  //*********//\n  // -------------------------- public views --------------------------- //\n  //*********//\n\n  /\n    @notice\n    Indicates if this contract adheres to the specified interface.\n\n    @dev \n    See {IERC165-supportsInterface}.\n\n    @param _interfaceId The ID of the interface to check for adherance to.\n  /\n  function supportsInterface(bytes4 _interfaceId)\n    public\n    view\n    virtual\n    override(JBSingleTokenPaymentTerminal, IERC165)\n    returns (bool)\n  {\n    return\n      _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||\n      _interfaceId == type(IJBPayoutTerminal).interfaceId ||\n      _interfaceId == type(IJBAllowanceTerminal).interfaceId ||\n      _interfaceId == type(IJBRedemptionTerminal).interfaceId ||\n      _interfaceId == type(IJBOperatable).interfaceId ||\n      super.supportsInterface(_interfaceId);\n  }\n\n  //**********//\n  // -------------------------- constructor ---------------------------- //\n  //*********//\n\n  /\n    @param _token The token that this terminal manages.\n    @param _decimals The number of decimals the token fixed point amounts are expected to have.\n    @param _currency The currency that this terminal's token adheres to for price feeds.\n    @param _baseWeightCurrency The currency to base token issuance on.\n    @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.\n    @param _operatorStore A contract storing operator assignments.\n    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.\n    @param _directory A contract storing directories of terminals and controllers for each project.\n    @param _splitsStore A contract that stores splits for each project.\n    @param _prices A contract that exposes price feeds.\n    @param _store A contract that stores the terminal's data.\n    @param _owner The address that will own this contract.\n  /\n  constructor(\n    // payable constructor save the gas used to check msg.value==0\n    address _token,\n    uint256 _decimals,\n    uint256 _currency,\n    uint256 _baseWeightCurrency,\n    uint256 _payoutSplitsGroup,\n    IJBOperatorStore _operatorStore,\n    IJBProjects _projects,\n    IJBDirectory _directory,\n    IJBSplitsStore _splitsStore,\n    IJBPrices _prices,\n    IJBSingleTokenPaymentTerminalStore _store,\n    address _owner\n  )\n    payable\n    JBSingleTokenPaymentTerminal(_token, _decimals, _currency)\n    JBOperatable(_operatorStore)\n  {\n    baseWeightCurrency = _baseWeightCurrency;\n    payoutSplitsGroup = _payoutSplitsGroup;\n    projects = _projects;\n    directory = _directory;\n    splitsStore = _splitsStore;\n    prices = _prices;\n    store = _store;\n\n    transferOwnership(_owner);\n  }\n\n  //**********//\n  // ---------------------- external transactions ---------------------- //\n  //*********//\n\n  /\n    @notice\n    Contribute tokens to a project.\n\n    @param _projectId The ID of the project being paid.\n    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.\n    @param _token The token being paid. This terminal ignores this property since it only manages one token. \n    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.\n    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.\n    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.\n    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.\n    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.\n\n    @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.\n  /\n  function pay(\n    uint256 _projectId,\n    uint256 _amount,\n    address _token,\n    address _beneficiary,\n    uint256 _minReturnedTokens,\n    bool _preferClaimedTokens,\n    string calldata _memo,\n    bytes calldata _metadata\n  ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {\n    _token; // Prevents unused var compiler and natspec complaints.\n\n    // ETH shouldn't be sent if this terminal's token isn't ETH.\n    if (token != JBTokens.ETH) {\n      if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();\n\n      // Transfer tokens to this terminal from the msg sender.\n      _transferFrom(msg.sender, payable(address(this)), _amount);\n    }\n    // If this terminal's token is ETH, override _amount with msg.value.\n    else _amount = msg.value;\n\n    return\n      _pay(\n        _amount,\n        msg.sender,\n        _projectId,\n        _beneficiary,\n        _minReturnedTokens,\n        _preferClaimedTokens,\n        _memo,\n        _metadata\n      );\n  }\n\n  /\n    @notice\n    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.\n\n    @dev\n    Only a token holder or a designated operator can redeem its tokens.\n\n    @param _holder The account to redeem tokens for.\n    @param _projectId The ID of the project to which the tokens being redeemed belong.\n    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.\n    @param _token The token being reclaimed. This terminal ignores this property since it only manages one token. \n    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.\n    @param _beneficiary The address to send the terminal tokens to.\n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.\n\n    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.\n  /\n  function redeemTokensOf(\n    address _holder,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    address _token,\n    uint256 _minReturnedTokens,\n    address payable _beneficiary,\n    string memory _memo,\n    bytes memory _metadata\n  )\n    external\n    virtual\n    override\n    requirePermission(_holder, _projectId, JBOperations.REDEEM)\n    returns (uint256 reclaimAmount)\n  {\n    _token; // Prevents unused var compiler and natspec complaints.\n\n    return\n      _redeemTokensOf(\n        _holder,\n        _projectId,\n        _tokenCount,\n        _minReturnedTokens,\n        _beneficiary,\n        _memo,\n        _metadata\n      );\n  }\n\n  /\n    @notice\n    Distributes payouts for a project with the distribution limit of its current funding cycle.\n\n    @dev\n    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.\n\n    @dev\n    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.\n\n    @dev\n    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.\n\n    @param _projectId The ID of the project having its payouts distributed.\n    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.\n    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.\n    @param _token The token being distributed. This terminal ignores this property since it only manages one token. \n    @param _minReturnedTokens The minimum number of terminal tokens that the _amount should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.\n  /\n  function distributePayoutsOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency,\n    address _token,\n    uint256 _minReturnedTokens,\n    string calldata _memo\n  ) external virtual override returns (uint256 netLeftoverDistributionAmount) {\n    _token; // Prevents unused var compiler and natspec complaints.\n\n    return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);\n  }\n\n  /\n    @notice\n    Allows a project to send funds from its overflow up to the preconfigured allowance.\n\n    @dev\n    Only a project's owner or a designated operator can use its allowance.\n\n    @dev\n    Incurs the protocol fee.\n\n    @param _projectId The ID of the project to use the allowance of.\n    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.\n    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.\n    @param _token The token being distributed. This terminal ignores this property since it only manages one token. \n    @param _minReturnedTokens The minimum number of tokens that the _amount should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.\n    @param _beneficiary The address to send the funds to.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.\n  /\n  function useAllowanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency,\n    address _token,\n    uint256 _minReturnedTokens,\n    address payable _beneficiary,\n    string memory _memo\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)\n    returns (uint256 netDistributedAmount)\n  {\n    _token; // Prevents unused var compiler and natspec complaints.\n\n    return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);\n  }\n\n  /\n    @notice\n    Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.\n\n    @dev\n    Only a project's owner or a designated operator can migrate it.\n\n    @param _projectId The ID of the project being migrated.\n    @param _to The terminal contract that will gain the project's funds.\n\n    @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.\n  */\n  function migrate(uint256 _projectId, IJBPaymentTerminal _to)\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)\n    returns (uint256 balance)\n  {\n    // The terminal being migrated to must accept the same token as this terminal.\n    if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE();\n\n    // Record the migration in the store.\n    balance = store.recordMigration(_projectId);\n\n    // Transfer the balance if needed.\n    if (balance &gt; 0) {\n      // Trigger any inherited pre-transfer logic.\n      _beforeTransferTo(address(_to), balance);\n\n      // If this terminal's token is ETH, send it in msg.value.\n      uint256 _payableValue = token == JBTokens.ETH ? balance : 0;\n\n      // Withdraw the balance to transfer to the new terminal;\n      _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes(''));\n    }\n\n    emit Migrate(_projectId, _to, balance, msg.sender);\n  }\n\n  /\n    @notice\n    Receives funds belonging to the specified project.\n\n    @param _projectId The ID of the project to which the funds received belong.\n    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.\n    @param _token The token being paid. This terminal ignores this property since it only manages one currency. \n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Extra data to pass along to the emitted event.\n  /\n  function addToBalanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    address _token,\n    string calldata _memo,\n    bytes calldata _metadata\n  ) external payable virtual override isTerminalOf(_projectId) {\n    _token; // Prevents unused var compiler and natspec complaints.\n\n    // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender.\n    if (token != JBTokens.ETH) {\n      // Amount must be greater than 0.\n      if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();\n\n      // Transfer tokens to this terminal from the msg sender.\n      _transferFrom(msg.sender, payable(address(this)), _amount);\n    }\n    // If the terminal's token is ETH, override _amount with msg.value.\n    else _amount = msg.value;\n\n    // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal.\n    _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);\n  }\n\n  /\n    @notice\n    Process any fees that are being held for the project.\n\n    @dev\n    Only a project owner, an operator, or the contract's owner can process held fees.\n\n    @param _projectId The ID of the project whos held fees should be processed.\n  /\n  function processFees(uint256 _projectId)\n    external\n    virtual\n    override\n    requirePermissionAllowingOverride(\n      projects.ownerOf(_projectId),\n      _projectId,\n      JBOperations.PROCESS_FEES,\n      msg.sender == owner()\n    )\n  {\n    // Get a reference to the project's held fees.\n    JBFee[] memory _heldFees = _heldFeesOf[_projectId];\n\n    // Delete the held fees.\n    delete _heldFeesOf[_projectId];\n\n    // Push array length in stack\n    uint256 _heldFeeLength = _heldFees.length;\n\n    // Process each fee.\n    for (uint256 _i = 0; _i &lt; _heldFeeLength; ) {\n      // Get the fee amount.\n      uint256 _amount = _feeAmount(\n        _heldFees[_i].amount,\n        _heldFees[_i].fee,\n        _heldFees[_i].feeDiscount\n      );\n\n      // Process the fee.\n      _processFee(_amount, _heldFees[_i].beneficiary);\n\n      emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /\n    @notice\n    Allows the fee to be updated.\n\n    @dev\n    Only the owner of this contract can change the fee.\n\n    @param _fee The new fee, out of MAX_FEE.\n  */\n  function setFee(uint256 _fee) external virtual override onlyOwner {\n    // The provided fee must be within the max.\n    if (_fee &gt; _FEE_CAP) revert FEE_TOO_HIGH();\n\n    // Store the new fee.\n    fee = _fee;\n\n    emit SetFee(_fee, msg.sender);\n  }\n\n  /\n    @notice\n    Allows the fee gauge to be updated.\n\n    @dev\n    Only the owner of this contract can change the fee gauge.\n\n    @dev\n    If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.\n\n    @param _feeGauge The new fee gauge.\n  /\n  function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {\n    // Store the new fee gauge.\n    feeGauge = _feeGauge;\n\n    emit SetFeeGauge(_feeGauge, msg.sender);\n  }\n\n  /\n    @notice\n    Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.\n\n    @dev\n    Only the owner of this contract can set addresses as feeless.\n\n    @param _address The address that can be paid towards while still bypassing fees.\n    @param _flag A flag indicating whether the terminal should be feeless or not.\n  /\n  function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {\n    // Set the flag value.\n    isFeelessAddress[_address] = _flag;\n\n    emit SetFeelessAddress(_address, _flag, msg.sender);\n  }\n\n  //*********//\n  // ---------------------- internal transactions ---------------------- //\n  //*********//\n\n  / \n    @notice\n    Transfers tokens.\n\n    @param _from The address from which the transfer should originate.\n    @param _to The address to which the transfer should go.\n    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.\n  /\n  function _transferFrom(\n    address _from,\n    address payable _to,\n    uint256 _amount\n  ) internal virtual;\n\n  / \n    @notice\n    Logic to be triggered before transferring tokens from this terminal.\n\n    @param _to The address to which the transfer is going.\n    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.\n  /\n  function _beforeTransferTo(address _to, uint256 _amount) internal virtual;\n\n  /\n    @notice\n    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.\n\n    @dev\n    Only a token holder or a designated operator can redeem its tokens.\n\n    @param _holder The account to redeem tokens for.\n    @param _projectId The ID of the project to which the tokens being redeemed belong.\n    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.\n    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.\n    @param _beneficiary The address to send the terminal tokens to.\n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.\n\n    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.\n  /\n  function _redeemTokensOf(\n    address _holder,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    uint256 _minReturnedTokens,\n    address payable _beneficiary,\n    string memory _memo,\n    bytes memory _metadata\n  ) internal returns (uint256 reclaimAmount) {\n    // Can't send reclaimed funds to the zero address.\n    if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS();\n\n    // Define variables that will be needed outside the scoped section below.\n    // Keep a reference to the funding cycle during which the redemption is being made.\n    JBFundingCycle memory _fundingCycle;\n\n    // Scoped section prevents stack too deep. _delegate only used within scope.\n    {\n      IJBRedemptionDelegate _delegate;\n\n      // Record the redemption.\n      (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(\n        _holder,\n        _projectId,\n        _tokenCount,\n        _memo,\n        _metadata\n      );\n\n      // The amount being reclaimed must be at least as much as was expected.\n      if (reclaimAmount &lt; _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();\n\n      // Burn the project tokens.\n      if (_tokenCount &gt; 0)\n        IJBController(directory.controllerOf(_projectId)).burnTokensOf(\n          _holder,\n          _projectId,\n          _tokenCount,\n          '',\n          false\n        );\n\n      // If a delegate was returned by the data source, issue a callback to it.\n      if (_delegate != IJBRedemptionDelegate(address(0))) {\n        JBDidRedeemData memory _data = JBDidRedeemData(\n          _holder,\n          _projectId,\n          _fundingCycle.configuration,\n          _tokenCount,\n          JBTokenAmount(token, reclaimAmount, decimals, currency),\n          _beneficiary,\n          _memo,\n          _metadata\n        );\n        _delegate.didRedeem(_data);\n        emit DelegateDidRedeem(_delegate, _data, msg.sender);\n      }\n    }\n\n    // Send the reclaimed funds to the beneficiary.\n    if (reclaimAmount &gt; 0) _transferFrom(address(this), _beneficiary, reclaimAmount);\n\n    emit RedeemTokens(\n      _fundingCycle.configuration,\n      _fundingCycle.number,\n      _projectId,\n      _holder,\n      _beneficiary,\n      _tokenCount,\n      reclaimAmount,\n      _memo,\n      _metadata,\n      msg.sender\n    );\n  }\n\n  /\n    @notice\n    Distributes payouts for a project with the distribution limit of its current funding cycle.\n\n    @dev\n    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.\n\n    @dev\n    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.\n\n    @dev\n    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.\n\n    @param _projectId The ID of the project having its payouts distributed.\n    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.\n    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.\n    @param _minReturnedTokens The minimum number of terminal tokens that the _amount should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.\n  */\n  function _distributePayoutsOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency,\n    uint256 _minReturnedTokens,\n    string calldata _memo\n  ) internal returns (uint256 netLeftoverDistributionAmount) {\n    // Record the distribution.\n    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(\n      _projectId,\n      _amount,\n      _currency\n    );\n\n    // The amount being distributed must be at least as much as was expected.\n    if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();\n\n    // Get a reference to the project owner, which will receive tokens from paying the platform fee\n    // and receive any extra distributable funds not allocated to payout splits.\n    address payable _projectOwner = payable(projects.ownerOf(_projectId));\n\n    // Define variables that will be needed outside the scoped section below.\n    // Keep a reference to the fee amount that was paid.\n    uint256 _fee;\n\n    // Scoped section prevents stack too deep. _feeDiscount, _feeEligibleDistributionAmount, and _leftoverDistributionAmount only used within scope.\n    {\n      // Get the amount of discount that should be applied to any fees taken.\n      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.\n      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]\n        ? JBConstants.MAX_FEE_DISCOUNT\n        : _currentFeeDiscount(_projectId);\n\n      // The amount distributed that is eligible for incurring fees.\n      uint256 _feeEligibleDistributionAmount;\n\n      // The amount leftover after distributing to the splits.\n      uint256 _leftoverDistributionAmount;\n\n      // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.\n      // Also get a reference to the amount that was distributed to splits from which fees should be taken.\n      (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(\n        _projectId,\n        _fundingCycle.configuration,\n        payoutSplitsGroup,\n        _distributedAmount,\n        _feeDiscount\n      );\n\n      // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.\n      unchecked {\n        _feeEligibleDistributionAmount += _leftoverDistributionAmount;\n      }\n\n      // Take the fee.\n      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0\n        ? 0\n        : _takeFeeFrom(\n          _projectId,\n          _fundingCycle,\n          _feeEligibleDistributionAmount,\n          _projectOwner,\n          _feeDiscount\n        );\n\n      // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.\n\n      unchecked {\n        netLeftoverDistributionAmount = _leftoverDistributionAmount == 0\n          ? 0\n          : _leftoverDistributionAmount -\n            _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);\n      }\n\n      // Transfer any remaining balance to the project owner.\n      if (netLeftoverDistributionAmount &gt; 0)\n        _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount);\n    }\n\n    emit DistributePayouts(\n      _fundingCycle.configuration,\n      _fundingCycle.number,\n      _projectId,\n      _projectOwner,\n      _amount,\n      _distributedAmount,\n      _fee,\n      netLeftoverDistributionAmount,\n      _memo,\n      msg.sender\n    );\n  }\n\n  /\n    @notice\n    Allows a project to send funds from its overflow up to the preconfigured allowance.\n\n    @dev\n    Only a project's owner or a designated operator can use its allowance.\n\n    @dev\n    Incurs the protocol fee.\n\n    @param _projectId The ID of the project to use the allowance of.\n    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.\n    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.\n    @param _minReturnedTokens The minimum number of tokens that the _amount should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.\n    @param _beneficiary The address to send the funds to.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.\n  /\n  function _useAllowanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency,\n    uint256 _minReturnedTokens,\n    address payable _beneficiary,\n    string memory _memo\n  ) internal returns (uint256 netDistributedAmount) {\n    // Record the use of the allowance.\n    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(\n      _projectId,\n      _amount,\n      _currency\n    );\n\n    // The amount being withdrawn must be at least as much as was expected.\n    if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();\n\n    // Scoped section prevents stack too deep. _fee, _projectOwner, _feeDiscount, and _netAmount only used within scope.\n    {\n      // Keep a reference to the fee amount that was paid.\n      uint256 _fee;\n\n      // Get a reference to the project owner, which will receive tokens from paying the platform fee.\n      address _projectOwner = projects.ownerOf(_projectId);\n\n      // Get the amount of discount that should be applied to any fees taken.\n      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.\n      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]\n        ? JBConstants.MAX_FEE_DISCOUNT\n        : _currentFeeDiscount(_projectId);\n\n      // Take a fee from the _distributedAmount, if needed.\n      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT\n        ? 0\n        : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);\n\n      unchecked {\n        // The net amount is the withdrawn amount without the fee.\n        netDistributedAmount = _distributedAmount - _fee;\n      }\n\n      // Transfer any remaining balance to the beneficiary.\n      if (netDistributedAmount &gt; 0)\n        _transferFrom(address(this), _beneficiary, netDistributedAmount);\n    }\n\n    emit UseAllowance(\n      _fundingCycle.configuration,\n      _fundingCycle.number,\n      _projectId,\n      _beneficiary,\n      _amount,\n      _distributedAmount,\n      netDistributedAmount,\n      _memo,\n      msg.sender\n    );\n  }\n\n  /\n    @notice\n    Pays out splits for a project's funding cycle configuration.\n\n    @param _projectId The ID of the project for which payout splits are being distributed.\n    @param _domain The domain of the splits to distribute the payout between.\n    @param _group The group of the splits to distribute the payout between.\n    @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal.\n    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.\n\n    @return leftoverAmount If the leftover amount if the splits don't add up to 100%.\n    @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.\n  /\n  function _distributeToPayoutSplitsOf(\n    uint256 _projectId,\n    uint256 _domain,\n    uint256 _group,\n    uint256 _amount,\n    uint256 _feeDiscount\n  ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {\n    // Set the leftover amount to the initial amount.\n    leftoverAmount = _amount;\n\n    // Get a reference to the project's payout splits.\n    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);\n\n    // Transfer between all splits.\n    for (uint256 _i = 0; _i &lt; _splits.length; ) {\n      // Get a reference to the split being iterated on.\n      JBSplit memory _split = _splits[_i];\n\n      // The amount to send towards the split.\n      uint256 _payoutAmount = PRBMath.mulDiv(\n        _amount,\n        _split.percent,\n        JBConstants.SPLITS_TOTAL_PERCENT\n      );\n\n      // The payout amount substracting any applicable incurred fees.\n      uint256 _netPayoutAmount;\n\n      if (_payoutAmount &gt; 0) {\n        // Transfer tokens to the split.\n        // If there's an allocator set, transfer to its allocate function.\n        if (_split.allocator != IJBSplitAllocator(address(0))) {\n          // If the split allocator is set as feeless, this distribution is not eligible for a fee.\n          if (isFeelessAddress[address(_split.allocator)])\n            _netPayoutAmount = _payoutAmount;\n            // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.\n          else {\n            unchecked {\n              _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT\n                ? _payoutAmount\n                : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);\n            }\n\n            // This distribution is eligible for a fee since the funds are leaving the ecosystem.\n            feeEligibleDistributionAmount += _payoutAmount;\n          }\n\n          // Trigger any inherited pre-transfer logic.\n          _beforeTransferTo(address(_split.allocator), _netPayoutAmount);\n\n          // If this terminal's token is ETH, send it in msg.value.\n          uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;\n\n          // Create the data to send to the allocator.\n          JBSplitAllocationData memory _data = JBSplitAllocationData(\n            token,\n            _netPayoutAmount,\n            decimals,\n            _projectId,\n            _group,\n            _split\n          );\n\n          // Trigger the allocator's allocate function.\n          _split.allocator.allocate{value: _payableValue}(_data);\n\n          // Otherwise, if a project is specified, make a payment to it.\n        } else if (_split.projectId != 0) {\n          // Get a reference to the Juicebox terminal being used.\n          IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);\n\n          // The project must have a terminal to send funds to.\n          if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();\n\n          // Save gas if this contract is being used as the terminal.\n          if (_terminal == this) {\n            // This distribution does not incur a fee.\n            _netPayoutAmount = _payoutAmount;\n\n            // Send the projectId in the metadata.\n            bytes memory _projectMetadata = new bytes(32);\n            _projectMetadata = bytes(abi.encodePacked(_projectId));\n\n            // Add to balance if prefered.\n            if (_split.preferAddToBalance)\n              _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);\n            else\n              _pay(\n                _netPayoutAmount,\n                address(this),\n                _split.projectId,\n                (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,\n                0,\n                _split.preferClaimed,\n                '',\n                _projectMetadata\n              );\n          } else {\n            // If the terminal is set as feeless, this distribution is not eligible for a fee.\n            if (isFeelessAddress[address(_terminal)])\n              _netPayoutAmount = _payoutAmount;\n              // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.\n            else {\n              unchecked {\n                _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT\n                  ? _payoutAmount\n                  : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);\n              }\n\n              feeEligibleDistributionAmount += _payoutAmount;\n            }\n\n            // Trigger any inherited pre-transfer logic.\n            _beforeTransferTo(address(_terminal), _netPayoutAmount);\n\n            // If this terminal's token is ETH, send it in msg.value.\n            uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;\n\n            // Send the projectId in the metadata.\n            bytes memory _projectMetadata = new bytes(32);\n            _projectMetadata = bytes(abi.encodePacked(_projectId));\n\n            // Add to balance if prefered.\n            if (_split.preferAddToBalance)\n              _terminal.addToBalanceOf{value: _payableValue}(\n                _split.projectId,\n                _netPayoutAmount,\n                token,\n                '',\n                _projectMetadata\n              );\n            else\n              _terminal.pay{value: _payableValue}(\n                _split.projectId,\n                _netPayoutAmount,\n                token,\n                _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,\n                0,\n                _split.preferClaimed,\n                '',\n                _projectMetadata\n              );\n          }\n        } else {\n          unchecked {\n            _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT\n              ? _payoutAmount\n              : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);\n          }\n\n          // This distribution is eligible for a fee since the funds are leaving the ecosystem.\n          feeEligibleDistributionAmount += _payoutAmount;\n\n          // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.\n          _transferFrom(\n            address(this),\n            _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),\n            _netPayoutAmount\n          );\n        }\n\n        // Subtract from the amount to be sent to the beneficiary.\n        unchecked {\n          leftoverAmount = leftoverAmount - _payoutAmount;\n        }\n      }\n\n      emit DistributeToPayoutSplit(\n        _projectId,\n        _domain,\n        _group,\n        _split,\n        _netPayoutAmount,\n        msg.sender\n      );\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /\n    @notice\n    Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID.\n\n    @param _projectId The ID of the project having fees taken from.\n    @param _fundingCycle The funding cycle during which the fee is being taken.\n    @param _amount The amount of the fee to take, as a floating point number with 18 decimals.\n    @param _beneficiary The address to mint the platforms tokens for.\n    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.\n\n    @return feeAmount The amount of the fee taken.\n  */\n  function _takeFeeFrom(\n    uint256 _projectId,\n    JBFundingCycle memory _fundingCycle,\n    uint256 _amount,\n    address _beneficiary,\n    uint256 _feeDiscount\n  ) internal returns (uint256 feeAmount) {\n    feeAmount = _feeAmount(_amount, fee, _feeDiscount);\n\n    if (_fundingCycle.shouldHoldFees()) {\n      // Store the held fee.\n      _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));\n\n      emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender);\n    } else {\n      // Process the fee.\n      _processFee(feeAmount, _beneficiary); // Take the fee.\n\n      emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender);\n    }\n  }\n\n  /\n    @notice\n    Process a fee of the specified amount.\n\n    @param _amount The fee amount, as a floating point number with 18 decimals.\n    @param _beneficiary The address to mint the platform's tokens for.\n  /\n  function _processFee(uint256 _amount, address _beneficiary) internal {\n    // Get the terminal for the protocol project.\n    IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token);\n\n    // When processing the admin fee, save gas if the admin is using this contract as its terminal.\n    if (_terminal == this)\n      _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call.\n    else {\n      // Trigger any inherited pre-transfer logic.\n      _beforeTransferTo(address(_terminal), _amount);\n\n      // If this terminal's token is ETH, send it in msg.value.\n      uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;\n\n      // Send the payment.\n      _terminal.pay{value: _payableValue}(\n        _PROTOCOL_PROJECT_ID,\n        _amount,\n        token,\n        _beneficiary,\n        0,\n        false,\n        '',\n        bytes('')\n      ); // Use the external pay call of the correct terminal.\n    }\n  }\n\n  /\n    @notice\n    Contribute tokens to a project.\n\n    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.\n    @param _payer The address making the payment.\n    @param _projectId The ID of the project being paid.\n    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.\n    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.\n    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.\n    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.\n    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.\n\n    @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.\n  /\n  function _pay(\n    uint256 _amount,\n    address _payer,\n    uint256 _projectId,\n    address _beneficiary,\n    uint256 _minReturnedTokens,\n    bool _preferClaimedTokens,\n    string memory _memo,\n    bytes memory _metadata\n  ) internal returns (uint256 beneficiaryTokenCount) {\n    // Cant send tokens to the zero address.\n    if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS();\n\n    // Define variables that will be needed outside the scoped section below.\n    // Keep a reference to the funding cycle during which the payment is being made.\n    JBFundingCycle memory _fundingCycle;\n\n    // Scoped section prevents stack too deep. _delegate and _tokenCount only used within scope.\n    {\n      IJBPayDelegate _delegate;\n      uint256 _tokenCount;\n\n      // Bundle the amount info into a JBTokenAmount struct.\n      JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);\n\n      // Record the payment.\n      (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(\n        _payer,\n        _bundledAmount,\n        _projectId,\n        baseWeightCurrency,\n        _beneficiary,\n        _memo,\n        _metadata\n      );\n\n      // Mint the tokens if needed.\n      if (_tokenCount &gt; 0)\n        // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.\n        beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(\n          _projectId,\n          _tokenCount,\n          _beneficiary,\n          '',\n          _preferClaimedTokens,\n          true\n        );\n\n      // The token count for the beneficiary must be greater than or equal to the minimum expected.\n      if (beneficiaryTokenCount &lt; _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();\n\n      // If a delegate was returned by the data source, issue a callback to it.\n      if (_delegate != IJBPayDelegate(address(0))) {\n        JBDidPayData memory _data = JBDidPayData(\n          _payer,\n          _projectId,\n          _fundingCycle.configuration,\n          _bundledAmount,\n          beneficiaryTokenCount,\n          _beneficiary,\n          _preferClaimedTokens,\n          _memo,\n          _metadata\n        );\n\n        _delegate.didPay(_data);\n        emit DelegateDidPay(_delegate, _data, msg.sender);\n      }\n    }\n\n    emit Pay(\n      _fundingCycle.configuration,\n      _fundingCycle.number,\n      _projectId,\n      _payer,\n      _beneficiary,\n      _amount,\n      beneficiaryTokenCount,\n      _memo,\n      _metadata,\n      msg.sender\n    );\n  }\n\n  /\n    @notice\n    Receives funds belonging to the specified project.\n\n    @param _projectId The ID of the project to which the funds received belong.\n    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.\n    @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added.\n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Extra data to pass along to the emitted event.\n  */\n  function _addToBalanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    bool _shouldRefundHeldFees,\n    string memory _memo,\n    bytes memory _metadata\n  ) internal {\n    // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.\n    uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0;\n\n    // Record the added funds with any refunded fees.\n    store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);\n\n    emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);\n  }\n\n  /\n    @notice\n    Refund fees based on the specified amount.\n\n    @param _projectId The project for which fees are being refunded.\n    @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.\n\n    @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal\n  /\n  function _refundHeldFees(uint256 _projectId, uint256 _amount)\n    internal\n    returns (uint256 refundedFees)\n  {\n    // Get a reference to the project's held fees.\n    JBFee[] memory _heldFees = _heldFeesOf[_projectId];\n\n    // Delete the current held fees.\n    delete _heldFeesOf[_projectId];\n\n    // Get a reference to the leftover amount once all fees have been settled.\n    uint256 leftoverAmount = _amount;\n\n    // Push length in stack\n    uint256 _heldFeesLength = _heldFees.length;\n\n    // Process each fee.\n    for (uint256 _i = 0; _i &lt; _heldFeesLength; ) {\n      if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);\n      else if (leftoverAmount &gt;= _heldFees[_i].amount) {\n        unchecked {\n          leftoverAmount = leftoverAmount - _heldFees[_i].amount;\n          refundedFees += _feeAmount(\n            _heldFees[_i].amount,\n            _heldFees[_i].fee,\n            _heldFees[_i].feeDiscount\n          );\n        }\n      } else {\n        _heldFeesOf[_projectId].push(\n          JBFee(\n            _heldFees[_i].amount - leftoverAmount,\n            _heldFees[_i].fee,\n            _heldFees[_i].feeDiscount,\n            _heldFees[_i].beneficiary\n          )\n        );\n        unchecked {\n          refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);\n        }\n        leftoverAmount = 0;\n      }\n\n      unchecked {\n        ++_i;\n      }\n    }\n\n    emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);\n  }\n\n  / \n    @notice \n    Returns the fee amount based on the provided amount for the specified project.\n\n    @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal.\n    @param _fee The percentage of the fee, out of MAX_FEE. \n    @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.\n\n    @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.\n  /\n  function _feeAmount(\n    uint256 _amount,\n    uint256 _fee,\n    uint256 _feeDiscount\n  ) internal pure returns (uint256) {\n    // Calculate the discounted fee.\n    uint256 _discountedFee = _fee -\n      PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT);\n\n    // The amount of tokens from the _amount to pay as a fee.\n    return\n      _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);\n  }\n\n  /* \n    @notice\n    Get the fee discount from the fee gauge for the specified project.\n\n    @param _projectId The ID of the project to get a fee discount for.\n    \n    @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.\n  /\n  function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {\n    // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.\n    if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))\n      return JBConstants.MAX_FEE_DISCOUNT;\n\n    // Get the fee discount.\n    if (feeGauge == IJBFeeGauge(address(0)))\n      feeDiscount = 0;\n      // If the guage reverts, set the discount to 0.\n    else\n      try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {\n        feeDiscount = discount;\n      } catch {\n        feeDiscount = 0;\n      }\n\n    // If the fee discount is greater than the max, nullify the discount.\n    if (feeDiscount &gt; JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;\n  }\n}\n", 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 17:18:09 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/security/ReentrancyGuard.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './../interfaces/IJBController.sol'; import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol'; import './../libraries/JBConstants.sol'; import './../libraries/JBCurrencies.sol'; import './../libraries/JBFixedPointNumber.sol'; import './../libraries/JBFundingCycleMetadataResolver.sol'; import './../libraries/JBOperations.sol'; import './../libraries/JBSplitsGroups.sol'; import './../libraries/JBTokens.sol'; import './../structs/JBTokenAmount.sol'; import './JBOperatable.sol'; import './JBSingleTokenPaymentTerminal.sol'; /**   @notice   Generic terminal managing all inflows and outflows of funds into the protocol ecosystem. @dev   A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time. @dev   Adheres to -   IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules. @dev   Inherits from -   JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.   JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.   Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.   ReentrancyGuard: Contract module that helps prevent reentrant calls to a function. */ abstract contract JBPayoutRedemptionPaymentTerminal is   IJBPayoutRedemptionPaymentTerminal,   JBSingleTokenPaymentTerminal,   JBOperatable,   Ownable,   ReentrancyGuard {   // A library that parses the packed funding cycle metadata into a friendlier format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error FEE_TOO_HIGH();   error INADEQUATE_DISTRIBUTION_AMOUNT();   error INADEQUATE_RECLAIM_AMOUNT();   error INADEQUATE_TOKEN_COUNT();   error NO_MSG_VALUE_ALLOWED();   error PAY_TO_ZERO_ADDRESS();   error PROJECT_TERMINAL_MISMATCH();   error REDEEM_TO_ZERO_ADDRESS();   error TERMINAL_IN_SPLIT_ZERO_ADDRESS();   error TERMINAL_TOKENS_INCOMPATIBLE(); //***********//   // ---------------------------- modifiers ---------------------------- //   //*************// /*      @notice      A modifier that verifies this terminal is a terminal of provided project ID.   /   modifier isTerminalOf(uint256 projectId) {     if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();     ;   } //***********//   // --------------------- internal stored constants ------------------- //   //*************// /**     @notice     Maximum fee that can be set for a funding cycle configuration. @dev Out of MAX_FEE (50_000_000 / 1_000_000_000).  */   uint256 internal constant _FEE_CAP = 50_000_000; /*     @notice     The protocol project ID is 1, as it should be the first project launched during the deployment process.   /   uint256 internal constant _PROTOCOL_PROJECT_ID = 1; //***********//   // --------------------- internal stored properties ------------------ //   //*************// /**     @notice     Fees that are being held to be processed later. _projectId The ID of the project for which fees are being held.  */   mapping(uint256 =&gt; JBFee[]) internal _heldFeesOf; //***********//   // ---------------- public immutable stored properties --------------- //   //*************// /*     @notice     Mints ERC-721's that represent project ownership and transfers.   /   IJBProjects public immutable override projects; /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; /*     @notice     The contract that stores splits for each project.   /   IJBSplitsStore public immutable override splitsStore; /*     @notice     The contract that exposes price feeds.   /   IJBPrices public immutable override prices; /*     @notice     The contract that stores and manages the terminal's data.   /   IJBSingleTokenPaymentTerminalStore public immutable override store; /**     @notice     The currency to base token issuance on. @dev If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.  */   uint256 public immutable override baseWeightCurrency; /*     @notice     The group that payout splits coming from this terminal are identified by.   /   uint256 public immutable override payoutSplitsGroup; //***********//   // --------------------- public stored properties -------------------- //   //*************// /**     @notice     The platform fee percent. @dev Out of MAX_FEE (25_000_000 / 1_000_000_000)  */   uint256 public override fee = 25_000_000; // 2.5% /*     @notice     The data source that returns a discount to apply to a project's fee.   /   IJBFeeGauge public override feeGauge; /**     @notice     Addresses that can be paid towards from this terminal without incurring a fee. _address The address that can be paid toward.  */   mapping(address =&gt; bool) public override isFeelessAddress; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     Gets the current overflowed amount in this terminal for a specified project, in terms of ETH. @dev The current overflow is represented as a fixed point number with 18 decimals.  @param _projectId The ID of the project to get overflow for.  @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.  */   function currentEthOverflowOf(uint256 _projectId)     external     view     virtual     override     returns (uint256)   {     // Get this terminal's current overflow.     uint256 _overflow = store.currentOverflowOf(this, _projectId); // Adjust the decimals of the fixed point number if needed to have 18 decimals. uint256 _adjustedOverflow = (decimals == 18)   ? _overflow   : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);  // Return the amount converted to ETH. return   (currency == JBCurrencies.ETH)     ? _adjustedOverflow     : PRBMath.mulDiv(       _adjustedOverflow,       10**decimals,       prices.priceFor(currency, JBCurrencies.ETH, decimals)     );  } /**     @notice     The fees that are currently being held to be processed later for each project. @param _projectId The ID of the project for which fees are being held.  @return An array of fees that are being held.  */   function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {     return _heldFeesOf[_projectId];   } //***********//   // -------------------------- public views --------------------------- //   //*************// /**     @notice     Indicates if this contract adheres to the specified interface. @dev  See {IERC165-supportsInterface}.  @param _interfaceId The ID of the interface to check for adherance to.  */   function supportsInterface(bytes4 _interfaceId)     public     view     virtual     override(JBSingleTokenPaymentTerminal, IERC165)     returns (bool)   {     return       _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||       _interfaceId == type(IJBPayoutTerminal).interfaceId ||       _interfaceId == type(IJBAllowanceTerminal).interfaceId ||       _interfaceId == type(IJBRedemptionTerminal).interfaceId ||       _interfaceId == type(IJBOperatable).interfaceId ||       super.supportsInterface(_interfaceId);   } //***********//   // -------------------------- constructor ---------------------------- //   //*************// /*     @param _token The token that this terminal manages.     @param _decimals The number of decimals the token fixed point amounts are expected to have.     @param _currency The currency that this terminal's token adheres to for price feeds.     @param _baseWeightCurrency The currency to base token issuance on.     @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.     @param _operatorStore A contract storing operator assignments.     @param _projects A contract which mints ERC-721's that represent project ownership and transfers.     @param _directory A contract storing directories of terminals and controllers for each project.     @param _splitsStore A contract that stores splits for each project.     @param _prices A contract that exposes price feeds.     @param _store A contract that stores the terminal's data.     @param _owner The address that will own this contract.   /   constructor(     // payable constructor save the gas used to check msg.value==0     address _token,     uint256 _decimals,     uint256 _currency,     uint256 _baseWeightCurrency,     uint256 _payoutSplitsGroup,     IJBOperatorStore _operatorStore,     IJBProjects _projects,     IJBDirectory _directory,     IJBSplitsStore _splitsStore,     IJBPrices _prices,     IJBSingleTokenPaymentTerminalStore _store,     address _owner   )     payable     JBSingleTokenPaymentTerminal(_token, _decimals, _currency)     JBOperatable(_operatorStore)   {     baseWeightCurrency = _baseWeightCurrency;     payoutSplitsGroup = _payoutSplitsGroup;     projects = _projects;     directory = _directory;     splitsStore = _splitsStore;     prices = _prices;     store = _store; transferOwnership(_owner);  } //***********//   // ---------------------- external transactions ---------------------- //   //*************// /**     @notice     Contribute tokens to a project. @param _projectId The ID of the project being paid. @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place. @param _token The token being paid. This terminal ignores this property since it only manages one token.  @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate. @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal. @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas. @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.  */   function pay(     uint256 _projectId,     uint256 _amount,     address _token,     address _beneficiary,     uint256 _minReturnedTokens,     bool _preferClaimedTokens,     string calldata _memo,     bytes calldata _metadata   ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {     _token; // Prevents unused var compiler and natspec complaints. // ETH shouldn't be sent if this terminal's token isn't ETH. if (token != JBTokens.ETH) {   if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();    // Transfer tokens to this terminal from the msg sender.   _transferFrom(msg.sender, payable(address(this)), _amount); } // If this terminal's token is ETH, override _amount with msg.value. else _amount = msg.value;  return   _pay(     _amount,     msg.sender,     _projectId,     _beneficiary,     _minReturnedTokens,     _preferClaimedTokens,     _memo,     _metadata   );  } /**     @notice     Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source. @dev Only a token holder or a designated operator can redeem its tokens.  @param _holder The account to redeem tokens for. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _token The token being reclaimed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal. @param _beneficiary The address to send the terminal tokens to. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.  */   function redeemTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     address _token,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo,     bytes memory _metadata   )     external     virtual     override     requirePermission(_holder, _projectId, JBOperations.REDEEM)     returns (uint256 reclaimAmount)   {     _token; // Prevents unused var compiler and natspec complaints. return   _redeemTokensOf(     _holder,     _projectId,     _tokenCount,     _minReturnedTokens,     _beneficiary,     _memo,     _metadata   );  } /**     @notice     Distributes payouts for a project with the distribution limit of its current funding cycle. @dev Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.  @dev Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.  @dev All funds distributed outside of this contract or any feeless terminals incure the protocol fee.  @param _projectId The ID of the project having its payouts distributed. @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency. @param _token The token being distributed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal. @param _memo A memo to pass along to the emitted event.  @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.  */   function distributePayoutsOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     address _token,     uint256 _minReturnedTokens,     string calldata _memo   ) external virtual override returns (uint256 netLeftoverDistributionAmount) {     _token; // Prevents unused var compiler and natspec complaints. return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);  } /**     @notice     Allows a project to send funds from its overflow up to the preconfigured allowance. @dev Only a project's owner or a designated operator can use its allowance.  @dev Incurs the protocol fee.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency. @param _token The token being distributed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals. @param _beneficiary The address to send the funds to. @param _memo A memo to pass along to the emitted event.  @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.  */   function useAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     address _token,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)     returns (uint256 netDistributedAmount)   {     _token; // Prevents unused var compiler and natspec complaints. return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);  } /**     @notice     Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type. @dev Only a project's owner or a designated operator can migrate it.  @param _projectId The ID of the project being migrated. @param _to The terminal contract that will gain the project's funds.  @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.  */   function migrate(uint256 _projectId, IJBPaymentTerminal _to)     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)     returns (uint256 balance)   {     // The terminal being migrated to must accept the same token as this terminal.     if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE(); // Record the migration in the store. balance = store.recordMigration(_projectId);  // Transfer the balance if needed. if (balance &gt; 0) {   // Trigger any inherited pre-transfer logic.   _beforeTransferTo(address(_to), balance);    // If this terminal's token is ETH, send it in msg.value.   uint256 _payableValue = token == JBTokens.ETH ? balance : 0;    // Withdraw the balance to transfer to the new terminal;   _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes('')); }  emit Migrate(_projectId, _to, balance, msg.sender);  } /**     @notice     Receives funds belonging to the specified project. @param _projectId The ID of the project to which the funds received belong. @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead. @param _token The token being paid. This terminal ignores this property since it only manages one currency.  @param _memo A memo to pass along to the emitted event. @param _metadata Extra data to pass along to the emitted event.  */   function addToBalanceOf(     uint256 _projectId,     uint256 _amount,     address _token,     string calldata _memo,     bytes calldata _metadata   ) external payable virtual override isTerminalOf(_projectId) {     _token; // Prevents unused var compiler and natspec complaints. // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender. if (token != JBTokens.ETH) {   // Amount must be greater than 0.   if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();    // Transfer tokens to this terminal from the msg sender.   _transferFrom(msg.sender, payable(address(this)), _amount); } // If the terminal's token is ETH, override `_amount` with msg.value. else _amount = msg.value;  // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal. _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);  } /**     @notice     Process any fees that are being held for the project. @dev Only a project owner, an operator, or the contract's owner can process held fees.  @param _projectId The ID of the project whos held fees should be processed.  */   function processFees(uint256 _projectId)     external     virtual     override     requirePermissionAllowingOverride(       projects.ownerOf(_projectId),       _projectId,       JBOperations.PROCESS_FEES,       msg.sender == owner()     )   {     // Get a reference to the project's held fees.     JBFee[] memory _heldFees = _heldFeesOf[_projectId]; // Delete the held fees. delete _heldFeesOf[_projectId];  // Push array length in stack uint256 _heldFeeLength = _heldFees.length;  // Process each fee. for (uint256 _i = 0; _i &lt; _heldFeeLength; ) {   // Get the fee amount.   uint256 _amount = _feeAmount(     _heldFees[_i].amount,     _heldFees[_i].fee,     _heldFees[_i].feeDiscount   );    // Process the fee.   _processFee(_amount, _heldFees[_i].beneficiary);    emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);    unchecked {     ++_i;   } }  } /**     @notice     Allows the fee to be updated. @dev Only the owner of this contract can change the fee.  @param _fee The new fee, out of MAX_FEE.  */   function setFee(uint256 _fee) external virtual override onlyOwner {     // The provided fee must be within the max.     if (_fee &gt; _FEE_CAP) revert FEE_TOO_HIGH(); // Store the new fee. fee = _fee;  emit SetFee(_fee, msg.sender);  } /**     @notice     Allows the fee gauge to be updated. @dev Only the owner of this contract can change the fee gauge.  @dev If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.  @param _feeGauge The new fee gauge.  */   function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {     // Store the new fee gauge.     feeGauge = _feeGauge; emit SetFeeGauge(_feeGauge, msg.sender);  } /**     @notice     Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee. @dev Only the owner of this contract can set addresses as feeless.  @param _address The address that can be paid towards while still bypassing fees. @param _flag A flag indicating whether the terminal should be feeless or not.  */   function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {     // Set the flag value.     isFeelessAddress[_address] = _flag; emit SetFeelessAddress(_address, _flag, msg.sender);  } //***********//   // ---------------------- internal transactions ---------------------- //   //*************// /**      @notice     Transfers tokens. @param _from The address from which the transfer should originate. @param _to The address to which the transfer should go. @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.  */   function _transferFrom(     address _from,     address payable _to,     uint256 _amount   ) internal virtual; /**      @notice     Logic to be triggered before transferring tokens from this terminal. @param _to The address to which the transfer is going. @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.  */   function _beforeTransferTo(address _to, uint256 _amount) internal virtual; /**     @notice     Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source. @dev Only a token holder or a designated operator can redeem its tokens.  @param _holder The account to redeem tokens for. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal. @param _beneficiary The address to send the terminal tokens to. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.  */   function _redeemTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo,     bytes memory _metadata   ) internal returns (uint256 reclaimAmount) {     // Can't send reclaimed funds to the zero address.     if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS(); // Define variables that will be needed outside the scoped section below. // Keep a reference to the funding cycle during which the redemption is being made. JBFundingCycle memory _fundingCycle;  // Scoped section prevents stack too deep. `_delegate` only used within scope. {   IJBRedemptionDelegate _delegate;    // Record the redemption.   (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(     _holder,     _projectId,     _tokenCount,     _memo,     _metadata   );    // The amount being reclaimed must be at least as much as was expected.   if (reclaimAmount &lt; _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();    // Burn the project tokens.   if (_tokenCount &gt; 0)     IJBController(directory.controllerOf(_projectId)).burnTokensOf(       _holder,       _projectId,       _tokenCount,       '',       false     );    // If a delegate was returned by the data source, issue a callback to it.   if (_delegate != IJBRedemptionDelegate(address(0))) {     JBDidRedeemData memory _data = JBDidRedeemData(       _holder,       _projectId,       _fundingCycle.configuration,       _tokenCount,       JBTokenAmount(token, reclaimAmount, decimals, currency),       _beneficiary,       _memo,       _metadata     );     _delegate.didRedeem(_data);     emit DelegateDidRedeem(_delegate, _data, msg.sender);   } }  // Send the reclaimed funds to the beneficiary. if (reclaimAmount &gt; 0) _transferFrom(address(this), _beneficiary, reclaimAmount);  emit RedeemTokens(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _holder,   _beneficiary,   _tokenCount,   reclaimAmount,   _memo,   _metadata,   msg.sender );  } /**     @notice     Distributes payouts for a project with the distribution limit of its current funding cycle. @dev Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.  @dev Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.  @dev All funds distributed outside of this contract or any feeless terminals incure the protocol fee.  @param _projectId The ID of the project having its payouts distributed. @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency. @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal. @param _memo A memo to pass along to the emitted event.  @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.  */   function _distributePayoutsOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     uint256 _minReturnedTokens,     string calldata _memo   ) internal returns (uint256 netLeftoverDistributionAmount) {     // Record the distribution.     (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(       _projectId,       _amount,       _currency     ); // The amount being distributed must be at least as much as was expected. if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();  // Get a reference to the project owner, which will receive tokens from paying the platform fee // and receive any extra distributable funds not allocated to payout splits. address payable _projectOwner = payable(projects.ownerOf(_projectId));  // Define variables that will be needed outside the scoped section below. // Keep a reference to the fee amount that was paid. uint256 _fee;  // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope. {   // Get the amount of discount that should be applied to any fees taken.   // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.   uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]     ? JBConstants.MAX_FEE_DISCOUNT     : _currentFeeDiscount(_projectId);    // The amount distributed that is eligible for incurring fees.   uint256 _feeEligibleDistributionAmount;    // The amount leftover after distributing to the splits.   uint256 _leftoverDistributionAmount;    // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.   // Also get a reference to the amount that was distributed to splits from which fees should be taken.   (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(     _projectId,     _fundingCycle.configuration,     payoutSplitsGroup,     _distributedAmount,     _feeDiscount   );    // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.   unchecked {     _feeEligibleDistributionAmount += _leftoverDistributionAmount;   }    // Take the fee.   _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0     ? 0     : _takeFeeFrom(       _projectId,       _fundingCycle,       _feeEligibleDistributionAmount,       _projectOwner,       _feeDiscount     );    // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.    unchecked {     netLeftoverDistributionAmount = _leftoverDistributionAmount == 0       ? 0       : _leftoverDistributionAmount -         _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);   }    // Transfer any remaining balance to the project owner.   if (netLeftoverDistributionAmount &gt; 0)     _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount); }  emit DistributePayouts(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _projectOwner,   _amount,   _distributedAmount,   _fee,   netLeftoverDistributionAmount,   _memo,   msg.sender );  } /**     @notice     Allows a project to send funds from its overflow up to the preconfigured allowance. @dev Only a project's owner or a designated operator can use its allowance.  @dev Incurs the protocol fee.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency. @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals. @param _beneficiary The address to send the funds to. @param _memo A memo to pass along to the emitted event.  @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.  */   function _useAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo   ) internal returns (uint256 netDistributedAmount) {     // Record the use of the allowance.     (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(       _projectId,       _amount,       _currency     ); // The amount being withdrawn must be at least as much as was expected. if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();  // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope. {   // Keep a reference to the fee amount that was paid.   uint256 _fee;    // Get a reference to the project owner, which will receive tokens from paying the platform fee.   address _projectOwner = projects.ownerOf(_projectId);    // Get the amount of discount that should be applied to any fees taken.   // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.   uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]     ? JBConstants.MAX_FEE_DISCOUNT     : _currentFeeDiscount(_projectId);    // Take a fee from the `_distributedAmount`, if needed.   _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT     ? 0     : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);    unchecked {     // The net amount is the withdrawn amount without the fee.     netDistributedAmount = _distributedAmount - _fee;   }    // Transfer any remaining balance to the beneficiary.   if (netDistributedAmount &gt; 0)     _transferFrom(address(this), _beneficiary, netDistributedAmount); }  emit UseAllowance(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _beneficiary,   _amount,   _distributedAmount,   netDistributedAmount,   _memo,   msg.sender );  } /**     @notice     Pays out splits for a project's funding cycle configuration. @param _projectId The ID of the project for which payout splits are being distributed. @param _domain The domain of the splits to distribute the payout between. @param _group The group of the splits to distribute the payout between. @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal. @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.  @return leftoverAmount If the leftover amount if the splits don't add up to 100%. @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.  */   function _distributeToPayoutSplitsOf(     uint256 _projectId,     uint256 _domain,     uint256 _group,     uint256 _amount,     uint256 _feeDiscount   ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {     // Set the leftover amount to the initial amount.     leftoverAmount = _amount; // Get a reference to the project's payout splits. JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);  // Transfer between all splits. for (uint256 _i = 0; _i &lt; _splits.length; ) {   // Get a reference to the split being iterated on.   JBSplit memory _split = _splits[_i];    // The amount to send towards the split.   uint256 _payoutAmount = PRBMath.mulDiv(     _amount,     _split.percent,     JBConstants.SPLITS_TOTAL_PERCENT   );    // The payout amount substracting any applicable incurred fees.   uint256 _netPayoutAmount;    if (_payoutAmount &gt; 0) {     // Transfer tokens to the split.     // If there's an allocator set, transfer to its `allocate` function.     if (_split.allocator != IJBSplitAllocator(address(0))) {       // If the split allocator is set as feeless, this distribution is not eligible for a fee.       if (isFeelessAddress[address(_split.allocator)])         _netPayoutAmount = _payoutAmount;         // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.       else {         unchecked {           _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT             ? _payoutAmount             : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);         }          // This distribution is eligible for a fee since the funds are leaving the ecosystem.         feeEligibleDistributionAmount += _payoutAmount;       }        // Trigger any inherited pre-transfer logic.       _beforeTransferTo(address(_split.allocator), _netPayoutAmount);        // If this terminal's token is ETH, send it in msg.value.       uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;        // Create the data to send to the allocator.       JBSplitAllocationData memory _data = JBSplitAllocationData(         token,         _netPayoutAmount,         decimals,         _projectId,         _group,         _split       );        // Trigger the allocator's `allocate` function.       _split.allocator.allocate{value: _payableValue}(_data);        // Otherwise, if a project is specified, make a payment to it.     } else if (_split.projectId != 0) {       // Get a reference to the Juicebox terminal being used.       IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);        // The project must have a terminal to send funds to.       if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();        // Save gas if this contract is being used as the terminal.       if (_terminal == this) {         // This distribution does not incur a fee.         _netPayoutAmount = _payoutAmount;          // Send the projectId in the metadata.         bytes memory _projectMetadata = new bytes(32);         _projectMetadata = bytes(abi.encodePacked(_projectId));          // Add to balance if prefered.         if (_split.preferAddToBalance)           _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);         else           _pay(             _netPayoutAmount,             address(this),             _split.projectId,             (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,             0,             _split.preferClaimed,             '',             _projectMetadata           );       } else {         // If the terminal is set as feeless, this distribution is not eligible for a fee.         if (isFeelessAddress[address(_terminal)])           _netPayoutAmount = _payoutAmount;           // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.         else {           unchecked {             _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT               ? _payoutAmount               : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);           }            feeEligibleDistributionAmount += _payoutAmount;         }          // Trigger any inherited pre-transfer logic.         _beforeTransferTo(address(_terminal), _netPayoutAmount);          // If this terminal's token is ETH, send it in msg.value.         uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;          // Send the projectId in the metadata.         bytes memory _projectMetadata = new bytes(32);         _projectMetadata = bytes(abi.encodePacked(_projectId));          // Add to balance if prefered.         if (_split.preferAddToBalance)           _terminal.addToBalanceOf{value: _payableValue}(             _split.projectId,             _netPayoutAmount,             token,             '',             _projectMetadata           );         else           _terminal.pay{value: _payableValue}(             _split.projectId,             _netPayoutAmount,             token,             _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,             0,             _split.preferClaimed,             '',             _projectMetadata           );       }     } else {       unchecked {         _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT           ? _payoutAmount           : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);       }        // This distribution is eligible for a fee since the funds are leaving the ecosystem.       feeEligibleDistributionAmount += _payoutAmount;        // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.       _transferFrom(         address(this),         _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),         _netPayoutAmount       );     }      // Subtract from the amount to be sent to the beneficiary.     unchecked {       leftoverAmount = leftoverAmount - _payoutAmount;     }   }    emit DistributeToPayoutSplit(     _projectId,     _domain,     _group,     _split,     _netPayoutAmount,     msg.sender   );    unchecked {     ++_i;   } }  } /**     @notice     Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID. @param _projectId The ID of the project having fees taken from. @param _fundingCycle The funding cycle during which the fee is being taken. @param _amount The amount of the fee to take, as a floating point number with 18 decimals. @param _beneficiary The address to mint the platforms tokens for. @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.  @return feeAmount The amount of the fee taken.  */   function _takeFeeFrom(     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _amount,     address _beneficiary,     uint256 _feeDiscount   ) internal returns (uint256 feeAmount) {     feeAmount = _feeAmount(_amount, fee, _feeDiscount); if (_fundingCycle.shouldHoldFees()) {   // Store the held fee.   _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));    emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender); } else {   // Process the fee.   _processFee(feeAmount, _beneficiary); // Take the fee.    emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender); }  } /**     @notice     Process a fee of the specified amount. @param _amount The fee amount, as a floating point number with 18 decimals. @param _beneficiary The address to mint the platform's tokens for.  */   function _processFee(uint256 _amount, address _beneficiary) internal {     // Get the terminal for the protocol project.     IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token); // When processing the admin fee, save gas if the admin is using this contract as its terminal. if (_terminal == this)   _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call. else {   // Trigger any inherited pre-transfer logic.   _beforeTransferTo(address(_terminal), _amount);    // If this terminal's token is ETH, send it in msg.value.   uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;    // Send the payment.   _terminal.pay{value: _payableValue}(     _PROTOCOL_PROJECT_ID,     _amount,     token,     _beneficiary,     0,     false,     '',     bytes('')   ); // Use the external pay call of the correct terminal. }  } /**     @notice     Contribute tokens to a project. @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place. @param _payer The address making the payment. @param _projectId The ID of the project being paid. @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate. @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal. @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas. @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.  */   function _pay(     uint256 _amount,     address _payer,     uint256 _projectId,     address _beneficiary,     uint256 _minReturnedTokens,     bool _preferClaimedTokens,     string memory _memo,     bytes memory _metadata   ) internal returns (uint256 beneficiaryTokenCount) {     // Cant send tokens to the zero address.     if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS(); // Define variables that will be needed outside the scoped section below. // Keep a reference to the funding cycle during which the payment is being made. JBFundingCycle memory _fundingCycle;  // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope. {   IJBPayDelegate _delegate;   uint256 _tokenCount;    // Bundle the amount info into a JBTokenAmount struct.   JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);    // Record the payment.   (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(     _payer,     _bundledAmount,     _projectId,     baseWeightCurrency,     _beneficiary,     _memo,     _metadata   );    // Mint the tokens if needed.   if (_tokenCount &gt; 0)     // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.     beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(       _projectId,       _tokenCount,       _beneficiary,       '',       _preferClaimedTokens,       true     );    // The token count for the beneficiary must be greater than or equal to the minimum expected.   if (beneficiaryTokenCount &lt; _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();    // If a delegate was returned by the data source, issue a callback to it.   if (_delegate != IJBPayDelegate(address(0))) {     JBDidPayData memory _data = JBDidPayData(       _payer,       _projectId,       _fundingCycle.configuration,       _bundledAmount,       beneficiaryTokenCount,       _beneficiary,       _preferClaimedTokens,       _memo,       _metadata     );      _delegate.didPay(_data);     emit DelegateDidPay(_delegate, _data, msg.sender);   } }  emit Pay(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _payer,   _beneficiary,   _amount,   beneficiaryTokenCount,   _memo,   _metadata,   msg.sender );  } /**     @notice     Receives funds belonging to the specified project. @param _projectId The ID of the project to which the funds received belong. @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead. @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added. @param _memo A memo to pass along to the emitted event. @param _metadata Extra data to pass along to the emitted event.  */   function _addToBalanceOf(     uint256 _projectId,     uint256 _amount,     bool _shouldRefundHeldFees,     string memory _memo,     bytes memory _metadata   ) internal {     // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.     uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0; // Record the added funds with any refunded fees. store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);  emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);  } /**     @notice     Refund fees based on the specified amount. @param _projectId The project for which fees are being refunded. @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.  @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal  */   function _refundHeldFees(uint256 _projectId, uint256 _amount)     internal     returns (uint256 refundedFees)   {     // Get a reference to the project's held fees.     JBFee[] memory _heldFees = _heldFeesOf[_projectId]; // Delete the current held fees. delete _heldFeesOf[_projectId];  // Get a reference to the leftover amount once all fees have been settled. uint256 leftoverAmount = _amount;  // Push length in stack uint256 _heldFeesLength = _heldFees.length;  // Process each fee. for (uint256 _i = 0; _i &lt; _heldFeesLength; ) {   if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);   else if (leftoverAmount &gt;= _heldFees[_i].amount) {     unchecked {       leftoverAmount = leftoverAmount - _heldFees[_i].amount;       refundedFees += _feeAmount(         _heldFees[_i].amount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount       );     }   } else {     _heldFeesOf[_projectId].push(       JBFee(         _heldFees[_i].amount - leftoverAmount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount,         _heldFees[_i].beneficiary       )     );     unchecked {       refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);     }     leftoverAmount = 0;   }    unchecked {     ++_i;   } }  emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);  } /**      @notice      Returns the fee amount based on the provided amount for the specified project. @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal. @param _fee The percentage of the fee, out of MAX_FEE.  @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.  @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.  */   function _feeAmount(     uint256 _amount,     uint256 _fee,     uint256 _feeDiscount   ) internal pure returns (uint256) {     // Calculate the discounted fee.     uint256 _discountedFee = _fee -       PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT); // The amount of tokens from the `_amount` to pay as a fee. return   _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);  } /**      @notice     Get the fee discount from the fee gauge for the specified project. @param _projectId The ID of the project to get a fee discount for.  @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.  */   function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {     // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.     if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))       return JBConstants.MAX_FEE_DISCOUNT; // Get the fee discount. if (feeGauge == IJBFeeGauge(address(0)))   feeDiscount = 0;   // If the guage reverts, set the discount to 0. else   try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {     feeDiscount = discount;   } catch {     feeDiscount = 0;   }  // If the fee discount is greater than the max, nullify the discount. if (feeDiscount &gt; JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 17:18:09 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './../interfaces/IJBController.sol';
import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol';
import './../libraries/JBConstants.sol';
import './../libraries/JBCurrencies.sol';
import './../libraries/JBFixedPointNumber.sol';
import './../libraries/JBFundingCycleMetadataResolver.sol';
import './../libraries/JBOperations.sol';
import './../libraries/JBSplitsGroups.sol';
import './../libraries/JBTokens.sol';
import './../structs/JBTokenAmount.sol';
import './JBOperatable.sol';
import './JBSingleTokenPaymentTerminal.sol';

/**
  @notice
  Generic terminal managing all inflows and outflows of funds into the protocol ecosystem.

  @dev
  A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time.

  @dev
  Adheres to -
  IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.
  JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
abstract contract JBPayoutRedemptionPaymentTerminal is
  IJBPayoutRedemptionPaymentTerminal,
  JBSingleTokenPaymentTerminal,
  JBOperatable,
  Ownable,
  ReentrancyGuard
{
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error FEE_TOO_HIGH();
  error INADEQUATE_DISTRIBUTION_AMOUNT();
  error INADEQUATE_RECLAIM_AMOUNT();
  error INADEQUATE_TOKEN_COUNT();
  error NO_MSG_VALUE_ALLOWED();
  error PAY_TO_ZERO_ADDRESS();
  error PROJECT_TERMINAL_MISMATCH();
  error REDEEM_TO_ZERO_ADDRESS();
  error TERMINAL_IN_SPLIT_ZERO_ADDRESS();
  error TERMINAL_TOKENS_INCOMPATIBLE();

  //*********************************************************************//
  // ---------------------------- modifiers ---------------------------- //
  //*********************************************************************//

  /** 
    @notice 
    A modifier that verifies this terminal is a terminal of provided project ID.
  */
  modifier isTerminalOf(uint256 _projectId) {
    if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();
    _;
  }

  //*********************************************************************//
  // --------------------- internal stored constants ------------------- //
  //*********************************************************************//

  /**
    @notice
    Maximum fee that can be set for a funding cycle configuration.

    @dev
    Out of MAX_FEE (50_000_000 / 1_000_000_000).
  */
  uint256 internal constant _FEE_CAP = 50_000_000;

  /**
    @notice
    The protocol project ID is 1, as it should be the first project launched during the deployment process.
  */
  uint256 internal constant _PROTOCOL_PROJECT_ID = 1;

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    Fees that are being held to be processed later.

    _projectId The ID of the project for which fees are being held.
  */
  mapping(uint256 => JBFee[]) internal _heldFeesOf;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership and transfers.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  /**
    @notice
    The contract that stores and manages the terminal's data.
  */
  IJBSingleTokenPaymentTerminalStore public immutable override store;

  /**
    @notice
    The currency to base token issuance on.

    @dev
    If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.
  */
  uint256 public immutable override baseWeightCurrency;

  /**
    @notice
    The group that payout splits coming from this terminal are identified by.
  */
  uint256 public immutable override payoutSplitsGroup;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The platform fee percent.

    @dev
    Out of MAX_FEE (25_000_000 / 1_000_000_000)
  */
  uint256 public override fee = 25_000_000; // 2.5%

  /**
    @notice
    The data source that returns a discount to apply to a project's fee.
  */
  IJBFeeGauge public override feeGauge;

  /**
    @notice
    Addresses that can be paid towards from this terminal without incurring a fee.

    _address The address that can be paid toward.
  */
  mapping(address => bool) public override isFeelessAddress;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.

    @dev
    The current overflow is represented as a fixed point number with 18 decimals.

    @param _projectId The ID of the project to get overflow for.

    @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.
  */
  function currentEthOverflowOf(uint256 _projectId)
    external
    view
    virtual
    override
    returns (uint256)
  {
    // Get this terminal's current overflow.
    uint256 _overflow = store.currentOverflowOf(this, _projectId);

    // Adjust the decimals of the fixed point number if needed to have 18 decimals.
    uint256 _adjustedOverflow = (decimals == 18)
      ? _overflow
      : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);

    // Return the amount converted to ETH.
    return
      (currency == JBCurrencies.ETH)
        ? _adjustedOverflow
        : PRBMath.mulDiv(
          _adjustedOverflow,
          10**decimals,
          prices.priceFor(currency, JBCurrencies.ETH, decimals)
        );
  }

  /**
    @notice
    The fees that are currently being held to be processed later for each project.

    @param _projectId The ID of the project for which fees are being held.

    @return An array of fees that are being held.
  */
  function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {
    return _heldFeesOf[_projectId];
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(JBSingleTokenPaymentTerminal, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||
      _interfaceId == type(IJBPayoutTerminal).interfaceId ||
      _interfaceId == type(IJBAllowanceTerminal).interfaceId ||
      _interfaceId == type(IJBRedemptionTerminal).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _token The token that this terminal manages.
    @param _decimals The number of decimals the token fixed point amounts are expected to have.
    @param _currency The currency that this terminal's token adheres to for price feeds.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _splitsStore A contract that stores splits for each project.
    @param _prices A contract that exposes price feeds.
    @param _store A contract that stores the terminal's data.
    @param _owner The address that will own this contract.
  */
  constructor(
    // payable constructor save the gas used to check msg.value==0
    address _token,
    uint256 _decimals,
    uint256 _currency,
    uint256 _baseWeightCurrency,
    uint256 _payoutSplitsGroup,
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBSplitsStore _splitsStore,
    IJBPrices _prices,
    IJBSingleTokenPaymentTerminalStore _store,
    address _owner
  )
    payable
    JBSingleTokenPaymentTerminal(_token, _decimals, _currency)
    JBOperatable(_operatorStore)
  {
    baseWeightCurrency = _baseWeightCurrency;
    payoutSplitsGroup = _payoutSplitsGroup;
    projects = _projects;
    directory = _directory;
    splitsStore = _splitsStore;
    prices = _prices;
    store = _store;

    transferOwnership(_owner);
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Contribute tokens to a project.

    @param _projectId The ID of the project being paid.
    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _token The token being paid. This terminal ignores this property since it only manages one token. 
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function pay(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {
    _token; // Prevents unused var compiler and natspec complaints.

    // ETH shouldn't be sent if this terminal's token isn't ETH.
    if (token != JBTokens.ETH) {
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If this terminal's token is ETH, override _amount with msg.value.
    else _amount = msg.value;

    return
      _pay(
        _amount,
        msg.sender,
        _projectId,
        _beneficiary,
        _minReturnedTokens,
        _preferClaimedTokens,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _token The token being reclaimed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  )
    external
    virtual
    override
    requirePermission(_holder, _projectId, JBOperations.REDEEM)
    returns (uint256 reclaimAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return
      _redeemTokensOf(
        _holder,
        _projectId,
        _tokenCount,
        _minReturnedTokens,
        _beneficiary,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) external virtual override returns (uint256 netLeftoverDistributionAmount) {
    _token; // Prevents unused var compiler and natspec complaints.

    return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)
    returns (uint256 netDistributedAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);
  }

  /**
    @notice
    Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project being migrated.
    @param _to The terminal contract that will gain the project's funds.

    @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.
  */
  function migrate(uint256 _projectId, IJBPaymentTerminal _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)
    returns (uint256 balance)
  {
    // The terminal being migrated to must accept the same token as this terminal.
    if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE();

    // Record the migration in the store.
    balance = store.recordMigration(_projectId);

    // Transfer the balance if needed.
    if (balance > 0) {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_to), balance);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? balance : 0;

      // Withdraw the balance to transfer to the new terminal;
      _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes(''));
    }

    emit Migrate(_projectId, _to, balance, msg.sender);
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _token The token being paid. This terminal ignores this property since it only manages one currency. 
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) {
    _token; // Prevents unused var compiler and natspec complaints.

    // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender.
    if (token != JBTokens.ETH) {
      // Amount must be greater than 0.
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If the terminal's token is ETH, override `_amount` with msg.value.
    else _amount = msg.value;

    // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal.
    _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);
  }

  /**
    @notice
    Process any fees that are being held for the project.

    @dev
    Only a project owner, an operator, or the contract's owner can process held fees.

    @param _projectId The ID of the project whos held fees should be processed.
  */
  function processFees(uint256 _projectId)
    external
    virtual
    override
    requirePermissionAllowingOverride(
      projects.ownerOf(_projectId),
      _projectId,
      JBOperations.PROCESS_FEES,
      msg.sender == owner()
    )
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the held fees.
    delete _heldFeesOf[_projectId];

    // Push array length in stack
    uint256 _heldFeeLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeeLength; ) {
      // Get the fee amount.
      uint256 _amount = _feeAmount(
        _heldFees[_i].amount,
        _heldFees[_i].fee,
        _heldFees[_i].feeDiscount
      );

      // Process the fee.
      _processFee(_amount, _heldFees[_i].beneficiary);

      emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Allows the fee to be updated.

    @dev
    Only the owner of this contract can change the fee.

    @param _fee The new fee, out of MAX_FEE.
  */
  function setFee(uint256 _fee) external virtual override onlyOwner {
    // The provided fee must be within the max.
    if (_fee > _FEE_CAP) revert FEE_TOO_HIGH();

    // Store the new fee.
    fee = _fee;

    emit SetFee(_fee, msg.sender);
  }

  /**
    @notice
    Allows the fee gauge to be updated.

    @dev
    Only the owner of this contract can change the fee gauge.

    @dev
    If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.

    @param _feeGauge The new fee gauge.
  */
  function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {
    // Store the new fee gauge.
    feeGauge = _feeGauge;

    emit SetFeeGauge(_feeGauge, msg.sender);
  }

  /**
    @notice
    Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.

    @dev
    Only the owner of this contract can set addresses as feeless.

    @param _address The address that can be paid towards while still bypassing fees.
    @param _flag A flag indicating whether the terminal should be feeless or not.
  */
  function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {
    // Set the flag value.
    isFeelessAddress[_address] = _flag;

    emit SetFeelessAddress(_address, _flag, msg.sender);
  }

  //*********************************************************************//
  // ---------------------- internal transactions ---------------------- //
  //*********************************************************************//

  /** 
    @notice
    Transfers tokens.

    @param _from The address from which the transfer should originate.
    @param _to The address to which the transfer should go.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _transferFrom(
    address _from,
    address payable _to,
    uint256 _amount
  ) internal virtual;

  /** 
    @notice
    Logic to be triggered before transferring tokens from this terminal.

    @param _to The address to which the transfer is going.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _beforeTransferTo(address _to, uint256 _amount) internal virtual;

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function _redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 reclaimAmount) {
    // Can't send reclaimed funds to the zero address.
    if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the redemption is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` only used within scope.
    {
      IJBRedemptionDelegate _delegate;

      // Record the redemption.
      (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(
        _holder,
        _projectId,
        _tokenCount,
        _memo,
        _metadata
      );

      // The amount being reclaimed must be at least as much as was expected.
      if (reclaimAmount < _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();

      // Burn the project tokens.
      if (_tokenCount > 0)
        IJBController(directory.controllerOf(_projectId)).burnTokensOf(
          _holder,
          _projectId,
          _tokenCount,
          '',
          false
        );

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBRedemptionDelegate(address(0))) {
        JBDidRedeemData memory _data = JBDidRedeemData(
          _holder,
          _projectId,
          _fundingCycle.configuration,
          _tokenCount,
          JBTokenAmount(token, reclaimAmount, decimals, currency),
          _beneficiary,
          _memo,
          _metadata
        );
        _delegate.didRedeem(_data);
        emit DelegateDidRedeem(_delegate, _data, msg.sender);
      }
    }

    // Send the reclaimed funds to the beneficiary.
    if (reclaimAmount > 0) _transferFrom(address(this), _beneficiary, reclaimAmount);

    emit RedeemTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _holder,
      _beneficiary,
      _tokenCount,
      reclaimAmount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) internal returns (uint256 netLeftoverDistributionAmount) {
    // Record the distribution.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(
      _projectId,
      _amount,
      _currency
    );

    // The amount being distributed must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Get a reference to the project owner, which will receive tokens from paying the platform fee
    // and receive any extra distributable funds not allocated to payout splits.
    address payable _projectOwner = payable(projects.ownerOf(_projectId));

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the fee amount that was paid.
    uint256 _fee;

    // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope.
    {
      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // The amount distributed that is eligible for incurring fees.
      uint256 _feeEligibleDistributionAmount;

      // The amount leftover after distributing to the splits.
      uint256 _leftoverDistributionAmount;

      // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.
      // Also get a reference to the amount that was distributed to splits from which fees should be taken.
      (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        payoutSplitsGroup,
        _distributedAmount,
        _feeDiscount
      );

      // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.
      unchecked {
        _feeEligibleDistributionAmount += _leftoverDistributionAmount;
      }

      // Take the fee.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0
        ? 0
        : _takeFeeFrom(
          _projectId,
          _fundingCycle,
          _feeEligibleDistributionAmount,
          _projectOwner,
          _feeDiscount
        );

      // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.

      unchecked {
        netLeftoverDistributionAmount = _leftoverDistributionAmount == 0
          ? 0
          : _leftoverDistributionAmount -
            _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);
      }

      // Transfer any remaining balance to the project owner.
      if (netLeftoverDistributionAmount > 0)
        _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount);
    }

    emit DistributePayouts(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _projectOwner,
      _amount,
      _distributedAmount,
      _fee,
      netLeftoverDistributionAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function _useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  ) internal returns (uint256 netDistributedAmount) {
    // Record the use of the allowance.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(
      _projectId,
      _amount,
      _currency
    );

    // The amount being withdrawn must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope.
    {
      // Keep a reference to the fee amount that was paid.
      uint256 _fee;

      // Get a reference to the project owner, which will receive tokens from paying the platform fee.
      address _projectOwner = projects.ownerOf(_projectId);

      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // Take a fee from the `_distributedAmount`, if needed.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
        ? 0
        : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);

      unchecked {
        // The net amount is the withdrawn amount without the fee.
        netDistributedAmount = _distributedAmount - _fee;
      }

      // Transfer any remaining balance to the beneficiary.
      if (netDistributedAmount > 0)
        _transferFrom(address(this), _beneficiary, netDistributedAmount);
    }

    emit UseAllowance(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _beneficiary,
      _amount,
      _distributedAmount,
      netDistributedAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Pays out splits for a project's funding cycle configuration.

    @param _projectId The ID of the project for which payout splits are being distributed.
    @param _domain The domain of the splits to distribute the payout between.
    @param _group The group of the splits to distribute the payout between.
    @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return leftoverAmount If the leftover amount if the splits don't add up to 100%.
    @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.
  */
  function _distributeToPayoutSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount,
    uint256 _feeDiscount
  ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's payout splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    // Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; ) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _payoutAmount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // The payout amount substracting any applicable incurred fees.
      uint256 _netPayoutAmount;

      if (_payoutAmount > 0) {
        // Transfer tokens to the split.
        // If there's an allocator set, transfer to its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0))) {
          // If the split allocator is set as feeless, this distribution is not eligible for a fee.
          if (isFeelessAddress[address(_split.allocator)])
            _netPayoutAmount = _payoutAmount;
            // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.
          else {
            unchecked {
              _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                ? _payoutAmount
                : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
            }

            // This distribution is eligible for a fee since the funds are leaving the ecosystem.
            feeEligibleDistributionAmount += _payoutAmount;
          }

          // Trigger any inherited pre-transfer logic.
          _beforeTransferTo(address(_split.allocator), _netPayoutAmount);

          // If this terminal's token is ETH, send it in msg.value.
          uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

          // Create the data to send to the allocator.
          JBSplitAllocationData memory _data = JBSplitAllocationData(
            token,
            _netPayoutAmount,
            decimals,
            _projectId,
            _group,
            _split
          );

          // Trigger the allocator's `allocate` function.
          _split.allocator.allocate{value: _payableValue}(_data);

          // Otherwise, if a project is specified, make a payment to it.
        } else if (_split.projectId != 0) {
          // Get a reference to the Juicebox terminal being used.
          IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);

          // The project must have a terminal to send funds to.
          if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();

          // Save gas if this contract is being used as the terminal.
          if (_terminal == this) {
            // This distribution does not incur a fee.
            _netPayoutAmount = _payoutAmount;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);
            else
              _pay(
                _netPayoutAmount,
                address(this),
                _split.projectId,
                (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          } else {
            // If the terminal is set as feeless, this distribution is not eligible for a fee.
            if (isFeelessAddress[address(_terminal)])
              _netPayoutAmount = _payoutAmount;
              // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.
            else {
              unchecked {
                _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                  ? _payoutAmount
                  : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
              }

              feeEligibleDistributionAmount += _payoutAmount;
            }

            // Trigger any inherited pre-transfer logic.
            _beforeTransferTo(address(_terminal), _netPayoutAmount);

            // If this terminal's token is ETH, send it in msg.value.
            uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _terminal.addToBalanceOf{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                '',
                _projectMetadata
              );
            else
              _terminal.pay{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          }
        } else {
          unchecked {
            _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
              ? _payoutAmount
              : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
          }

          // This distribution is eligible for a fee since the funds are leaving the ecosystem.
          feeEligibleDistributionAmount += _payoutAmount;

          // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.
          _transferFrom(
            address(this),
            _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),
            _netPayoutAmount
          );
        }

        // Subtract from the amount to be sent to the beneficiary.
        unchecked {
          leftoverAmount = leftoverAmount - _payoutAmount;
        }
      }

      emit DistributeToPayoutSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _netPayoutAmount,
        msg.sender
      );

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID.

    @param _projectId The ID of the project having fees taken from.
    @param _fundingCycle The funding cycle during which the fee is being taken.
    @param _amount The amount of the fee to take, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platforms tokens for.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return feeAmount The amount of the fee taken.
  */
  function _takeFeeFrom(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _amount,
    address _beneficiary,
    uint256 _feeDiscount
  ) internal returns (uint256 feeAmount) {
    feeAmount = _feeAmount(_amount, fee, _feeDiscount);

    if (_fundingCycle.shouldHoldFees()) {
      // Store the held fee.
      _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));

      emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender);
    } else {
      // Process the fee.
      _processFee(feeAmount, _beneficiary); // Take the fee.

      emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender);
    }
  }

  /**
    @notice
    Process a fee of the specified amount.

    @param _amount The fee amount, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platform's tokens for.
  */
  function _processFee(uint256 _amount, address _beneficiary) internal {
    // Get the terminal for the protocol project.
    IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token);

    // When processing the admin fee, save gas if the admin is using this contract as its terminal.
    if (_terminal == this)
      _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call.
    else {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_terminal), _amount);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;

      // Send the payment.
      _terminal.pay{value: _payableValue}(
        _PROTOCOL_PROJECT_ID,
        _amount,
        token,
        _beneficiary,
        0,
        false,
        '',
        bytes('')
      ); // Use the external pay call of the correct terminal.
    }
  }

  /**
    @notice
    Contribute tokens to a project.

    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _payer The address making the payment.
    @param _projectId The ID of the project being paid.
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function _pay(
    uint256 _amount,
    address _payer,
    uint256 _projectId,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 beneficiaryTokenCount) {
    // Cant send tokens to the zero address.
    if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the payment is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope.
    {
      IJBPayDelegate _delegate;
      uint256 _tokenCount;

      // Bundle the amount info into a JBTokenAmount struct.
      JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);

      // Record the payment.
      (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(
        _payer,
        _bundledAmount,
        _projectId,
        baseWeightCurrency,
        _beneficiary,
        _memo,
        _metadata
      );

      // Mint the tokens if needed.
      if (_tokenCount > 0)
        // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.
        beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(
          _projectId,
          _tokenCount,
          _beneficiary,
          '',
          _preferClaimedTokens,
          true
        );

      // The token count for the beneficiary must be greater than or equal to the minimum expected.
      if (beneficiaryTokenCount < _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBPayDelegate(address(0))) {
        JBDidPayData memory _data = JBDidPayData(
          _payer,
          _projectId,
          _fundingCycle.configuration,
          _bundledAmount,
          beneficiaryTokenCount,
          _beneficiary,
          _preferClaimedTokens,
          _memo,
          _metadata
        );

        _delegate.didPay(_data);
        emit DelegateDidPay(_delegate, _data, msg.sender);
      }
    }

    emit Pay(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _payer,
      _beneficiary,
      _amount,
      beneficiaryTokenCount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function _addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    bool _shouldRefundHeldFees,
    string memory _memo,
    bytes memory _metadata
  ) internal {
    // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.
    uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0;

    // Record the added funds with any refunded fees.
    store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);

    emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);
  }

  /**
    @notice
    Refund fees based on the specified amount.

    @param _projectId The project for which fees are being refunded.
    @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.

    @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal
  */
  function _refundHeldFees(uint256 _projectId, uint256 _amount)
    internal
    returns (uint256 refundedFees)
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the current held fees.
    delete _heldFeesOf[_projectId];

    // Get a reference to the leftover amount once all fees have been settled.
    uint256 leftoverAmount = _amount;

    // Push length in stack
    uint256 _heldFeesLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeesLength; ) {
      if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);
      else if (leftoverAmount >= _heldFees[_i].amount) {
        unchecked {
          leftoverAmount = leftoverAmount - _heldFees[_i].amount;
          refundedFees += _feeAmount(
            _heldFees[_i].amount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount
          );
        }
      } else {
        _heldFeesOf[_projectId].push(
          JBFee(
            _heldFees[_i].amount - leftoverAmount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount,
            _heldFees[_i].beneficiary
          )
        );
        unchecked {
          refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);
        }
        leftoverAmount = 0;
      }

      unchecked {
        ++_i;
      }
    }

    emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);
  }

  /** 
    @notice 
    Returns the fee amount based on the provided amount for the specified project.

    @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal.
    @param _fee The percentage of the fee, out of MAX_FEE. 
    @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.

    @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _feeAmount(
    uint256 _amount,
    uint256 _fee,
    uint256 _feeDiscount
  ) internal pure returns (uint256) {
    // Calculate the discounted fee.
    uint256 _discountedFee = _fee -
      PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT);

    // The amount of tokens from the `_amount` to pay as a fee.
    return
      _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);
  }

  /** 
    @notice
    Get the fee discount from the fee gauge for the specified project.

    @param _projectId The ID of the project to get a fee discount for.
    
    @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.
  */
  function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {
    // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.
    if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))
      return JBConstants.MAX_FEE_DISCOUNT;

    // Get the fee discount.
    if (feeGauge == IJBFeeGauge(address(0)))
      feeDiscount = 0;
      // If the guage reverts, set the discount to 0.
    else
      try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {
        feeDiscount = discount;
      } catch {
        feeDiscount = 0;
      }

    // If the fee discount is greater than the max, nullify the discount.
    if (feeDiscount > JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;
  }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './../interfaces/IJBController.sol';
import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol';
import './../libraries/JBConstants.sol';
import './../libraries/JBCurrencies.sol';
import './../libraries/JBFixedPointNumber.sol';
import './../libraries/JBFundingCycleMetadataResolver.sol';
import './../libraries/JBOperations.sol';
import './../libraries/JBSplitsGroups.sol';
import './../libraries/JBTokens.sol';
import './../structs/JBTokenAmount.sol';
import './JBOperatable.sol';
import './JBSingleTokenPaymentTerminal.sol';

/**
  @notice
  Generic terminal managing all inflows and outflows of funds into the protocol ecosystem.

  @dev
  A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time.

  @dev
  Adheres to -
  IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.
  JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
abstract contract JBPayoutRedemptionPaymentTerminal is
  IJBPayoutRedemptionPaymentTerminal,
  JBSingleTokenPaymentTerminal,
  JBOperatable,
  Ownable,
  ReentrancyGuard
{
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error FEE_TOO_HIGH();
  error INADEQUATE_DISTRIBUTION_AMOUNT();
  error INADEQUATE_RECLAIM_AMOUNT();
  error INADEQUATE_TOKEN_COUNT();
  error NO_MSG_VALUE_ALLOWED();
  error PAY_TO_ZERO_ADDRESS();
  error PROJECT_TERMINAL_MISMATCH();
  error REDEEM_TO_ZERO_ADDRESS();
  error TERMINAL_IN_SPLIT_ZERO_ADDRESS();
  error TERMINAL_TOKENS_INCOMPATIBLE();

  //*********************************************************************//
  // ---------------------------- modifiers ---------------------------- //
  //*********************************************************************//

  /** 
    @notice 
    A modifier that verifies this terminal is a terminal of provided project ID.
  */
  modifier isTerminalOf(uint256 _projectId) {
    if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();
    _;
  }

  //*********************************************************************//
  // --------------------- internal stored constants ------------------- //
  //*********************************************************************//

  /**
    @notice
    Maximum fee that can be set for a funding cycle configuration.

    @dev
    Out of MAX_FEE (50_000_000 / 1_000_000_000).
  */
  uint256 internal constant _FEE_CAP = 50_000_000;

  /**
    @notice
    The protocol project ID is 1, as it should be the first project launched during the deployment process.
  */
  uint256 internal constant _PROTOCOL_PROJECT_ID = 1;

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    Fees that are being held to be processed later.

    _projectId The ID of the project for which fees are being held.
  */
  mapping(uint256 => JBFee[]) internal _heldFeesOf;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership and transfers.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  /**
    @notice
    The contract that stores and manages the terminal's data.
  */
  IJBSingleTokenPaymentTerminalStore public immutable override store;

  /**
    @notice
    The currency to base token issuance on.

    @dev
    If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.
  */
  uint256 public immutable override baseWeightCurrency;

  /**
    @notice
    The group that payout splits coming from this terminal are identified by.
  */
  uint256 public immutable override payoutSplitsGroup;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The platform fee percent.

    @dev
    Out of MAX_FEE (25_000_000 / 1_000_000_000)
  */
  uint256 public override fee = 25_000_000; // 2.5%

  /**
    @notice
    The data source that returns a discount to apply to a project's fee.
  */
  IJBFeeGauge public override feeGauge;

  /**
    @notice
    Addresses that can be paid towards from this terminal without incurring a fee.

    _address The address that can be paid toward.
  */
  mapping(address => bool) public override isFeelessAddress;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.

    @dev
    The current overflow is represented as a fixed point number with 18 decimals.

    @param _projectId The ID of the project to get overflow for.

    @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.
  */
  function currentEthOverflowOf(uint256 _projectId)
    external
    view
    virtual
    override
    returns (uint256)
  {
    // Get this terminal's current overflow.
    uint256 _overflow = store.currentOverflowOf(this, _projectId);

    // Adjust the decimals of the fixed point number if needed to have 18 decimals.
    uint256 _adjustedOverflow = (decimals == 18)
      ? _overflow
      : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);

    // Return the amount converted to ETH.
    return
      (currency == JBCurrencies.ETH)
        ? _adjustedOverflow
        : PRBMath.mulDiv(
          _adjustedOverflow,
          10**decimals,
          prices.priceFor(currency, JBCurrencies.ETH, decimals)
        );
  }

  /**
    @notice
    The fees that are currently being held to be processed later for each project.

    @param _projectId The ID of the project for which fees are being held.

    @return An array of fees that are being held.
  */
  function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {
    return _heldFeesOf[_projectId];
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(JBSingleTokenPaymentTerminal, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||
      _interfaceId == type(IJBPayoutTerminal).interfaceId ||
      _interfaceId == type(IJBAllowanceTerminal).interfaceId ||
      _interfaceId == type(IJBRedemptionTerminal).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _token The token that this terminal manages.
    @param _decimals The number of decimals the token fixed point amounts are expected to have.
    @param _currency The currency that this terminal's token adheres to for price feeds.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _splitsStore A contract that stores splits for each project.
    @param _prices A contract that exposes price feeds.
    @param _store A contract that stores the terminal's data.
    @param _owner The address that will own this contract.
  */
  constructor(
    // payable constructor save the gas used to check msg.value==0
    address _token,
    uint256 _decimals,
    uint256 _currency,
    uint256 _baseWeightCurrency,
    uint256 _payoutSplitsGroup,
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBSplitsStore _splitsStore,
    IJBPrices _prices,
    IJBSingleTokenPaymentTerminalStore _store,
    address _owner
  )
    payable
    JBSingleTokenPaymentTerminal(_token, _decimals, _currency)
    JBOperatable(_operatorStore)
  {
    baseWeightCurrency = _baseWeightCurrency;
    payoutSplitsGroup = _payoutSplitsGroup;
    projects = _projects;
    directory = _directory;
    splitsStore = _splitsStore;
    prices = _prices;
    store = _store;

    transferOwnership(_owner);
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Contribute tokens to a project.

    @param _projectId The ID of the project being paid.
    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _token The token being paid. This terminal ignores this property since it only manages one token. 
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function pay(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {
    _token; // Prevents unused var compiler and natspec complaints.

    // ETH shouldn't be sent if this terminal's token isn't ETH.
    if (token != JBTokens.ETH) {
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If this terminal's token is ETH, override _amount with msg.value.
    else _amount = msg.value;

    return
      _pay(
        _amount,
        msg.sender,
        _projectId,
        _beneficiary,
        _minReturnedTokens,
        _preferClaimedTokens,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _token The token being reclaimed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  )
    external
    virtual
    override
    requirePermission(_holder, _projectId, JBOperations.REDEEM)
    returns (uint256 reclaimAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return
      _redeemTokensOf(
        _holder,
        _projectId,
        _tokenCount,
        _minReturnedTokens,
        _beneficiary,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) external virtual override returns (uint256 netLeftoverDistributionAmount) {
    _token; // Prevents unused var compiler and natspec complaints.

    return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)
    returns (uint256 netDistributedAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);
  }

  /**
    @notice
    Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project being migrated.
    @param _to The terminal contract that will gain the project's funds.

    @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.
  */
  function migrate(uint256 _projectId, IJBPaymentTerminal _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)
    returns (uint256 balance)
  {
    // The terminal being migrated to must accept the same token as this terminal.
    if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE();

    // Record the migration in the store.
    balance = store.recordMigration(_projectId);

    // Transfer the balance if needed.
    if (balance > 0) {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_to), balance);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? balance : 0;

      // Withdraw the balance to transfer to the new terminal;
      _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes(''));
    }

    emit Migrate(_projectId, _to, balance, msg.sender);
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _token The token being paid. This terminal ignores this property since it only manages one currency. 
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) {
    _token; // Prevents unused var compiler and natspec complaints.

    // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender.
    if (token != JBTokens.ETH) {
      // Amount must be greater than 0.
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If the terminal's token is ETH, override `_amount` with msg.value.
    else _amount = msg.value;

    // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal.
    _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);
  }

  /**
    @notice
    Process any fees that are being held for the project.

    @dev
    Only a project owner, an operator, or the contract's owner can process held fees.

    @param _projectId The ID of the project whos held fees should be processed.
  */
  function processFees(uint256 _projectId)
    external
    virtual
    override
    requirePermissionAllowingOverride(
      projects.ownerOf(_projectId),
      _projectId,
      JBOperations.PROCESS_FEES,
      msg.sender == owner()
    )
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the held fees.
    delete _heldFeesOf[_projectId];

    // Push array length in stack
    uint256 _heldFeeLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeeLength; ) {
      // Get the fee amount.
      uint256 _amount = _feeAmount(
        _heldFees[_i].amount,
        _heldFees[_i].fee,
        _heldFees[_i].feeDiscount
      );

      // Process the fee.
      _processFee(_amount, _heldFees[_i].beneficiary);

      emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Allows the fee to be updated.

    @dev
    Only the owner of this contract can change the fee.

    @param _fee The new fee, out of MAX_FEE.
  */
  function setFee(uint256 _fee) external virtual override onlyOwner {
    // The provided fee must be within the max.
    if (_fee > _FEE_CAP) revert FEE_TOO_HIGH();

    // Store the new fee.
    fee = _fee;

    emit SetFee(_fee, msg.sender);
  }

  /**
    @notice
    Allows the fee gauge to be updated.

    @dev
    Only the owner of this contract can change the fee gauge.

    @dev
    If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.

    @param _feeGauge The new fee gauge.
  */
  function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {
    // Store the new fee gauge.
    feeGauge = _feeGauge;

    emit SetFeeGauge(_feeGauge, msg.sender);
  }

  /**
    @notice
    Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.

    @dev
    Only the owner of this contract can set addresses as feeless.

    @param _address The address that can be paid towards while still bypassing fees.
    @param _flag A flag indicating whether the terminal should be feeless or not.
  */
  function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {
    // Set the flag value.
    isFeelessAddress[_address] = _flag;

    emit SetFeelessAddress(_address, _flag, msg.sender);
  }

  //*********************************************************************//
  // ---------------------- internal transactions ---------------------- //
  //*********************************************************************//

  /** 
    @notice
    Transfers tokens.

    @param _from The address from which the transfer should originate.
    @param _to The address to which the transfer should go.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _transferFrom(
    address _from,
    address payable _to,
    uint256 _amount
  ) internal virtual;

  /** 
    @notice
    Logic to be triggered before transferring tokens from this terminal.

    @param _to The address to which the transfer is going.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _beforeTransferTo(address _to, uint256 _amount) internal virtual;

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function _redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 reclaimAmount) {
    // Can't send reclaimed funds to the zero address.
    if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the redemption is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` only used within scope.
    {
      IJBRedemptionDelegate _delegate;

      // Record the redemption.
      (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(
        _holder,
        _projectId,
        _tokenCount,
        _memo,
        _metadata
      );

      // The amount being reclaimed must be at least as much as was expected.
      if (reclaimAmount < _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();

      // Burn the project tokens.
      if (_tokenCount > 0)
        IJBController(directory.controllerOf(_projectId)).burnTokensOf(
          _holder,
          _projectId,
          _tokenCount,
          '',
          false
        );

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBRedemptionDelegate(address(0))) {
        JBDidRedeemData memory _data = JBDidRedeemData(
          _holder,
          _projectId,
          _fundingCycle.configuration,
          _tokenCount,
          JBTokenAmount(token, reclaimAmount, decimals, currency),
          _beneficiary,
          _memo,
          _metadata
        );
        _delegate.didRedeem(_data);
        emit DelegateDidRedeem(_delegate, _data, msg.sender);
      }
    }

    // Send the reclaimed funds to the beneficiary.
    if (reclaimAmount > 0) _transferFrom(address(this), _beneficiary, reclaimAmount);

    emit RedeemTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _holder,
      _beneficiary,
      _tokenCount,
      reclaimAmount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) internal returns (uint256 netLeftoverDistributionAmount) {
    // Record the distribution.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(
      _projectId,
      _amount,
      _currency
    );

    // The amount being distributed must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Get a reference to the project owner, which will receive tokens from paying the platform fee
    // and receive any extra distributable funds not allocated to payout splits.
    address payable _projectOwner = payable(projects.ownerOf(_projectId));

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the fee amount that was paid.
    uint256 _fee;

    // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope.
    {
      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // The amount distributed that is eligible for incurring fees.
      uint256 _feeEligibleDistributionAmount;

      // The amount leftover after distributing to the splits.
      uint256 _leftoverDistributionAmount;

      // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.
      // Also get a reference to the amount that was distributed to splits from which fees should be taken.
      (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        payoutSplitsGroup,
        _distributedAmount,
        _feeDiscount
      );

      // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.
      unchecked {
        _feeEligibleDistributionAmount += _leftoverDistributionAmount;
      }

      // Take the fee.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0
        ? 0
        : _takeFeeFrom(
          _projectId,
          _fundingCycle,
          _feeEligibleDistributionAmount,
          _projectOwner,
          _feeDiscount
        );

      // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.

      unchecked {
        netLeftoverDistributionAmount = _leftoverDistributionAmount == 0
          ? 0
          : _leftoverDistributionAmount -
            _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);
      }

      // Transfer any remaining balance to the project owner.
      if (netLeftoverDistributionAmount > 0)
        _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount);
    }

    emit DistributePayouts(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _projectOwner,
      _amount,
      _distributedAmount,
      _fee,
      netLeftoverDistributionAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function _useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  ) internal returns (uint256 netDistributedAmount) {
    // Record the use of the allowance.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(
      _projectId,
      _amount,
      _currency
    );

    // The amount being withdrawn must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope.
    {
      // Keep a reference to the fee amount that was paid.
      uint256 _fee;

      // Get a reference to the project owner, which will receive tokens from paying the platform fee.
      address _projectOwner = projects.ownerOf(_projectId);

      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // Take a fee from the `_distributedAmount`, if needed.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
        ? 0
        : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);

      unchecked {
        // The net amount is the withdrawn amount without the fee.
        netDistributedAmount = _distributedAmount - _fee;
      }

      // Transfer any remaining balance to the beneficiary.
      if (netDistributedAmount > 0)
        _transferFrom(address(this), _beneficiary, netDistributedAmount);
    }

    emit UseAllowance(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _beneficiary,
      _amount,
      _distributedAmount,
      netDistributedAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Pays out splits for a project's funding cycle configuration.

    @param _projectId The ID of the project for which payout splits are being distributed.
    @param _domain The domain of the splits to distribute the payout between.
    @param _group The group of the splits to distribute the payout between.
    @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return leftoverAmount If the leftover amount if the splits don't add up to 100%.
    @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.
  */
  function _distributeToPayoutSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount,
    uint256 _feeDiscount
  ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's payout splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    // Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; ) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _payoutAmount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // The payout amount substracting any applicable incurred fees.
      uint256 _netPayoutAmount;

      if (_payoutAmount > 0) {
        // Transfer tokens to the split.
        // If there's an allocator set, transfer to its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0))) {
          // If the split allocator is set as feeless, this distribution is not eligible for a fee.
          if (isFeelessAddress[address(_split.allocator)])
            _netPayoutAmount = _payoutAmount;
            // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.
          else {
            unchecked {
              _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                ? _payoutAmount
                : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
            }

            // This distribution is eligible for a fee since the funds are leaving the ecosystem.
            feeEligibleDistributionAmount += _payoutAmount;
          }

          // Trigger any inherited pre-transfer logic.
          _beforeTransferTo(address(_split.allocator), _netPayoutAmount);

          // If this terminal's token is ETH, send it in msg.value.
          uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

          // Create the data to send to the allocator.
          JBSplitAllocationData memory _data = JBSplitAllocationData(
            token,
            _netPayoutAmount,
            decimals,
            _projectId,
            _group,
            _split
          );

          // Trigger the allocator's `allocate` function.
          _split.allocator.allocate{value: _payableValue}(_data);

          // Otherwise, if a project is specified, make a payment to it.
        } else if (_split.projectId != 0) {
          // Get a reference to the Juicebox terminal being used.
          IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);

          // The project must have a terminal to send funds to.
          if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();

          // Save gas if this contract is being used as the terminal.
          if (_terminal == this) {
            // This distribution does not incur a fee.
            _netPayoutAmount = _payoutAmount;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);
            else
              _pay(
                _netPayoutAmount,
                address(this),
                _split.projectId,
                (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          } else {
            // If the terminal is set as feeless, this distribution is not eligible for a fee.
            if (isFeelessAddress[address(_terminal)])
              _netPayoutAmount = _payoutAmount;
              // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.
            else {
              unchecked {
                _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                  ? _payoutAmount
                  : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
              }

              feeEligibleDistributionAmount += _payoutAmount;
            }

            // Trigger any inherited pre-transfer logic.
            _beforeTransferTo(address(_terminal), _netPayoutAmount);

            // If this terminal's token is ETH, send it in msg.value.
            uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _terminal.addToBalanceOf{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                '',
                _projectMetadata
              );
            else
              _terminal.pay{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          }
        } else {
          unchecked {
            _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
              ? _payoutAmount
              : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
          }

          // This distribution is eligible for a fee since the funds are leaving the ecosystem.
          feeEligibleDistributionAmount += _payoutAmount;

          // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.
          _transferFrom(
            address(this),
            _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),
            _netPayoutAmount
          );
        }

        // Subtract from the amount to be sent to the beneficiary.
        unchecked {
          leftoverAmount = leftoverAmount - _payoutAmount;
        }
      }

      emit DistributeToPayoutSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _netPayoutAmount,
        msg.sender
      );

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID.

    @param _projectId The ID of the project having fees taken from.
    @param _fundingCycle The funding cycle during which the fee is being taken.
    @param _amount The amount of the fee to take, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platforms tokens for.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return feeAmount The amount of the fee taken.
  */
  function _takeFeeFrom(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _amount,
    address _beneficiary,
    uint256 _feeDiscount
  ) internal returns (uint256 feeAmount) {
    feeAmount = _feeAmount(_amount, fee, _feeDiscount);

    if (_fundingCycle.shouldHoldFees()) {
      // Store the held fee.
      _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));

      emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender);
    } else {
      // Process the fee.
      _processFee(feeAmount, _beneficiary); // Take the fee.

      emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender);
    }
  }

  /**
    @notice
    Process a fee of the specified amount.

    @param _amount The fee amount, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platform's tokens for.
  */
  function _processFee(uint256 _amount, address _beneficiary) internal {
    // Get the terminal for the protocol project.
    IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token);

    // When processing the admin fee, save gas if the admin is using this contract as its terminal.
    if (_terminal == this)
      _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call.
    else {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_terminal), _amount);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;

      // Send the payment.
      _terminal.pay{value: _payableValue}(
        _PROTOCOL_PROJECT_ID,
        _amount,
        token,
        _beneficiary,
        0,
        false,
        '',
        bytes('')
      ); // Use the external pay call of the correct terminal.
    }
  }

  /**
    @notice
    Contribute tokens to a project.

    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _payer The address making the payment.
    @param _projectId The ID of the project being paid.
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function _pay(
    uint256 _amount,
    address _payer,
    uint256 _projectId,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 beneficiaryTokenCount) {
    // Cant send tokens to the zero address.
    if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the payment is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope.
    {
      IJBPayDelegate _delegate;
      uint256 _tokenCount;

      // Bundle the amount info into a JBTokenAmount struct.
      JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);

      // Record the payment.
      (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(
        _payer,
        _bundledAmount,
        _projectId,
        baseWeightCurrency,
        _beneficiary,
        _memo,
        _metadata
      );

      // Mint the tokens if needed.
      if (_tokenCount > 0)
        // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.
        beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(
          _projectId,
          _tokenCount,
          _beneficiary,
          '',
          _preferClaimedTokens,
          true
        );

      // The token count for the beneficiary must be greater than or equal to the minimum expected.
      if (beneficiaryTokenCount < _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBPayDelegate(address(0))) {
        JBDidPayData memory _data = JBDidPayData(
          _payer,
          _projectId,
          _fundingCycle.configuration,
          _bundledAmount,
          beneficiaryTokenCount,
          _beneficiary,
          _preferClaimedTokens,
          _memo,
          _metadata
        );

        _delegate.didPay(_data);
        emit DelegateDidPay(_delegate, _data, msg.sender);
      }
    }

    emit Pay(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _payer,
      _beneficiary,
      _amount,
      beneficiaryTokenCount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function _addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    bool _shouldRefundHeldFees,
    string memory _memo,
    bytes memory _metadata
  ) internal {
    // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.
    uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0;

    // Record the added funds with any refunded fees.
    store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);

    emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);
  }

  /**
    @notice
    Refund fees based on the specified amount.

    @param _projectId The project for which fees are being refunded.
    @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.

    @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal
  */
  function _refundHeldFees(uint256 _projectId, uint256 _amount)
    internal
    returns (uint256 refundedFees)
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the current held fees.
    delete _heldFeesOf[_projectId];

    // Get a reference to the leftover amount once all fees have been settled.
    uint256 leftoverAmount = _amount;

    // Push length in stack
    uint256 _heldFeesLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeesLength; ) {
      if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);
      else if (leftoverAmount >= _heldFees[_i].amount) {
        unchecked {
          leftoverAmount = leftoverAmount - _heldFees[_i].amount;
          refundedFees += _feeAmount(
            _heldFees[_i].amount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount
          );
        }
      } else {
        _heldFeesOf[_projectId].push(
          JBFee(
            _heldFees[_i].amount - leftoverAmount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount,
            _heldFees[_i].beneficiary
          )
        );
        unchecked {
          refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);
        }
        leftoverAmount = 0;
      }

      unchecked {
        ++_i;
      }
    }

    emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);
  }

  /** 
    @notice 
    Returns the fee amount based on the provided amount for the specified project.

    @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal.
    @param _fee The percentage of the fee, out of MAX_FEE. 
    @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.

    @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _feeAmount(
    uint256 _amount,
    uint256 _fee,
    uint256 _feeDiscount
  ) internal pure returns (uint256) {
    // Calculate the discounted fee.
    uint256 _discountedFee = _fee -
      PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT);

    // The amount of tokens from the `_amount` to pay as a fee.
    return
      _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);
  }

  /** 
    @notice
    Get the fee discount from the fee gauge for the specified project.

    @param _projectId The ID of the project to get a fee discount for.
    
    @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.
  */
  function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {
    // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.
    if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))
      return JBConstants.MAX_FEE_DISCOUNT;

    // Get the fee discount.
    if (feeGauge == IJBFeeGauge(address(0)))
      feeDiscount = 0;
      // If the guage reverts, set the discount to 0.
    else
      try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {
        feeDiscount = discount;
      } catch {
        feeDiscount = 0;
      }

    // If the fee discount is greater than the max, nullify the discount.
    if (feeDiscount > JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;
  }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-01-09 17:18:13 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 17:18:13 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 25445
completion_tokens: 1
total_tokens: 25446
cost: $-1.000000


[2024-01-09 17:18:13 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './../interfaces/IJBController.sol';
import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol';
import './../libraries/JBConstants.sol';
import './../libraries/JBCurrencies.sol';
import './../libraries/JBFixedPointNumber.sol';
import './../libraries/JBFundingCycleMetadataResolver.sol';
import './../libraries/JBOperations.sol';
import './../libraries/JBSplitsGroups.sol';
import './../libraries/JBTokens.sol';
import './../structs/JBTokenAmount.sol';
import './JBOperatable.sol';
import './JBSingleTokenPaymentTerminal.sol';

/**
  @notice
  Generic terminal managing all inflows and outflows of funds into the protocol ecosystem.

  @dev
  A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time.

  @dev
  Adheres to -
  IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.
  JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
abstract contract JBPayoutRedemptionPaymentTerminal is
  IJBPayoutRedemptionPaymentTerminal,
  JBSingleTokenPaymentTerminal,
  JBOperatable,
  Ownable,
  ReentrancyGuard
{
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error FEE_TOO_HIGH();
  error INADEQUATE_DISTRIBUTION_AMOUNT();
  error INADEQUATE_RECLAIM_AMOUNT();
  error INADEQUATE_TOKEN_COUNT();
  error NO_MSG_VALUE_ALLOWED();
  error PAY_TO_ZERO_ADDRESS();
  error PROJECT_TERMINAL_MISMATCH();
  error REDEEM_TO_ZERO_ADDRESS();
  error TERMINAL_IN_SPLIT_ZERO_ADDRESS();
  error TERMINAL_TOKENS_INCOMPATIBLE();

  //*********************************************************************//
  // ---------------------------- modifiers ---------------------------- //
  //*********************************************************************//

  /** 
    @notice 
    A modifier that verifies this terminal is a terminal of provided project ID.
  */
  modifier isTerminalOf(uint256 _projectId) {
    if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();
    _;
  }

  //*********************************************************************//
  // --------------------- internal stored constants ------------------- //
  //*********************************************************************//

  /**
    @notice
    Maximum fee that can be set for a funding cycle configuration.

    @dev
    Out of MAX_FEE (50_000_000 / 1_000_000_000).
  */
  uint256 internal constant _FEE_CAP = 50_000_000;

  /**
    @notice
    The protocol project ID is 1, as it should be the first project launched during the deployment process.
  */
  uint256 internal constant _PROTOCOL_PROJECT_ID = 1;

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    Fees that are being held to be processed later.

    _projectId The ID of the project for which fees are being held.
  */
  mapping(uint256 => JBFee[]) internal _heldFeesOf;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership and transfers.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  /**
    @notice
    The contract that stores and manages the terminal's data.
  */
  IJBSingleTokenPaymentTerminalStore public immutable override store;

  /**
    @notice
    The currency to base token issuance on.

    @dev
    If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.
  */
  uint256 public immutable override baseWeightCurrency;

  /**
    @notice
    The group that payout splits coming from this terminal are identified by.
  */
  uint256 public immutable override payoutSplitsGroup;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The platform fee percent.

    @dev
    Out of MAX_FEE (25_000_000 / 1_000_000_000)
  */
  uint256 public override fee = 25_000_000; // 2.5%

  /**
    @notice
    The data source that returns a discount to apply to a project's fee.
  */
  IJBFeeGauge public override feeGauge;

  /**
    @notice
    Addresses that can be paid towards from this terminal without incurring a fee.

    _address The address that can be paid toward.
  */
  mapping(address => bool) public override isFeelessAddress;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.

    @dev
    The current overflow is represented as a fixed point number with 18 decimals.

    @param _projectId The ID of the project to get overflow for.

    @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.
  */
  function currentEthOverflowOf(uint256 _projectId)
    external
    view
    virtual
    override
    returns (uint256)
  {
    // Get this terminal's current overflow.
    uint256 _overflow = store.currentOverflowOf(this, _projectId);

    // Adjust the decimals of the fixed point number if needed to have 18 decimals.
    uint256 _adjustedOverflow = (decimals == 18)
      ? _overflow
      : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);

    // Return the amount converted to ETH.
    return
      (currency == JBCurrencies.ETH)
        ? _adjustedOverflow
        : PRBMath.mulDiv(
          _adjustedOverflow,
          10**decimals,
          prices.priceFor(currency, JBCurrencies.ETH, decimals)
        );
  }

  /**
    @notice
    The fees that are currently being held to be processed later for each project.

    @param _projectId The ID of the project for which fees are being held.

    @return An array of fees that are being held.
  */
  function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {
    return _heldFeesOf[_projectId];
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(JBSingleTokenPaymentTerminal, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||
      _interfaceId == type(IJBPayoutTerminal).interfaceId ||
      _interfaceId == type(IJBAllowanceTerminal).interfaceId ||
      _interfaceId == type(IJBRedemptionTerminal).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _token The token that this terminal manages.
    @param _decimals The number of decimals the token fixed point amounts are expected to have.
    @param _currency The currency that this terminal's token adheres to for price feeds.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _splitsStore A contract that stores splits for each project.
    @param _prices A contract that exposes price feeds.
    @param _store A contract that stores the terminal's data.
    @param _owner The address that will own this contract.
  */
  constructor(
    // payable constructor save the gas used to check msg.value==0
    address _token,
    uint256 _decimals,
    uint256 _currency,
    uint256 _baseWeightCurrency,
    uint256 _payoutSplitsGroup,
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBSplitsStore _splitsStore,
    IJBPrices _prices,
    IJBSingleTokenPaymentTerminalStore _store,
    address _owner
  )
    payable
    JBSingleTokenPaymentTerminal(_token, _decimals, _currency)
    JBOperatable(_operatorStore)
  {
    baseWeightCurrency = _baseWeightCurrency;
    payoutSplitsGroup = _payoutSplitsGroup;
    projects = _projects;
    directory = _directory;
    splitsStore = _splitsStore;
    prices = _prices;
    store = _store;

    transferOwnership(_owner);
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Contribute tokens to a project.

    @param _projectId The ID of the project being paid.
    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _token The token being paid. This terminal ignores this property since it only manages one token. 
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function pay(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {
    _token; // Prevents unused var compiler and natspec complaints.

    // ETH shouldn't be sent if this terminal's token isn't ETH.
    if (token != JBTokens.ETH) {
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If this terminal's token is ETH, override _amount with msg.value.
    else _amount = msg.value;

    return
      _pay(
        _amount,
        msg.sender,
        _projectId,
        _beneficiary,
        _minReturnedTokens,
        _preferClaimedTokens,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _token The token being reclaimed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  )
    external
    virtual
    override
    requirePermission(_holder, _projectId, JBOperations.REDEEM)
    returns (uint256 reclaimAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return
      _redeemTokensOf(
        _holder,
        _projectId,
        _tokenCount,
        _minReturnedTokens,
        _beneficiary,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) external virtual override returns (uint256 netLeftoverDistributionAmount) {
    _token; // Prevents unused var compiler and natspec complaints.

    return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)
    returns (uint256 netDistributedAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);
  }

  /**
    @notice
    Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project being migrated.
    @param _to The terminal contract that will gain the project's funds.

    @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.
  */
  function migrate(uint256 _projectId, IJBPaymentTerminal _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)
    returns (uint256 balance)
  {
    // The terminal being migrated to must accept the same token as this terminal.
    if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE();

    // Record the migration in the store.
    balance = store.recordMigration(_projectId);

    // Transfer the balance if needed.
    if (balance > 0) {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_to), balance);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? balance : 0;

      // Withdraw the balance to transfer to the new terminal;
      _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes(''));
    }

    emit Migrate(_projectId, _to, balance, msg.sender);
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _token The token being paid. This terminal ignores this property since it only manages one currency. 
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) {
    _token; // Prevents unused var compiler and natspec complaints.

    // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender.
    if (token != JBTokens.ETH) {
      // Amount must be greater than 0.
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If the terminal's token is ETH, override `_amount` with msg.value.
    else _amount = msg.value;

    // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal.
    _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);
  }

  /**
    @notice
    Process any fees that are being held for the project.

    @dev
    Only a project owner, an operator, or the contract's owner can process held fees.

    @param _projectId The ID of the project whos held fees should be processed.
  */
  function processFees(uint256 _projectId)
    external
    virtual
    override
    requirePermissionAllowingOverride(
      projects.ownerOf(_projectId),
      _projectId,
      JBOperations.PROCESS_FEES,
      msg.sender == owner()
    )
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the held fees.
    delete _heldFeesOf[_projectId];

    // Push array length in stack
    uint256 _heldFeeLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeeLength; ) {
      // Get the fee amount.
      uint256 _amount = _feeAmount(
        _heldFees[_i].amount,
        _heldFees[_i].fee,
        _heldFees[_i].feeDiscount
      );

      // Process the fee.
      _processFee(_amount, _heldFees[_i].beneficiary);

      emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Allows the fee to be updated.

    @dev
    Only the owner of this contract can change the fee.

    @param _fee The new fee, out of MAX_FEE.
  */
  function setFee(uint256 _fee) external virtual override onlyOwner {
    // The provided fee must be within the max.
    if (_fee > _FEE_CAP) revert FEE_TOO_HIGH();

    // Store the new fee.
    fee = _fee;

    emit SetFee(_fee, msg.sender);
  }

  /**
    @notice
    Allows the fee gauge to be updated.

    @dev
    Only the owner of this contract can change the fee gauge.

    @dev
    If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.

    @param _feeGauge The new fee gauge.
  */
  function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {
    // Store the new fee gauge.
    feeGauge = _feeGauge;

    emit SetFeeGauge(_feeGauge, msg.sender);
  }

  /**
    @notice
    Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.

    @dev
    Only the owner of this contract can set addresses as feeless.

    @param _address The address that can be paid towards while still bypassing fees.
    @param _flag A flag indicating whether the terminal should be feeless or not.
  */
  function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {
    // Set the flag value.
    isFeelessAddress[_address] = _flag;

    emit SetFeelessAddress(_address, _flag, msg.sender);
  }

  //*********************************************************************//
  // ---------------------- internal transactions ---------------------- //
  //*********************************************************************//

  /** 
    @notice
    Transfers tokens.

    @param _from The address from which the transfer should originate.
    @param _to The address to which the transfer should go.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _transferFrom(
    address _from,
    address payable _to,
    uint256 _amount
  ) internal virtual;

  /** 
    @notice
    Logic to be triggered before transferring tokens from this terminal.

    @param _to The address to which the transfer is going.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _beforeTransferTo(address _to, uint256 _amount) internal virtual;

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function _redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 reclaimAmount) {
    // Can't send reclaimed funds to the zero address.
    if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the redemption is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` only used within scope.
    {
      IJBRedemptionDelegate _delegate;

      // Record the redemption.
      (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(
        _holder,
        _projectId,
        _tokenCount,
        _memo,
        _metadata
      );

      // The amount being reclaimed must be at least as much as was expected.
      if (reclaimAmount < _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();

      // Burn the project tokens.
      if (_tokenCount > 0)
        IJBController(directory.controllerOf(_projectId)).burnTokensOf(
          _holder,
          _projectId,
          _tokenCount,
          '',
          false
        );

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBRedemptionDelegate(address(0))) {
        JBDidRedeemData memory _data = JBDidRedeemData(
          _holder,
          _projectId,
          _fundingCycle.configuration,
          _tokenCount,
          JBTokenAmount(token, reclaimAmount, decimals, currency),
          _beneficiary,
          _memo,
          _metadata
        );
        _delegate.didRedeem(_data);
        emit DelegateDidRedeem(_delegate, _data, msg.sender);
      }
    }

    // Send the reclaimed funds to the beneficiary.
    if (reclaimAmount > 0) _transferFrom(address(this), _beneficiary, reclaimAmount);

    emit RedeemTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _holder,
      _beneficiary,
      _tokenCount,
      reclaimAmount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) internal returns (uint256 netLeftoverDistributionAmount) {
    // Record the distribution.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(
      _projectId,
      _amount,
      _currency
    );

    // The amount being distributed must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Get a reference to the project owner, which will receive tokens from paying the platform fee
    // and receive any extra distributable funds not allocated to payout splits.
    address payable _projectOwner = payable(projects.ownerOf(_projectId));

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the fee amount that was paid.
    uint256 _fee;

    // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope.
    {
      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // The amount distributed that is eligible for incurring fees.
      uint256 _feeEligibleDistributionAmount;

      // The amount leftover after distributing to the splits.
      uint256 _leftoverDistributionAmount;

      // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.
      // Also get a reference to the amount that was distributed to splits from which fees should be taken.
      (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        payoutSplitsGroup,
        _distributedAmount,
        _feeDiscount
      );

      // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.
      unchecked {
        _feeEligibleDistributionAmount += _leftoverDistributionAmount;
      }

      // Take the fee.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0
        ? 0
        : _takeFeeFrom(
          _projectId,
          _fundingCycle,
          _feeEligibleDistributionAmount,
          _projectOwner,
          _feeDiscount
        );

      // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.

      unchecked {
        netLeftoverDistributionAmount = _leftoverDistributionAmount == 0
          ? 0
          : _leftoverDistributionAmount -
            _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);
      }

      // Transfer any remaining balance to the project owner.
      if (netLeftoverDistributionAmount > 0)
        _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount);
    }

    emit DistributePayouts(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _projectOwner,
      _amount,
      _distributedAmount,
      _fee,
      netLeftoverDistributionAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function _useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  ) internal returns (uint256 netDistributedAmount) {
    // Record the use of the allowance.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(
      _projectId,
      _amount,
      _currency
    );

    // The amount being withdrawn must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope.
    {
      // Keep a reference to the fee amount that was paid.
      uint256 _fee;

      // Get a reference to the project owner, which will receive tokens from paying the platform fee.
      address _projectOwner = projects.ownerOf(_projectId);

      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // Take a fee from the `_distributedAmount`, if needed.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
        ? 0
        : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);

      unchecked {
        // The net amount is the withdrawn amount without the fee.
        netDistributedAmount = _distributedAmount - _fee;
      }

      // Transfer any remaining balance to the beneficiary.
      if (netDistributedAmount > 0)
        _transferFrom(address(this), _beneficiary, netDistributedAmount);
    }

    emit UseAllowance(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _beneficiary,
      _amount,
      _distributedAmount,
      netDistributedAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Pays out splits for a project's funding cycle configuration.

    @param _projectId The ID of the project for which payout splits are being distributed.
    @param _domain The domain of the splits to distribute the payout between.
    @param _group The group of the splits to distribute the payout between.
    @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return leftoverAmount If the leftover amount if the splits don't add up to 100%.
    @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.
  */
  function _distributeToPayoutSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount,
    uint256 _feeDiscount
  ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's payout splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    // Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; ) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _payoutAmount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // The payout amount substracting any applicable incurred fees.
      uint256 _netPayoutAmount;

      if (_payoutAmount > 0) {
        // Transfer tokens to the split.
        // If there's an allocator set, transfer to its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0))) {
          // If the split allocator is set as feeless, this distribution is not eligible for a fee.
          if (isFeelessAddress[address(_split.allocator)])
            _netPayoutAmount = _payoutAmount;
            // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.
          else {
            unchecked {
              _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                ? _payoutAmount
                : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
            }

            // This distribution is eligible for a fee since the funds are leaving the ecosystem.
            feeEligibleDistributionAmount += _payoutAmount;
          }

          // Trigger any inherited pre-transfer logic.
          _beforeTransferTo(address(_split.allocator), _netPayoutAmount);

          // If this terminal's token is ETH, send it in msg.value.
          uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

          // Create the data to send to the allocator.
          JBSplitAllocationData memory _data = JBSplitAllocationData(
            token,
            _netPayoutAmount,
            decimals,
            _projectId,
            _group,
            _split
          );

          // Trigger the allocator's `allocate` function.
          _split.allocator.allocate{value: _payableValue}(_data);

          // Otherwise, if a project is specified, make a payment to it.
        } else if (_split.projectId != 0) {
          // Get a reference to the Juicebox terminal being used.
          IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);

          // The project must have a terminal to send funds to.
          if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();

          // Save gas if this contract is being used as the terminal.
          if (_terminal == this) {
            // This distribution does not incur a fee.
            _netPayoutAmount = _payoutAmount;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);
            else
              _pay(
                _netPayoutAmount,
                address(this),
                _split.projectId,
                (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          } else {
            // If the terminal is set as feeless, this distribution is not eligible for a fee.
            if (isFeelessAddress[address(_terminal)])
              _netPayoutAmount = _payoutAmount;
              // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.
            else {
              unchecked {
                _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                  ? _payoutAmount
                  : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
              }

              feeEligibleDistributionAmount += _payoutAmount;
            }

            // Trigger any inherited pre-transfer logic.
            _beforeTransferTo(address(_terminal), _netPayoutAmount);

            // If this terminal's token is ETH, send it in msg.value.
            uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _terminal.addToBalanceOf{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                '',
                _projectMetadata
              );
            else
              _terminal.pay{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          }
        } else {
          unchecked {
            _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
              ? _payoutAmount
              : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
          }

          // This distribution is eligible for a fee since the funds are leaving the ecosystem.
          feeEligibleDistributionAmount += _payoutAmount;

          // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.
          _transferFrom(
            address(this),
            _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),
            _netPayoutAmount
          );
        }

        // Subtract from the amount to be sent to the beneficiary.
        unchecked {
          leftoverAmount = leftoverAmount - _payoutAmount;
        }
      }

      emit DistributeToPayoutSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _netPayoutAmount,
        msg.sender
      );

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID.

    @param _projectId The ID of the project having fees taken from.
    @param _fundingCycle The funding cycle during which the fee is being taken.
    @param _amount The amount of the fee to take, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platforms tokens for.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return feeAmount The amount of the fee taken.
  */
  function _takeFeeFrom(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _amount,
    address _beneficiary,
    uint256 _feeDiscount
  ) internal returns (uint256 feeAmount) {
    feeAmount = _feeAmount(_amount, fee, _feeDiscount);

    if (_fundingCycle.shouldHoldFees()) {
      // Store the held fee.
      _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));

      emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender);
    } else {
      // Process the fee.
      _processFee(feeAmount, _beneficiary); // Take the fee.

      emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender);
    }
  }

  /**
    @notice
    Process a fee of the specified amount.

    @param _amount The fee amount, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platform's tokens for.
  */
  function _processFee(uint256 _amount, address _beneficiary) internal {
    // Get the terminal for the protocol project.
    IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token);

    // When processing the admin fee, save gas if the admin is using this contract as its terminal.
    if (_terminal == this)
      _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call.
    else {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_terminal), _amount);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;

      // Send the payment.
      _terminal.pay{value: _payableValue}(
        _PROTOCOL_PROJECT_ID,
        _amount,
        token,
        _beneficiary,
        0,
        false,
        '',
        bytes('')
      ); // Use the external pay call of the correct terminal.
    }
  }

  /**
    @notice
    Contribute tokens to a project.

    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _payer The address making the payment.
    @param _projectId The ID of the project being paid.
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function _pay(
    uint256 _amount,
    address _payer,
    uint256 _projectId,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 beneficiaryTokenCount) {
    // Cant send tokens to the zero address.
    if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the payment is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope.
    {
      IJBPayDelegate _delegate;
      uint256 _tokenCount;

      // Bundle the amount info into a JBTokenAmount struct.
      JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);

      // Record the payment.
      (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(
        _payer,
        _bundledAmount,
        _projectId,
        baseWeightCurrency,
        _beneficiary,
        _memo,
        _metadata
      );

      // Mint the tokens if needed.
      if (_tokenCount > 0)
        // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.
        beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(
          _projectId,
          _tokenCount,
          _beneficiary,
          '',
          _preferClaimedTokens,
          true
        );

      // The token count for the beneficiary must be greater than or equal to the minimum expected.
      if (beneficiaryTokenCount < _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBPayDelegate(address(0))) {
        JBDidPayData memory _data = JBDidPayData(
          _payer,
          _projectId,
          _fundingCycle.configuration,
          _bundledAmount,
          beneficiaryTokenCount,
          _beneficiary,
          _preferClaimedTokens,
          _memo,
          _metadata
        );

        _delegate.didPay(_data);
        emit DelegateDidPay(_delegate, _data, msg.sender);
      }
    }

    emit Pay(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _payer,
      _beneficiary,
      _amount,
      beneficiaryTokenCount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function _addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    bool _shouldRefundHeldFees,
    string memory _memo,
    bytes memory _metadata
  ) internal {
    // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.
    uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0;

    // Record the added funds with any refunded fees.
    store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);

    emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);
  }

  /**
    @notice
    Refund fees based on the specified amount.

    @param _projectId The project for which fees are being refunded.
    @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.

    @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal
  */
  function _refundHeldFees(uint256 _projectId, uint256 _amount)
    internal
    returns (uint256 refundedFees)
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the current held fees.
    delete _heldFeesOf[_projectId];

    // Get a reference to the leftover amount once all fees have been settled.
    uint256 leftoverAmount = _amount;

    // Push length in stack
    uint256 _heldFeesLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeesLength; ) {
      if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);
      else if (leftoverAmount >= _heldFees[_i].amount) {
        unchecked {
          leftoverAmount = leftoverAmount - _heldFees[_i].amount;
          refundedFees += _feeAmount(
            _heldFees[_i].amount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount
          );
        }
      } else {
        _heldFeesOf[_projectId].push(
          JBFee(
            _heldFees[_i].amount - leftoverAmount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount,
            _heldFees[_i].beneficiary
          )
        );
        unchecked {
          refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);
        }
        leftoverAmount = 0;
      }

      unchecked {
        ++_i;
      }
    }

    emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);
  }

  /** 
    @notice 
    Returns the fee amount based on the provided amount for the specified project.

    @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal.
    @param _fee The percentage of the fee, out of MAX_FEE. 
    @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.

    @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _feeAmount(
    uint256 _amount,
    uint256 _fee,
    uint256 _feeDiscount
  ) internal pure returns (uint256) {
    // Calculate the discounted fee.
    uint256 _discountedFee = _fee -
      PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT);

    // The amount of tokens from the `_amount` to pay as a fee.
    return
      _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);
  }

  /** 
    @notice
    Get the fee discount from the fee gauge for the specified project.

    @param _projectId The ID of the project to get a fee discount for.
    
    @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.
  */
  function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {
    // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.
    if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))
      return JBConstants.MAX_FEE_DISCOUNT;

    // Get the fee discount.
    if (feeGauge == IJBFeeGauge(address(0)))
      feeDiscount = 0;
      // If the guage reverts, set the discount to 0.
    else
      try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {
        feeDiscount = discount;
      } catch {
        feeDiscount = 0;
      }

    // If the fee discount is greater than the max, nullify the discount.
    if (feeDiscount > JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;
  }
}
.]

###

[2024-01-09 17:18:13 INFO] **[Seminar Conclusion]**:

 ###

[2024-01-09 17:18:13 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-01-09 17:18:13 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/security/ReentrancyGuard.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './../interfaces/IJBController.sol'; import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol'; import './../libraries/JBConstants.sol'; import './../libraries/JBCurrencies.sol'; import './../libraries/JBFixedPointNumber.sol'; import './../libraries/JBFundingCycleMetadataResolver.sol'; import './../libraries/JBOperations.sol'; import './../libraries/JBSplitsGroups.sol'; import './../libraries/JBTokens.sol'; import './../structs/JBTokenAmount.sol'; import './JBOperatable.sol'; import './JBSingleTokenPaymentTerminal.sol'; /**   @notice   Generic terminal managing all inflows and outflows of funds into the protocol ecosystem. @dev   A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time. @dev   Adheres to -   IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules. @dev   Inherits from -   JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.   JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.   Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.   ReentrancyGuard: Contract module that helps prevent reentrant calls to a function. */ abstract contract JBPayoutRedemptionPaymentTerminal is   IJBPayoutRedemptionPaymentTerminal,   JBSingleTokenPaymentTerminal,   JBOperatable,   Ownable,   ReentrancyGuard {   // A library that parses the packed funding cycle metadata into a friendlier format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error FEE_TOO_HIGH();   error INADEQUATE_DISTRIBUTION_AMOUNT();   error INADEQUATE_RECLAIM_AMOUNT();   error INADEQUATE_TOKEN_COUNT();   error NO_MSG_VALUE_ALLOWED();   error PAY_TO_ZERO_ADDRESS();   error PROJECT_TERMINAL_MISMATCH();   error REDEEM_TO_ZERO_ADDRESS();   error TERMINAL_IN_SPLIT_ZERO_ADDRESS();   error TERMINAL_TOKENS_INCOMPATIBLE(); //***********//   // ---------------------------- modifiers ---------------------------- //   //*************// /*      @notice      A modifier that verifies this terminal is a terminal of provided project ID.   /   modifier isTerminalOf(uint256 projectId) {     if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();     ;   } //***********//   // --------------------- internal stored constants ------------------- //   //*************// /**     @notice     Maximum fee that can be set for a funding cycle configuration. @dev Out of MAX_FEE (50_000_000 / 1_000_000_000).  */   uint256 internal constant _FEE_CAP = 50_000_000; /*     @notice     The protocol project ID is 1, as it should be the first project launched during the deployment process.   /   uint256 internal constant _PROTOCOL_PROJECT_ID = 1; //***********//   // --------------------- internal stored properties ------------------ //   //*************// /**     @notice     Fees that are being held to be processed later. _projectId The ID of the project for which fees are being held.  */   mapping(uint256 =&gt; JBFee[]) internal _heldFeesOf; //***********//   // ---------------- public immutable stored properties --------------- //   //*************// /*     @notice     Mints ERC-721's that represent project ownership and transfers.   /   IJBProjects public immutable override projects; /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; /*     @notice     The contract that stores splits for each project.   /   IJBSplitsStore public immutable override splitsStore; /*     @notice     The contract that exposes price feeds.   /   IJBPrices public immutable override prices; /*     @notice     The contract that stores and manages the terminal's data.   /   IJBSingleTokenPaymentTerminalStore public immutable override store; /**     @notice     The currency to base token issuance on. @dev If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.  */   uint256 public immutable override baseWeightCurrency; /*     @notice     The group that payout splits coming from this terminal are identified by.   /   uint256 public immutable override payoutSplitsGroup; //***********//   // --------------------- public stored properties -------------------- //   //*************// /**     @notice     The platform fee percent. @dev Out of MAX_FEE (25_000_000 / 1_000_000_000)  */   uint256 public override fee = 25_000_000; // 2.5% /*     @notice     The data source that returns a discount to apply to a project's fee.   /   IJBFeeGauge public override feeGauge; /**     @notice     Addresses that can be paid towards from this terminal without incurring a fee. _address The address that can be paid toward.  */   mapping(address =&gt; bool) public override isFeelessAddress; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     Gets the current overflowed amount in this terminal for a specified project, in terms of ETH. @dev The current overflow is represented as a fixed point number with 18 decimals.  @param _projectId The ID of the project to get overflow for.  @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.  */   function currentEthOverflowOf(uint256 _projectId)     external     view     virtual     override     returns (uint256)   {     // Get this terminal's current overflow.     uint256 _overflow = store.currentOverflowOf(this, _projectId); // Adjust the decimals of the fixed point number if needed to have 18 decimals. uint256 _adjustedOverflow = (decimals == 18)   ? _overflow   : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);  // Return the amount converted to ETH. return   (currency == JBCurrencies.ETH)     ? _adjustedOverflow     : PRBMath.mulDiv(       _adjustedOverflow,       10**decimals,       prices.priceFor(currency, JBCurrencies.ETH, decimals)     );  } /**     @notice     The fees that are currently being held to be processed later for each project. @param _projectId The ID of the project for which fees are being held.  @return An array of fees that are being held.  */   function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {     return _heldFeesOf[_projectId];   } //***********//   // -------------------------- public views --------------------------- //   //*************// /**     @notice     Indicates if this contract adheres to the specified interface. @dev  See {IERC165-supportsInterface}.  @param _interfaceId The ID of the interface to check for adherance to.  */   function supportsInterface(bytes4 _interfaceId)     public     view     virtual     override(JBSingleTokenPaymentTerminal, IERC165)     returns (bool)   {     return       _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||       _interfaceId == type(IJBPayoutTerminal).interfaceId ||       _interfaceId == type(IJBAllowanceTerminal).interfaceId ||       _interfaceId == type(IJBRedemptionTerminal).interfaceId ||       _interfaceId == type(IJBOperatable).interfaceId ||       super.supportsInterface(_interfaceId);   } //***********//   // -------------------------- constructor ---------------------------- //   //*************// /*     @param _token The token that this terminal manages.     @param _decimals The number of decimals the token fixed point amounts are expected to have.     @param _currency The currency that this terminal's token adheres to for price feeds.     @param _baseWeightCurrency The currency to base token issuance on.     @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.     @param _operatorStore A contract storing operator assignments.     @param _projects A contract which mints ERC-721's that represent project ownership and transfers.     @param _directory A contract storing directories of terminals and controllers for each project.     @param _splitsStore A contract that stores splits for each project.     @param _prices A contract that exposes price feeds.     @param _store A contract that stores the terminal's data.     @param _owner The address that will own this contract.   /   constructor(     // payable constructor save the gas used to check msg.value==0     address _token,     uint256 _decimals,     uint256 _currency,     uint256 _baseWeightCurrency,     uint256 _payoutSplitsGroup,     IJBOperatorStore _operatorStore,     IJBProjects _projects,     IJBDirectory _directory,     IJBSplitsStore _splitsStore,     IJBPrices _prices,     IJBSingleTokenPaymentTerminalStore _store,     address _owner   )     payable     JBSingleTokenPaymentTerminal(_token, _decimals, _currency)     JBOperatable(_operatorStore)   {     baseWeightCurrency = _baseWeightCurrency;     payoutSplitsGroup = _payoutSplitsGroup;     projects = _projects;     directory = _directory;     splitsStore = _splitsStore;     prices = _prices;     store = _store; transferOwnership(_owner);  } //***********//   // ---------------------- external transactions ---------------------- //   //*************// /**     @notice     Contribute tokens to a project. @param _projectId The ID of the project being paid. @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place. @param _token The token being paid. This terminal ignores this property since it only manages one token.  @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate. @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal. @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas. @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.  */   function pay(     uint256 _projectId,     uint256 _amount,     address _token,     address _beneficiary,     uint256 _minReturnedTokens,     bool _preferClaimedTokens,     string calldata _memo,     bytes calldata _metadata   ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {     _token; // Prevents unused var compiler and natspec complaints. // ETH shouldn't be sent if this terminal's token isn't ETH. if (token != JBTokens.ETH) {   if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();    // Transfer tokens to this terminal from the msg sender.   _transferFrom(msg.sender, payable(address(this)), _amount); } // If this terminal's token is ETH, override _amount with msg.value. else _amount = msg.value;  return   _pay(     _amount,     msg.sender,     _projectId,     _beneficiary,     _minReturnedTokens,     _preferClaimedTokens,     _memo,     _metadata   );  } /**     @notice     Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source. @dev Only a token holder or a designated operator can redeem its tokens.  @param _holder The account to redeem tokens for. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _token The token being reclaimed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal. @param _beneficiary The address to send the terminal tokens to. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.  */   function redeemTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     address _token,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo,     bytes memory _metadata   )     external     virtual     override     requirePermission(_holder, _projectId, JBOperations.REDEEM)     returns (uint256 reclaimAmount)   {     _token; // Prevents unused var compiler and natspec complaints. return   _redeemTokensOf(     _holder,     _projectId,     _tokenCount,     _minReturnedTokens,     _beneficiary,     _memo,     _metadata   );  } /**     @notice     Distributes payouts for a project with the distribution limit of its current funding cycle. @dev Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.  @dev Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.  @dev All funds distributed outside of this contract or any feeless terminals incure the protocol fee.  @param _projectId The ID of the project having its payouts distributed. @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency. @param _token The token being distributed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal. @param _memo A memo to pass along to the emitted event.  @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.  */   function distributePayoutsOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     address _token,     uint256 _minReturnedTokens,     string calldata _memo   ) external virtual override returns (uint256 netLeftoverDistributionAmount) {     _token; // Prevents unused var compiler and natspec complaints. return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);  } /**     @notice     Allows a project to send funds from its overflow up to the preconfigured allowance. @dev Only a project's owner or a designated operator can use its allowance.  @dev Incurs the protocol fee.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency. @param _token The token being distributed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals. @param _beneficiary The address to send the funds to. @param _memo A memo to pass along to the emitted event.  @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.  */   function useAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     address _token,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)     returns (uint256 netDistributedAmount)   {     _token; // Prevents unused var compiler and natspec complaints. return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);  } /**     @notice     Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type. @dev Only a project's owner or a designated operator can migrate it.  @param _projectId The ID of the project being migrated. @param _to The terminal contract that will gain the project's funds.  @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.  */   function migrate(uint256 _projectId, IJBPaymentTerminal _to)     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)     returns (uint256 balance)   {     // The terminal being migrated to must accept the same token as this terminal.     if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE(); // Record the migration in the store. balance = store.recordMigration(_projectId);  // Transfer the balance if needed. if (balance &gt; 0) {   // Trigger any inherited pre-transfer logic.   _beforeTransferTo(address(_to), balance);    // If this terminal's token is ETH, send it in msg.value.   uint256 _payableValue = token == JBTokens.ETH ? balance : 0;    // Withdraw the balance to transfer to the new terminal;   _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes('')); }  emit Migrate(_projectId, _to, balance, msg.sender);  } /**     @notice     Receives funds belonging to the specified project. @param _projectId The ID of the project to which the funds received belong. @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead. @param _token The token being paid. This terminal ignores this property since it only manages one currency.  @param _memo A memo to pass along to the emitted event. @param _metadata Extra data to pass along to the emitted event.  */   function addToBalanceOf(     uint256 _projectId,     uint256 _amount,     address _token,     string calldata _memo,     bytes calldata _metadata   ) external payable virtual override isTerminalOf(_projectId) {     _token; // Prevents unused var compiler and natspec complaints. // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender. if (token != JBTokens.ETH) {   // Amount must be greater than 0.   if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();    // Transfer tokens to this terminal from the msg sender.   _transferFrom(msg.sender, payable(address(this)), _amount); } // If the terminal's token is ETH, override `_amount` with msg.value. else _amount = msg.value;  // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal. _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);  } /**     @notice     Process any fees that are being held for the project. @dev Only a project owner, an operator, or the contract's owner can process held fees.  @param _projectId The ID of the project whos held fees should be processed.  */   function processFees(uint256 _projectId)     external     virtual     override     requirePermissionAllowingOverride(       projects.ownerOf(_projectId),       _projectId,       JBOperations.PROCESS_FEES,       msg.sender == owner()     )   {     // Get a reference to the project's held fees.     JBFee[] memory _heldFees = _heldFeesOf[_projectId]; // Delete the held fees. delete _heldFeesOf[_projectId];  // Push array length in stack uint256 _heldFeeLength = _heldFees.length;  // Process each fee. for (uint256 _i = 0; _i &lt; _heldFeeLength; ) {   // Get the fee amount.   uint256 _amount = _feeAmount(     _heldFees[_i].amount,     _heldFees[_i].fee,     _heldFees[_i].feeDiscount   );    // Process the fee.   _processFee(_amount, _heldFees[_i].beneficiary);    emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);    unchecked {     ++_i;   } }  } /**     @notice     Allows the fee to be updated. @dev Only the owner of this contract can change the fee.  @param _fee The new fee, out of MAX_FEE.  */   function setFee(uint256 _fee) external virtual override onlyOwner {     // The provided fee must be within the max.     if (_fee &gt; _FEE_CAP) revert FEE_TOO_HIGH(); // Store the new fee. fee = _fee;  emit SetFee(_fee, msg.sender);  } /**     @notice     Allows the fee gauge to be updated. @dev Only the owner of this contract can change the fee gauge.  @dev If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.  @param _feeGauge The new fee gauge.  */   function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {     // Store the new fee gauge.     feeGauge = _feeGauge; emit SetFeeGauge(_feeGauge, msg.sender);  } /**     @notice     Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee. @dev Only the owner of this contract can set addresses as feeless.  @param _address The address that can be paid towards while still bypassing fees. @param _flag A flag indicating whether the terminal should be feeless or not.  */   function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {     // Set the flag value.     isFeelessAddress[_address] = _flag; emit SetFeelessAddress(_address, _flag, msg.sender);  } //***********//   // ---------------------- internal transactions ---------------------- //   //*************// /**      @notice     Transfers tokens. @param _from The address from which the transfer should originate. @param _to The address to which the transfer should go. @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.  */   function _transferFrom(     address _from,     address payable _to,     uint256 _amount   ) internal virtual; /**      @notice     Logic to be triggered before transferring tokens from this terminal. @param _to The address to which the transfer is going. @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.  */   function _beforeTransferTo(address _to, uint256 _amount) internal virtual; /**     @notice     Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source. @dev Only a token holder or a designated operator can redeem its tokens.  @param _holder The account to redeem tokens for. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal. @param _beneficiary The address to send the terminal tokens to. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.  */   function _redeemTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo,     bytes memory _metadata   ) internal returns (uint256 reclaimAmount) {     // Can't send reclaimed funds to the zero address.     if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS(); // Define variables that will be needed outside the scoped section below. // Keep a reference to the funding cycle during which the redemption is being made. JBFundingCycle memory _fundingCycle;  // Scoped section prevents stack too deep. `_delegate` only used within scope. {   IJBRedemptionDelegate _delegate;    // Record the redemption.   (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(     _holder,     _projectId,     _tokenCount,     _memo,     _metadata   );    // The amount being reclaimed must be at least as much as was expected.   if (reclaimAmount &lt; _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();    // Burn the project tokens.   if (_tokenCount &gt; 0)     IJBController(directory.controllerOf(_projectId)).burnTokensOf(       _holder,       _projectId,       _tokenCount,       '',       false     );    // If a delegate was returned by the data source, issue a callback to it.   if (_delegate != IJBRedemptionDelegate(address(0))) {     JBDidRedeemData memory _data = JBDidRedeemData(       _holder,       _projectId,       _fundingCycle.configuration,       _tokenCount,       JBTokenAmount(token, reclaimAmount, decimals, currency),       _beneficiary,       _memo,       _metadata     );     _delegate.didRedeem(_data);     emit DelegateDidRedeem(_delegate, _data, msg.sender);   } }  // Send the reclaimed funds to the beneficiary. if (reclaimAmount &gt; 0) _transferFrom(address(this), _beneficiary, reclaimAmount);  emit RedeemTokens(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _holder,   _beneficiary,   _tokenCount,   reclaimAmount,   _memo,   _metadata,   msg.sender );  } /**     @notice     Distributes payouts for a project with the distribution limit of its current funding cycle. @dev Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.  @dev Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.  @dev All funds distributed outside of this contract or any feeless terminals incure the protocol fee.  @param _projectId The ID of the project having its payouts distributed. @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency. @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal. @param _memo A memo to pass along to the emitted event.  @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.  */   function _distributePayoutsOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     uint256 _minReturnedTokens,     string calldata _memo   ) internal returns (uint256 netLeftoverDistributionAmount) {     // Record the distribution.     (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(       _projectId,       _amount,       _currency     ); // The amount being distributed must be at least as much as was expected. if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();  // Get a reference to the project owner, which will receive tokens from paying the platform fee // and receive any extra distributable funds not allocated to payout splits. address payable _projectOwner = payable(projects.ownerOf(_projectId));  // Define variables that will be needed outside the scoped section below. // Keep a reference to the fee amount that was paid. uint256 _fee;  // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope. {   // Get the amount of discount that should be applied to any fees taken.   // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.   uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]     ? JBConstants.MAX_FEE_DISCOUNT     : _currentFeeDiscount(_projectId);    // The amount distributed that is eligible for incurring fees.   uint256 _feeEligibleDistributionAmount;    // The amount leftover after distributing to the splits.   uint256 _leftoverDistributionAmount;    // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.   // Also get a reference to the amount that was distributed to splits from which fees should be taken.   (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(     _projectId,     _fundingCycle.configuration,     payoutSplitsGroup,     _distributedAmount,     _feeDiscount   );    // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.   unchecked {     _feeEligibleDistributionAmount += _leftoverDistributionAmount;   }    // Take the fee.   _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0     ? 0     : _takeFeeFrom(       _projectId,       _fundingCycle,       _feeEligibleDistributionAmount,       _projectOwner,       _feeDiscount     );    // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.    unchecked {     netLeftoverDistributionAmount = _leftoverDistributionAmount == 0       ? 0       : _leftoverDistributionAmount -         _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);   }    // Transfer any remaining balance to the project owner.   if (netLeftoverDistributionAmount &gt; 0)     _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount); }  emit DistributePayouts(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _projectOwner,   _amount,   _distributedAmount,   _fee,   netLeftoverDistributionAmount,   _memo,   msg.sender );  } /**     @notice     Allows a project to send funds from its overflow up to the preconfigured allowance. @dev Only a project's owner or a designated operator can use its allowance.  @dev Incurs the protocol fee.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency. @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals. @param _beneficiary The address to send the funds to. @param _memo A memo to pass along to the emitted event.  @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.  */   function _useAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo   ) internal returns (uint256 netDistributedAmount) {     // Record the use of the allowance.     (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(       _projectId,       _amount,       _currency     ); // The amount being withdrawn must be at least as much as was expected. if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();  // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope. {   // Keep a reference to the fee amount that was paid.   uint256 _fee;    // Get a reference to the project owner, which will receive tokens from paying the platform fee.   address _projectOwner = projects.ownerOf(_projectId);    // Get the amount of discount that should be applied to any fees taken.   // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.   uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]     ? JBConstants.MAX_FEE_DISCOUNT     : _currentFeeDiscount(_projectId);    // Take a fee from the `_distributedAmount`, if needed.   _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT     ? 0     : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);    unchecked {     // The net amount is the withdrawn amount without the fee.     netDistributedAmount = _distributedAmount - _fee;   }    // Transfer any remaining balance to the beneficiary.   if (netDistributedAmount &gt; 0)     _transferFrom(address(this), _beneficiary, netDistributedAmount); }  emit UseAllowance(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _beneficiary,   _amount,   _distributedAmount,   netDistributedAmount,   _memo,   msg.sender );  } /**     @notice     Pays out splits for a project's funding cycle configuration. @param _projectId The ID of the project for which payout splits are being distributed. @param _domain The domain of the splits to distribute the payout between. @param _group The group of the splits to distribute the payout between. @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal. @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.  @return leftoverAmount If the leftover amount if the splits don't add up to 100%. @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.  */   function _distributeToPayoutSplitsOf(     uint256 _projectId,     uint256 _domain,     uint256 _group,     uint256 _amount,     uint256 _feeDiscount   ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {     // Set the leftover amount to the initial amount.     leftoverAmount = _amount; // Get a reference to the project's payout splits. JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);  // Transfer between all splits. for (uint256 _i = 0; _i &lt; _splits.length; ) {   // Get a reference to the split being iterated on.   JBSplit memory _split = _splits[_i];    // The amount to send towards the split.   uint256 _payoutAmount = PRBMath.mulDiv(     _amount,     _split.percent,     JBConstants.SPLITS_TOTAL_PERCENT   );    // The payout amount substracting any applicable incurred fees.   uint256 _netPayoutAmount;    if (_payoutAmount &gt; 0) {     // Transfer tokens to the split.     // If there's an allocator set, transfer to its `allocate` function.     if (_split.allocator != IJBSplitAllocator(address(0))) {       // If the split allocator is set as feeless, this distribution is not eligible for a fee.       if (isFeelessAddress[address(_split.allocator)])         _netPayoutAmount = _payoutAmount;         // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.       else {         unchecked {           _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT             ? _payoutAmount             : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);         }          // This distribution is eligible for a fee since the funds are leaving the ecosystem.         feeEligibleDistributionAmount += _payoutAmount;       }        // Trigger any inherited pre-transfer logic.       _beforeTransferTo(address(_split.allocator), _netPayoutAmount);        // If this terminal's token is ETH, send it in msg.value.       uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;        // Create the data to send to the allocator.       JBSplitAllocationData memory _data = JBSplitAllocationData(         token,         _netPayoutAmount,         decimals,         _projectId,         _group,         _split       );        // Trigger the allocator's `allocate` function.       _split.allocator.allocate{value: _payableValue}(_data);        // Otherwise, if a project is specified, make a payment to it.     } else if (_split.projectId != 0) {       // Get a reference to the Juicebox terminal being used.       IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);        // The project must have a terminal to send funds to.       if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();        // Save gas if this contract is being used as the terminal.       if (_terminal == this) {         // This distribution does not incur a fee.         _netPayoutAmount = _payoutAmount;          // Send the projectId in the metadata.         bytes memory _projectMetadata = new bytes(32);         _projectMetadata = bytes(abi.encodePacked(_projectId));          // Add to balance if prefered.         if (_split.preferAddToBalance)           _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);         else           _pay(             _netPayoutAmount,             address(this),             _split.projectId,             (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,             0,             _split.preferClaimed,             '',             _projectMetadata           );       } else {         // If the terminal is set as feeless, this distribution is not eligible for a fee.         if (isFeelessAddress[address(_terminal)])           _netPayoutAmount = _payoutAmount;           // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.         else {           unchecked {             _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT               ? _payoutAmount               : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);           }            feeEligibleDistributionAmount += _payoutAmount;         }          // Trigger any inherited pre-transfer logic.         _beforeTransferTo(address(_terminal), _netPayoutAmount);          // If this terminal's token is ETH, send it in msg.value.         uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;          // Send the projectId in the metadata.         bytes memory _projectMetadata = new bytes(32);         _projectMetadata = bytes(abi.encodePacked(_projectId));          // Add to balance if prefered.         if (_split.preferAddToBalance)           _terminal.addToBalanceOf{value: _payableValue}(             _split.projectId,             _netPayoutAmount,             token,             '',             _projectMetadata           );         else           _terminal.pay{value: _payableValue}(             _split.projectId,             _netPayoutAmount,             token,             _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,             0,             _split.preferClaimed,             '',             _projectMetadata           );       }     } else {       unchecked {         _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT           ? _payoutAmount           : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);       }        // This distribution is eligible for a fee since the funds are leaving the ecosystem.       feeEligibleDistributionAmount += _payoutAmount;        // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.       _transferFrom(         address(this),         _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),         _netPayoutAmount       );     }      // Subtract from the amount to be sent to the beneficiary.     unchecked {       leftoverAmount = leftoverAmount - _payoutAmount;     }   }    emit DistributeToPayoutSplit(     _projectId,     _domain,     _group,     _split,     _netPayoutAmount,     msg.sender   );    unchecked {     ++_i;   } }  } /**     @notice     Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID. @param _projectId The ID of the project having fees taken from. @param _fundingCycle The funding cycle during which the fee is being taken. @param _amount The amount of the fee to take, as a floating point number with 18 decimals. @param _beneficiary The address to mint the platforms tokens for. @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.  @return feeAmount The amount of the fee taken.  */   function _takeFeeFrom(     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _amount,     address _beneficiary,     uint256 _feeDiscount   ) internal returns (uint256 feeAmount) {     feeAmount = _feeAmount(_amount, fee, _feeDiscount); if (_fundingCycle.shouldHoldFees()) {   // Store the held fee.   _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));    emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender); } else {   // Process the fee.   _processFee(feeAmount, _beneficiary); // Take the fee.    emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender); }  } /**     @notice     Process a fee of the specified amount. @param _amount The fee amount, as a floating point number with 18 decimals. @param _beneficiary The address to mint the platform's tokens for.  */   function _processFee(uint256 _amount, address _beneficiary) internal {     // Get the terminal for the protocol project.     IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token); // When processing the admin fee, save gas if the admin is using this contract as its terminal. if (_terminal == this)   _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call. else {   // Trigger any inherited pre-transfer logic.   _beforeTransferTo(address(_terminal), _amount);    // If this terminal's token is ETH, send it in msg.value.   uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;    // Send the payment.   _terminal.pay{value: _payableValue}(     _PROTOCOL_PROJECT_ID,     _amount,     token,     _beneficiary,     0,     false,     '',     bytes('')   ); // Use the external pay call of the correct terminal. }  } /**     @notice     Contribute tokens to a project. @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place. @param _payer The address making the payment. @param _projectId The ID of the project being paid. @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate. @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal. @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas. @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.  */   function _pay(     uint256 _amount,     address _payer,     uint256 _projectId,     address _beneficiary,     uint256 _minReturnedTokens,     bool _preferClaimedTokens,     string memory _memo,     bytes memory _metadata   ) internal returns (uint256 beneficiaryTokenCount) {     // Cant send tokens to the zero address.     if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS(); // Define variables that will be needed outside the scoped section below. // Keep a reference to the funding cycle during which the payment is being made. JBFundingCycle memory _fundingCycle;  // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope. {   IJBPayDelegate _delegate;   uint256 _tokenCount;    // Bundle the amount info into a JBTokenAmount struct.   JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);    // Record the payment.   (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(     _payer,     _bundledAmount,     _projectId,     baseWeightCurrency,     _beneficiary,     _memo,     _metadata   );    // Mint the tokens if needed.   if (_tokenCount &gt; 0)     // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.     beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(       _projectId,       _tokenCount,       _beneficiary,       '',       _preferClaimedTokens,       true     );    // The token count for the beneficiary must be greater than or equal to the minimum expected.   if (beneficiaryTokenCount &lt; _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();    // If a delegate was returned by the data source, issue a callback to it.   if (_delegate != IJBPayDelegate(address(0))) {     JBDidPayData memory _data = JBDidPayData(       _payer,       _projectId,       _fundingCycle.configuration,       _bundledAmount,       beneficiaryTokenCount,       _beneficiary,       _preferClaimedTokens,       _memo,       _metadata     );      _delegate.didPay(_data);     emit DelegateDidPay(_delegate, _data, msg.sender);   } }  emit Pay(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _payer,   _beneficiary,   _amount,   beneficiaryTokenCount,   _memo,   _metadata,   msg.sender );  } /**     @notice     Receives funds belonging to the specified project. @param _projectId The ID of the project to which the funds received belong. @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead. @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added. @param _memo A memo to pass along to the emitted event. @param _metadata Extra data to pass along to the emitted event.  */   function _addToBalanceOf(     uint256 _projectId,     uint256 _amount,     bool _shouldRefundHeldFees,     string memory _memo,     bytes memory _metadata   ) internal {     // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.     uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0; // Record the added funds with any refunded fees. store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);  emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);  } /**     @notice     Refund fees based on the specified amount. @param _projectId The project for which fees are being refunded. @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.  @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal  */   function _refundHeldFees(uint256 _projectId, uint256 _amount)     internal     returns (uint256 refundedFees)   {     // Get a reference to the project's held fees.     JBFee[] memory _heldFees = _heldFeesOf[_projectId]; // Delete the current held fees. delete _heldFeesOf[_projectId];  // Get a reference to the leftover amount once all fees have been settled. uint256 leftoverAmount = _amount;  // Push length in stack uint256 _heldFeesLength = _heldFees.length;  // Process each fee. for (uint256 _i = 0; _i &lt; _heldFeesLength; ) {   if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);   else if (leftoverAmount &gt;= _heldFees[_i].amount) {     unchecked {       leftoverAmount = leftoverAmount - _heldFees[_i].amount;       refundedFees += _feeAmount(         _heldFees[_i].amount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount       );     }   } else {     _heldFeesOf[_projectId].push(       JBFee(         _heldFees[_i].amount - leftoverAmount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount,         _heldFees[_i].beneficiary       )     );     unchecked {       refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);     }     leftoverAmount = 0;   }    unchecked {     ++_i;   } }  emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);  } /**      @notice      Returns the fee amount based on the provided amount for the specified project. @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal. @param _fee The percentage of the fee, out of MAX_FEE.  @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.  @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.  */   function _feeAmount(     uint256 _amount,     uint256 _fee,     uint256 _feeDiscount   ) internal pure returns (uint256) {     // Calculate the discounted fee.     uint256 _discountedFee = _fee -       PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT); // The amount of tokens from the `_amount` to pay as a fee. return   _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);  } /**      @notice     Get the fee discount from the fee gauge for the specified project. @param _projectId The ID of the project to get a fee discount for.  @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.  */   function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {     // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.     if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))       return JBConstants.MAX_FEE_DISCOUNT; // Get the fee discount. if (feeGauge == IJBFeeGauge(address(0)))   feeDiscount = 0;   // If the guage reverts, set the discount to 0. else   try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {     feeDiscount = discount;   } catch {     feeDiscount = 0;   }  // If the fee discount is greater than the max, nullify the discount. if (feeDiscount &gt; JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;  } } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 17:18:13 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/security/ReentrancyGuard.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './../interfaces/IJBController.sol'; import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol'; import './../libraries/JBConstants.sol'; import './../libraries/JBCurrencies.sol'; import './../libraries/JBFixedPointNumber.sol'; import './../libraries/JBFundingCycleMetadataResolver.sol'; import './../libraries/JBOperations.sol'; import './../libraries/JBSplitsGroups.sol'; import './../libraries/JBTokens.sol'; import './../structs/JBTokenAmount.sol'; import './JBOperatable.sol'; import './JBSingleTokenPaymentTerminal.sol'; /**   @notice   Generic terminal managing all inflows and outflows of funds into the protocol ecosystem. @dev   A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time. @dev   Adheres to -   IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules. @dev   Inherits from -   JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.   JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.   Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.   ReentrancyGuard: Contract module that helps prevent reentrant calls to a function. */ abstract contract JBPayoutRedemptionPaymentTerminal is   IJBPayoutRedemptionPaymentTerminal,   JBSingleTokenPaymentTerminal,   JBOperatable,   Ownable,   ReentrancyGuard {   // A library that parses the packed funding cycle metadata into a friendlier format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error FEE_TOO_HIGH();   error INADEQUATE_DISTRIBUTION_AMOUNT();   error INADEQUATE_RECLAIM_AMOUNT();   error INADEQUATE_TOKEN_COUNT();   error NO_MSG_VALUE_ALLOWED();   error PAY_TO_ZERO_ADDRESS();   error PROJECT_TERMINAL_MISMATCH();   error REDEEM_TO_ZERO_ADDRESS();   error TERMINAL_IN_SPLIT_ZERO_ADDRESS();   error TERMINAL_TOKENS_INCOMPATIBLE(); //***********//   // ---------------------------- modifiers ---------------------------- //   //*************// /*      @notice      A modifier that verifies this terminal is a terminal of provided project ID.   /   modifier isTerminalOf(uint256 projectId) {     if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();     ;   } //***********//   // --------------------- internal stored constants ------------------- //   //*************// /**     @notice     Maximum fee that can be set for a funding cycle configuration. @dev Out of MAX_FEE (50_000_000 / 1_000_000_000).  */   uint256 internal constant _FEE_CAP = 50_000_000; /*     @notice     The protocol project ID is 1, as it should be the first project launched during the deployment process.   /   uint256 internal constant _PROTOCOL_PROJECT_ID = 1; //***********//   // --------------------- internal stored properties ------------------ //   //*************// /**     @notice     Fees that are being held to be processed later. _projectId The ID of the project for which fees are being held.  */   mapping(uint256 =&gt; JBFee[]) internal _heldFeesOf; //***********//   // ---------------- public immutable stored properties --------------- //   //*************// /*     @notice     Mints ERC-721's that represent project ownership and transfers.   /   IJBProjects public immutable override projects; /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; /*     @notice     The contract that stores splits for each project.   /   IJBSplitsStore public immutable override splitsStore; /*     @notice     The contract that exposes price feeds.   /   IJBPrices public immutable override prices; /*     @notice     The contract that stores and manages the terminal's data.   /   IJBSingleTokenPaymentTerminalStore public immutable override store; /**     @notice     The currency to base token issuance on. @dev If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.  */   uint256 public immutable override baseWeightCurrency; /*     @notice     The group that payout splits coming from this terminal are identified by.   /   uint256 public immutable override payoutSplitsGroup; //***********//   // --------------------- public stored properties -------------------- //   //*************// /**     @notice     The platform fee percent. @dev Out of MAX_FEE (25_000_000 / 1_000_000_000)  */   uint256 public override fee = 25_000_000; // 2.5% /*     @notice     The data source that returns a discount to apply to a project's fee.   /   IJBFeeGauge public override feeGauge; /**     @notice     Addresses that can be paid towards from this terminal without incurring a fee. _address The address that can be paid toward.  */   mapping(address =&gt; bool) public override isFeelessAddress; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     Gets the current overflowed amount in this terminal for a specified project, in terms of ETH. @dev The current overflow is represented as a fixed point number with 18 decimals.  @param _projectId The ID of the project to get overflow for.  @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.  */   function currentEthOverflowOf(uint256 _projectId)     external     view     virtual     override     returns (uint256)   {     // Get this terminal's current overflow.     uint256 _overflow = store.currentOverflowOf(this, _projectId); // Adjust the decimals of the fixed point number if needed to have 18 decimals. uint256 _adjustedOverflow = (decimals == 18)   ? _overflow   : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);  // Return the amount converted to ETH. return   (currency == JBCurrencies.ETH)     ? _adjustedOverflow     : PRBMath.mulDiv(       _adjustedOverflow,       10**decimals,       prices.priceFor(currency, JBCurrencies.ETH, decimals)     );  } /**     @notice     The fees that are currently being held to be processed later for each project. @param _projectId The ID of the project for which fees are being held.  @return An array of fees that are being held.  */   function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {     return _heldFeesOf[_projectId];   } //***********//   // -------------------------- public views --------------------------- //   //*************// /**     @notice     Indicates if this contract adheres to the specified interface. @dev  See {IERC165-supportsInterface}.  @param _interfaceId The ID of the interface to check for adherance to.  */   function supportsInterface(bytes4 _interfaceId)     public     view     virtual     override(JBSingleTokenPaymentTerminal, IERC165)     returns (bool)   {     return       _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||       _interfaceId == type(IJBPayoutTerminal).interfaceId ||       _interfaceId == type(IJBAllowanceTerminal).interfaceId ||       _interfaceId == type(IJBRedemptionTerminal).interfaceId ||       _interfaceId == type(IJBOperatable).interfaceId ||       super.supportsInterface(_interfaceId);   } //***********//   // -------------------------- constructor ---------------------------- //   //*************// /*     @param _token The token that this terminal manages.     @param _decimals The number of decimals the token fixed point amounts are expected to have.     @param _currency The currency that this terminal's token adheres to for price feeds.     @param _baseWeightCurrency The currency to base token issuance on.     @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.     @param _operatorStore A contract storing operator assignments.     @param _projects A contract which mints ERC-721's that represent project ownership and transfers.     @param _directory A contract storing directories of terminals and controllers for each project.     @param _splitsStore A contract that stores splits for each project.     @param _prices A contract that exposes price feeds.     @param _store A contract that stores the terminal's data.     @param _owner The address that will own this contract.   /   constructor(     // payable constructor save the gas used to check msg.value==0     address _token,     uint256 _decimals,     uint256 _currency,     uint256 _baseWeightCurrency,     uint256 _payoutSplitsGroup,     IJBOperatorStore _operatorStore,     IJBProjects _projects,     IJBDirectory _directory,     IJBSplitsStore _splitsStore,     IJBPrices _prices,     IJBSingleTokenPaymentTerminalStore _store,     address _owner   )     payable     JBSingleTokenPaymentTerminal(_token, _decimals, _currency)     JBOperatable(_operatorStore)   {     baseWeightCurrency = _baseWeightCurrency;     payoutSplitsGroup = _payoutSplitsGroup;     projects = _projects;     directory = _directory;     splitsStore = _splitsStore;     prices = _prices;     store = _store; transferOwnership(_owner);  } //***********//   // ---------------------- external transactions ---------------------- //   //*************// /**     @notice     Contribute tokens to a project. @param _projectId The ID of the project being paid. @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place. @param _token The token being paid. This terminal ignores this property since it only manages one token.  @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate. @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal. @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas. @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.  */   function pay(     uint256 _projectId,     uint256 _amount,     address _token,     address _beneficiary,     uint256 _minReturnedTokens,     bool _preferClaimedTokens,     string calldata _memo,     bytes calldata _metadata   ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {     _token; // Prevents unused var compiler and natspec complaints. // ETH shouldn't be sent if this terminal's token isn't ETH. if (token != JBTokens.ETH) {   if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();    // Transfer tokens to this terminal from the msg sender.   _transferFrom(msg.sender, payable(address(this)), _amount); } // If this terminal's token is ETH, override _amount with msg.value. else _amount = msg.value;  return   _pay(     _amount,     msg.sender,     _projectId,     _beneficiary,     _minReturnedTokens,     _preferClaimedTokens,     _memo,     _metadata   );  } /**     @notice     Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source. @dev Only a token holder or a designated operator can redeem its tokens.  @param _holder The account to redeem tokens for. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _token The token being reclaimed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal. @param _beneficiary The address to send the terminal tokens to. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.  */   function redeemTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     address _token,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo,     bytes memory _metadata   )     external     virtual     override     requirePermission(_holder, _projectId, JBOperations.REDEEM)     returns (uint256 reclaimAmount)   {     _token; // Prevents unused var compiler and natspec complaints. return   _redeemTokensOf(     _holder,     _projectId,     _tokenCount,     _minReturnedTokens,     _beneficiary,     _memo,     _metadata   );  } /**     @notice     Distributes payouts for a project with the distribution limit of its current funding cycle. @dev Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.  @dev Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.  @dev All funds distributed outside of this contract or any feeless terminals incure the protocol fee.  @param _projectId The ID of the project having its payouts distributed. @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency. @param _token The token being distributed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal. @param _memo A memo to pass along to the emitted event.  @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.  */   function distributePayoutsOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     address _token,     uint256 _minReturnedTokens,     string calldata _memo   ) external virtual override returns (uint256 netLeftoverDistributionAmount) {     _token; // Prevents unused var compiler and natspec complaints. return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);  } /**     @notice     Allows a project to send funds from its overflow up to the preconfigured allowance. @dev Only a project's owner or a designated operator can use its allowance.  @dev Incurs the protocol fee.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency. @param _token The token being distributed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals. @param _beneficiary The address to send the funds to. @param _memo A memo to pass along to the emitted event.  @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.  */   function useAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     address _token,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)     returns (uint256 netDistributedAmount)   {     _token; // Prevents unused var compiler and natspec complaints. return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);  } /**     @notice     Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type. @dev Only a project's owner or a designated operator can migrate it.  @param _projectId The ID of the project being migrated. @param _to The terminal contract that will gain the project's funds.  @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.  */   function migrate(uint256 _projectId, IJBPaymentTerminal _to)     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)     returns (uint256 balance)   {     // The terminal being migrated to must accept the same token as this terminal.     if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE(); // Record the migration in the store. balance = store.recordMigration(_projectId);  // Transfer the balance if needed. if (balance &gt; 0) {   // Trigger any inherited pre-transfer logic.   _beforeTransferTo(address(_to), balance);    // If this terminal's token is ETH, send it in msg.value.   uint256 _payableValue = token == JBTokens.ETH ? balance : 0;    // Withdraw the balance to transfer to the new terminal;   _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes('')); }  emit Migrate(_projectId, _to, balance, msg.sender);  } /**     @notice     Receives funds belonging to the specified project. @param _projectId The ID of the project to which the funds received belong. @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead. @param _token The token being paid. This terminal ignores this property since it only manages one currency.  @param _memo A memo to pass along to the emitted event. @param _metadata Extra data to pass along to the emitted event.  */   function addToBalanceOf(     uint256 _projectId,     uint256 _amount,     address _token,     string calldata _memo,     bytes calldata _metadata   ) external payable virtual override isTerminalOf(_projectId) {     _token; // Prevents unused var compiler and natspec complaints. // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender. if (token != JBTokens.ETH) {   // Amount must be greater than 0.   if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();    // Transfer tokens to this terminal from the msg sender.   _transferFrom(msg.sender, payable(address(this)), _amount); } // If the terminal's token is ETH, override `_amount` with msg.value. else _amount = msg.value;  // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal. _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);  } /**     @notice     Process any fees that are being held for the project. @dev Only a project owner, an operator, or the contract's owner can process held fees.  @param _projectId The ID of the project whos held fees should be processed.  */   function processFees(uint256 _projectId)     external     virtual     override     requirePermissionAllowingOverride(       projects.ownerOf(_projectId),       _projectId,       JBOperations.PROCESS_FEES,       msg.sender == owner()     )   {     // Get a reference to the project's held fees.     JBFee[] memory _heldFees = _heldFeesOf[_projectId]; // Delete the held fees. delete _heldFeesOf[_projectId];  // Push array length in stack uint256 _heldFeeLength = _heldFees.length;  // Process each fee. for (uint256 _i = 0; _i &lt; _heldFeeLength; ) {   // Get the fee amount.   uint256 _amount = _feeAmount(     _heldFees[_i].amount,     _heldFees[_i].fee,     _heldFees[_i].feeDiscount   );    // Process the fee.   _processFee(_amount, _heldFees[_i].beneficiary);    emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);    unchecked {     ++_i;   } }  } /**     @notice     Allows the fee to be updated. @dev Only the owner of this contract can change the fee.  @param _fee The new fee, out of MAX_FEE.  */   function setFee(uint256 _fee) external virtual override onlyOwner {     // The provided fee must be within the max.     if (_fee &gt; _FEE_CAP) revert FEE_TOO_HIGH(); // Store the new fee. fee = _fee;  emit SetFee(_fee, msg.sender);  } /**     @notice     Allows the fee gauge to be updated. @dev Only the owner of this contract can change the fee gauge.  @dev If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.  @param _feeGauge The new fee gauge.  */   function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {     // Store the new fee gauge.     feeGauge = _feeGauge; emit SetFeeGauge(_feeGauge, msg.sender);  } /**     @notice     Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee. @dev Only the owner of this contract can set addresses as feeless.  @param _address The address that can be paid towards while still bypassing fees. @param _flag A flag indicating whether the terminal should be feeless or not.  */   function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {     // Set the flag value.     isFeelessAddress[_address] = _flag; emit SetFeelessAddress(_address, _flag, msg.sender);  } //***********//   // ---------------------- internal transactions ---------------------- //   //*************// /**      @notice     Transfers tokens. @param _from The address from which the transfer should originate. @param _to The address to which the transfer should go. @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.  */   function _transferFrom(     address _from,     address payable _to,     uint256 _amount   ) internal virtual; /**      @notice     Logic to be triggered before transferring tokens from this terminal. @param _to The address to which the transfer is going. @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.  */   function _beforeTransferTo(address _to, uint256 _amount) internal virtual; /**     @notice     Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source. @dev Only a token holder or a designated operator can redeem its tokens.  @param _holder The account to redeem tokens for. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal. @param _beneficiary The address to send the terminal tokens to. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.  */   function _redeemTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo,     bytes memory _metadata   ) internal returns (uint256 reclaimAmount) {     // Can't send reclaimed funds to the zero address.     if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS(); // Define variables that will be needed outside the scoped section below. // Keep a reference to the funding cycle during which the redemption is being made. JBFundingCycle memory _fundingCycle;  // Scoped section prevents stack too deep. `_delegate` only used within scope. {   IJBRedemptionDelegate _delegate;    // Record the redemption.   (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(     _holder,     _projectId,     _tokenCount,     _memo,     _metadata   );    // The amount being reclaimed must be at least as much as was expected.   if (reclaimAmount &lt; _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();    // Burn the project tokens.   if (_tokenCount &gt; 0)     IJBController(directory.controllerOf(_projectId)).burnTokensOf(       _holder,       _projectId,       _tokenCount,       '',       false     );    // If a delegate was returned by the data source, issue a callback to it.   if (_delegate != IJBRedemptionDelegate(address(0))) {     JBDidRedeemData memory _data = JBDidRedeemData(       _holder,       _projectId,       _fundingCycle.configuration,       _tokenCount,       JBTokenAmount(token, reclaimAmount, decimals, currency),       _beneficiary,       _memo,       _metadata     );     _delegate.didRedeem(_data);     emit DelegateDidRedeem(_delegate, _data, msg.sender);   } }  // Send the reclaimed funds to the beneficiary. if (reclaimAmount &gt; 0) _transferFrom(address(this), _beneficiary, reclaimAmount);  emit RedeemTokens(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _holder,   _beneficiary,   _tokenCount,   reclaimAmount,   _memo,   _metadata,   msg.sender );  } /**     @notice     Distributes payouts for a project with the distribution limit of its current funding cycle. @dev Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.  @dev Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.  @dev All funds distributed outside of this contract or any feeless terminals incure the protocol fee.  @param _projectId The ID of the project having its payouts distributed. @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency. @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal. @param _memo A memo to pass along to the emitted event.  @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.  */   function _distributePayoutsOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     uint256 _minReturnedTokens,     string calldata _memo   ) internal returns (uint256 netLeftoverDistributionAmount) {     // Record the distribution.     (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(       _projectId,       _amount,       _currency     ); // The amount being distributed must be at least as much as was expected. if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();  // Get a reference to the project owner, which will receive tokens from paying the platform fee // and receive any extra distributable funds not allocated to payout splits. address payable _projectOwner = payable(projects.ownerOf(_projectId));  // Define variables that will be needed outside the scoped section below. // Keep a reference to the fee amount that was paid. uint256 _fee;  // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope. {   // Get the amount of discount that should be applied to any fees taken.   // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.   uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]     ? JBConstants.MAX_FEE_DISCOUNT     : _currentFeeDiscount(_projectId);    // The amount distributed that is eligible for incurring fees.   uint256 _feeEligibleDistributionAmount;    // The amount leftover after distributing to the splits.   uint256 _leftoverDistributionAmount;    // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.   // Also get a reference to the amount that was distributed to splits from which fees should be taken.   (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(     _projectId,     _fundingCycle.configuration,     payoutSplitsGroup,     _distributedAmount,     _feeDiscount   );    // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.   unchecked {     _feeEligibleDistributionAmount += _leftoverDistributionAmount;   }    // Take the fee.   _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0     ? 0     : _takeFeeFrom(       _projectId,       _fundingCycle,       _feeEligibleDistributionAmount,       _projectOwner,       _feeDiscount     );    // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.    unchecked {     netLeftoverDistributionAmount = _leftoverDistributionAmount == 0       ? 0       : _leftoverDistributionAmount -         _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);   }    // Transfer any remaining balance to the project owner.   if (netLeftoverDistributionAmount &gt; 0)     _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount); }  emit DistributePayouts(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _projectOwner,   _amount,   _distributedAmount,   _fee,   netLeftoverDistributionAmount,   _memo,   msg.sender );  } /**     @notice     Allows a project to send funds from its overflow up to the preconfigured allowance. @dev Only a project's owner or a designated operator can use its allowance.  @dev Incurs the protocol fee.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency. @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals. @param _beneficiary The address to send the funds to. @param _memo A memo to pass along to the emitted event.  @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.  */   function _useAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo   ) internal returns (uint256 netDistributedAmount) {     // Record the use of the allowance.     (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(       _projectId,       _amount,       _currency     ); // The amount being withdrawn must be at least as much as was expected. if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();  // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope. {   // Keep a reference to the fee amount that was paid.   uint256 _fee;    // Get a reference to the project owner, which will receive tokens from paying the platform fee.   address _projectOwner = projects.ownerOf(_projectId);    // Get the amount of discount that should be applied to any fees taken.   // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.   uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]     ? JBConstants.MAX_FEE_DISCOUNT     : _currentFeeDiscount(_projectId);    // Take a fee from the `_distributedAmount`, if needed.   _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT     ? 0     : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);    unchecked {     // The net amount is the withdrawn amount without the fee.     netDistributedAmount = _distributedAmount - _fee;   }    // Transfer any remaining balance to the beneficiary.   if (netDistributedAmount &gt; 0)     _transferFrom(address(this), _beneficiary, netDistributedAmount); }  emit UseAllowance(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _beneficiary,   _amount,   _distributedAmount,   netDistributedAmount,   _memo,   msg.sender );  } /**     @notice     Pays out splits for a project's funding cycle configuration. @param _projectId The ID of the project for which payout splits are being distributed. @param _domain The domain of the splits to distribute the payout between. @param _group The group of the splits to distribute the payout between. @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal. @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.  @return leftoverAmount If the leftover amount if the splits don't add up to 100%. @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.  */   function _distributeToPayoutSplitsOf(     uint256 _projectId,     uint256 _domain,     uint256 _group,     uint256 _amount,     uint256 _feeDiscount   ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {     // Set the leftover amount to the initial amount.     leftoverAmount = _amount; // Get a reference to the project's payout splits. JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);  // Transfer between all splits. for (uint256 _i = 0; _i &lt; _splits.length; ) {   // Get a reference to the split being iterated on.   JBSplit memory _split = _splits[_i];    // The amount to send towards the split.   uint256 _payoutAmount = PRBMath.mulDiv(     _amount,     _split.percent,     JBConstants.SPLITS_TOTAL_PERCENT   );    // The payout amount substracting any applicable incurred fees.   uint256 _netPayoutAmount;    if (_payoutAmount &gt; 0) {     // Transfer tokens to the split.     // If there's an allocator set, transfer to its `allocate` function.     if (_split.allocator != IJBSplitAllocator(address(0))) {       // If the split allocator is set as feeless, this distribution is not eligible for a fee.       if (isFeelessAddress[address(_split.allocator)])         _netPayoutAmount = _payoutAmount;         // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.       else {         unchecked {           _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT             ? _payoutAmount             : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);         }          // This distribution is eligible for a fee since the funds are leaving the ecosystem.         feeEligibleDistributionAmount += _payoutAmount;       }        // Trigger any inherited pre-transfer logic.       _beforeTransferTo(address(_split.allocator), _netPayoutAmount);        // If this terminal's token is ETH, send it in msg.value.       uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;        // Create the data to send to the allocator.       JBSplitAllocationData memory _data = JBSplitAllocationData(         token,         _netPayoutAmount,         decimals,         _projectId,         _group,         _split       );        // Trigger the allocator's `allocate` function.       _split.allocator.allocate{value: _payableValue}(_data);        // Otherwise, if a project is specified, make a payment to it.     } else if (_split.projectId != 0) {       // Get a reference to the Juicebox terminal being used.       IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);        // The project must have a terminal to send funds to.       if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();        // Save gas if this contract is being used as the terminal.       if (_terminal == this) {         // This distribution does not incur a fee.         _netPayoutAmount = _payoutAmount;          // Send the projectId in the metadata.         bytes memory _projectMetadata = new bytes(32);         _projectMetadata = bytes(abi.encodePacked(_projectId));          // Add to balance if prefered.         if (_split.preferAddToBalance)           _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);         else           _pay(             _netPayoutAmount,             address(this),             _split.projectId,             (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,             0,             _split.preferClaimed,             '',             _projectMetadata           );       } else {         // If the terminal is set as feeless, this distribution is not eligible for a fee.         if (isFeelessAddress[address(_terminal)])           _netPayoutAmount = _payoutAmount;           // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.         else {           unchecked {             _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT               ? _payoutAmount               : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);           }            feeEligibleDistributionAmount += _payoutAmount;         }          // Trigger any inherited pre-transfer logic.         _beforeTransferTo(address(_terminal), _netPayoutAmount);          // If this terminal's token is ETH, send it in msg.value.         uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;          // Send the projectId in the metadata.         bytes memory _projectMetadata = new bytes(32);         _projectMetadata = bytes(abi.encodePacked(_projectId));          // Add to balance if prefered.         if (_split.preferAddToBalance)           _terminal.addToBalanceOf{value: _payableValue}(             _split.projectId,             _netPayoutAmount,             token,             '',             _projectMetadata           );         else           _terminal.pay{value: _payableValue}(             _split.projectId,             _netPayoutAmount,             token,             _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,             0,             _split.preferClaimed,             '',             _projectMetadata           );       }     } else {       unchecked {         _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT           ? _payoutAmount           : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);       }        // This distribution is eligible for a fee since the funds are leaving the ecosystem.       feeEligibleDistributionAmount += _payoutAmount;        // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.       _transferFrom(         address(this),         _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),         _netPayoutAmount       );     }      // Subtract from the amount to be sent to the beneficiary.     unchecked {       leftoverAmount = leftoverAmount - _payoutAmount;     }   }    emit DistributeToPayoutSplit(     _projectId,     _domain,     _group,     _split,     _netPayoutAmount,     msg.sender   );    unchecked {     ++_i;   } }  } /**     @notice     Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID. @param _projectId The ID of the project having fees taken from. @param _fundingCycle The funding cycle during which the fee is being taken. @param _amount The amount of the fee to take, as a floating point number with 18 decimals. @param _beneficiary The address to mint the platforms tokens for. @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.  @return feeAmount The amount of the fee taken.  */   function _takeFeeFrom(     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _amount,     address _beneficiary,     uint256 _feeDiscount   ) internal returns (uint256 feeAmount) {     feeAmount = _feeAmount(_amount, fee, _feeDiscount); if (_fundingCycle.shouldHoldFees()) {   // Store the held fee.   _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));    emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender); } else {   // Process the fee.   _processFee(feeAmount, _beneficiary); // Take the fee.    emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender); }  } /**     @notice     Process a fee of the specified amount. @param _amount The fee amount, as a floating point number with 18 decimals. @param _beneficiary The address to mint the platform's tokens for.  */   function _processFee(uint256 _amount, address _beneficiary) internal {     // Get the terminal for the protocol project.     IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token); // When processing the admin fee, save gas if the admin is using this contract as its terminal. if (_terminal == this)   _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call. else {   // Trigger any inherited pre-transfer logic.   _beforeTransferTo(address(_terminal), _amount);    // If this terminal's token is ETH, send it in msg.value.   uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;    // Send the payment.   _terminal.pay{value: _payableValue}(     _PROTOCOL_PROJECT_ID,     _amount,     token,     _beneficiary,     0,     false,     '',     bytes('')   ); // Use the external pay call of the correct terminal. }  } /**     @notice     Contribute tokens to a project. @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place. @param _payer The address making the payment. @param _projectId The ID of the project being paid. @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate. @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal. @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas. @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.  */   function _pay(     uint256 _amount,     address _payer,     uint256 _projectId,     address _beneficiary,     uint256 _minReturnedTokens,     bool _preferClaimedTokens,     string memory _memo,     bytes memory _metadata   ) internal returns (uint256 beneficiaryTokenCount) {     // Cant send tokens to the zero address.     if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS(); // Define variables that will be needed outside the scoped section below. // Keep a reference to the funding cycle during which the payment is being made. JBFundingCycle memory _fundingCycle;  // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope. {   IJBPayDelegate _delegate;   uint256 _tokenCount;    // Bundle the amount info into a JBTokenAmount struct.   JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);    // Record the payment.   (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(     _payer,     _bundledAmount,     _projectId,     baseWeightCurrency,     _beneficiary,     _memo,     _metadata   );    // Mint the tokens if needed.   if (_tokenCount &gt; 0)     // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.     beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(       _projectId,       _tokenCount,       _beneficiary,       '',       _preferClaimedTokens,       true     );    // The token count for the beneficiary must be greater than or equal to the minimum expected.   if (beneficiaryTokenCount &lt; _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();    // If a delegate was returned by the data source, issue a callback to it.   if (_delegate != IJBPayDelegate(address(0))) {     JBDidPayData memory _data = JBDidPayData(       _payer,       _projectId,       _fundingCycle.configuration,       _bundledAmount,       beneficiaryTokenCount,       _beneficiary,       _preferClaimedTokens,       _memo,       _metadata     );      _delegate.didPay(_data);     emit DelegateDidPay(_delegate, _data, msg.sender);   } }  emit Pay(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _payer,   _beneficiary,   _amount,   beneficiaryTokenCount,   _memo,   _metadata,   msg.sender );  } /**     @notice     Receives funds belonging to the specified project. @param _projectId The ID of the project to which the funds received belong. @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead. @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added. @param _memo A memo to pass along to the emitted event. @param _metadata Extra data to pass along to the emitted event.  */   function _addToBalanceOf(     uint256 _projectId,     uint256 _amount,     bool _shouldRefundHeldFees,     string memory _memo,     bytes memory _metadata   ) internal {     // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.     uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0; // Record the added funds with any refunded fees. store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);  emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);  } /**     @notice     Refund fees based on the specified amount. @param _projectId The project for which fees are being refunded. @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.  @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal  */   function _refundHeldFees(uint256 _projectId, uint256 _amount)     internal     returns (uint256 refundedFees)   {     // Get a reference to the project's held fees.     JBFee[] memory _heldFees = _heldFeesOf[_projectId]; // Delete the current held fees. delete _heldFeesOf[_projectId];  // Get a reference to the leftover amount once all fees have been settled. uint256 leftoverAmount = _amount;  // Push length in stack uint256 _heldFeesLength = _heldFees.length;  // Process each fee. for (uint256 _i = 0; _i &lt; _heldFeesLength; ) {   if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);   else if (leftoverAmount &gt;= _heldFees[_i].amount) {     unchecked {       leftoverAmount = leftoverAmount - _heldFees[_i].amount;       refundedFees += _feeAmount(         _heldFees[_i].amount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount       );     }   } else {     _heldFeesOf[_projectId].push(       JBFee(         _heldFees[_i].amount - leftoverAmount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount,         _heldFees[_i].beneficiary       )     );     unchecked {       refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);     }     leftoverAmount = 0;   }    unchecked {     ++_i;   } }  emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);  } /**      @notice      Returns the fee amount based on the provided amount for the specified project. @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal. @param _fee The percentage of the fee, out of MAX_FEE.  @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.  @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.  */   function _feeAmount(     uint256 _amount,     uint256 _fee,     uint256 _feeDiscount   ) internal pure returns (uint256) {     // Calculate the discounted fee.     uint256 _discountedFee = _fee -       PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT); // The amount of tokens from the `_amount` to pay as a fee. return   _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);  } /**      @notice     Get the fee discount from the fee gauge for the specified project. @param _projectId The ID of the project to get a fee discount for.  @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.  */   function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {     // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.     if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))       return JBConstants.MAX_FEE_DISCOUNT; // Get the fee discount. if (feeGauge == IJBFeeGauge(address(0)))   feeDiscount = 0;   // If the guage reverts, set the discount to 0. else   try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {     feeDiscount = discount;   } catch {     feeDiscount = 0;   }  // If the fee discount is greater than the max, nullify the discount. if (feeDiscount &gt; JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 17:18:13 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './../interfaces/IJBController.sol';
import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol';
import './../libraries/JBConstants.sol';
import './../libraries/JBCurrencies.sol';
import './../libraries/JBFixedPointNumber.sol';
import './../libraries/JBFundingCycleMetadataResolver.sol';
import './../libraries/JBOperations.sol';
import './../libraries/JBSplitsGroups.sol';
import './../libraries/JBTokens.sol';
import './../structs/JBTokenAmount.sol';
import './JBOperatable.sol';
import './JBSingleTokenPaymentTerminal.sol';

/**
  @notice
  Generic terminal managing all inflows and outflows of funds into the protocol ecosystem.

  @dev
  A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time.

  @dev
  Adheres to -
  IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.
  JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
abstract contract JBPayoutRedemptionPaymentTerminal is
  IJBPayoutRedemptionPaymentTerminal,
  JBSingleTokenPaymentTerminal,
  JBOperatable,
  Ownable,
  ReentrancyGuard
{
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error FEE_TOO_HIGH();
  error INADEQUATE_DISTRIBUTION_AMOUNT();
  error INADEQUATE_RECLAIM_AMOUNT();
  error INADEQUATE_TOKEN_COUNT();
  error NO_MSG_VALUE_ALLOWED();
  error PAY_TO_ZERO_ADDRESS();
  error PROJECT_TERMINAL_MISMATCH();
  error REDEEM_TO_ZERO_ADDRESS();
  error TERMINAL_IN_SPLIT_ZERO_ADDRESS();
  error TERMINAL_TOKENS_INCOMPATIBLE();

  //*********************************************************************//
  // ---------------------------- modifiers ---------------------------- //
  //*********************************************************************//

  /** 
    @notice 
    A modifier that verifies this terminal is a terminal of provided project ID.
  */
  modifier isTerminalOf(uint256 _projectId) {
    if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();
    _;
  }

  //*********************************************************************//
  // --------------------- internal stored constants ------------------- //
  //*********************************************************************//

  /**
    @notice
    Maximum fee that can be set for a funding cycle configuration.

    @dev
    Out of MAX_FEE (50_000_000 / 1_000_000_000).
  */
  uint256 internal constant _FEE_CAP = 50_000_000;

  /**
    @notice
    The protocol project ID is 1, as it should be the first project launched during the deployment process.
  */
  uint256 internal constant _PROTOCOL_PROJECT_ID = 1;

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    Fees that are being held to be processed later.

    _projectId The ID of the project for which fees are being held.
  */
  mapping(uint256 => JBFee[]) internal _heldFeesOf;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership and transfers.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  /**
    @notice
    The contract that stores and manages the terminal's data.
  */
  IJBSingleTokenPaymentTerminalStore public immutable override store;

  /**
    @notice
    The currency to base token issuance on.

    @dev
    If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.
  */
  uint256 public immutable override baseWeightCurrency;

  /**
    @notice
    The group that payout splits coming from this terminal are identified by.
  */
  uint256 public immutable override payoutSplitsGroup;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The platform fee percent.

    @dev
    Out of MAX_FEE (25_000_000 / 1_000_000_000)
  */
  uint256 public override fee = 25_000_000; // 2.5%

  /**
    @notice
    The data source that returns a discount to apply to a project's fee.
  */
  IJBFeeGauge public override feeGauge;

  /**
    @notice
    Addresses that can be paid towards from this terminal without incurring a fee.

    _address The address that can be paid toward.
  */
  mapping(address => bool) public override isFeelessAddress;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.

    @dev
    The current overflow is represented as a fixed point number with 18 decimals.

    @param _projectId The ID of the project to get overflow for.

    @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.
  */
  function currentEthOverflowOf(uint256 _projectId)
    external
    view
    virtual
    override
    returns (uint256)
  {
    // Get this terminal's current overflow.
    uint256 _overflow = store.currentOverflowOf(this, _projectId);

    // Adjust the decimals of the fixed point number if needed to have 18 decimals.
    uint256 _adjustedOverflow = (decimals == 18)
      ? _overflow
      : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);

    // Return the amount converted to ETH.
    return
      (currency == JBCurrencies.ETH)
        ? _adjustedOverflow
        : PRBMath.mulDiv(
          _adjustedOverflow,
          10**decimals,
          prices.priceFor(currency, JBCurrencies.ETH, decimals)
        );
  }

  /**
    @notice
    The fees that are currently being held to be processed later for each project.

    @param _projectId The ID of the project for which fees are being held.

    @return An array of fees that are being held.
  */
  function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {
    return _heldFeesOf[_projectId];
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(JBSingleTokenPaymentTerminal, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||
      _interfaceId == type(IJBPayoutTerminal).interfaceId ||
      _interfaceId == type(IJBAllowanceTerminal).interfaceId ||
      _interfaceId == type(IJBRedemptionTerminal).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _token The token that this terminal manages.
    @param _decimals The number of decimals the token fixed point amounts are expected to have.
    @param _currency The currency that this terminal's token adheres to for price feeds.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _splitsStore A contract that stores splits for each project.
    @param _prices A contract that exposes price feeds.
    @param _store A contract that stores the terminal's data.
    @param _owner The address that will own this contract.
  */
  constructor(
    // payable constructor save the gas used to check msg.value==0
    address _token,
    uint256 _decimals,
    uint256 _currency,
    uint256 _baseWeightCurrency,
    uint256 _payoutSplitsGroup,
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBSplitsStore _splitsStore,
    IJBPrices _prices,
    IJBSingleTokenPaymentTerminalStore _store,
    address _owner
  )
    payable
    JBSingleTokenPaymentTerminal(_token, _decimals, _currency)
    JBOperatable(_operatorStore)
  {
    baseWeightCurrency = _baseWeightCurrency;
    payoutSplitsGroup = _payoutSplitsGroup;
    projects = _projects;
    directory = _directory;
    splitsStore = _splitsStore;
    prices = _prices;
    store = _store;

    transferOwnership(_owner);
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Contribute tokens to a project.

    @param _projectId The ID of the project being paid.
    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _token The token being paid. This terminal ignores this property since it only manages one token. 
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function pay(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {
    _token; // Prevents unused var compiler and natspec complaints.

    // ETH shouldn't be sent if this terminal's token isn't ETH.
    if (token != JBTokens.ETH) {
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If this terminal's token is ETH, override _amount with msg.value.
    else _amount = msg.value;

    return
      _pay(
        _amount,
        msg.sender,
        _projectId,
        _beneficiary,
        _minReturnedTokens,
        _preferClaimedTokens,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _token The token being reclaimed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  )
    external
    virtual
    override
    requirePermission(_holder, _projectId, JBOperations.REDEEM)
    returns (uint256 reclaimAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return
      _redeemTokensOf(
        _holder,
        _projectId,
        _tokenCount,
        _minReturnedTokens,
        _beneficiary,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) external virtual override returns (uint256 netLeftoverDistributionAmount) {
    _token; // Prevents unused var compiler and natspec complaints.

    return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)
    returns (uint256 netDistributedAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);
  }

  /**
    @notice
    Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project being migrated.
    @param _to The terminal contract that will gain the project's funds.

    @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.
  */
  function migrate(uint256 _projectId, IJBPaymentTerminal _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)
    returns (uint256 balance)
  {
    // The terminal being migrated to must accept the same token as this terminal.
    if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE();

    // Record the migration in the store.
    balance = store.recordMigration(_projectId);

    // Transfer the balance if needed.
    if (balance > 0) {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_to), balance);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? balance : 0;

      // Withdraw the balance to transfer to the new terminal;
      _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes(''));
    }

    emit Migrate(_projectId, _to, balance, msg.sender);
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _token The token being paid. This terminal ignores this property since it only manages one currency. 
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) {
    _token; // Prevents unused var compiler and natspec complaints.

    // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender.
    if (token != JBTokens.ETH) {
      // Amount must be greater than 0.
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If the terminal's token is ETH, override `_amount` with msg.value.
    else _amount = msg.value;

    // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal.
    _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);
  }

  /**
    @notice
    Process any fees that are being held for the project.

    @dev
    Only a project owner, an operator, or the contract's owner can process held fees.

    @param _projectId The ID of the project whos held fees should be processed.
  */
  function processFees(uint256 _projectId)
    external
    virtual
    override
    requirePermissionAllowingOverride(
      projects.ownerOf(_projectId),
      _projectId,
      JBOperations.PROCESS_FEES,
      msg.sender == owner()
    )
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the held fees.
    delete _heldFeesOf[_projectId];

    // Push array length in stack
    uint256 _heldFeeLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeeLength; ) {
      // Get the fee amount.
      uint256 _amount = _feeAmount(
        _heldFees[_i].amount,
        _heldFees[_i].fee,
        _heldFees[_i].feeDiscount
      );

      // Process the fee.
      _processFee(_amount, _heldFees[_i].beneficiary);

      emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Allows the fee to be updated.

    @dev
    Only the owner of this contract can change the fee.

    @param _fee The new fee, out of MAX_FEE.
  */
  function setFee(uint256 _fee) external virtual override onlyOwner {
    // The provided fee must be within the max.
    if (_fee > _FEE_CAP) revert FEE_TOO_HIGH();

    // Store the new fee.
    fee = _fee;

    emit SetFee(_fee, msg.sender);
  }

  /**
    @notice
    Allows the fee gauge to be updated.

    @dev
    Only the owner of this contract can change the fee gauge.

    @dev
    If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.

    @param _feeGauge The new fee gauge.
  */
  function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {
    // Store the new fee gauge.
    feeGauge = _feeGauge;

    emit SetFeeGauge(_feeGauge, msg.sender);
  }

  /**
    @notice
    Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.

    @dev
    Only the owner of this contract can set addresses as feeless.

    @param _address The address that can be paid towards while still bypassing fees.
    @param _flag A flag indicating whether the terminal should be feeless or not.
  */
  function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {
    // Set the flag value.
    isFeelessAddress[_address] = _flag;

    emit SetFeelessAddress(_address, _flag, msg.sender);
  }

  //*********************************************************************//
  // ---------------------- internal transactions ---------------------- //
  //*********************************************************************//

  /** 
    @notice
    Transfers tokens.

    @param _from The address from which the transfer should originate.
    @param _to The address to which the transfer should go.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _transferFrom(
    address _from,
    address payable _to,
    uint256 _amount
  ) internal virtual;

  /** 
    @notice
    Logic to be triggered before transferring tokens from this terminal.

    @param _to The address to which the transfer is going.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _beforeTransferTo(address _to, uint256 _amount) internal virtual;

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function _redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 reclaimAmount) {
    // Can't send reclaimed funds to the zero address.
    if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the redemption is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` only used within scope.
    {
      IJBRedemptionDelegate _delegate;

      // Record the redemption.
      (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(
        _holder,
        _projectId,
        _tokenCount,
        _memo,
        _metadata
      );

      // The amount being reclaimed must be at least as much as was expected.
      if (reclaimAmount < _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();

      // Burn the project tokens.
      if (_tokenCount > 0)
        IJBController(directory.controllerOf(_projectId)).burnTokensOf(
          _holder,
          _projectId,
          _tokenCount,
          '',
          false
        );

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBRedemptionDelegate(address(0))) {
        JBDidRedeemData memory _data = JBDidRedeemData(
          _holder,
          _projectId,
          _fundingCycle.configuration,
          _tokenCount,
          JBTokenAmount(token, reclaimAmount, decimals, currency),
          _beneficiary,
          _memo,
          _metadata
        );
        _delegate.didRedeem(_data);
        emit DelegateDidRedeem(_delegate, _data, msg.sender);
      }
    }

    // Send the reclaimed funds to the beneficiary.
    if (reclaimAmount > 0) _transferFrom(address(this), _beneficiary, reclaimAmount);

    emit RedeemTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _holder,
      _beneficiary,
      _tokenCount,
      reclaimAmount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) internal returns (uint256 netLeftoverDistributionAmount) {
    // Record the distribution.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(
      _projectId,
      _amount,
      _currency
    );

    // The amount being distributed must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Get a reference to the project owner, which will receive tokens from paying the platform fee
    // and receive any extra distributable funds not allocated to payout splits.
    address payable _projectOwner = payable(projects.ownerOf(_projectId));

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the fee amount that was paid.
    uint256 _fee;

    // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope.
    {
      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // The amount distributed that is eligible for incurring fees.
      uint256 _feeEligibleDistributionAmount;

      // The amount leftover after distributing to the splits.
      uint256 _leftoverDistributionAmount;

      // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.
      // Also get a reference to the amount that was distributed to splits from which fees should be taken.
      (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        payoutSplitsGroup,
        _distributedAmount,
        _feeDiscount
      );

      // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.
      unchecked {
        _feeEligibleDistributionAmount += _leftoverDistributionAmount;
      }

      // Take the fee.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0
        ? 0
        : _takeFeeFrom(
          _projectId,
          _fundingCycle,
          _feeEligibleDistributionAmount,
          _projectOwner,
          _feeDiscount
        );

      // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.

      unchecked {
        netLeftoverDistributionAmount = _leftoverDistributionAmount == 0
          ? 0
          : _leftoverDistributionAmount -
            _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);
      }

      // Transfer any remaining balance to the project owner.
      if (netLeftoverDistributionAmount > 0)
        _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount);
    }

    emit DistributePayouts(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _projectOwner,
      _amount,
      _distributedAmount,
      _fee,
      netLeftoverDistributionAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function _useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  ) internal returns (uint256 netDistributedAmount) {
    // Record the use of the allowance.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(
      _projectId,
      _amount,
      _currency
    );

    // The amount being withdrawn must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope.
    {
      // Keep a reference to the fee amount that was paid.
      uint256 _fee;

      // Get a reference to the project owner, which will receive tokens from paying the platform fee.
      address _projectOwner = projects.ownerOf(_projectId);

      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // Take a fee from the `_distributedAmount`, if needed.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
        ? 0
        : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);

      unchecked {
        // The net amount is the withdrawn amount without the fee.
        netDistributedAmount = _distributedAmount - _fee;
      }

      // Transfer any remaining balance to the beneficiary.
      if (netDistributedAmount > 0)
        _transferFrom(address(this), _beneficiary, netDistributedAmount);
    }

    emit UseAllowance(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _beneficiary,
      _amount,
      _distributedAmount,
      netDistributedAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Pays out splits for a project's funding cycle configuration.

    @param _projectId The ID of the project for which payout splits are being distributed.
    @param _domain The domain of the splits to distribute the payout between.
    @param _group The group of the splits to distribute the payout between.
    @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return leftoverAmount If the leftover amount if the splits don't add up to 100%.
    @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.
  */
  function _distributeToPayoutSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount,
    uint256 _feeDiscount
  ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's payout splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    // Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; ) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _payoutAmount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // The payout amount substracting any applicable incurred fees.
      uint256 _netPayoutAmount;

      if (_payoutAmount > 0) {
        // Transfer tokens to the split.
        // If there's an allocator set, transfer to its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0))) {
          // If the split allocator is set as feeless, this distribution is not eligible for a fee.
          if (isFeelessAddress[address(_split.allocator)])
            _netPayoutAmount = _payoutAmount;
            // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.
          else {
            unchecked {
              _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                ? _payoutAmount
                : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
            }

            // This distribution is eligible for a fee since the funds are leaving the ecosystem.
            feeEligibleDistributionAmount += _payoutAmount;
          }

          // Trigger any inherited pre-transfer logic.
          _beforeTransferTo(address(_split.allocator), _netPayoutAmount);

          // If this terminal's token is ETH, send it in msg.value.
          uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

          // Create the data to send to the allocator.
          JBSplitAllocationData memory _data = JBSplitAllocationData(
            token,
            _netPayoutAmount,
            decimals,
            _projectId,
            _group,
            _split
          );

          // Trigger the allocator's `allocate` function.
          _split.allocator.allocate{value: _payableValue}(_data);

          // Otherwise, if a project is specified, make a payment to it.
        } else if (_split.projectId != 0) {
          // Get a reference to the Juicebox terminal being used.
          IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);

          // The project must have a terminal to send funds to.
          if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();

          // Save gas if this contract is being used as the terminal.
          if (_terminal == this) {
            // This distribution does not incur a fee.
            _netPayoutAmount = _payoutAmount;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);
            else
              _pay(
                _netPayoutAmount,
                address(this),
                _split.projectId,
                (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          } else {
            // If the terminal is set as feeless, this distribution is not eligible for a fee.
            if (isFeelessAddress[address(_terminal)])
              _netPayoutAmount = _payoutAmount;
              // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.
            else {
              unchecked {
                _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                  ? _payoutAmount
                  : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
              }

              feeEligibleDistributionAmount += _payoutAmount;
            }

            // Trigger any inherited pre-transfer logic.
            _beforeTransferTo(address(_terminal), _netPayoutAmount);

            // If this terminal's token is ETH, send it in msg.value.
            uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _terminal.addToBalanceOf{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                '',
                _projectMetadata
              );
            else
              _terminal.pay{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          }
        } else {
          unchecked {
            _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
              ? _payoutAmount
              : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
          }

          // This distribution is eligible for a fee since the funds are leaving the ecosystem.
          feeEligibleDistributionAmount += _payoutAmount;

          // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.
          _transferFrom(
            address(this),
            _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),
            _netPayoutAmount
          );
        }

        // Subtract from the amount to be sent to the beneficiary.
        unchecked {
          leftoverAmount = leftoverAmount - _payoutAmount;
        }
      }

      emit DistributeToPayoutSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _netPayoutAmount,
        msg.sender
      );

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID.

    @param _projectId The ID of the project having fees taken from.
    @param _fundingCycle The funding cycle during which the fee is being taken.
    @param _amount The amount of the fee to take, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platforms tokens for.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return feeAmount The amount of the fee taken.
  */
  function _takeFeeFrom(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _amount,
    address _beneficiary,
    uint256 _feeDiscount
  ) internal returns (uint256 feeAmount) {
    feeAmount = _feeAmount(_amount, fee, _feeDiscount);

    if (_fundingCycle.shouldHoldFees()) {
      // Store the held fee.
      _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));

      emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender);
    } else {
      // Process the fee.
      _processFee(feeAmount, _beneficiary); // Take the fee.

      emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender);
    }
  }

  /**
    @notice
    Process a fee of the specified amount.

    @param _amount The fee amount, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platform's tokens for.
  */
  function _processFee(uint256 _amount, address _beneficiary) internal {
    // Get the terminal for the protocol project.
    IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token);

    // When processing the admin fee, save gas if the admin is using this contract as its terminal.
    if (_terminal == this)
      _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call.
    else {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_terminal), _amount);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;

      // Send the payment.
      _terminal.pay{value: _payableValue}(
        _PROTOCOL_PROJECT_ID,
        _amount,
        token,
        _beneficiary,
        0,
        false,
        '',
        bytes('')
      ); // Use the external pay call of the correct terminal.
    }
  }

  /**
    @notice
    Contribute tokens to a project.

    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _payer The address making the payment.
    @param _projectId The ID of the project being paid.
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function _pay(
    uint256 _amount,
    address _payer,
    uint256 _projectId,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 beneficiaryTokenCount) {
    // Cant send tokens to the zero address.
    if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the payment is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope.
    {
      IJBPayDelegate _delegate;
      uint256 _tokenCount;

      // Bundle the amount info into a JBTokenAmount struct.
      JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);

      // Record the payment.
      (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(
        _payer,
        _bundledAmount,
        _projectId,
        baseWeightCurrency,
        _beneficiary,
        _memo,
        _metadata
      );

      // Mint the tokens if needed.
      if (_tokenCount > 0)
        // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.
        beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(
          _projectId,
          _tokenCount,
          _beneficiary,
          '',
          _preferClaimedTokens,
          true
        );

      // The token count for the beneficiary must be greater than or equal to the minimum expected.
      if (beneficiaryTokenCount < _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBPayDelegate(address(0))) {
        JBDidPayData memory _data = JBDidPayData(
          _payer,
          _projectId,
          _fundingCycle.configuration,
          _bundledAmount,
          beneficiaryTokenCount,
          _beneficiary,
          _preferClaimedTokens,
          _memo,
          _metadata
        );

        _delegate.didPay(_data);
        emit DelegateDidPay(_delegate, _data, msg.sender);
      }
    }

    emit Pay(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _payer,
      _beneficiary,
      _amount,
      beneficiaryTokenCount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function _addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    bool _shouldRefundHeldFees,
    string memory _memo,
    bytes memory _metadata
  ) internal {
    // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.
    uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0;

    // Record the added funds with any refunded fees.
    store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);

    emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);
  }

  /**
    @notice
    Refund fees based on the specified amount.

    @param _projectId The project for which fees are being refunded.
    @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.

    @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal
  */
  function _refundHeldFees(uint256 _projectId, uint256 _amount)
    internal
    returns (uint256 refundedFees)
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the current held fees.
    delete _heldFeesOf[_projectId];

    // Get a reference to the leftover amount once all fees have been settled.
    uint256 leftoverAmount = _amount;

    // Push length in stack
    uint256 _heldFeesLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeesLength; ) {
      if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);
      else if (leftoverAmount >= _heldFees[_i].amount) {
        unchecked {
          leftoverAmount = leftoverAmount - _heldFees[_i].amount;
          refundedFees += _feeAmount(
            _heldFees[_i].amount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount
          );
        }
      } else {
        _heldFeesOf[_projectId].push(
          JBFee(
            _heldFees[_i].amount - leftoverAmount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount,
            _heldFees[_i].beneficiary
          )
        );
        unchecked {
          refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);
        }
        leftoverAmount = 0;
      }

      unchecked {
        ++_i;
      }
    }

    emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);
  }

  /** 
    @notice 
    Returns the fee amount based on the provided amount for the specified project.

    @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal.
    @param _fee The percentage of the fee, out of MAX_FEE. 
    @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.

    @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _feeAmount(
    uint256 _amount,
    uint256 _fee,
    uint256 _feeDiscount
  ) internal pure returns (uint256) {
    // Calculate the discounted fee.
    uint256 _discountedFee = _fee -
      PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT);

    // The amount of tokens from the `_amount` to pay as a fee.
    return
      _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);
  }

  /** 
    @notice
    Get the fee discount from the fee gauge for the specified project.

    @param _projectId The ID of the project to get a fee discount for.
    
    @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.
  */
  function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {
    // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.
    if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))
      return JBConstants.MAX_FEE_DISCOUNT;

    // Get the fee discount.
    if (feeGauge == IJBFeeGauge(address(0)))
      feeDiscount = 0;
      // If the guage reverts, set the discount to 0.
    else
      try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {
        feeDiscount = discount;
      } catch {
        feeDiscount = 0;
      }

    // If the fee discount is greater than the max, nullify the discount.
    if (feeDiscount > JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;
  }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-01-09 17:18:21 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 17:18:21 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 12782
completion_tokens: 875
total_tokens: 13657
cost: $-1.000000


[2024-01-09 17:18:21 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './../interfaces/IJBController.sol';
import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol';
import './../libraries/JBConstants.sol';
import './../libraries/JBCurrencies.sol';
import './../libraries/JBFixedPointNumber.sol';
import './../libraries/JBFundingCycleMetadataResolver.sol';
import './../libraries/JBOperations.sol';
import './../libraries/JBSplitsGroups.sol';
import './../libraries/JBTokens.sol';
import './../structs/JBTokenAmount.sol';
import './JBOperatable.sol';
import './JBSingleTokenPaymentTerminal.sol';

/**
  @notice
  Generic terminal managing all inflows and outflows of funds into the protocol ecosystem.

  @dev
  A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time.

  @dev
  Adheres to -
  IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.
  JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
abstract contract JBPayoutRedemptionPaymentTerminal is
  IJBPayoutRedemptionPaymentTerminal,
  JBSingleTokenPaymentTerminal,
  JBOperatable,
  Ownable,
  ReentrancyGuard
{
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error FEE_TOO_HIGH();
  error INADEQUATE_DISTRIBUTION_AMOUNT();
  error INADEQUATE_RECLAIM_AMOUNT();
  error INADEQUATE_TOKEN_COUNT();
  error NO_MSG_VALUE_ALLOWED();
  error PAY_TO_ZERO_ADDRESS();
  error PROJECT_TERMINAL_MISMATCH();
  error REDEEM_TO_ZERO_ADDRESS();
  error TERMINAL_IN_SPLIT_ZERO_ADDRESS();
  error TERMINAL_TOKENS_INCOMPATIBLE();

  //*********************************************************************//
  // ---------------------------- modifiers ---------------------------- //
  //*********************************************************************//

  /** 
    @notice 
    A modifier that verifies this terminal is a terminal of provided project ID.
  */
  modifier isTerminalOf(uint256 _projectId) {
    if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();
    _;
  }

  //*********************************************************************//
  // --------------------- internal stored constants ------------------- //
  //*********************************************************************//

  /**
    @notice
    Maximum fee that can be set for a funding cycle configuration.

    @dev
    Out of MAX_FEE (50_000_000 / 1_000_000_000).
  */
  uint256 internal constant _FEE_CAP = 50_000_000;

  /**
    @notice
    The protocol project ID is 1, as it should be the first project launched during the deployment process.
  */
  uint256 internal constant _PROTOCOL_PROJECT_ID = 1;

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    Fees that are being held to be processed later.

    _projectId The ID of the project for which fees are being held.
  */
  mapping(uint256 => JBFee[]) internal _heldFeesOf;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership and transfers.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  /**
    @notice
    The contract that stores and manages the terminal's data.
  */
  IJBSingleTokenPaymentTerminalStore public immutable override store;

  /**
    @notice
    The currency to base token issuance on.

    @dev
    If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.
  */
  uint256 public immutable override baseWeightCurrency;

  /**
    @notice
    The group that payout splits coming from this terminal are identified by.
  */
  uint256 public immutable override payoutSplitsGroup;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The platform fee percent.

    @dev
    Out of MAX_FEE (25_000_000 / 1_000_000_000)
  */
  uint256 public override fee = 25_000_000; // 2.5%

  /**
    @notice
    The data source that returns a discount to apply to a project's fee.
  */
  IJBFeeGauge public override feeGauge;

  /**
    @notice
    Addresses that can be paid towards from this terminal without incurring a fee.

    _address The address that can be paid toward.
  */
  mapping(address => bool) public override isFeelessAddress;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.

    @dev
    The current overflow is represented as a fixed point number with 18 decimals.

    @param _projectId The ID of the project to get overflow for.

    @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.
  */
  function currentEthOverflowOf(uint256 _projectId)
    external
    view
    virtual
    override
    returns (uint256)
  {
    // Get this terminal's current overflow.
    uint256 _overflow = store.currentOverflowOf(this, _projectId);

    // Adjust the decimals of the fixed point number if needed to have 18 decimals.
    uint256 _adjustedOverflow = (decimals == 18)
      ? _overflow
      : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);

    // Return the amount converted to ETH.
    return
      (currency == JBCurrencies.ETH)
        ? _adjustedOverflow
        : PRBMath.mulDiv(
          _adjustedOverflow,
          10**decimals,
          prices.priceFor(currency, JBCurrencies.ETH, decimals)
        );
  }

  /**
    @notice
    The fees that are currently being held to be processed later for each project.

    @param _projectId The ID of the project for which fees are being held.

    @return An array of fees that are being held.
  */
  function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {
    return _heldFeesOf[_projectId];
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(JBSingleTokenPaymentTerminal, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||
      _interfaceId == type(IJBPayoutTerminal).interfaceId ||
      _interfaceId == type(IJBAllowanceTerminal).interfaceId ||
      _interfaceId == type(IJBRedemptionTerminal).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _token The token that this terminal manages.
    @param _decimals The number of decimals the token fixed point amounts are expected to have.
    @param _currency The currency that this terminal's token adheres to for price feeds.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _splitsStore A contract that stores splits for each project.
    @param _prices A contract that exposes price feeds.
    @param _store A contract that stores the terminal's data.
    @param _owner The address that will own this contract.
  */
  constructor(
    // payable constructor save the gas used to check msg.value==0
    address _token,
    uint256 _decimals,
    uint256 _currency,
    uint256 _baseWeightCurrency,
    uint256 _payoutSplitsGroup,
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBSplitsStore _splitsStore,
    IJBPrices _prices,
    IJBSingleTokenPaymentTerminalStore _store,
    address _owner
  )
    payable
    JBSingleTokenPaymentTerminal(_token, _decimals, _currency)
    JBOperatable(_operatorStore)
  {
    baseWeightCurrency = _baseWeightCurrency;
    payoutSplitsGroup = _payoutSplitsGroup;
    projects = _projects;
    directory = _directory;
    splitsStore = _splitsStore;
    prices = _prices;
    store = _store;

    transferOwnership(_owner);
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Contribute tokens to a project.

    @param _projectId The ID of the project being paid.
    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _token The token being paid. This terminal ignores this property since it only manages one token. 
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function pay(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {
    _token; // Prevents unused var compiler and natspec complaints.

    // ETH shouldn't be sent if this terminal's token isn't ETH.
    if (token != JBTokens.ETH) {
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If this terminal's token is ETH, override _amount with msg.value.
    else _amount = msg.value;

    return
      _pay(
        _amount,
        msg.sender,
        _projectId,
        _beneficiary,
        _minReturnedTokens,
        _preferClaimedTokens,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _token The token being reclaimed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  )
    external
    virtual
    override
    requirePermission(_holder, _projectId, JBOperations.REDEEM)
    returns (uint256 reclaimAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return
      _redeemTokensOf(
        _holder,
        _projectId,
        _tokenCount,
        _minReturnedTokens,
        _beneficiary,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) external virtual override returns (uint256 netLeftoverDistributionAmount) {
    _token; // Prevents unused var compiler and natspec complaints.

    return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)
    returns (uint256 netDistributedAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);
  }

  /**
    @notice
    Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project being migrated.
    @param _to The terminal contract that will gain the project's funds.

    @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.
  */
  function migrate(uint256 _projectId, IJBPaymentTerminal _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)
    returns (uint256 balance)
  {
    // The terminal being migrated to must accept the same token as this terminal.
    if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE();

    // Record the migration in the store.
    balance = store.recordMigration(_projectId);

    // Transfer the balance if needed.
    if (balance > 0) {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_to), balance);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? balance : 0;

      // Withdraw the balance to transfer to the new terminal;
      _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes(''));
    }

    emit Migrate(_projectId, _to, balance, msg.sender);
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _token The token being paid. This terminal ignores this property since it only manages one currency. 
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) {
    _token; // Prevents unused var compiler and natspec complaints.

    // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender.
    if (token != JBTokens.ETH) {
      // Amount must be greater than 0.
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If the terminal's token is ETH, override `_amount` with msg.value.
    else _amount = msg.value;

    // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal.
    _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);
  }

  /**
    @notice
    Process any fees that are being held for the project.

    @dev
    Only a project owner, an operator, or the contract's owner can process held fees.

    @param _projectId The ID of the project whos held fees should be processed.
  */
  function processFees(uint256 _projectId)
    external
    virtual
    override
    requirePermissionAllowingOverride(
      projects.ownerOf(_projectId),
      _projectId,
      JBOperations.PROCESS_FEES,
      msg.sender == owner()
    )
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the held fees.
    delete _heldFeesOf[_projectId];

    // Push array length in stack
    uint256 _heldFeeLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeeLength; ) {
      // Get the fee amount.
      uint256 _amount = _feeAmount(
        _heldFees[_i].amount,
        _heldFees[_i].fee,
        _heldFees[_i].feeDiscount
      );

      // Process the fee.
      _processFee(_amount, _heldFees[_i].beneficiary);

      emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Allows the fee to be updated.

    @dev
    Only the owner of this contract can change the fee.

    @param _fee The new fee, out of MAX_FEE.
  */
  function setFee(uint256 _fee) external virtual override onlyOwner {
    // The provided fee must be within the max.
    if (_fee > _FEE_CAP) revert FEE_TOO_HIGH();

    // Store the new fee.
    fee = _fee;

    emit SetFee(_fee, msg.sender);
  }

  /**
    @notice
    Allows the fee gauge to be updated.

    @dev
    Only the owner of this contract can change the fee gauge.

    @dev
    If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.

    @param _feeGauge The new fee gauge.
  */
  function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {
    // Store the new fee gauge.
    feeGauge = _feeGauge;

    emit SetFeeGauge(_feeGauge, msg.sender);
  }

  /**
    @notice
    Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.

    @dev
    Only the owner of this contract can set addresses as feeless.

    @param _address The address that can be paid towards while still bypassing fees.
    @param _flag A flag indicating whether the terminal should be feeless or not.
  */
  function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {
    // Set the flag value.
    isFeelessAddress[_address] = _flag;

    emit SetFeelessAddress(_address, _flag, msg.sender);
  }

  //*********************************************************************//
  // ---------------------- internal transactions ---------------------- //
  //*********************************************************************//

  /** 
    @notice
    Transfers tokens.

    @param _from The address from which the transfer should originate.
    @param _to The address to which the transfer should go.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _transferFrom(
    address _from,
    address payable _to,
    uint256 _amount
  ) internal virtual;

  /** 
    @notice
    Logic to be triggered before transferring tokens from this terminal.

    @param _to The address to which the transfer is going.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _beforeTransferTo(address _to, uint256 _amount) internal virtual;

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function _redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 reclaimAmount) {
    // Can't send reclaimed funds to the zero address.
    if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the redemption is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` only used within scope.
    {
      IJBRedemptionDelegate _delegate;

      // Record the redemption.
      (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(
        _holder,
        _projectId,
        _tokenCount,
        _memo,
        _metadata
      );

      // The amount being reclaimed must be at least as much as was expected.
      if (reclaimAmount < _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();

      // Burn the project tokens.
      if (_tokenCount > 0)
        IJBController(directory.controllerOf(_projectId)).burnTokensOf(
          _holder,
          _projectId,
          _tokenCount,
          '',
          false
        );

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBRedemptionDelegate(address(0))) {
        JBDidRedeemData memory _data = JBDidRedeemData(
          _holder,
          _projectId,
          _fundingCycle.configuration,
          _tokenCount,
          JBTokenAmount(token, reclaimAmount, decimals, currency),
          _beneficiary,
          _memo,
          _metadata
        );
        _delegate.didRedeem(_data);
        emit DelegateDidRedeem(_delegate, _data, msg.sender);
      }
    }

    // Send the reclaimed funds to the beneficiary.
    if (reclaimAmount > 0) _transferFrom(address(this), _beneficiary, reclaimAmount);

    emit RedeemTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _holder,
      _beneficiary,
      _tokenCount,
      reclaimAmount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) internal returns (uint256 netLeftoverDistributionAmount) {
    // Record the distribution.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(
      _projectId,
      _amount,
      _currency
    );

    // The amount being distributed must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Get a reference to the project owner, which will receive tokens from paying the platform fee
    // and receive any extra distributable funds not allocated to payout splits.
    address payable _projectOwner = payable(projects.ownerOf(_projectId));

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the fee amount that was paid.
    uint256 _fee;

    // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope.
    {
      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // The amount distributed that is eligible for incurring fees.
      uint256 _feeEligibleDistributionAmount;

      // The amount leftover after distributing to the splits.
      uint256 _leftoverDistributionAmount;

      // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.
      // Also get a reference to the amount that was distributed to splits from which fees should be taken.
      (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        payoutSplitsGroup,
        _distributedAmount,
        _feeDiscount
      );

      // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.
      unchecked {
        _feeEligibleDistributionAmount += _leftoverDistributionAmount;
      }

      // Take the fee.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0
        ? 0
        : _takeFeeFrom(
          _projectId,
          _fundingCycle,
          _feeEligibleDistributionAmount,
          _projectOwner,
          _feeDiscount
        );

      // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.

      unchecked {
        netLeftoverDistributionAmount = _leftoverDistributionAmount == 0
          ? 0
          : _leftoverDistributionAmount -
            _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);
      }

      // Transfer any remaining balance to the project owner.
      if (netLeftoverDistributionAmount > 0)
        _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount);
    }

    emit DistributePayouts(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _projectOwner,
      _amount,
      _distributedAmount,
      _fee,
      netLeftoverDistributionAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function _useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  ) internal returns (uint256 netDistributedAmount) {
    // Record the use of the allowance.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(
      _projectId,
      _amount,
      _currency
    );

    // The amount being withdrawn must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope.
    {
      // Keep a reference to the fee amount that was paid.
      uint256 _fee;

      // Get a reference to the project owner, which will receive tokens from paying the platform fee.
      address _projectOwner = projects.ownerOf(_projectId);

      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // Take a fee from the `_distributedAmount`, if needed.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
        ? 0
        : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);

      unchecked {
        // The net amount is the withdrawn amount without the fee.
        netDistributedAmount = _distributedAmount - _fee;
      }

      // Transfer any remaining balance to the beneficiary.
      if (netDistributedAmount > 0)
        _transferFrom(address(this), _beneficiary, netDistributedAmount);
    }

    emit UseAllowance(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _beneficiary,
      _amount,
      _distributedAmount,
      netDistributedAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Pays out splits for a project's funding cycle configuration.

    @param _projectId The ID of the project for which payout splits are being distributed.
    @param _domain The domain of the splits to distribute the payout between.
    @param _group The group of the splits to distribute the payout between.
    @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return leftoverAmount If the leftover amount if the splits don't add up to 100%.
    @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.
  */
  function _distributeToPayoutSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount,
    uint256 _feeDiscount
  ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's payout splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    // Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; ) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _payoutAmount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // The payout amount substracting any applicable incurred fees.
      uint256 _netPayoutAmount;

      if (_payoutAmount > 0) {
        // Transfer tokens to the split.
        // If there's an allocator set, transfer to its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0))) {
          // If the split allocator is set as feeless, this distribution is not eligible for a fee.
          if (isFeelessAddress[address(_split.allocator)])
            _netPayoutAmount = _payoutAmount;
            // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.
          else {
            unchecked {
              _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                ? _payoutAmount
                : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
            }

            // This distribution is eligible for a fee since the funds are leaving the ecosystem.
            feeEligibleDistributionAmount += _payoutAmount;
          }

          // Trigger any inherited pre-transfer logic.
          _beforeTransferTo(address(_split.allocator), _netPayoutAmount);

          // If this terminal's token is ETH, send it in msg.value.
          uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

          // Create the data to send to the allocator.
          JBSplitAllocationData memory _data = JBSplitAllocationData(
            token,
            _netPayoutAmount,
            decimals,
            _projectId,
            _group,
            _split
          );

          // Trigger the allocator's `allocate` function.
          _split.allocator.allocate{value: _payableValue}(_data);

          // Otherwise, if a project is specified, make a payment to it.
        } else if (_split.projectId != 0) {
          // Get a reference to the Juicebox terminal being used.
          IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);

          // The project must have a terminal to send funds to.
          if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();

          // Save gas if this contract is being used as the terminal.
          if (_terminal == this) {
            // This distribution does not incur a fee.
            _netPayoutAmount = _payoutAmount;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);
            else
              _pay(
                _netPayoutAmount,
                address(this),
                _split.projectId,
                (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          } else {
            // If the terminal is set as feeless, this distribution is not eligible for a fee.
            if (isFeelessAddress[address(_terminal)])
              _netPayoutAmount = _payoutAmount;
              // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.
            else {
              unchecked {
                _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                  ? _payoutAmount
                  : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
              }

              feeEligibleDistributionAmount += _payoutAmount;
            }

            // Trigger any inherited pre-transfer logic.
            _beforeTransferTo(address(_terminal), _netPayoutAmount);

            // If this terminal's token is ETH, send it in msg.value.
            uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _terminal.addToBalanceOf{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                '',
                _projectMetadata
              );
            else
              _terminal.pay{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          }
        } else {
          unchecked {
            _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
              ? _payoutAmount
              : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
          }

          // This distribution is eligible for a fee since the funds are leaving the ecosystem.
          feeEligibleDistributionAmount += _payoutAmount;

          // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.
          _transferFrom(
            address(this),
            _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),
            _netPayoutAmount
          );
        }

        // Subtract from the amount to be sent to the beneficiary.
        unchecked {
          leftoverAmount = leftoverAmount - _payoutAmount;
        }
      }

      emit DistributeToPayoutSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _netPayoutAmount,
        msg.sender
      );

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID.

    @param _projectId The ID of the project having fees taken from.
    @param _fundingCycle The funding cycle during which the fee is being taken.
    @param _amount The amount of the fee to take, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platforms tokens for.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return feeAmount The amount of the fee taken.
  */
  function _takeFeeFrom(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _amount,
    address _beneficiary,
    uint256 _feeDiscount
  ) internal returns (uint256 feeAmount) {
    feeAmount = _feeAmount(_amount, fee, _feeDiscount);

    if (_fundingCycle.shouldHoldFees()) {
      // Store the held fee.
      _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));

      emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender);
    } else {
      // Process the fee.
      _processFee(feeAmount, _beneficiary); // Take the fee.

      emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender);
    }
  }

  /**
    @notice
    Process a fee of the specified amount.

    @param _amount The fee amount, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platform's tokens for.
  */
  function _processFee(uint256 _amount, address _beneficiary) internal {
    // Get the terminal for the protocol project.
    IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token);

    // When processing the admin fee, save gas if the admin is using this contract as its terminal.
    if (_terminal == this)
      _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call.
    else {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_terminal), _amount);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;

      // Send the payment.
      _terminal.pay{value: _payableValue}(
        _PROTOCOL_PROJECT_ID,
        _amount,
        token,
        _beneficiary,
        0,
        false,
        '',
        bytes('')
      ); // Use the external pay call of the correct terminal.
    }
  }

  /**
    @notice
    Contribute tokens to a project.

    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _payer The address making the payment.
    @param _projectId The ID of the project being paid.
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function _pay(
    uint256 _amount,
    address _payer,
    uint256 _projectId,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 beneficiaryTokenCount) {
    // Cant send tokens to the zero address.
    if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the payment is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope.
    {
      IJBPayDelegate _delegate;
      uint256 _tokenCount;

      // Bundle the amount info into a JBTokenAmount struct.
      JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);

      // Record the payment.
      (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(
        _payer,
        _bundledAmount,
        _projectId,
        baseWeightCurrency,
        _beneficiary,
        _memo,
        _metadata
      );

      // Mint the tokens if needed.
      if (_tokenCount > 0)
        // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.
        beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(
          _projectId,
          _tokenCount,
          _beneficiary,
          '',
          _preferClaimedTokens,
          true
        );

      // The token count for the beneficiary must be greater than or equal to the minimum expected.
      if (beneficiaryTokenCount < _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBPayDelegate(address(0))) {
        JBDidPayData memory _data = JBDidPayData(
          _payer,
          _projectId,
          _fundingCycle.configuration,
          _bundledAmount,
          beneficiaryTokenCount,
          _beneficiary,
          _preferClaimedTokens,
          _memo,
          _metadata
        );

        _delegate.didPay(_data);
        emit DelegateDidPay(_delegate, _data, msg.sender);
      }
    }

    emit Pay(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _payer,
      _beneficiary,
      _amount,
      beneficiaryTokenCount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function _addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    bool _shouldRefundHeldFees,
    string memory _memo,
    bytes memory _metadata
  ) internal {
    // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.
    uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0;

    // Record the added funds with any refunded fees.
    store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);

    emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);
  }

  /**
    @notice
    Refund fees based on the specified amount.

    @param _projectId The project for which fees are being refunded.
    @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.

    @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal
  */
  function _refundHeldFees(uint256 _projectId, uint256 _amount)
    internal
    returns (uint256 refundedFees)
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the current held fees.
    delete _heldFeesOf[_projectId];

    // Get a reference to the leftover amount once all fees have been settled.
    uint256 leftoverAmount = _amount;

    // Push length in stack
    uint256 _heldFeesLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeesLength; ) {
      if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);
      else if (leftoverAmount >= _heldFees[_i].amount) {
        unchecked {
          leftoverAmount = leftoverAmount - _heldFees[_i].amount;
          refundedFees += _feeAmount(
            _heldFees[_i].amount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount
          );
        }
      } else {
        _heldFeesOf[_projectId].push(
          JBFee(
            _heldFees[_i].amount - leftoverAmount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount,
            _heldFees[_i].beneficiary
          )
        );
        unchecked {
          refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);
        }
        leftoverAmount = 0;
      }

      unchecked {
        ++_i;
      }
    }

    emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);
  }

  /** 
    @notice 
    Returns the fee amount based on the provided amount for the specified project.

    @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal.
    @param _fee The percentage of the fee, out of MAX_FEE. 
    @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.

    @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _feeAmount(
    uint256 _amount,
    uint256 _fee,
    uint256 _feeDiscount
  ) internal pure returns (uint256) {
    // Calculate the discounted fee.
    uint256 _discountedFee = _fee -
      PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT);

    // The amount of tokens from the `_amount` to pay as a fee.
    return
      _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);
  }

  /** 
    @notice
    Get the fee discount from the fee gauge for the specified project.

    @param _projectId The ID of the project to get a fee discount for.
    
    @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.
  */
  function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {
    // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.
    if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))
      return JBConstants.MAX_FEE_DISCOUNT;

    // Get the fee discount.
    if (feeGauge == IJBFeeGauge(address(0)))
      feeDiscount = 0;
      // If the guage reverts, set the discount to 0.
    else
      try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {
        feeDiscount = discount;
      } catch {
        feeDiscount = 0;
      }

    // If the fee discount is greater than the max, nullify the discount.
    if (feeDiscount > JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;
  }
}
.]

Based on the provided smart contract code for the `JBPayoutRedemptionPaymentTerminal`, here is a summary of potential security vulnerabilities identified:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - Although the contract inherits from `ReentrancyGuard`, which helps prevent reentrant calls, careful attention must be paid to all external calls (e.g., `_transferFrom`, `_pay`, `_redeemTokensOf`, etc.) to ensure that they do not inadvertently allow reentrancy.

2. **Access Control Issues**:
   - The contract uses `onlyOwner` and `requirePermission` modifiers for access control. If the ownership is compromised or if there are flaws in the permission checks, unauthorized users could potentially execute sensitive functions.

3. **Error Handling**:
   - The contract uses custom errors for various conditions (e.g., `FEE_TOO_HIGH`, `INADEQUATE_DISTRIBUTION_AMOUNT`, etc.). While this is a good practice for gas efficiency, it is crucial to ensure that all error conditions are correctly handled and that the contract does not revert unexpectedly in critical paths.

4. **Fee Management**:
   - The fee structure allows for fees to be held and processed later. If not managed correctly, this could lead to unexpected behavior or loss of funds. The logic for refunding held fees must be robust to avoid double counting or mismanagement of funds.

5. **Zero Address Checks**:
   - The contract has checks for zero addresses in several functions (e.g., `PAY_TO_ZERO_ADDRESS`, `REDEEM_TO_ZERO_ADDRESS`). However, it is essential to ensure that all functions that involve address parameters consistently validate against zero addresses to prevent potential fund loss.

6. **Gas Limit Issues**:
   - Functions that involve loops (e.g., processing fees, distributing payouts) could run into gas limit issues if the number of iterations is large. This could lead to failed transactions or require users to manually split calls.

7. **External Call Risks**:
   - The contract makes several external calls to other contracts (e.g., `IJBController`, `IJBSplitsStore`). If these contracts are not well-audited or if they contain vulnerabilities, they could pose risks to the security of this contract.

8. **Fallback Function**:
   - The contract does not explicitly define a fallback function. If the contract is intended to receive ETH, it should implement a fallback or receive function to handle incoming transactions correctly.

### Comprehensive Analysis Report:

The `JBPayoutRedemptionPaymentTerminal` contract is a complex piece of code that manages funds and payouts within a decentralized finance ecosystem. While it incorporates several best practices, including the use of OpenZeppelin's libraries for access control and security, there are notable vulnerabilities that must be addressed to ensure the contract's robustness.

1. **Reentrancy Protection**: The use of `ReentrancyGuard` is a positive aspect, but developers must remain vigilant about external calls that could still lead to reentrancy attacks if not handled properly.

2. **Access Control**: The reliance on ownership and permission checks necessitates thorough testing to ensure that only authorized users can execute sensitive functions. Any compromise of the owner account could lead to significant security risks.

3. **Fee Management**: The fee structure introduces complexity that could lead to mismanagement of funds if not carefully implemented. It is crucial to ensure that all fee-related logic is thoroughly tested and audited.

4. **Error Handling and Address Validation**: The contract's use of custom errors is efficient, but developers must ensure that all potential error conditions are accounted for. Additionally, consistent validation against zero addresses is critical to prevent fund loss.

5. **Gas Limit Considerations**: Functions that involve loops should be optimized to prevent gas limit issues, especially in scenarios where the number of iterations could be high.

6. **External Dependencies**: The contract's reliance on external contracts introduces risks that must be mitigated through careful auditing of those contracts.

In conclusion, while the `JBPayoutRedemptionPaymentTerminal` contract demonstrates a solid foundation for managing project funds, addressing the identified vulnerabilities is essential for ensuring its security and reliability in a production environment. A thorough audit and testing process, including stress testing and scenario analysis, should be conducted to mitigate these risks effectively.

[2024-01-09 17:18:21 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for the `JBPayoutRedemptionPaymentTerminal`, here is a summary of potential security vulnerabilities identified:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - Although the contract inherits from `ReentrancyGuard`, which helps prevent reentrant calls, careful attention must be paid to all external calls (e.g., `_transferFrom`, `_pay`, `_redeemTokensOf`, etc.) to ensure that they do not inadvertently allow reentrancy.

2. **Access Control Issues**:
   - The contract uses `onlyOwner` and `requirePermission` modifiers for access control. If the ownership is compromised or if there are flaws in the permission checks, unauthorized users could potentially execute sensitive functions.

3. **Error Handling**:
   - The contract uses custom errors for various conditions (e.g., `FEE_TOO_HIGH`, `INADEQUATE_DISTRIBUTION_AMOUNT`, etc.). While this is a good practice for gas efficiency, it is crucial to ensure that all error conditions are correctly handled and that the contract does not revert unexpectedly in critical paths.

4. **Fee Management**:
   - The fee structure allows for fees to be held and processed later. If not managed correctly, this could lead to unexpected behavior or loss of funds. The logic for refunding held fees must be robust to avoid double counting or mismanagement of funds.

5. **Zero Address Checks**:
   - The contract has checks for zero addresses in several functions (e.g., `PAY_TO_ZERO_ADDRESS`, `REDEEM_TO_ZERO_ADDRESS`). However, it is essential to ensure that all functions that involve address parameters consistently validate against zero addresses to prevent potential fund loss.

6. **Gas Limit Issues**:
   - Functions that involve loops (e.g., processing fees, distributing payouts) could run into gas limit issues if the number of iterations is large. This could lead to failed transactions or require users to manually split calls.

7. **External Call Risks**:
   - The contract makes several external calls to other contracts (e.g., `IJBController`, `IJBSplitsStore`). If these contracts are not well-audited or if they contain vulnerabilities, they could pose risks to the security of this contract.

8. **Fallback Function**:
   - The contract does not explicitly define a fallback function. If the contract is intended to receive ETH, it should implement a fallback or receive function to handle incoming transactions correctly.

### Comprehensive Analysis Report:

The `JBPayoutRedemptionPaymentTerminal` contract is a complex piece of code that manages funds and payouts within a decentralized finance ecosystem. While it incorporates several best practices, including the use of OpenZeppelin's libraries for access control and security, there are notable vulnerabilities that must be addressed to ensure the contract's robustness.

1. **Reentrancy Protection**: The use of `ReentrancyGuard` is a positive aspect, but developers must remain vigilant about external calls that could still lead to reentrancy attacks if not handled properly.

2. **Access Control**: The reliance on ownership and permission checks necessitates thorough testing to ensure that only authorized users can execute sensitive functions. Any compromise of the owner account could lead to significant security risks.

3. **Fee Management**: The fee structure introduces complexity that could lead to mismanagement of funds if not carefully implemented. It is crucial to ensure that all fee-related logic is thoroughly tested and audited.

4. **Error Handling and Address Validation**: The contract's use of custom errors is efficient, but developers must ensure that all potential error conditions are accounted for. Additionally, consistent validation against zero addresses is critical to prevent fund loss.

5. **Gas Limit Considerations**: Functions that involve loops should be optimized to prevent gas limit issues, especially in scenarios where the number of iterations could be high.

6. **External Dependencies**: The contract's reliance on external contracts introduces risks that must be mitigated through careful auditing of those contracts.

In conclusion, while the `JBPayoutRedemptionPaymentTerminal` contract demonstrates a solid foundation for managing project funds, addressing the identified vulnerabilities is essential for ensuring its security and reliability in a production environment. A thorough audit and testing process, including stress testing and scenario analysis, should be conducted to mitigate these risks effectively.

[2024-01-09 17:18:24 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/security/ReentrancyGuard.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './../interfaces/IJBController.sol'; import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol'; import './../libraries/JBConstants.sol'; import './../libraries/JBCurrencies.sol'; import './../libraries/JBFixedPointNumber.sol'; import './../libraries/JBFundingCycleMetadataResolver.sol'; import './../libraries/JBOperations.sol'; import './../libraries/JBSplitsGroups.sol'; import './../libraries/JBTokens.sol'; import './../structs/JBTokenAmount.sol'; import './JBOperatable.sol'; import './JBSingleTokenPaymentTerminal.sol'; /**   @notice   Generic terminal managing all inflows and outflows of funds into the protocol ecosystem. @dev   A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time. @dev   Adheres to -   IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules. @dev   Inherits from -   JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.   JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.   Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.   ReentrancyGuard: Contract module that helps prevent reentrant calls to a function. */ abstract contract JBPayoutRedemptionPaymentTerminal is   IJBPayoutRedemptionPaymentTerminal,   JBSingleTokenPaymentTerminal,   JBOperatable,   Ownable,   ReentrancyGuard {   // A library that parses the packed funding cycle metadata into a friendlier format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error FEE_TOO_HIGH();   error INADEQUATE_DISTRIBUTION_AMOUNT();   error INADEQUATE_RECLAIM_AMOUNT();   error INADEQUATE_TOKEN_COUNT();   error NO_MSG_VALUE_ALLOWED();   error PAY_TO_ZERO_ADDRESS();   error PROJECT_TERMINAL_MISMATCH();   error REDEEM_TO_ZERO_ADDRESS();   error TERMINAL_IN_SPLIT_ZERO_ADDRESS();   error TERMINAL_TOKENS_INCOMPATIBLE(); //***********//   // ---------------------------- modifiers ---------------------------- //   //*************// /*      @notice      A modifier that verifies this terminal is a terminal of provided project ID.   /   modifier isTerminalOf(uint256 projectId) {     if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();     ;   } //***********//   // --------------------- internal stored constants ------------------- //   //*************// /**     @notice     Maximum fee that can be set for a funding cycle configuration. @dev Out of MAX_FEE (50_000_000 / 1_000_000_000).  */   uint256 internal constant _FEE_CAP = 50_000_000; /*     @notice     The protocol project ID is 1, as it should be the first project launched during the deployment process.   /   uint256 internal constant _PROTOCOL_PROJECT_ID = 1; //***********//   // --------------------- internal stored properties ------------------ //   //*************// /**     @notice     Fees that are being held to be processed later. _projectId The ID of the project for which fees are being held.  */   mapping(uint256 =&gt; JBFee[]) internal _heldFeesOf; //***********//   // ---------------- public immutable stored properties --------------- //   //*************// /*     @notice     Mints ERC-721's that represent project ownership and transfers.   /   IJBProjects public immutable override projects; /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; /*     @notice     The contract that stores splits for each project.   /   IJBSplitsStore public immutable override splitsStore; /*     @notice     The contract that exposes price feeds.   /   IJBPrices public immutable override prices; /*     @notice     The contract that stores and manages the terminal's data.   /   IJBSingleTokenPaymentTerminalStore public immutable override store; /**     @notice     The currency to base token issuance on. @dev If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.  */   uint256 public immutable override baseWeightCurrency; /*     @notice     The group that payout splits coming from this terminal are identified by.   /   uint256 public immutable override payoutSplitsGroup; //***********//   // --------------------- public stored properties -------------------- //   //*************// /**     @notice     The platform fee percent. @dev Out of MAX_FEE (25_000_000 / 1_000_000_000)  */   uint256 public override fee = 25_000_000; // 2.5% /*     @notice     The data source that returns a discount to apply to a project's fee.   /   IJBFeeGauge public override feeGauge; /**     @notice     Addresses that can be paid towards from this terminal without incurring a fee. _address The address that can be paid toward.  */   mapping(address =&gt; bool) public override isFeelessAddress; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     Gets the current overflowed amount in this terminal for a specified project, in terms of ETH. @dev The current overflow is represented as a fixed point number with 18 decimals.  @param _projectId The ID of the project to get overflow for.  @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.  */   function currentEthOverflowOf(uint256 _projectId)     external     view     virtual     override     returns (uint256)   {     // Get this terminal's current overflow.     uint256 _overflow = store.currentOverflowOf(this, _projectId); // Adjust the decimals of the fixed point number if needed to have 18 decimals. uint256 _adjustedOverflow = (decimals == 18)   ? _overflow   : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);  // Return the amount converted to ETH. return   (currency == JBCurrencies.ETH)     ? _adjustedOverflow     : PRBMath.mulDiv(       _adjustedOverflow,       10**decimals,       prices.priceFor(currency, JBCurrencies.ETH, decimals)     );  } /**     @notice     The fees that are currently being held to be processed later for each project. @param _projectId The ID of the project for which fees are being held.  @return An array of fees that are being held.  */   function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {     return _heldFeesOf[_projectId];   } //***********//   // -------------------------- public views --------------------------- //   //*************// /**     @notice     Indicates if this contract adheres to the specified interface. @dev  See {IERC165-supportsInterface}.  @param _interfaceId The ID of the interface to check for adherance to.  */   function supportsInterface(bytes4 _interfaceId)     public     view     virtual     override(JBSingleTokenPaymentTerminal, IERC165)     returns (bool)   {     return       _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||       _interfaceId == type(IJBPayoutTerminal).interfaceId ||       _interfaceId == type(IJBAllowanceTerminal).interfaceId ||       _interfaceId == type(IJBRedemptionTerminal).interfaceId ||       _interfaceId == type(IJBOperatable).interfaceId ||       super.supportsInterface(_interfaceId);   } //***********//   // -------------------------- constructor ---------------------------- //   //*************// /*     @param _token The token that this terminal manages.     @param _decimals The number of decimals the token fixed point amounts are expected to have.     @param _currency The currency that this terminal's token adheres to for price feeds.     @param _baseWeightCurrency The currency to base token issuance on.     @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.     @param _operatorStore A contract storing operator assignments.     @param _projects A contract which mints ERC-721's that represent project ownership and transfers.     @param _directory A contract storing directories of terminals and controllers for each project.     @param _splitsStore A contract that stores splits for each project.     @param _prices A contract that exposes price feeds.     @param _store A contract that stores the terminal's data.     @param _owner The address that will own this contract.   /   constructor(     // payable constructor save the gas used to check msg.value==0     address _token,     uint256 _decimals,     uint256 _currency,     uint256 _baseWeightCurrency,     uint256 _payoutSplitsGroup,     IJBOperatorStore _operatorStore,     IJBProjects _projects,     IJBDirectory _directory,     IJBSplitsStore _splitsStore,     IJBPrices _prices,     IJBSingleTokenPaymentTerminalStore _store,     address _owner   )     payable     JBSingleTokenPaymentTerminal(_token, _decimals, _currency)     JBOperatable(_operatorStore)   {     baseWeightCurrency = _baseWeightCurrency;     payoutSplitsGroup = _payoutSplitsGroup;     projects = _projects;     directory = _directory;     splitsStore = _splitsStore;     prices = _prices;     store = _store; transferOwnership(_owner);  } //***********//   // ---------------------- external transactions ---------------------- //   //*************// /**     @notice     Contribute tokens to a project. @param _projectId The ID of the project being paid. @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place. @param _token The token being paid. This terminal ignores this property since it only manages one token.  @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate. @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal. @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas. @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.  */   function pay(     uint256 _projectId,     uint256 _amount,     address _token,     address _beneficiary,     uint256 _minReturnedTokens,     bool _preferClaimedTokens,     string calldata _memo,     bytes calldata _metadata   ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {     _token; // Prevents unused var compiler and natspec complaints. // ETH shouldn't be sent if this terminal's token isn't ETH. if (token != JBTokens.ETH) {   if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();    // Transfer tokens to this terminal from the msg sender.   _transferFrom(msg.sender, payable(address(this)), _amount); } // If this terminal's token is ETH, override _amount with msg.value. else _amount = msg.value;  return   _pay(     _amount,     msg.sender,     _projectId,     _beneficiary,     _minReturnedTokens,     _preferClaimedTokens,     _memo,     _metadata   );  } /**     @notice     Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source. @dev Only a token holder or a designated operator can redeem its tokens.  @param _holder The account to redeem tokens for. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _token The token being reclaimed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal. @param _beneficiary The address to send the terminal tokens to. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.  */   function redeemTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     address _token,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo,     bytes memory _metadata   )     external     virtual     override     requirePermission(_holder, _projectId, JBOperations.REDEEM)     returns (uint256 reclaimAmount)   {     _token; // Prevents unused var compiler and natspec complaints. return   _redeemTokensOf(     _holder,     _projectId,     _tokenCount,     _minReturnedTokens,     _beneficiary,     _memo,     _metadata   );  } /**     @notice     Distributes payouts for a project with the distribution limit of its current funding cycle. @dev Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.  @dev Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.  @dev All funds distributed outside of this contract or any feeless terminals incure the protocol fee.  @param _projectId The ID of the project having its payouts distributed. @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency. @param _token The token being distributed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal. @param _memo A memo to pass along to the emitted event.  @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.  */   function distributePayoutsOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     address _token,     uint256 _minReturnedTokens,     string calldata _memo   ) external virtual override returns (uint256 netLeftoverDistributionAmount) {     _token; // Prevents unused var compiler and natspec complaints. return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);  } /**     @notice     Allows a project to send funds from its overflow up to the preconfigured allowance. @dev Only a project's owner or a designated operator can use its allowance.  @dev Incurs the protocol fee.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency. @param _token The token being distributed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals. @param _beneficiary The address to send the funds to. @param _memo A memo to pass along to the emitted event.  @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.  */   function useAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     address _token,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)     returns (uint256 netDistributedAmount)   {     _token; // Prevents unused var compiler and natspec complaints. return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);  } /**     @notice     Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type. @dev Only a project's owner or a designated operator can migrate it.  @param _projectId The ID of the project being migrated. @param _to The terminal contract that will gain the project's funds.  @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.  */   function migrate(uint256 _projectId, IJBPaymentTerminal _to)     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)     returns (uint256 balance)   {     // The terminal being migrated to must accept the same token as this terminal.     if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE(); // Record the migration in the store. balance = store.recordMigration(_projectId);  // Transfer the balance if needed. if (balance &gt; 0) {   // Trigger any inherited pre-transfer logic.   _beforeTransferTo(address(_to), balance);    // If this terminal's token is ETH, send it in msg.value.   uint256 _payableValue = token == JBTokens.ETH ? balance : 0;    // Withdraw the balance to transfer to the new terminal;   _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes('')); }  emit Migrate(_projectId, _to, balance, msg.sender);  } /**     @notice     Receives funds belonging to the specified project. @param _projectId The ID of the project to which the funds received belong. @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead. @param _token The token being paid. This terminal ignores this property since it only manages one currency.  @param _memo A memo to pass along to the emitted event. @param _metadata Extra data to pass along to the emitted event.  */   function addToBalanceOf(     uint256 _projectId,     uint256 _amount,     address _token,     string calldata _memo,     bytes calldata _metadata   ) external payable virtual override isTerminalOf(_projectId) {     _token; // Prevents unused var compiler and natspec complaints. // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender. if (token != JBTokens.ETH) {   // Amount must be greater than 0.   if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();    // Transfer tokens to this terminal from the msg sender.   _transferFrom(msg.sender, payable(address(this)), _amount); } // If the terminal's token is ETH, override `_amount` with msg.value. else _amount = msg.value;  // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal. _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);  } /**     @notice     Process any fees that are being held for the project. @dev Only a project owner, an operator, or the contract's owner can process held fees.  @param _projectId The ID of the project whos held fees should be processed.  */   function processFees(uint256 _projectId)     external     virtual     override     requirePermissionAllowingOverride(       projects.ownerOf(_projectId),       _projectId,       JBOperations.PROCESS_FEES,       msg.sender == owner()     )   {     // Get a reference to the project's held fees.     JBFee[] memory _heldFees = _heldFeesOf[_projectId]; // Delete the held fees. delete _heldFeesOf[_projectId];  // Push array length in stack uint256 _heldFeeLength = _heldFees.length;  // Process each fee. for (uint256 _i = 0; _i &lt; _heldFeeLength; ) {   // Get the fee amount.   uint256 _amount = _feeAmount(     _heldFees[_i].amount,     _heldFees[_i].fee,     _heldFees[_i].feeDiscount   );    // Process the fee.   _processFee(_amount, _heldFees[_i].beneficiary);    emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);    unchecked {     ++_i;   } }  } /**     @notice     Allows the fee to be updated. @dev Only the owner of this contract can change the fee.  @param _fee The new fee, out of MAX_FEE.  */   function setFee(uint256 _fee) external virtual override onlyOwner {     // The provided fee must be within the max.     if (_fee &gt; _FEE_CAP) revert FEE_TOO_HIGH(); // Store the new fee. fee = _fee;  emit SetFee(_fee, msg.sender);  } /**     @notice     Allows the fee gauge to be updated. @dev Only the owner of this contract can change the fee gauge.  @dev If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.  @param _feeGauge The new fee gauge.  */   function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {     // Store the new fee gauge.     feeGauge = _feeGauge; emit SetFeeGauge(_feeGauge, msg.sender);  } /**     @notice     Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee. @dev Only the owner of this contract can set addresses as feeless.  @param _address The address that can be paid towards while still bypassing fees. @param _flag A flag indicating whether the terminal should be feeless or not.  */   function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {     // Set the flag value.     isFeelessAddress[_address] = _flag; emit SetFeelessAddress(_address, _flag, msg.sender);  } //***********//   // ---------------------- internal transactions ---------------------- //   //*************// /**      @notice     Transfers tokens. @param _from The address from which the transfer should originate. @param _to The address to which the transfer should go. @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.  */   function _transferFrom(     address _from,     address payable _to,     uint256 _amount   ) internal virtual; /**      @notice     Logic to be triggered before transferring tokens from this terminal. @param _to The address to which the transfer is going. @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.  */   function _beforeTransferTo(address _to, uint256 _amount) internal virtual; /**     @notice     Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source. @dev Only a token holder or a designated operator can redeem its tokens.  @param _holder The account to redeem tokens for. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal. @param _beneficiary The address to send the terminal tokens to. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.  */   function _redeemTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo,     bytes memory _metadata   ) internal returns (uint256 reclaimAmount) {     // Can't send reclaimed funds to the zero address.     if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS(); // Define variables that will be needed outside the scoped section below. // Keep a reference to the funding cycle during which the redemption is being made. JBFundingCycle memory _fundingCycle;  // Scoped section prevents stack too deep. `_delegate` only used within scope. {   IJBRedemptionDelegate _delegate;    // Record the redemption.   (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(     _holder,     _projectId,     _tokenCount,     _memo,     _metadata   );    // The amount being reclaimed must be at least as much as was expected.   if (reclaimAmount &lt; _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();    // Burn the project tokens.   if (_tokenCount &gt; 0)     IJBController(directory.controllerOf(_projectId)).burnTokensOf(       _holder,       _projectId,       _tokenCount,       '',       false     );    // If a delegate was returned by the data source, issue a callback to it.   if (_delegate != IJBRedemptionDelegate(address(0))) {     JBDidRedeemData memory _data = JBDidRedeemData(       _holder,       _projectId,       _fundingCycle.configuration,       _tokenCount,       JBTokenAmount(token, reclaimAmount, decimals, currency),       _beneficiary,       _memo,       _metadata     );     _delegate.didRedeem(_data);     emit DelegateDidRedeem(_delegate, _data, msg.sender);   } }  // Send the reclaimed funds to the beneficiary. if (reclaimAmount &gt; 0) _transferFrom(address(this), _beneficiary, reclaimAmount);  emit RedeemTokens(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _holder,   _beneficiary,   _tokenCount,   reclaimAmount,   _memo,   _metadata,   msg.sender );  } /**     @notice     Distributes payouts for a project with the distribution limit of its current funding cycle. @dev Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.  @dev Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.  @dev All funds distributed outside of this contract or any feeless terminals incure the protocol fee.  @param _projectId The ID of the project having its payouts distributed. @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency. @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal. @param _memo A memo to pass along to the emitted event.  @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.  */   function _distributePayoutsOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     uint256 _minReturnedTokens,     string calldata _memo   ) internal returns (uint256 netLeftoverDistributionAmount) {     // Record the distribution.     (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(       _projectId,       _amount,       _currency     ); // The amount being distributed must be at least as much as was expected. if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();  // Get a reference to the project owner, which will receive tokens from paying the platform fee // and receive any extra distributable funds not allocated to payout splits. address payable _projectOwner = payable(projects.ownerOf(_projectId));  // Define variables that will be needed outside the scoped section below. // Keep a reference to the fee amount that was paid. uint256 _fee;  // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope. {   // Get the amount of discount that should be applied to any fees taken.   // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.   uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]     ? JBConstants.MAX_FEE_DISCOUNT     : _currentFeeDiscount(_projectId);    // The amount distributed that is eligible for incurring fees.   uint256 _feeEligibleDistributionAmount;    // The amount leftover after distributing to the splits.   uint256 _leftoverDistributionAmount;    // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.   // Also get a reference to the amount that was distributed to splits from which fees should be taken.   (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(     _projectId,     _fundingCycle.configuration,     payoutSplitsGroup,     _distributedAmount,     _feeDiscount   );    // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.   unchecked {     _feeEligibleDistributionAmount += _leftoverDistributionAmount;   }    // Take the fee.   _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0     ? 0     : _takeFeeFrom(       _projectId,       _fundingCycle,       _feeEligibleDistributionAmount,       _projectOwner,       _feeDiscount     );    // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.    unchecked {     netLeftoverDistributionAmount = _leftoverDistributionAmount == 0       ? 0       : _leftoverDistributionAmount -         _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);   }    // Transfer any remaining balance to the project owner.   if (netLeftoverDistributionAmount &gt; 0)     _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount); }  emit DistributePayouts(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _projectOwner,   _amount,   _distributedAmount,   _fee,   netLeftoverDistributionAmount,   _memo,   msg.sender );  } /**     @notice     Allows a project to send funds from its overflow up to the preconfigured allowance. @dev Only a project's owner or a designated operator can use its allowance.  @dev Incurs the protocol fee.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency. @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals. @param _beneficiary The address to send the funds to. @param _memo A memo to pass along to the emitted event.  @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.  */   function _useAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo   ) internal returns (uint256 netDistributedAmount) {     // Record the use of the allowance.     (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(       _projectId,       _amount,       _currency     ); // The amount being withdrawn must be at least as much as was expected. if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();  // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope. {   // Keep a reference to the fee amount that was paid.   uint256 _fee;    // Get a reference to the project owner, which will receive tokens from paying the platform fee.   address _projectOwner = projects.ownerOf(_projectId);    // Get the amount of discount that should be applied to any fees taken.   // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.   uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]     ? JBConstants.MAX_FEE_DISCOUNT     : _currentFeeDiscount(_projectId);    // Take a fee from the `_distributedAmount`, if needed.   _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT     ? 0     : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);    unchecked {     // The net amount is the withdrawn amount without the fee.     netDistributedAmount = _distributedAmount - _fee;   }    // Transfer any remaining balance to the beneficiary.   if (netDistributedAmount &gt; 0)     _transferFrom(address(this), _beneficiary, netDistributedAmount); }  emit UseAllowance(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _beneficiary,   _amount,   _distributedAmount,   netDistributedAmount,   _memo,   msg.sender );  } /**     @notice     Pays out splits for a project's funding cycle configuration. @param _projectId The ID of the project for which payout splits are being distributed. @param _domain The domain of the splits to distribute the payout between. @param _group The group of the splits to distribute the payout between. @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal. @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.  @return leftoverAmount If the leftover amount if the splits don't add up to 100%. @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.  */   function _distributeToPayoutSplitsOf(     uint256 _projectId,     uint256 _domain,     uint256 _group,     uint256 _amount,     uint256 _feeDiscount   ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {     // Set the leftover amount to the initial amount.     leftoverAmount = _amount; // Get a reference to the project's payout splits. JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);  // Transfer between all splits. for (uint256 _i = 0; _i &lt; _splits.length; ) {   // Get a reference to the split being iterated on.   JBSplit memory _split = _splits[_i];    // The amount to send towards the split.   uint256 _payoutAmount = PRBMath.mulDiv(     _amount,     _split.percent,     JBConstants.SPLITS_TOTAL_PERCENT   );    // The payout amount substracting any applicable incurred fees.   uint256 _netPayoutAmount;    if (_payoutAmount &gt; 0) {     // Transfer tokens to the split.     // If there's an allocator set, transfer to its `allocate` function.     if (_split.allocator != IJBSplitAllocator(address(0))) {       // If the split allocator is set as feeless, this distribution is not eligible for a fee.       if (isFeelessAddress[address(_split.allocator)])         _netPayoutAmount = _payoutAmount;         // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.       else {         unchecked {           _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT             ? _payoutAmount             : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);         }          // This distribution is eligible for a fee since the funds are leaving the ecosystem.         feeEligibleDistributionAmount += _payoutAmount;       }        // Trigger any inherited pre-transfer logic.       _beforeTransferTo(address(_split.allocator), _netPayoutAmount);        // If this terminal's token is ETH, send it in msg.value.       uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;        // Create the data to send to the allocator.       JBSplitAllocationData memory _data = JBSplitAllocationData(         token,         _netPayoutAmount,         decimals,         _projectId,         _group,         _split       );        // Trigger the allocator's `allocate` function.       _split.allocator.allocate{value: _payableValue}(_data);        // Otherwise, if a project is specified, make a payment to it.     } else if (_split.projectId != 0) {       // Get a reference to the Juicebox terminal being used.       IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);        // The project must have a terminal to send funds to.       if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();        // Save gas if this contract is being used as the terminal.       if (_terminal == this) {         // This distribution does not incur a fee.         _netPayoutAmount = _payoutAmount;          // Send the projectId in the metadata.         bytes memory _projectMetadata = new bytes(32);         _projectMetadata = bytes(abi.encodePacked(_projectId));          // Add to balance if prefered.         if (_split.preferAddToBalance)           _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);         else           _pay(             _netPayoutAmount,             address(this),             _split.projectId,             (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,             0,             _split.preferClaimed,             '',             _projectMetadata           );       } else {         // If the terminal is set as feeless, this distribution is not eligible for a fee.         if (isFeelessAddress[address(_terminal)])           _netPayoutAmount = _payoutAmount;           // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.         else {           unchecked {             _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT               ? _payoutAmount               : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);           }            feeEligibleDistributionAmount += _payoutAmount;         }          // Trigger any inherited pre-transfer logic.         _beforeTransferTo(address(_terminal), _netPayoutAmount);          // If this terminal's token is ETH, send it in msg.value.         uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;          // Send the projectId in the metadata.         bytes memory _projectMetadata = new bytes(32);         _projectMetadata = bytes(abi.encodePacked(_projectId));          // Add to balance if prefered.         if (_split.preferAddToBalance)           _terminal.addToBalanceOf{value: _payableValue}(             _split.projectId,             _netPayoutAmount,             token,             '',             _projectMetadata           );         else           _terminal.pay{value: _payableValue}(             _split.projectId,             _netPayoutAmount,             token,             _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,             0,             _split.preferClaimed,             '',             _projectMetadata           );       }     } else {       unchecked {         _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT           ? _payoutAmount           : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);       }        // This distribution is eligible for a fee since the funds are leaving the ecosystem.       feeEligibleDistributionAmount += _payoutAmount;        // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.       _transferFrom(         address(this),         _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),         _netPayoutAmount       );     }      // Subtract from the amount to be sent to the beneficiary.     unchecked {       leftoverAmount = leftoverAmount - _payoutAmount;     }   }    emit DistributeToPayoutSplit(     _projectId,     _domain,     _group,     _split,     _netPayoutAmount,     msg.sender   );    unchecked {     ++_i;   } }  } /**     @notice     Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID. @param _projectId The ID of the project having fees taken from. @param _fundingCycle The funding cycle during which the fee is being taken. @param _amount The amount of the fee to take, as a floating point number with 18 decimals. @param _beneficiary The address to mint the platforms tokens for. @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.  @return feeAmount The amount of the fee taken.  */   function _takeFeeFrom(     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _amount,     address _beneficiary,     uint256 _feeDiscount   ) internal returns (uint256 feeAmount) {     feeAmount = _feeAmount(_amount, fee, _feeDiscount); if (_fundingCycle.shouldHoldFees()) {   // Store the held fee.   _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));    emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender); } else {   // Process the fee.   _processFee(feeAmount, _beneficiary); // Take the fee.    emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender); }  } /**     @notice     Process a fee of the specified amount. @param _amount The fee amount, as a floating point number with 18 decimals. @param _beneficiary The address to mint the platform's tokens for.  */   function _processFee(uint256 _amount, address _beneficiary) internal {     // Get the terminal for the protocol project.     IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token); // When processing the admin fee, save gas if the admin is using this contract as its terminal. if (_terminal == this)   _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call. else {   // Trigger any inherited pre-transfer logic.   _beforeTransferTo(address(_terminal), _amount);    // If this terminal's token is ETH, send it in msg.value.   uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;    // Send the payment.   _terminal.pay{value: _payableValue}(     _PROTOCOL_PROJECT_ID,     _amount,     token,     _beneficiary,     0,     false,     '',     bytes('')   ); // Use the external pay call of the correct terminal. }  } /**     @notice     Contribute tokens to a project. @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place. @param _payer The address making the payment. @param _projectId The ID of the project being paid. @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate. @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal. @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas. @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.  */   function _pay(     uint256 _amount,     address _payer,     uint256 _projectId,     address _beneficiary,     uint256 _minReturnedTokens,     bool _preferClaimedTokens,     string memory _memo,     bytes memory _metadata   ) internal returns (uint256 beneficiaryTokenCount) {     // Cant send tokens to the zero address.     if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS(); // Define variables that will be needed outside the scoped section below. // Keep a reference to the funding cycle during which the payment is being made. JBFundingCycle memory _fundingCycle;  // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope. {   IJBPayDelegate _delegate;   uint256 _tokenCount;    // Bundle the amount info into a JBTokenAmount struct.   JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);    // Record the payment.   (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(     _payer,     _bundledAmount,     _projectId,     baseWeightCurrency,     _beneficiary,     _memo,     _metadata   );    // Mint the tokens if needed.   if (_tokenCount &gt; 0)     // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.     beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(       _projectId,       _tokenCount,       _beneficiary,       '',       _preferClaimedTokens,       true     );    // The token count for the beneficiary must be greater than or equal to the minimum expected.   if (beneficiaryTokenCount &lt; _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();    // If a delegate was returned by the data source, issue a callback to it.   if (_delegate != IJBPayDelegate(address(0))) {     JBDidPayData memory _data = JBDidPayData(       _payer,       _projectId,       _fundingCycle.configuration,       _bundledAmount,       beneficiaryTokenCount,       _beneficiary,       _preferClaimedTokens,       _memo,       _metadata     );      _delegate.didPay(_data);     emit DelegateDidPay(_delegate, _data, msg.sender);   } }  emit Pay(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _payer,   _beneficiary,   _amount,   beneficiaryTokenCount,   _memo,   _metadata,   msg.sender );  } /**     @notice     Receives funds belonging to the specified project. @param _projectId The ID of the project to which the funds received belong. @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead. @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added. @param _memo A memo to pass along to the emitted event. @param _metadata Extra data to pass along to the emitted event.  */   function _addToBalanceOf(     uint256 _projectId,     uint256 _amount,     bool _shouldRefundHeldFees,     string memory _memo,     bytes memory _metadata   ) internal {     // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.     uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0; // Record the added funds with any refunded fees. store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);  emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);  } /**     @notice     Refund fees based on the specified amount. @param _projectId The project for which fees are being refunded. @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.  @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal  */   function _refundHeldFees(uint256 _projectId, uint256 _amount)     internal     returns (uint256 refundedFees)   {     // Get a reference to the project's held fees.     JBFee[] memory _heldFees = _heldFeesOf[_projectId]; // Delete the current held fees. delete _heldFeesOf[_projectId];  // Get a reference to the leftover amount once all fees have been settled. uint256 leftoverAmount = _amount;  // Push length in stack uint256 _heldFeesLength = _heldFees.length;  // Process each fee. for (uint256 _i = 0; _i &lt; _heldFeesLength; ) {   if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);   else if (leftoverAmount &gt;= _heldFees[_i].amount) {     unchecked {       leftoverAmount = leftoverAmount - _heldFees[_i].amount;       refundedFees += _feeAmount(         _heldFees[_i].amount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount       );     }   } else {     _heldFeesOf[_projectId].push(       JBFee(         _heldFees[_i].amount - leftoverAmount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount,         _heldFees[_i].beneficiary       )     );     unchecked {       refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);     }     leftoverAmount = 0;   }    unchecked {     ++_i;   } }  emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);  } /**      @notice      Returns the fee amount based on the provided amount for the specified project. @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal. @param _fee The percentage of the fee, out of MAX_FEE.  @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.  @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.  */   function _feeAmount(     uint256 _amount,     uint256 _fee,     uint256 _feeDiscount   ) internal pure returns (uint256) {     // Calculate the discounted fee.     uint256 _discountedFee = _fee -       PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT); // The amount of tokens from the `_amount` to pay as a fee. return   _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);  } /**      @notice     Get the fee discount from the fee gauge for the specified project. @param _projectId The ID of the project to get a fee discount for.  @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.  */   function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {     // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.     if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))       return JBConstants.MAX_FEE_DISCOUNT; // Get the fee discount. if (feeGauge == IJBFeeGauge(address(0)))   feeDiscount = 0;   // If the guage reverts, set the discount to 0. else   try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {     feeDiscount = discount;   } catch {     feeDiscount = 0;   }  // If the fee discount is greater than the max, nullify the discount. if (feeDiscount &gt; JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;  } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@paulrberg/contracts/math/PRBMath.sol';\nimport './../interfaces/IJBController.sol';\nimport './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol';\nimport './../libraries/JBConstants.sol';\nimport './../libraries/JBCurrencies.sol';\nimport './../libraries/JBFixedPointNumber.sol';\nimport './../libraries/JBFundingCycleMetadataResolver.sol';\nimport './../libraries/JBOperations.sol';\nimport './../libraries/JBSplitsGroups.sol';\nimport './../libraries/JBTokens.sol';\nimport './../structs/JBTokenAmount.sol';\nimport './JBOperatable.sol';\nimport './JBSingleTokenPaymentTerminal.sol';\n\n/\n  @notice\n  Generic terminal managing all inflows and outflows of funds into the protocol ecosystem.\n\n  @dev\n  A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time.\n\n  @dev\n  Adheres to -\n  IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.\n\n  @dev\n  Inherits from -\n  JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.\n  JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.\n  Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.\n  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.\n/\nabstract contract JBPayoutRedemptionPaymentTerminal is\n  IJBPayoutRedemptionPaymentTerminal,\n  JBSingleTokenPaymentTerminal,\n  JBOperatable,\n  Ownable,\n  ReentrancyGuard\n{\n  // A library that parses the packed funding cycle metadata into a friendlier format.\n  using JBFundingCycleMetadataResolver for JBFundingCycle;\n\n  //*********//\n  // --------------------------- custom errors ------------------------- //\n  //*********//\n  error FEE_TOO_HIGH();\n  error INADEQUATE_DISTRIBUTION_AMOUNT();\n  error INADEQUATE_RECLAIM_AMOUNT();\n  error INADEQUATE_TOKEN_COUNT();\n  error NO_MSG_VALUE_ALLOWED();\n  error PAY_TO_ZERO_ADDRESS();\n  error PROJECT_TERMINAL_MISMATCH();\n  error REDEEM_TO_ZERO_ADDRESS();\n  error TERMINAL_IN_SPLIT_ZERO_ADDRESS();\n  error TERMINAL_TOKENS_INCOMPATIBLE();\n\n  //*********//\n  // ---------------------------- modifiers ---------------------------- //\n  //*********//\n\n  / \n    @notice \n    A modifier that verifies this terminal is a terminal of provided project ID.\n  /\n  modifier isTerminalOf(uint256 projectId) {\n    if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();\n    ;\n  }\n\n  //**********//\n  // --------------------- internal stored constants ------------------- //\n  //*********//\n\n  /\n    @notice\n    Maximum fee that can be set for a funding cycle configuration.\n\n    @dev\n    Out of MAX_FEE (50_000_000 / 1_000_000_000).\n  /\n  uint256 internal constant _FEE_CAP = 50_000_000;\n\n  /\n    @notice\n    The protocol project ID is 1, as it should be the first project launched during the deployment process.\n  /\n  uint256 internal constant _PROTOCOL_PROJECT_ID = 1;\n\n  //**********//\n  // --------------------- internal stored properties ------------------ //\n  //**********//\n\n  /\n    @notice\n    Fees that are being held to be processed later.\n\n    _projectId The ID of the project for which fees are being held.\n  /\n  mapping(uint256 =&gt; JBFee[]) internal _heldFeesOf;\n\n  //**********//\n  // ---------------- public immutable stored properties --------------- //\n  //*********//\n\n  /\n    @notice\n    Mints ERC-721's that represent project ownership and transfers.\n  /\n  IJBProjects public immutable override projects;\n\n  /\n    @notice\n    The directory of terminals and controllers for projects.\n  /\n  IJBDirectory public immutable override directory;\n\n  /\n    @notice\n    The contract that stores splits for each project.\n  /\n  IJBSplitsStore public immutable override splitsStore;\n\n  /\n    @notice\n    The contract that exposes price feeds.\n  /\n  IJBPrices public immutable override prices;\n\n  /\n    @notice\n    The contract that stores and manages the terminal's data.\n  */\n  IJBSingleTokenPaymentTerminalStore public immutable override store;\n\n  /\n    @notice\n    The currency to base token issuance on.\n\n    @dev\n    If this differs from currency, there must be a price feed available to convert currency to baseWeightCurrency.\n  /\n  uint256 public immutable override baseWeightCurrency;\n\n  /\n    @notice\n    The group that payout splits coming from this terminal are identified by.\n  /\n  uint256 public immutable override payoutSplitsGroup;\n\n  //*********//\n  // --------------------- public stored properties -------------------- //\n  //*********//\n\n  /\n    @notice\n    The platform fee percent.\n\n    @dev\n    Out of MAX_FEE (25_000_000 / 1_000_000_000)\n  /\n  uint256 public override fee = 25_000_000; // 2.5%\n\n  /\n    @notice\n    The data source that returns a discount to apply to a project's fee.\n  /\n  IJBFeeGauge public override feeGauge;\n\n  /\n    @notice\n    Addresses that can be paid towards from this terminal without incurring a fee.\n\n    _address The address that can be paid toward.\n  /\n  mapping(address =&gt; bool) public override isFeelessAddress;\n\n  //***********//\n  // ------------------------- external views -------------------------- //\n  //**********//\n\n  /\n    @notice\n    Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.\n\n    @dev\n    The current overflow is represented as a fixed point number with 18 decimals.\n\n    @param _projectId The ID of the project to get overflow for.\n\n    @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.\n  /\n  function currentEthOverflowOf(uint256 _projectId)\n    external\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    // Get this terminal's current overflow.\n    uint256 _overflow = store.currentOverflowOf(this, _projectId);\n\n    // Adjust the decimals of the fixed point number if needed to have 18 decimals.\n    uint256 _adjustedOverflow = (decimals == 18)\n      ? _overflow\n      : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);\n\n    // Return the amount converted to ETH.\n    return\n      (currency == JBCurrencies.ETH)\n        ? _adjustedOverflow\n        : PRBMath.mulDiv(\n          _adjustedOverflow,\n          10decimals,\n          prices.priceFor(currency, JBCurrencies.ETH, decimals)\n        );\n  }\n\n  /\n    @notice\n    The fees that are currently being held to be processed later for each project.\n\n    @param _projectId The ID of the project for which fees are being held.\n\n    @return An array of fees that are being held.\n  /\n  function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {\n    return _heldFeesOf[_projectId];\n  }\n\n  //*********//\n  // -------------------------- public views --------------------------- //\n  //*********//\n\n  /\n    @notice\n    Indicates if this contract adheres to the specified interface.\n\n    @dev \n    See {IERC165-supportsInterface}.\n\n    @param _interfaceId The ID of the interface to check for adherance to.\n  /\n  function supportsInterface(bytes4 _interfaceId)\n    public\n    view\n    virtual\n    override(JBSingleTokenPaymentTerminal, IERC165)\n    returns (bool)\n  {\n    return\n      _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||\n      _interfaceId == type(IJBPayoutTerminal).interfaceId ||\n      _interfaceId == type(IJBAllowanceTerminal).interfaceId ||\n      _interfaceId == type(IJBRedemptionTerminal).interfaceId ||\n      _interfaceId == type(IJBOperatable).interfaceId ||\n      super.supportsInterface(_interfaceId);\n  }\n\n  //**********//\n  // -------------------------- constructor ---------------------------- //\n  //*********//\n\n  /\n    @param _token The token that this terminal manages.\n    @param _decimals The number of decimals the token fixed point amounts are expected to have.\n    @param _currency The currency that this terminal's token adheres to for price feeds.\n    @param _baseWeightCurrency The currency to base token issuance on.\n    @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.\n    @param _operatorStore A contract storing operator assignments.\n    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.\n    @param _directory A contract storing directories of terminals and controllers for each project.\n    @param _splitsStore A contract that stores splits for each project.\n    @param _prices A contract that exposes price feeds.\n    @param _store A contract that stores the terminal's data.\n    @param _owner The address that will own this contract.\n  /\n  constructor(\n    // payable constructor save the gas used to check msg.value==0\n    address _token,\n    uint256 _decimals,\n    uint256 _currency,\n    uint256 _baseWeightCurrency,\n    uint256 _payoutSplitsGroup,\n    IJBOperatorStore _operatorStore,\n    IJBProjects _projects,\n    IJBDirectory _directory,\n    IJBSplitsStore _splitsStore,\n    IJBPrices _prices,\n    IJBSingleTokenPaymentTerminalStore _store,\n    address _owner\n  )\n    payable\n    JBSingleTokenPaymentTerminal(_token, _decimals, _currency)\n    JBOperatable(_operatorStore)\n  {\n    baseWeightCurrency = _baseWeightCurrency;\n    payoutSplitsGroup = _payoutSplitsGroup;\n    projects = _projects;\n    directory = _directory;\n    splitsStore = _splitsStore;\n    prices = _prices;\n    store = _store;\n\n    transferOwnership(_owner);\n  }\n\n  //**********//\n  // ---------------------- external transactions ---------------------- //\n  //*********//\n\n  /\n    @notice\n    Contribute tokens to a project.\n\n    @param _projectId The ID of the project being paid.\n    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.\n    @param _token The token being paid. This terminal ignores this property since it only manages one token. \n    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.\n    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.\n    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.\n    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.\n    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.\n\n    @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.\n  /\n  function pay(\n    uint256 _projectId,\n    uint256 _amount,\n    address _token,\n    address _beneficiary,\n    uint256 _minReturnedTokens,\n    bool _preferClaimedTokens,\n    string calldata _memo,\n    bytes calldata _metadata\n  ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {\n    _token; // Prevents unused var compiler and natspec complaints.\n\n    // ETH shouldn't be sent if this terminal's token isn't ETH.\n    if (token != JBTokens.ETH) {\n      if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();\n\n      // Transfer tokens to this terminal from the msg sender.\n      _transferFrom(msg.sender, payable(address(this)), _amount);\n    }\n    // If this terminal's token is ETH, override _amount with msg.value.\n    else _amount = msg.value;\n\n    return\n      _pay(\n        _amount,\n        msg.sender,\n        _projectId,\n        _beneficiary,\n        _minReturnedTokens,\n        _preferClaimedTokens,\n        _memo,\n        _metadata\n      );\n  }\n\n  /\n    @notice\n    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.\n\n    @dev\n    Only a token holder or a designated operator can redeem its tokens.\n\n    @param _holder The account to redeem tokens for.\n    @param _projectId The ID of the project to which the tokens being redeemed belong.\n    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.\n    @param _token The token being reclaimed. This terminal ignores this property since it only manages one token. \n    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.\n    @param _beneficiary The address to send the terminal tokens to.\n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.\n\n    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.\n  /\n  function redeemTokensOf(\n    address _holder,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    address _token,\n    uint256 _minReturnedTokens,\n    address payable _beneficiary,\n    string memory _memo,\n    bytes memory _metadata\n  )\n    external\n    virtual\n    override\n    requirePermission(_holder, _projectId, JBOperations.REDEEM)\n    returns (uint256 reclaimAmount)\n  {\n    _token; // Prevents unused var compiler and natspec complaints.\n\n    return\n      _redeemTokensOf(\n        _holder,\n        _projectId,\n        _tokenCount,\n        _minReturnedTokens,\n        _beneficiary,\n        _memo,\n        _metadata\n      );\n  }\n\n  /\n    @notice\n    Distributes payouts for a project with the distribution limit of its current funding cycle.\n\n    @dev\n    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.\n\n    @dev\n    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.\n\n    @dev\n    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.\n\n    @param _projectId The ID of the project having its payouts distributed.\n    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.\n    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.\n    @param _token The token being distributed. This terminal ignores this property since it only manages one token. \n    @param _minReturnedTokens The minimum number of terminal tokens that the _amount should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.\n  /\n  function distributePayoutsOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency,\n    address _token,\n    uint256 _minReturnedTokens,\n    string calldata _memo\n  ) external virtual override returns (uint256 netLeftoverDistributionAmount) {\n    _token; // Prevents unused var compiler and natspec complaints.\n\n    return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);\n  }\n\n  /\n    @notice\n    Allows a project to send funds from its overflow up to the preconfigured allowance.\n\n    @dev\n    Only a project's owner or a designated operator can use its allowance.\n\n    @dev\n    Incurs the protocol fee.\n\n    @param _projectId The ID of the project to use the allowance of.\n    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.\n    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.\n    @param _token The token being distributed. This terminal ignores this property since it only manages one token. \n    @param _minReturnedTokens The minimum number of tokens that the _amount should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.\n    @param _beneficiary The address to send the funds to.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.\n  /\n  function useAllowanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency,\n    address _token,\n    uint256 _minReturnedTokens,\n    address payable _beneficiary,\n    string memory _memo\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)\n    returns (uint256 netDistributedAmount)\n  {\n    _token; // Prevents unused var compiler and natspec complaints.\n\n    return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);\n  }\n\n  /\n    @notice\n    Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.\n\n    @dev\n    Only a project's owner or a designated operator can migrate it.\n\n    @param _projectId The ID of the project being migrated.\n    @param _to The terminal contract that will gain the project's funds.\n\n    @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.\n  */\n  function migrate(uint256 _projectId, IJBPaymentTerminal _to)\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)\n    returns (uint256 balance)\n  {\n    // The terminal being migrated to must accept the same token as this terminal.\n    if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE();\n\n    // Record the migration in the store.\n    balance = store.recordMigration(_projectId);\n\n    // Transfer the balance if needed.\n    if (balance &gt; 0) {\n      // Trigger any inherited pre-transfer logic.\n      _beforeTransferTo(address(_to), balance);\n\n      // If this terminal's token is ETH, send it in msg.value.\n      uint256 _payableValue = token == JBTokens.ETH ? balance : 0;\n\n      // Withdraw the balance to transfer to the new terminal;\n      _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes(''));\n    }\n\n    emit Migrate(_projectId, _to, balance, msg.sender);\n  }\n\n  /\n    @notice\n    Receives funds belonging to the specified project.\n\n    @param _projectId The ID of the project to which the funds received belong.\n    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.\n    @param _token The token being paid. This terminal ignores this property since it only manages one currency. \n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Extra data to pass along to the emitted event.\n  /\n  function addToBalanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    address _token,\n    string calldata _memo,\n    bytes calldata _metadata\n  ) external payable virtual override isTerminalOf(_projectId) {\n    _token; // Prevents unused var compiler and natspec complaints.\n\n    // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender.\n    if (token != JBTokens.ETH) {\n      // Amount must be greater than 0.\n      if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();\n\n      // Transfer tokens to this terminal from the msg sender.\n      _transferFrom(msg.sender, payable(address(this)), _amount);\n    }\n    // If the terminal's token is ETH, override _amount with msg.value.\n    else _amount = msg.value;\n\n    // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal.\n    _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);\n  }\n\n  /\n    @notice\n    Process any fees that are being held for the project.\n\n    @dev\n    Only a project owner, an operator, or the contract's owner can process held fees.\n\n    @param _projectId The ID of the project whos held fees should be processed.\n  /\n  function processFees(uint256 _projectId)\n    external\n    virtual\n    override\n    requirePermissionAllowingOverride(\n      projects.ownerOf(_projectId),\n      _projectId,\n      JBOperations.PROCESS_FEES,\n      msg.sender == owner()\n    )\n  {\n    // Get a reference to the project's held fees.\n    JBFee[] memory _heldFees = _heldFeesOf[_projectId];\n\n    // Delete the held fees.\n    delete _heldFeesOf[_projectId];\n\n    // Push array length in stack\n    uint256 _heldFeeLength = _heldFees.length;\n\n    // Process each fee.\n    for (uint256 _i = 0; _i &lt; _heldFeeLength; ) {\n      // Get the fee amount.\n      uint256 _amount = _feeAmount(\n        _heldFees[_i].amount,\n        _heldFees[_i].fee,\n        _heldFees[_i].feeDiscount\n      );\n\n      // Process the fee.\n      _processFee(_amount, _heldFees[_i].beneficiary);\n\n      emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /\n    @notice\n    Allows the fee to be updated.\n\n    @dev\n    Only the owner of this contract can change the fee.\n\n    @param _fee The new fee, out of MAX_FEE.\n  */\n  function setFee(uint256 _fee) external virtual override onlyOwner {\n    // The provided fee must be within the max.\n    if (_fee &gt; _FEE_CAP) revert FEE_TOO_HIGH();\n\n    // Store the new fee.\n    fee = _fee;\n\n    emit SetFee(_fee, msg.sender);\n  }\n\n  /\n    @notice\n    Allows the fee gauge to be updated.\n\n    @dev\n    Only the owner of this contract can change the fee gauge.\n\n    @dev\n    If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.\n\n    @param _feeGauge The new fee gauge.\n  /\n  function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {\n    // Store the new fee gauge.\n    feeGauge = _feeGauge;\n\n    emit SetFeeGauge(_feeGauge, msg.sender);\n  }\n\n  /\n    @notice\n    Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.\n\n    @dev\n    Only the owner of this contract can set addresses as feeless.\n\n    @param _address The address that can be paid towards while still bypassing fees.\n    @param _flag A flag indicating whether the terminal should be feeless or not.\n  /\n  function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {\n    // Set the flag value.\n    isFeelessAddress[_address] = _flag;\n\n    emit SetFeelessAddress(_address, _flag, msg.sender);\n  }\n\n  //*********//\n  // ---------------------- internal transactions ---------------------- //\n  //*********//\n\n  / \n    @notice\n    Transfers tokens.\n\n    @param _from The address from which the transfer should originate.\n    @param _to The address to which the transfer should go.\n    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.\n  /\n  function _transferFrom(\n    address _from,\n    address payable _to,\n    uint256 _amount\n  ) internal virtual;\n\n  / \n    @notice\n    Logic to be triggered before transferring tokens from this terminal.\n\n    @param _to The address to which the transfer is going.\n    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.\n  /\n  function _beforeTransferTo(address _to, uint256 _amount) internal virtual;\n\n  /\n    @notice\n    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.\n\n    @dev\n    Only a token holder or a designated operator can redeem its tokens.\n\n    @param _holder The account to redeem tokens for.\n    @param _projectId The ID of the project to which the tokens being redeemed belong.\n    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.\n    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.\n    @param _beneficiary The address to send the terminal tokens to.\n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.\n\n    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.\n  /\n  function _redeemTokensOf(\n    address _holder,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    uint256 _minReturnedTokens,\n    address payable _beneficiary,\n    string memory _memo,\n    bytes memory _metadata\n  ) internal returns (uint256 reclaimAmount) {\n    // Can't send reclaimed funds to the zero address.\n    if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS();\n\n    // Define variables that will be needed outside the scoped section below.\n    // Keep a reference to the funding cycle during which the redemption is being made.\n    JBFundingCycle memory _fundingCycle;\n\n    // Scoped section prevents stack too deep. _delegate only used within scope.\n    {\n      IJBRedemptionDelegate _delegate;\n\n      // Record the redemption.\n      (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(\n        _holder,\n        _projectId,\n        _tokenCount,\n        _memo,\n        _metadata\n      );\n\n      // The amount being reclaimed must be at least as much as was expected.\n      if (reclaimAmount &lt; _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();\n\n      // Burn the project tokens.\n      if (_tokenCount &gt; 0)\n        IJBController(directory.controllerOf(_projectId)).burnTokensOf(\n          _holder,\n          _projectId,\n          _tokenCount,\n          '',\n          false\n        );\n\n      // If a delegate was returned by the data source, issue a callback to it.\n      if (_delegate != IJBRedemptionDelegate(address(0))) {\n        JBDidRedeemData memory _data = JBDidRedeemData(\n          _holder,\n          _projectId,\n          _fundingCycle.configuration,\n          _tokenCount,\n          JBTokenAmount(token, reclaimAmount, decimals, currency),\n          _beneficiary,\n          _memo,\n          _metadata\n        );\n        _delegate.didRedeem(_data);\n        emit DelegateDidRedeem(_delegate, _data, msg.sender);\n      }\n    }\n\n    // Send the reclaimed funds to the beneficiary.\n    if (reclaimAmount &gt; 0) _transferFrom(address(this), _beneficiary, reclaimAmount);\n\n    emit RedeemTokens(\n      _fundingCycle.configuration,\n      _fundingCycle.number,\n      _projectId,\n      _holder,\n      _beneficiary,\n      _tokenCount,\n      reclaimAmount,\n      _memo,\n      _metadata,\n      msg.sender\n    );\n  }\n\n  /\n    @notice\n    Distributes payouts for a project with the distribution limit of its current funding cycle.\n\n    @dev\n    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.\n\n    @dev\n    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.\n\n    @dev\n    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.\n\n    @param _projectId The ID of the project having its payouts distributed.\n    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.\n    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.\n    @param _minReturnedTokens The minimum number of terminal tokens that the _amount should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.\n  */\n  function _distributePayoutsOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency,\n    uint256 _minReturnedTokens,\n    string calldata _memo\n  ) internal returns (uint256 netLeftoverDistributionAmount) {\n    // Record the distribution.\n    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(\n      _projectId,\n      _amount,\n      _currency\n    );\n\n    // The amount being distributed must be at least as much as was expected.\n    if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();\n\n    // Get a reference to the project owner, which will receive tokens from paying the platform fee\n    // and receive any extra distributable funds not allocated to payout splits.\n    address payable _projectOwner = payable(projects.ownerOf(_projectId));\n\n    // Define variables that will be needed outside the scoped section below.\n    // Keep a reference to the fee amount that was paid.\n    uint256 _fee;\n\n    // Scoped section prevents stack too deep. _feeDiscount, _feeEligibleDistributionAmount, and _leftoverDistributionAmount only used within scope.\n    {\n      // Get the amount of discount that should be applied to any fees taken.\n      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.\n      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]\n        ? JBConstants.MAX_FEE_DISCOUNT\n        : _currentFeeDiscount(_projectId);\n\n      // The amount distributed that is eligible for incurring fees.\n      uint256 _feeEligibleDistributionAmount;\n\n      // The amount leftover after distributing to the splits.\n      uint256 _leftoverDistributionAmount;\n\n      // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.\n      // Also get a reference to the amount that was distributed to splits from which fees should be taken.\n      (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(\n        _projectId,\n        _fundingCycle.configuration,\n        payoutSplitsGroup,\n        _distributedAmount,\n        _feeDiscount\n      );\n\n      // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.\n      unchecked {\n        _feeEligibleDistributionAmount += _leftoverDistributionAmount;\n      }\n\n      // Take the fee.\n      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0\n        ? 0\n        : _takeFeeFrom(\n          _projectId,\n          _fundingCycle,\n          _feeEligibleDistributionAmount,\n          _projectOwner,\n          _feeDiscount\n        );\n\n      // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.\n\n      unchecked {\n        netLeftoverDistributionAmount = _leftoverDistributionAmount == 0\n          ? 0\n          : _leftoverDistributionAmount -\n            _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);\n      }\n\n      // Transfer any remaining balance to the project owner.\n      if (netLeftoverDistributionAmount &gt; 0)\n        _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount);\n    }\n\n    emit DistributePayouts(\n      _fundingCycle.configuration,\n      _fundingCycle.number,\n      _projectId,\n      _projectOwner,\n      _amount,\n      _distributedAmount,\n      _fee,\n      netLeftoverDistributionAmount,\n      _memo,\n      msg.sender\n    );\n  }\n\n  /\n    @notice\n    Allows a project to send funds from its overflow up to the preconfigured allowance.\n\n    @dev\n    Only a project's owner or a designated operator can use its allowance.\n\n    @dev\n    Incurs the protocol fee.\n\n    @param _projectId The ID of the project to use the allowance of.\n    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.\n    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.\n    @param _minReturnedTokens The minimum number of tokens that the _amount should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.\n    @param _beneficiary The address to send the funds to.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.\n  /\n  function _useAllowanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency,\n    uint256 _minReturnedTokens,\n    address payable _beneficiary,\n    string memory _memo\n  ) internal returns (uint256 netDistributedAmount) {\n    // Record the use of the allowance.\n    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(\n      _projectId,\n      _amount,\n      _currency\n    );\n\n    // The amount being withdrawn must be at least as much as was expected.\n    if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();\n\n    // Scoped section prevents stack too deep. _fee, _projectOwner, _feeDiscount, and _netAmount only used within scope.\n    {\n      // Keep a reference to the fee amount that was paid.\n      uint256 _fee;\n\n      // Get a reference to the project owner, which will receive tokens from paying the platform fee.\n      address _projectOwner = projects.ownerOf(_projectId);\n\n      // Get the amount of discount that should be applied to any fees taken.\n      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.\n      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]\n        ? JBConstants.MAX_FEE_DISCOUNT\n        : _currentFeeDiscount(_projectId);\n\n      // Take a fee from the _distributedAmount, if needed.\n      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT\n        ? 0\n        : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);\n\n      unchecked {\n        // The net amount is the withdrawn amount without the fee.\n        netDistributedAmount = _distributedAmount - _fee;\n      }\n\n      // Transfer any remaining balance to the beneficiary.\n      if (netDistributedAmount &gt; 0)\n        _transferFrom(address(this), _beneficiary, netDistributedAmount);\n    }\n\n    emit UseAllowance(\n      _fundingCycle.configuration,\n      _fundingCycle.number,\n      _projectId,\n      _beneficiary,\n      _amount,\n      _distributedAmount,\n      netDistributedAmount,\n      _memo,\n      msg.sender\n    );\n  }\n\n  /\n    @notice\n    Pays out splits for a project's funding cycle configuration.\n\n    @param _projectId The ID of the project for which payout splits are being distributed.\n    @param _domain The domain of the splits to distribute the payout between.\n    @param _group The group of the splits to distribute the payout between.\n    @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal.\n    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.\n\n    @return leftoverAmount If the leftover amount if the splits don't add up to 100%.\n    @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.\n  /\n  function _distributeToPayoutSplitsOf(\n    uint256 _projectId,\n    uint256 _domain,\n    uint256 _group,\n    uint256 _amount,\n    uint256 _feeDiscount\n  ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {\n    // Set the leftover amount to the initial amount.\n    leftoverAmount = _amount;\n\n    // Get a reference to the project's payout splits.\n    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);\n\n    // Transfer between all splits.\n    for (uint256 _i = 0; _i &lt; _splits.length; ) {\n      // Get a reference to the split being iterated on.\n      JBSplit memory _split = _splits[_i];\n\n      // The amount to send towards the split.\n      uint256 _payoutAmount = PRBMath.mulDiv(\n        _amount,\n        _split.percent,\n        JBConstants.SPLITS_TOTAL_PERCENT\n      );\n\n      // The payout amount substracting any applicable incurred fees.\n      uint256 _netPayoutAmount;\n\n      if (_payoutAmount &gt; 0) {\n        // Transfer tokens to the split.\n        // If there's an allocator set, transfer to its allocate function.\n        if (_split.allocator != IJBSplitAllocator(address(0))) {\n          // If the split allocator is set as feeless, this distribution is not eligible for a fee.\n          if (isFeelessAddress[address(_split.allocator)])\n            _netPayoutAmount = _payoutAmount;\n            // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.\n          else {\n            unchecked {\n              _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT\n                ? _payoutAmount\n                : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);\n            }\n\n            // This distribution is eligible for a fee since the funds are leaving the ecosystem.\n            feeEligibleDistributionAmount += _payoutAmount;\n          }\n\n          // Trigger any inherited pre-transfer logic.\n          _beforeTransferTo(address(_split.allocator), _netPayoutAmount);\n\n          // If this terminal's token is ETH, send it in msg.value.\n          uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;\n\n          // Create the data to send to the allocator.\n          JBSplitAllocationData memory _data = JBSplitAllocationData(\n            token,\n            _netPayoutAmount,\n            decimals,\n            _projectId,\n            _group,\n            _split\n          );\n\n          // Trigger the allocator's allocate function.\n          _split.allocator.allocate{value: _payableValue}(_data);\n\n          // Otherwise, if a project is specified, make a payment to it.\n        } else if (_split.projectId != 0) {\n          // Get a reference to the Juicebox terminal being used.\n          IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);\n\n          // The project must have a terminal to send funds to.\n          if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();\n\n          // Save gas if this contract is being used as the terminal.\n          if (_terminal == this) {\n            // This distribution does not incur a fee.\n            _netPayoutAmount = _payoutAmount;\n\n            // Send the projectId in the metadata.\n            bytes memory _projectMetadata = new bytes(32);\n            _projectMetadata = bytes(abi.encodePacked(_projectId));\n\n            // Add to balance if prefered.\n            if (_split.preferAddToBalance)\n              _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);\n            else\n              _pay(\n                _netPayoutAmount,\n                address(this),\n                _split.projectId,\n                (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,\n                0,\n                _split.preferClaimed,\n                '',\n                _projectMetadata\n              );\n          } else {\n            // If the terminal is set as feeless, this distribution is not eligible for a fee.\n            if (isFeelessAddress[address(_terminal)])\n              _netPayoutAmount = _payoutAmount;\n              // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.\n            else {\n              unchecked {\n                _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT\n                  ? _payoutAmount\n                  : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);\n              }\n\n              feeEligibleDistributionAmount += _payoutAmount;\n            }\n\n            // Trigger any inherited pre-transfer logic.\n            _beforeTransferTo(address(_terminal), _netPayoutAmount);\n\n            // If this terminal's token is ETH, send it in msg.value.\n            uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;\n\n            // Send the projectId in the metadata.\n            bytes memory _projectMetadata = new bytes(32);\n            _projectMetadata = bytes(abi.encodePacked(_projectId));\n\n            // Add to balance if prefered.\n            if (_split.preferAddToBalance)\n              _terminal.addToBalanceOf{value: _payableValue}(\n                _split.projectId,\n                _netPayoutAmount,\n                token,\n                '',\n                _projectMetadata\n              );\n            else\n              _terminal.pay{value: _payableValue}(\n                _split.projectId,\n                _netPayoutAmount,\n                token,\n                _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,\n                0,\n                _split.preferClaimed,\n                '',\n                _projectMetadata\n              );\n          }\n        } else {\n          unchecked {\n            _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT\n              ? _payoutAmount\n              : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);\n          }\n\n          // This distribution is eligible for a fee since the funds are leaving the ecosystem.\n          feeEligibleDistributionAmount += _payoutAmount;\n\n          // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.\n          _transferFrom(\n            address(this),\n            _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),\n            _netPayoutAmount\n          );\n        }\n\n        // Subtract from the amount to be sent to the beneficiary.\n        unchecked {\n          leftoverAmount = leftoverAmount - _payoutAmount;\n        }\n      }\n\n      emit DistributeToPayoutSplit(\n        _projectId,\n        _domain,\n        _group,\n        _split,\n        _netPayoutAmount,\n        msg.sender\n      );\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /\n    @notice\n    Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID.\n\n    @param _projectId The ID of the project having fees taken from.\n    @param _fundingCycle The funding cycle during which the fee is being taken.\n    @param _amount The amount of the fee to take, as a floating point number with 18 decimals.\n    @param _beneficiary The address to mint the platforms tokens for.\n    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.\n\n    @return feeAmount The amount of the fee taken.\n  */\n  function _takeFeeFrom(\n    uint256 _projectId,\n    JBFundingCycle memory _fundingCycle,\n    uint256 _amount,\n    address _beneficiary,\n    uint256 _feeDiscount\n  ) internal returns (uint256 feeAmount) {\n    feeAmount = _feeAmount(_amount, fee, _feeDiscount);\n\n    if (_fundingCycle.shouldHoldFees()) {\n      // Store the held fee.\n      _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));\n\n      emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender);\n    } else {\n      // Process the fee.\n      _processFee(feeAmount, _beneficiary); // Take the fee.\n\n      emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender);\n    }\n  }\n\n  /\n    @notice\n    Process a fee of the specified amount.\n\n    @param _amount The fee amount, as a floating point number with 18 decimals.\n    @param _beneficiary The address to mint the platform's tokens for.\n  /\n  function _processFee(uint256 _amount, address _beneficiary) internal {\n    // Get the terminal for the protocol project.\n    IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token);\n\n    // When processing the admin fee, save gas if the admin is using this contract as its terminal.\n    if (_terminal == this)\n      _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call.\n    else {\n      // Trigger any inherited pre-transfer logic.\n      _beforeTransferTo(address(_terminal), _amount);\n\n      // If this terminal's token is ETH, send it in msg.value.\n      uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;\n\n      // Send the payment.\n      _terminal.pay{value: _payableValue}(\n        _PROTOCOL_PROJECT_ID,\n        _amount,\n        token,\n        _beneficiary,\n        0,\n        false,\n        '',\n        bytes('')\n      ); // Use the external pay call of the correct terminal.\n    }\n  }\n\n  /\n    @notice\n    Contribute tokens to a project.\n\n    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.\n    @param _payer The address making the payment.\n    @param _projectId The ID of the project being paid.\n    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.\n    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.\n    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.\n    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.\n    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.\n\n    @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.\n  /\n  function _pay(\n    uint256 _amount,\n    address _payer,\n    uint256 _projectId,\n    address _beneficiary,\n    uint256 _minReturnedTokens,\n    bool _preferClaimedTokens,\n    string memory _memo,\n    bytes memory _metadata\n  ) internal returns (uint256 beneficiaryTokenCount) {\n    // Cant send tokens to the zero address.\n    if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS();\n\n    // Define variables that will be needed outside the scoped section below.\n    // Keep a reference to the funding cycle during which the payment is being made.\n    JBFundingCycle memory _fundingCycle;\n\n    // Scoped section prevents stack too deep. _delegate and _tokenCount only used within scope.\n    {\n      IJBPayDelegate _delegate;\n      uint256 _tokenCount;\n\n      // Bundle the amount info into a JBTokenAmount struct.\n      JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);\n\n      // Record the payment.\n      (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(\n        _payer,\n        _bundledAmount,\n        _projectId,\n        baseWeightCurrency,\n        _beneficiary,\n        _memo,\n        _metadata\n      );\n\n      // Mint the tokens if needed.\n      if (_tokenCount &gt; 0)\n        // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.\n        beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(\n          _projectId,\n          _tokenCount,\n          _beneficiary,\n          '',\n          _preferClaimedTokens,\n          true\n        );\n\n      // The token count for the beneficiary must be greater than or equal to the minimum expected.\n      if (beneficiaryTokenCount &lt; _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();\n\n      // If a delegate was returned by the data source, issue a callback to it.\n      if (_delegate != IJBPayDelegate(address(0))) {\n        JBDidPayData memory _data = JBDidPayData(\n          _payer,\n          _projectId,\n          _fundingCycle.configuration,\n          _bundledAmount,\n          beneficiaryTokenCount,\n          _beneficiary,\n          _preferClaimedTokens,\n          _memo,\n          _metadata\n        );\n\n        _delegate.didPay(_data);\n        emit DelegateDidPay(_delegate, _data, msg.sender);\n      }\n    }\n\n    emit Pay(\n      _fundingCycle.configuration,\n      _fundingCycle.number,\n      _projectId,\n      _payer,\n      _beneficiary,\n      _amount,\n      beneficiaryTokenCount,\n      _memo,\n      _metadata,\n      msg.sender\n    );\n  }\n\n  /\n    @notice\n    Receives funds belonging to the specified project.\n\n    @param _projectId The ID of the project to which the funds received belong.\n    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.\n    @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added.\n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Extra data to pass along to the emitted event.\n  */\n  function _addToBalanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    bool _shouldRefundHeldFees,\n    string memory _memo,\n    bytes memory _metadata\n  ) internal {\n    // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.\n    uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0;\n\n    // Record the added funds with any refunded fees.\n    store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);\n\n    emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);\n  }\n\n  /\n    @notice\n    Refund fees based on the specified amount.\n\n    @param _projectId The project for which fees are being refunded.\n    @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.\n\n    @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal\n  /\n  function _refundHeldFees(uint256 _projectId, uint256 _amount)\n    internal\n    returns (uint256 refundedFees)\n  {\n    // Get a reference to the project's held fees.\n    JBFee[] memory _heldFees = _heldFeesOf[_projectId];\n\n    // Delete the current held fees.\n    delete _heldFeesOf[_projectId];\n\n    // Get a reference to the leftover amount once all fees have been settled.\n    uint256 leftoverAmount = _amount;\n\n    // Push length in stack\n    uint256 _heldFeesLength = _heldFees.length;\n\n    // Process each fee.\n    for (uint256 _i = 0; _i &lt; _heldFeesLength; ) {\n      if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);\n      else if (leftoverAmount &gt;= _heldFees[_i].amount) {\n        unchecked {\n          leftoverAmount = leftoverAmount - _heldFees[_i].amount;\n          refundedFees += _feeAmount(\n            _heldFees[_i].amount,\n            _heldFees[_i].fee,\n            _heldFees[_i].feeDiscount\n          );\n        }\n      } else {\n        _heldFeesOf[_projectId].push(\n          JBFee(\n            _heldFees[_i].amount - leftoverAmount,\n            _heldFees[_i].fee,\n            _heldFees[_i].feeDiscount,\n            _heldFees[_i].beneficiary\n          )\n        );\n        unchecked {\n          refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);\n        }\n        leftoverAmount = 0;\n      }\n\n      unchecked {\n        ++_i;\n      }\n    }\n\n    emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);\n  }\n\n  / \n    @notice \n    Returns the fee amount based on the provided amount for the specified project.\n\n    @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal.\n    @param _fee The percentage of the fee, out of MAX_FEE. \n    @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.\n\n    @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.\n  /\n  function _feeAmount(\n    uint256 _amount,\n    uint256 _fee,\n    uint256 _feeDiscount\n  ) internal pure returns (uint256) {\n    // Calculate the discounted fee.\n    uint256 _discountedFee = _fee -\n      PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT);\n\n    // The amount of tokens from the _amount to pay as a fee.\n    return\n      _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);\n  }\n\n  /* \n    @notice\n    Get the fee discount from the fee gauge for the specified project.\n\n    @param _projectId The ID of the project to get a fee discount for.\n    \n    @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.\n  /\n  function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {\n    // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.\n    if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))\n      return JBConstants.MAX_FEE_DISCOUNT;\n\n    // Get the fee discount.\n    if (feeGauge == IJBFeeGauge(address(0)))\n      feeDiscount = 0;\n      // If the guage reverts, set the discount to 0.\n    else\n      try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {\n        feeDiscount = discount;\n      } catch {\n        feeDiscount = 0;\n      }\n\n    // If the fee discount is greater than the max, nullify the discount.\n    if (feeDiscount &gt; JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;\n  }\n}\n", 'ideas': ' Security', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-01-09 17:18:24 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/security/ReentrancyGuard.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './../interfaces/IJBController.sol'; import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol'; import './../libraries/JBConstants.sol'; import './../libraries/JBCurrencies.sol'; import './../libraries/JBFixedPointNumber.sol'; import './../libraries/JBFundingCycleMetadataResolver.sol'; import './../libraries/JBOperations.sol'; import './../libraries/JBSplitsGroups.sol'; import './../libraries/JBTokens.sol'; import './../structs/JBTokenAmount.sol'; import './JBOperatable.sol'; import './JBSingleTokenPaymentTerminal.sol'; /**   @notice   Generic terminal managing all inflows and outflows of funds into the protocol ecosystem. @dev   A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time. @dev   Adheres to -   IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules. @dev   Inherits from -   JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.   JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.   Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.   ReentrancyGuard: Contract module that helps prevent reentrant calls to a function. */ abstract contract JBPayoutRedemptionPaymentTerminal is   IJBPayoutRedemptionPaymentTerminal,   JBSingleTokenPaymentTerminal,   JBOperatable,   Ownable,   ReentrancyGuard {   // A library that parses the packed funding cycle metadata into a friendlier format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error FEE_TOO_HIGH();   error INADEQUATE_DISTRIBUTION_AMOUNT();   error INADEQUATE_RECLAIM_AMOUNT();   error INADEQUATE_TOKEN_COUNT();   error NO_MSG_VALUE_ALLOWED();   error PAY_TO_ZERO_ADDRESS();   error PROJECT_TERMINAL_MISMATCH();   error REDEEM_TO_ZERO_ADDRESS();   error TERMINAL_IN_SPLIT_ZERO_ADDRESS();   error TERMINAL_TOKENS_INCOMPATIBLE(); //***********//   // ---------------------------- modifiers ---------------------------- //   //*************// /*      @notice      A modifier that verifies this terminal is a terminal of provided project ID.   /   modifier isTerminalOf(uint256 projectId) {     if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();     ;   } //***********//   // --------------------- internal stored constants ------------------- //   //*************// /**     @notice     Maximum fee that can be set for a funding cycle configuration. @dev Out of MAX_FEE (50_000_000 / 1_000_000_000).  */   uint256 internal constant _FEE_CAP = 50_000_000; /*     @notice     The protocol project ID is 1, as it should be the first project launched during the deployment process.   /   uint256 internal constant _PROTOCOL_PROJECT_ID = 1; //***********//   // --------------------- internal stored properties ------------------ //   //*************// /**     @notice     Fees that are being held to be processed later. _projectId The ID of the project for which fees are being held.  */   mapping(uint256 =&gt; JBFee[]) internal _heldFeesOf; //***********//   // ---------------- public immutable stored properties --------------- //   //*************// /*     @notice     Mints ERC-721's that represent project ownership and transfers.   /   IJBProjects public immutable override projects; /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; /*     @notice     The contract that stores splits for each project.   /   IJBSplitsStore public immutable override splitsStore; /*     @notice     The contract that exposes price feeds.   /   IJBPrices public immutable override prices; /*     @notice     The contract that stores and manages the terminal's data.   /   IJBSingleTokenPaymentTerminalStore public immutable override store; /**     @notice     The currency to base token issuance on. @dev If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.  */   uint256 public immutable override baseWeightCurrency; /*     @notice     The group that payout splits coming from this terminal are identified by.   /   uint256 public immutable override payoutSplitsGroup; //***********//   // --------------------- public stored properties -------------------- //   //*************// /**     @notice     The platform fee percent. @dev Out of MAX_FEE (25_000_000 / 1_000_000_000)  */   uint256 public override fee = 25_000_000; // 2.5% /*     @notice     The data source that returns a discount to apply to a project's fee.   /   IJBFeeGauge public override feeGauge; /**     @notice     Addresses that can be paid towards from this terminal without incurring a fee. _address The address that can be paid toward.  */   mapping(address =&gt; bool) public override isFeelessAddress; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     Gets the current overflowed amount in this terminal for a specified project, in terms of ETH. @dev The current overflow is represented as a fixed point number with 18 decimals.  @param _projectId The ID of the project to get overflow for.  @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.  */   function currentEthOverflowOf(uint256 _projectId)     external     view     virtual     override     returns (uint256)   {     // Get this terminal's current overflow.     uint256 _overflow = store.currentOverflowOf(this, _projectId); // Adjust the decimals of the fixed point number if needed to have 18 decimals. uint256 _adjustedOverflow = (decimals == 18)   ? _overflow   : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);  // Return the amount converted to ETH. return   (currency == JBCurrencies.ETH)     ? _adjustedOverflow     : PRBMath.mulDiv(       _adjustedOverflow,       10**decimals,       prices.priceFor(currency, JBCurrencies.ETH, decimals)     );  } /**     @notice     The fees that are currently being held to be processed later for each project. @param _projectId The ID of the project for which fees are being held.  @return An array of fees that are being held.  */   function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {     return _heldFeesOf[_projectId];   } //***********//   // -------------------------- public views --------------------------- //   //*************// /**     @notice     Indicates if this contract adheres to the specified interface. @dev  See {IERC165-supportsInterface}.  @param _interfaceId The ID of the interface to check for adherance to.  */   function supportsInterface(bytes4 _interfaceId)     public     view     virtual     override(JBSingleTokenPaymentTerminal, IERC165)     returns (bool)   {     return       _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||       _interfaceId == type(IJBPayoutTerminal).interfaceId ||       _interfaceId == type(IJBAllowanceTerminal).interfaceId ||       _interfaceId == type(IJBRedemptionTerminal).interfaceId ||       _interfaceId == type(IJBOperatable).interfaceId ||       super.supportsInterface(_interfaceId);   } //***********//   // -------------------------- constructor ---------------------------- //   //*************// /*     @param _token The token that this terminal manages.     @param _decimals The number of decimals the token fixed point amounts are expected to have.     @param _currency The currency that this terminal's token adheres to for price feeds.     @param _baseWeightCurrency The currency to base token issuance on.     @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.     @param _operatorStore A contract storing operator assignments.     @param _projects A contract which mints ERC-721's that represent project ownership and transfers.     @param _directory A contract storing directories of terminals and controllers for each project.     @param _splitsStore A contract that stores splits for each project.     @param _prices A contract that exposes price feeds.     @param _store A contract that stores the terminal's data.     @param _owner The address that will own this contract.   /   constructor(     // payable constructor save the gas used to check msg.value==0     address _token,     uint256 _decimals,     uint256 _currency,     uint256 _baseWeightCurrency,     uint256 _payoutSplitsGroup,     IJBOperatorStore _operatorStore,     IJBProjects _projects,     IJBDirectory _directory,     IJBSplitsStore _splitsStore,     IJBPrices _prices,     IJBSingleTokenPaymentTerminalStore _store,     address _owner   )     payable     JBSingleTokenPaymentTerminal(_token, _decimals, _currency)     JBOperatable(_operatorStore)   {     baseWeightCurrency = _baseWeightCurrency;     payoutSplitsGroup = _payoutSplitsGroup;     projects = _projects;     directory = _directory;     splitsStore = _splitsStore;     prices = _prices;     store = _store; transferOwnership(_owner);  } //***********//   // ---------------------- external transactions ---------------------- //   //*************// /**     @notice     Contribute tokens to a project. @param _projectId The ID of the project being paid. @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place. @param _token The token being paid. This terminal ignores this property since it only manages one token.  @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate. @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal. @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas. @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.  */   function pay(     uint256 _projectId,     uint256 _amount,     address _token,     address _beneficiary,     uint256 _minReturnedTokens,     bool _preferClaimedTokens,     string calldata _memo,     bytes calldata _metadata   ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {     _token; // Prevents unused var compiler and natspec complaints. // ETH shouldn't be sent if this terminal's token isn't ETH. if (token != JBTokens.ETH) {   if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();    // Transfer tokens to this terminal from the msg sender.   _transferFrom(msg.sender, payable(address(this)), _amount); } // If this terminal's token is ETH, override _amount with msg.value. else _amount = msg.value;  return   _pay(     _amount,     msg.sender,     _projectId,     _beneficiary,     _minReturnedTokens,     _preferClaimedTokens,     _memo,     _metadata   );  } /**     @notice     Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source. @dev Only a token holder or a designated operator can redeem its tokens.  @param _holder The account to redeem tokens for. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _token The token being reclaimed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal. @param _beneficiary The address to send the terminal tokens to. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.  */   function redeemTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     address _token,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo,     bytes memory _metadata   )     external     virtual     override     requirePermission(_holder, _projectId, JBOperations.REDEEM)     returns (uint256 reclaimAmount)   {     _token; // Prevents unused var compiler and natspec complaints. return   _redeemTokensOf(     _holder,     _projectId,     _tokenCount,     _minReturnedTokens,     _beneficiary,     _memo,     _metadata   );  } /**     @notice     Distributes payouts for a project with the distribution limit of its current funding cycle. @dev Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.  @dev Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.  @dev All funds distributed outside of this contract or any feeless terminals incure the protocol fee.  @param _projectId The ID of the project having its payouts distributed. @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency. @param _token The token being distributed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal. @param _memo A memo to pass along to the emitted event.  @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.  */   function distributePayoutsOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     address _token,     uint256 _minReturnedTokens,     string calldata _memo   ) external virtual override returns (uint256 netLeftoverDistributionAmount) {     _token; // Prevents unused var compiler and natspec complaints. return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);  } /**     @notice     Allows a project to send funds from its overflow up to the preconfigured allowance. @dev Only a project's owner or a designated operator can use its allowance.  @dev Incurs the protocol fee.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency. @param _token The token being distributed. This terminal ignores this property since it only manages one token.  @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals. @param _beneficiary The address to send the funds to. @param _memo A memo to pass along to the emitted event.  @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.  */   function useAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     address _token,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)     returns (uint256 netDistributedAmount)   {     _token; // Prevents unused var compiler and natspec complaints. return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);  } /**     @notice     Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type. @dev Only a project's owner or a designated operator can migrate it.  @param _projectId The ID of the project being migrated. @param _to The terminal contract that will gain the project's funds.  @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.  */   function migrate(uint256 _projectId, IJBPaymentTerminal _to)     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)     returns (uint256 balance)   {     // The terminal being migrated to must accept the same token as this terminal.     if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE(); // Record the migration in the store. balance = store.recordMigration(_projectId);  // Transfer the balance if needed. if (balance &gt; 0) {   // Trigger any inherited pre-transfer logic.   _beforeTransferTo(address(_to), balance);    // If this terminal's token is ETH, send it in msg.value.   uint256 _payableValue = token == JBTokens.ETH ? balance : 0;    // Withdraw the balance to transfer to the new terminal;   _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes('')); }  emit Migrate(_projectId, _to, balance, msg.sender);  } /**     @notice     Receives funds belonging to the specified project. @param _projectId The ID of the project to which the funds received belong. @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead. @param _token The token being paid. This terminal ignores this property since it only manages one currency.  @param _memo A memo to pass along to the emitted event. @param _metadata Extra data to pass along to the emitted event.  */   function addToBalanceOf(     uint256 _projectId,     uint256 _amount,     address _token,     string calldata _memo,     bytes calldata _metadata   ) external payable virtual override isTerminalOf(_projectId) {     _token; // Prevents unused var compiler and natspec complaints. // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender. if (token != JBTokens.ETH) {   // Amount must be greater than 0.   if (msg.value &gt; 0) revert NO_MSG_VALUE_ALLOWED();    // Transfer tokens to this terminal from the msg sender.   _transferFrom(msg.sender, payable(address(this)), _amount); } // If the terminal's token is ETH, override `_amount` with msg.value. else _amount = msg.value;  // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal. _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);  } /**     @notice     Process any fees that are being held for the project. @dev Only a project owner, an operator, or the contract's owner can process held fees.  @param _projectId The ID of the project whos held fees should be processed.  */   function processFees(uint256 _projectId)     external     virtual     override     requirePermissionAllowingOverride(       projects.ownerOf(_projectId),       _projectId,       JBOperations.PROCESS_FEES,       msg.sender == owner()     )   {     // Get a reference to the project's held fees.     JBFee[] memory _heldFees = _heldFeesOf[_projectId]; // Delete the held fees. delete _heldFeesOf[_projectId];  // Push array length in stack uint256 _heldFeeLength = _heldFees.length;  // Process each fee. for (uint256 _i = 0; _i &lt; _heldFeeLength; ) {   // Get the fee amount.   uint256 _amount = _feeAmount(     _heldFees[_i].amount,     _heldFees[_i].fee,     _heldFees[_i].feeDiscount   );    // Process the fee.   _processFee(_amount, _heldFees[_i].beneficiary);    emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);    unchecked {     ++_i;   } }  } /**     @notice     Allows the fee to be updated. @dev Only the owner of this contract can change the fee.  @param _fee The new fee, out of MAX_FEE.  */   function setFee(uint256 _fee) external virtual override onlyOwner {     // The provided fee must be within the max.     if (_fee &gt; _FEE_CAP) revert FEE_TOO_HIGH(); // Store the new fee. fee = _fee;  emit SetFee(_fee, msg.sender);  } /**     @notice     Allows the fee gauge to be updated. @dev Only the owner of this contract can change the fee gauge.  @dev If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.  @param _feeGauge The new fee gauge.  */   function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {     // Store the new fee gauge.     feeGauge = _feeGauge; emit SetFeeGauge(_feeGauge, msg.sender);  } /**     @notice     Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee. @dev Only the owner of this contract can set addresses as feeless.  @param _address The address that can be paid towards while still bypassing fees. @param _flag A flag indicating whether the terminal should be feeless or not.  */   function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {     // Set the flag value.     isFeelessAddress[_address] = _flag; emit SetFeelessAddress(_address, _flag, msg.sender);  } //***********//   // ---------------------- internal transactions ---------------------- //   //*************// /**      @notice     Transfers tokens. @param _from The address from which the transfer should originate. @param _to The address to which the transfer should go. @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.  */   function _transferFrom(     address _from,     address payable _to,     uint256 _amount   ) internal virtual; /**      @notice     Logic to be triggered before transferring tokens from this terminal. @param _to The address to which the transfer is going. @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.  */   function _beforeTransferTo(address _to, uint256 _amount) internal virtual; /**     @notice     Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source. @dev Only a token holder or a designated operator can redeem its tokens.  @param _holder The account to redeem tokens for. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal. @param _beneficiary The address to send the terminal tokens to. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.  */   function _redeemTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo,     bytes memory _metadata   ) internal returns (uint256 reclaimAmount) {     // Can't send reclaimed funds to the zero address.     if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS(); // Define variables that will be needed outside the scoped section below. // Keep a reference to the funding cycle during which the redemption is being made. JBFundingCycle memory _fundingCycle;  // Scoped section prevents stack too deep. `_delegate` only used within scope. {   IJBRedemptionDelegate _delegate;    // Record the redemption.   (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(     _holder,     _projectId,     _tokenCount,     _memo,     _metadata   );    // The amount being reclaimed must be at least as much as was expected.   if (reclaimAmount &lt; _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();    // Burn the project tokens.   if (_tokenCount &gt; 0)     IJBController(directory.controllerOf(_projectId)).burnTokensOf(       _holder,       _projectId,       _tokenCount,       '',       false     );    // If a delegate was returned by the data source, issue a callback to it.   if (_delegate != IJBRedemptionDelegate(address(0))) {     JBDidRedeemData memory _data = JBDidRedeemData(       _holder,       _projectId,       _fundingCycle.configuration,       _tokenCount,       JBTokenAmount(token, reclaimAmount, decimals, currency),       _beneficiary,       _memo,       _metadata     );     _delegate.didRedeem(_data);     emit DelegateDidRedeem(_delegate, _data, msg.sender);   } }  // Send the reclaimed funds to the beneficiary. if (reclaimAmount &gt; 0) _transferFrom(address(this), _beneficiary, reclaimAmount);  emit RedeemTokens(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _holder,   _beneficiary,   _tokenCount,   reclaimAmount,   _memo,   _metadata,   msg.sender );  } /**     @notice     Distributes payouts for a project with the distribution limit of its current funding cycle. @dev Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.  @dev Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.  @dev All funds distributed outside of this contract or any feeless terminals incure the protocol fee.  @param _projectId The ID of the project having its payouts distributed. @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency. @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal. @param _memo A memo to pass along to the emitted event.  @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.  */   function _distributePayoutsOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     uint256 _minReturnedTokens,     string calldata _memo   ) internal returns (uint256 netLeftoverDistributionAmount) {     // Record the distribution.     (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(       _projectId,       _amount,       _currency     ); // The amount being distributed must be at least as much as was expected. if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();  // Get a reference to the project owner, which will receive tokens from paying the platform fee // and receive any extra distributable funds not allocated to payout splits. address payable _projectOwner = payable(projects.ownerOf(_projectId));  // Define variables that will be needed outside the scoped section below. // Keep a reference to the fee amount that was paid. uint256 _fee;  // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope. {   // Get the amount of discount that should be applied to any fees taken.   // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.   uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]     ? JBConstants.MAX_FEE_DISCOUNT     : _currentFeeDiscount(_projectId);    // The amount distributed that is eligible for incurring fees.   uint256 _feeEligibleDistributionAmount;    // The amount leftover after distributing to the splits.   uint256 _leftoverDistributionAmount;    // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.   // Also get a reference to the amount that was distributed to splits from which fees should be taken.   (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(     _projectId,     _fundingCycle.configuration,     payoutSplitsGroup,     _distributedAmount,     _feeDiscount   );    // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.   unchecked {     _feeEligibleDistributionAmount += _leftoverDistributionAmount;   }    // Take the fee.   _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0     ? 0     : _takeFeeFrom(       _projectId,       _fundingCycle,       _feeEligibleDistributionAmount,       _projectOwner,       _feeDiscount     );    // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.    unchecked {     netLeftoverDistributionAmount = _leftoverDistributionAmount == 0       ? 0       : _leftoverDistributionAmount -         _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);   }    // Transfer any remaining balance to the project owner.   if (netLeftoverDistributionAmount &gt; 0)     _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount); }  emit DistributePayouts(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _projectOwner,   _amount,   _distributedAmount,   _fee,   netLeftoverDistributionAmount,   _memo,   msg.sender );  } /**     @notice     Allows a project to send funds from its overflow up to the preconfigured allowance. @dev Only a project's owner or a designated operator can use its allowance.  @dev Incurs the protocol fee.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal. @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency. @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals. @param _beneficiary The address to send the funds to. @param _memo A memo to pass along to the emitted event.  @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.  */   function _useAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency,     uint256 _minReturnedTokens,     address payable _beneficiary,     string memory _memo   ) internal returns (uint256 netDistributedAmount) {     // Record the use of the allowance.     (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(       _projectId,       _amount,       _currency     ); // The amount being withdrawn must be at least as much as was expected. if (_distributedAmount &lt; _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();  // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope. {   // Keep a reference to the fee amount that was paid.   uint256 _fee;    // Get a reference to the project owner, which will receive tokens from paying the platform fee.   address _projectOwner = projects.ownerOf(_projectId);    // Get the amount of discount that should be applied to any fees taken.   // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.   uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]     ? JBConstants.MAX_FEE_DISCOUNT     : _currentFeeDiscount(_projectId);    // Take a fee from the `_distributedAmount`, if needed.   _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT     ? 0     : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);    unchecked {     // The net amount is the withdrawn amount without the fee.     netDistributedAmount = _distributedAmount - _fee;   }    // Transfer any remaining balance to the beneficiary.   if (netDistributedAmount &gt; 0)     _transferFrom(address(this), _beneficiary, netDistributedAmount); }  emit UseAllowance(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _beneficiary,   _amount,   _distributedAmount,   netDistributedAmount,   _memo,   msg.sender );  } /**     @notice     Pays out splits for a project's funding cycle configuration. @param _projectId The ID of the project for which payout splits are being distributed. @param _domain The domain of the splits to distribute the payout between. @param _group The group of the splits to distribute the payout between. @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal. @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.  @return leftoverAmount If the leftover amount if the splits don't add up to 100%. @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.  */   function _distributeToPayoutSplitsOf(     uint256 _projectId,     uint256 _domain,     uint256 _group,     uint256 _amount,     uint256 _feeDiscount   ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {     // Set the leftover amount to the initial amount.     leftoverAmount = _amount; // Get a reference to the project's payout splits. JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);  // Transfer between all splits. for (uint256 _i = 0; _i &lt; _splits.length; ) {   // Get a reference to the split being iterated on.   JBSplit memory _split = _splits[_i];    // The amount to send towards the split.   uint256 _payoutAmount = PRBMath.mulDiv(     _amount,     _split.percent,     JBConstants.SPLITS_TOTAL_PERCENT   );    // The payout amount substracting any applicable incurred fees.   uint256 _netPayoutAmount;    if (_payoutAmount &gt; 0) {     // Transfer tokens to the split.     // If there's an allocator set, transfer to its `allocate` function.     if (_split.allocator != IJBSplitAllocator(address(0))) {       // If the split allocator is set as feeless, this distribution is not eligible for a fee.       if (isFeelessAddress[address(_split.allocator)])         _netPayoutAmount = _payoutAmount;         // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.       else {         unchecked {           _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT             ? _payoutAmount             : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);         }          // This distribution is eligible for a fee since the funds are leaving the ecosystem.         feeEligibleDistributionAmount += _payoutAmount;       }        // Trigger any inherited pre-transfer logic.       _beforeTransferTo(address(_split.allocator), _netPayoutAmount);        // If this terminal's token is ETH, send it in msg.value.       uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;        // Create the data to send to the allocator.       JBSplitAllocationData memory _data = JBSplitAllocationData(         token,         _netPayoutAmount,         decimals,         _projectId,         _group,         _split       );        // Trigger the allocator's `allocate` function.       _split.allocator.allocate{value: _payableValue}(_data);        // Otherwise, if a project is specified, make a payment to it.     } else if (_split.projectId != 0) {       // Get a reference to the Juicebox terminal being used.       IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);        // The project must have a terminal to send funds to.       if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();        // Save gas if this contract is being used as the terminal.       if (_terminal == this) {         // This distribution does not incur a fee.         _netPayoutAmount = _payoutAmount;          // Send the projectId in the metadata.         bytes memory _projectMetadata = new bytes(32);         _projectMetadata = bytes(abi.encodePacked(_projectId));          // Add to balance if prefered.         if (_split.preferAddToBalance)           _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);         else           _pay(             _netPayoutAmount,             address(this),             _split.projectId,             (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,             0,             _split.preferClaimed,             '',             _projectMetadata           );       } else {         // If the terminal is set as feeless, this distribution is not eligible for a fee.         if (isFeelessAddress[address(_terminal)])           _netPayoutAmount = _payoutAmount;           // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.         else {           unchecked {             _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT               ? _payoutAmount               : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);           }            feeEligibleDistributionAmount += _payoutAmount;         }          // Trigger any inherited pre-transfer logic.         _beforeTransferTo(address(_terminal), _netPayoutAmount);          // If this terminal's token is ETH, send it in msg.value.         uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;          // Send the projectId in the metadata.         bytes memory _projectMetadata = new bytes(32);         _projectMetadata = bytes(abi.encodePacked(_projectId));          // Add to balance if prefered.         if (_split.preferAddToBalance)           _terminal.addToBalanceOf{value: _payableValue}(             _split.projectId,             _netPayoutAmount,             token,             '',             _projectMetadata           );         else           _terminal.pay{value: _payableValue}(             _split.projectId,             _netPayoutAmount,             token,             _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,             0,             _split.preferClaimed,             '',             _projectMetadata           );       }     } else {       unchecked {         _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT           ? _payoutAmount           : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);       }        // This distribution is eligible for a fee since the funds are leaving the ecosystem.       feeEligibleDistributionAmount += _payoutAmount;        // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.       _transferFrom(         address(this),         _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),         _netPayoutAmount       );     }      // Subtract from the amount to be sent to the beneficiary.     unchecked {       leftoverAmount = leftoverAmount - _payoutAmount;     }   }    emit DistributeToPayoutSplit(     _projectId,     _domain,     _group,     _split,     _netPayoutAmount,     msg.sender   );    unchecked {     ++_i;   } }  } /**     @notice     Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID. @param _projectId The ID of the project having fees taken from. @param _fundingCycle The funding cycle during which the fee is being taken. @param _amount The amount of the fee to take, as a floating point number with 18 decimals. @param _beneficiary The address to mint the platforms tokens for. @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.  @return feeAmount The amount of the fee taken.  */   function _takeFeeFrom(     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _amount,     address _beneficiary,     uint256 _feeDiscount   ) internal returns (uint256 feeAmount) {     feeAmount = _feeAmount(_amount, fee, _feeDiscount); if (_fundingCycle.shouldHoldFees()) {   // Store the held fee.   _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));    emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender); } else {   // Process the fee.   _processFee(feeAmount, _beneficiary); // Take the fee.    emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender); }  } /**     @notice     Process a fee of the specified amount. @param _amount The fee amount, as a floating point number with 18 decimals. @param _beneficiary The address to mint the platform's tokens for.  */   function _processFee(uint256 _amount, address _beneficiary) internal {     // Get the terminal for the protocol project.     IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token); // When processing the admin fee, save gas if the admin is using this contract as its terminal. if (_terminal == this)   _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call. else {   // Trigger any inherited pre-transfer logic.   _beforeTransferTo(address(_terminal), _amount);    // If this terminal's token is ETH, send it in msg.value.   uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;    // Send the payment.   _terminal.pay{value: _payableValue}(     _PROTOCOL_PROJECT_ID,     _amount,     token,     _beneficiary,     0,     false,     '',     bytes('')   ); // Use the external pay call of the correct terminal. }  } /**     @notice     Contribute tokens to a project. @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place. @param _payer The address making the payment. @param _projectId The ID of the project being paid. @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate. @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal. @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas. @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate. @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.  @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.  */   function _pay(     uint256 _amount,     address _payer,     uint256 _projectId,     address _beneficiary,     uint256 _minReturnedTokens,     bool _preferClaimedTokens,     string memory _memo,     bytes memory _metadata   ) internal returns (uint256 beneficiaryTokenCount) {     // Cant send tokens to the zero address.     if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS(); // Define variables that will be needed outside the scoped section below. // Keep a reference to the funding cycle during which the payment is being made. JBFundingCycle memory _fundingCycle;  // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope. {   IJBPayDelegate _delegate;   uint256 _tokenCount;    // Bundle the amount info into a JBTokenAmount struct.   JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);    // Record the payment.   (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(     _payer,     _bundledAmount,     _projectId,     baseWeightCurrency,     _beneficiary,     _memo,     _metadata   );    // Mint the tokens if needed.   if (_tokenCount &gt; 0)     // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.     beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(       _projectId,       _tokenCount,       _beneficiary,       '',       _preferClaimedTokens,       true     );    // The token count for the beneficiary must be greater than or equal to the minimum expected.   if (beneficiaryTokenCount &lt; _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();    // If a delegate was returned by the data source, issue a callback to it.   if (_delegate != IJBPayDelegate(address(0))) {     JBDidPayData memory _data = JBDidPayData(       _payer,       _projectId,       _fundingCycle.configuration,       _bundledAmount,       beneficiaryTokenCount,       _beneficiary,       _preferClaimedTokens,       _memo,       _metadata     );      _delegate.didPay(_data);     emit DelegateDidPay(_delegate, _data, msg.sender);   } }  emit Pay(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _payer,   _beneficiary,   _amount,   beneficiaryTokenCount,   _memo,   _metadata,   msg.sender );  } /**     @notice     Receives funds belonging to the specified project. @param _projectId The ID of the project to which the funds received belong. @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead. @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added. @param _memo A memo to pass along to the emitted event. @param _metadata Extra data to pass along to the emitted event.  */   function _addToBalanceOf(     uint256 _projectId,     uint256 _amount,     bool _shouldRefundHeldFees,     string memory _memo,     bytes memory _metadata   ) internal {     // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.     uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0; // Record the added funds with any refunded fees. store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);  emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);  } /**     @notice     Refund fees based on the specified amount. @param _projectId The project for which fees are being refunded. @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.  @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal  */   function _refundHeldFees(uint256 _projectId, uint256 _amount)     internal     returns (uint256 refundedFees)   {     // Get a reference to the project's held fees.     JBFee[] memory _heldFees = _heldFeesOf[_projectId]; // Delete the current held fees. delete _heldFeesOf[_projectId];  // Get a reference to the leftover amount once all fees have been settled. uint256 leftoverAmount = _amount;  // Push length in stack uint256 _heldFeesLength = _heldFees.length;  // Process each fee. for (uint256 _i = 0; _i &lt; _heldFeesLength; ) {   if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);   else if (leftoverAmount &gt;= _heldFees[_i].amount) {     unchecked {       leftoverAmount = leftoverAmount - _heldFees[_i].amount;       refundedFees += _feeAmount(         _heldFees[_i].amount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount       );     }   } else {     _heldFeesOf[_projectId].push(       JBFee(         _heldFees[_i].amount - leftoverAmount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount,         _heldFees[_i].beneficiary       )     );     unchecked {       refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);     }     leftoverAmount = 0;   }    unchecked {     ++_i;   } }  emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);  } /**      @notice      Returns the fee amount based on the provided amount for the specified project. @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal. @param _fee The percentage of the fee, out of MAX_FEE.  @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.  @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.  */   function _feeAmount(     uint256 _amount,     uint256 _fee,     uint256 _feeDiscount   ) internal pure returns (uint256) {     // Calculate the discounted fee.     uint256 _discountedFee = _fee -       PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT); // The amount of tokens from the `_amount` to pay as a fee. return   _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);  } /**      @notice     Get the fee discount from the fee gauge for the specified project. @param _projectId The ID of the project to get a fee discount for.  @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.  */   function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {     // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.     if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))       return JBConstants.MAX_FEE_DISCOUNT; // Get the fee discount. if (feeGauge == IJBFeeGauge(address(0)))   feeDiscount = 0;   // If the guage reverts, set the discount to 0. else   try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {     feeDiscount = discount;   } catch {     feeDiscount = 0;   }  // If the fee discount is greater than the max, nullify the discount. if (feeDiscount &gt; JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;  } } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 17:18:24 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './../interfaces/IJBController.sol';
import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol';
import './../libraries/JBConstants.sol';
import './../libraries/JBCurrencies.sol';
import './../libraries/JBFixedPointNumber.sol';
import './../libraries/JBFundingCycleMetadataResolver.sol';
import './../libraries/JBOperations.sol';
import './../libraries/JBSplitsGroups.sol';
import './../libraries/JBTokens.sol';
import './../structs/JBTokenAmount.sol';
import './JBOperatable.sol';
import './JBSingleTokenPaymentTerminal.sol';

/**
  @notice
  Generic terminal managing all inflows and outflows of funds into the protocol ecosystem.

  @dev
  A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time.

  @dev
  Adheres to -
  IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.
  JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
abstract contract JBPayoutRedemptionPaymentTerminal is
  IJBPayoutRedemptionPaymentTerminal,
  JBSingleTokenPaymentTerminal,
  JBOperatable,
  Ownable,
  ReentrancyGuard
{
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error FEE_TOO_HIGH();
  error INADEQUATE_DISTRIBUTION_AMOUNT();
  error INADEQUATE_RECLAIM_AMOUNT();
  error INADEQUATE_TOKEN_COUNT();
  error NO_MSG_VALUE_ALLOWED();
  error PAY_TO_ZERO_ADDRESS();
  error PROJECT_TERMINAL_MISMATCH();
  error REDEEM_TO_ZERO_ADDRESS();
  error TERMINAL_IN_SPLIT_ZERO_ADDRESS();
  error TERMINAL_TOKENS_INCOMPATIBLE();

  //*********************************************************************//
  // ---------------------------- modifiers ---------------------------- //
  //*********************************************************************//

  /** 
    @notice 
    A modifier that verifies this terminal is a terminal of provided project ID.
  */
  modifier isTerminalOf(uint256 _projectId) {
    if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();
    _;
  }

  //*********************************************************************//
  // --------------------- internal stored constants ------------------- //
  //*********************************************************************//

  /**
    @notice
    Maximum fee that can be set for a funding cycle configuration.

    @dev
    Out of MAX_FEE (50_000_000 / 1_000_000_000).
  */
  uint256 internal constant _FEE_CAP = 50_000_000;

  /**
    @notice
    The protocol project ID is 1, as it should be the first project launched during the deployment process.
  */
  uint256 internal constant _PROTOCOL_PROJECT_ID = 1;

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    Fees that are being held to be processed later.

    _projectId The ID of the project for which fees are being held.
  */
  mapping(uint256 => JBFee[]) internal _heldFeesOf;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership and transfers.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  /**
    @notice
    The contract that stores and manages the terminal's data.
  */
  IJBSingleTokenPaymentTerminalStore public immutable override store;

  /**
    @notice
    The currency to base token issuance on.

    @dev
    If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.
  */
  uint256 public immutable override baseWeightCurrency;

  /**
    @notice
    The group that payout splits coming from this terminal are identified by.
  */
  uint256 public immutable override payoutSplitsGroup;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The platform fee percent.

    @dev
    Out of MAX_FEE (25_000_000 / 1_000_000_000)
  */
  uint256 public override fee = 25_000_000; // 2.5%

  /**
    @notice
    The data source that returns a discount to apply to a project's fee.
  */
  IJBFeeGauge public override feeGauge;

  /**
    @notice
    Addresses that can be paid towards from this terminal without incurring a fee.

    _address The address that can be paid toward.
  */
  mapping(address => bool) public override isFeelessAddress;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.

    @dev
    The current overflow is represented as a fixed point number with 18 decimals.

    @param _projectId The ID of the project to get overflow for.

    @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.
  */
  function currentEthOverflowOf(uint256 _projectId)
    external
    view
    virtual
    override
    returns (uint256)
  {
    // Get this terminal's current overflow.
    uint256 _overflow = store.currentOverflowOf(this, _projectId);

    // Adjust the decimals of the fixed point number if needed to have 18 decimals.
    uint256 _adjustedOverflow = (decimals == 18)
      ? _overflow
      : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);

    // Return the amount converted to ETH.
    return
      (currency == JBCurrencies.ETH)
        ? _adjustedOverflow
        : PRBMath.mulDiv(
          _adjustedOverflow,
          10**decimals,
          prices.priceFor(currency, JBCurrencies.ETH, decimals)
        );
  }

  /**
    @notice
    The fees that are currently being held to be processed later for each project.

    @param _projectId The ID of the project for which fees are being held.

    @return An array of fees that are being held.
  */
  function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {
    return _heldFeesOf[_projectId];
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(JBSingleTokenPaymentTerminal, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||
      _interfaceId == type(IJBPayoutTerminal).interfaceId ||
      _interfaceId == type(IJBAllowanceTerminal).interfaceId ||
      _interfaceId == type(IJBRedemptionTerminal).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _token The token that this terminal manages.
    @param _decimals The number of decimals the token fixed point amounts are expected to have.
    @param _currency The currency that this terminal's token adheres to for price feeds.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _splitsStore A contract that stores splits for each project.
    @param _prices A contract that exposes price feeds.
    @param _store A contract that stores the terminal's data.
    @param _owner The address that will own this contract.
  */
  constructor(
    // payable constructor save the gas used to check msg.value==0
    address _token,
    uint256 _decimals,
    uint256 _currency,
    uint256 _baseWeightCurrency,
    uint256 _payoutSplitsGroup,
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBSplitsStore _splitsStore,
    IJBPrices _prices,
    IJBSingleTokenPaymentTerminalStore _store,
    address _owner
  )
    payable
    JBSingleTokenPaymentTerminal(_token, _decimals, _currency)
    JBOperatable(_operatorStore)
  {
    baseWeightCurrency = _baseWeightCurrency;
    payoutSplitsGroup = _payoutSplitsGroup;
    projects = _projects;
    directory = _directory;
    splitsStore = _splitsStore;
    prices = _prices;
    store = _store;

    transferOwnership(_owner);
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Contribute tokens to a project.

    @param _projectId The ID of the project being paid.
    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _token The token being paid. This terminal ignores this property since it only manages one token. 
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function pay(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {
    _token; // Prevents unused var compiler and natspec complaints.

    // ETH shouldn't be sent if this terminal's token isn't ETH.
    if (token != JBTokens.ETH) {
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If this terminal's token is ETH, override _amount with msg.value.
    else _amount = msg.value;

    return
      _pay(
        _amount,
        msg.sender,
        _projectId,
        _beneficiary,
        _minReturnedTokens,
        _preferClaimedTokens,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _token The token being reclaimed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  )
    external
    virtual
    override
    requirePermission(_holder, _projectId, JBOperations.REDEEM)
    returns (uint256 reclaimAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return
      _redeemTokensOf(
        _holder,
        _projectId,
        _tokenCount,
        _minReturnedTokens,
        _beneficiary,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) external virtual override returns (uint256 netLeftoverDistributionAmount) {
    _token; // Prevents unused var compiler and natspec complaints.

    return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)
    returns (uint256 netDistributedAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);
  }

  /**
    @notice
    Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project being migrated.
    @param _to The terminal contract that will gain the project's funds.

    @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.
  */
  function migrate(uint256 _projectId, IJBPaymentTerminal _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)
    returns (uint256 balance)
  {
    // The terminal being migrated to must accept the same token as this terminal.
    if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE();

    // Record the migration in the store.
    balance = store.recordMigration(_projectId);

    // Transfer the balance if needed.
    if (balance > 0) {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_to), balance);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? balance : 0;

      // Withdraw the balance to transfer to the new terminal;
      _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes(''));
    }

    emit Migrate(_projectId, _to, balance, msg.sender);
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _token The token being paid. This terminal ignores this property since it only manages one currency. 
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) {
    _token; // Prevents unused var compiler and natspec complaints.

    // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender.
    if (token != JBTokens.ETH) {
      // Amount must be greater than 0.
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If the terminal's token is ETH, override `_amount` with msg.value.
    else _amount = msg.value;

    // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal.
    _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);
  }

  /**
    @notice
    Process any fees that are being held for the project.

    @dev
    Only a project owner, an operator, or the contract's owner can process held fees.

    @param _projectId The ID of the project whos held fees should be processed.
  */
  function processFees(uint256 _projectId)
    external
    virtual
    override
    requirePermissionAllowingOverride(
      projects.ownerOf(_projectId),
      _projectId,
      JBOperations.PROCESS_FEES,
      msg.sender == owner()
    )
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the held fees.
    delete _heldFeesOf[_projectId];

    // Push array length in stack
    uint256 _heldFeeLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeeLength; ) {
      // Get the fee amount.
      uint256 _amount = _feeAmount(
        _heldFees[_i].amount,
        _heldFees[_i].fee,
        _heldFees[_i].feeDiscount
      );

      // Process the fee.
      _processFee(_amount, _heldFees[_i].beneficiary);

      emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Allows the fee to be updated.

    @dev
    Only the owner of this contract can change the fee.

    @param _fee The new fee, out of MAX_FEE.
  */
  function setFee(uint256 _fee) external virtual override onlyOwner {
    // The provided fee must be within the max.
    if (_fee > _FEE_CAP) revert FEE_TOO_HIGH();

    // Store the new fee.
    fee = _fee;

    emit SetFee(_fee, msg.sender);
  }

  /**
    @notice
    Allows the fee gauge to be updated.

    @dev
    Only the owner of this contract can change the fee gauge.

    @dev
    If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.

    @param _feeGauge The new fee gauge.
  */
  function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {
    // Store the new fee gauge.
    feeGauge = _feeGauge;

    emit SetFeeGauge(_feeGauge, msg.sender);
  }

  /**
    @notice
    Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.

    @dev
    Only the owner of this contract can set addresses as feeless.

    @param _address The address that can be paid towards while still bypassing fees.
    @param _flag A flag indicating whether the terminal should be feeless or not.
  */
  function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {
    // Set the flag value.
    isFeelessAddress[_address] = _flag;

    emit SetFeelessAddress(_address, _flag, msg.sender);
  }

  //*********************************************************************//
  // ---------------------- internal transactions ---------------------- //
  //*********************************************************************//

  /** 
    @notice
    Transfers tokens.

    @param _from The address from which the transfer should originate.
    @param _to The address to which the transfer should go.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _transferFrom(
    address _from,
    address payable _to,
    uint256 _amount
  ) internal virtual;

  /** 
    @notice
    Logic to be triggered before transferring tokens from this terminal.

    @param _to The address to which the transfer is going.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _beforeTransferTo(address _to, uint256 _amount) internal virtual;

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function _redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 reclaimAmount) {
    // Can't send reclaimed funds to the zero address.
    if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the redemption is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` only used within scope.
    {
      IJBRedemptionDelegate _delegate;

      // Record the redemption.
      (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(
        _holder,
        _projectId,
        _tokenCount,
        _memo,
        _metadata
      );

      // The amount being reclaimed must be at least as much as was expected.
      if (reclaimAmount < _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();

      // Burn the project tokens.
      if (_tokenCount > 0)
        IJBController(directory.controllerOf(_projectId)).burnTokensOf(
          _holder,
          _projectId,
          _tokenCount,
          '',
          false
        );

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBRedemptionDelegate(address(0))) {
        JBDidRedeemData memory _data = JBDidRedeemData(
          _holder,
          _projectId,
          _fundingCycle.configuration,
          _tokenCount,
          JBTokenAmount(token, reclaimAmount, decimals, currency),
          _beneficiary,
          _memo,
          _metadata
        );
        _delegate.didRedeem(_data);
        emit DelegateDidRedeem(_delegate, _data, msg.sender);
      }
    }

    // Send the reclaimed funds to the beneficiary.
    if (reclaimAmount > 0) _transferFrom(address(this), _beneficiary, reclaimAmount);

    emit RedeemTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _holder,
      _beneficiary,
      _tokenCount,
      reclaimAmount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) internal returns (uint256 netLeftoverDistributionAmount) {
    // Record the distribution.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(
      _projectId,
      _amount,
      _currency
    );

    // The amount being distributed must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Get a reference to the project owner, which will receive tokens from paying the platform fee
    // and receive any extra distributable funds not allocated to payout splits.
    address payable _projectOwner = payable(projects.ownerOf(_projectId));

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the fee amount that was paid.
    uint256 _fee;

    // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope.
    {
      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // The amount distributed that is eligible for incurring fees.
      uint256 _feeEligibleDistributionAmount;

      // The amount leftover after distributing to the splits.
      uint256 _leftoverDistributionAmount;

      // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.
      // Also get a reference to the amount that was distributed to splits from which fees should be taken.
      (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        payoutSplitsGroup,
        _distributedAmount,
        _feeDiscount
      );

      // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.
      unchecked {
        _feeEligibleDistributionAmount += _leftoverDistributionAmount;
      }

      // Take the fee.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0
        ? 0
        : _takeFeeFrom(
          _projectId,
          _fundingCycle,
          _feeEligibleDistributionAmount,
          _projectOwner,
          _feeDiscount
        );

      // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.

      unchecked {
        netLeftoverDistributionAmount = _leftoverDistributionAmount == 0
          ? 0
          : _leftoverDistributionAmount -
            _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);
      }

      // Transfer any remaining balance to the project owner.
      if (netLeftoverDistributionAmount > 0)
        _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount);
    }

    emit DistributePayouts(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _projectOwner,
      _amount,
      _distributedAmount,
      _fee,
      netLeftoverDistributionAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function _useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  ) internal returns (uint256 netDistributedAmount) {
    // Record the use of the allowance.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(
      _projectId,
      _amount,
      _currency
    );

    // The amount being withdrawn must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope.
    {
      // Keep a reference to the fee amount that was paid.
      uint256 _fee;

      // Get a reference to the project owner, which will receive tokens from paying the platform fee.
      address _projectOwner = projects.ownerOf(_projectId);

      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // Take a fee from the `_distributedAmount`, if needed.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
        ? 0
        : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);

      unchecked {
        // The net amount is the withdrawn amount without the fee.
        netDistributedAmount = _distributedAmount - _fee;
      }

      // Transfer any remaining balance to the beneficiary.
      if (netDistributedAmount > 0)
        _transferFrom(address(this), _beneficiary, netDistributedAmount);
    }

    emit UseAllowance(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _beneficiary,
      _amount,
      _distributedAmount,
      netDistributedAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Pays out splits for a project's funding cycle configuration.

    @param _projectId The ID of the project for which payout splits are being distributed.
    @param _domain The domain of the splits to distribute the payout between.
    @param _group The group of the splits to distribute the payout between.
    @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return leftoverAmount If the leftover amount if the splits don't add up to 100%.
    @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.
  */
  function _distributeToPayoutSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount,
    uint256 _feeDiscount
  ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's payout splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    // Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; ) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _payoutAmount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // The payout amount substracting any applicable incurred fees.
      uint256 _netPayoutAmount;

      if (_payoutAmount > 0) {
        // Transfer tokens to the split.
        // If there's an allocator set, transfer to its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0))) {
          // If the split allocator is set as feeless, this distribution is not eligible for a fee.
          if (isFeelessAddress[address(_split.allocator)])
            _netPayoutAmount = _payoutAmount;
            // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.
          else {
            unchecked {
              _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                ? _payoutAmount
                : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
            }

            // This distribution is eligible for a fee since the funds are leaving the ecosystem.
            feeEligibleDistributionAmount += _payoutAmount;
          }

          // Trigger any inherited pre-transfer logic.
          _beforeTransferTo(address(_split.allocator), _netPayoutAmount);

          // If this terminal's token is ETH, send it in msg.value.
          uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

          // Create the data to send to the allocator.
          JBSplitAllocationData memory _data = JBSplitAllocationData(
            token,
            _netPayoutAmount,
            decimals,
            _projectId,
            _group,
            _split
          );

          // Trigger the allocator's `allocate` function.
          _split.allocator.allocate{value: _payableValue}(_data);

          // Otherwise, if a project is specified, make a payment to it.
        } else if (_split.projectId != 0) {
          // Get a reference to the Juicebox terminal being used.
          IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);

          // The project must have a terminal to send funds to.
          if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();

          // Save gas if this contract is being used as the terminal.
          if (_terminal == this) {
            // This distribution does not incur a fee.
            _netPayoutAmount = _payoutAmount;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);
            else
              _pay(
                _netPayoutAmount,
                address(this),
                _split.projectId,
                (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          } else {
            // If the terminal is set as feeless, this distribution is not eligible for a fee.
            if (isFeelessAddress[address(_terminal)])
              _netPayoutAmount = _payoutAmount;
              // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.
            else {
              unchecked {
                _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                  ? _payoutAmount
                  : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
              }

              feeEligibleDistributionAmount += _payoutAmount;
            }

            // Trigger any inherited pre-transfer logic.
            _beforeTransferTo(address(_terminal), _netPayoutAmount);

            // If this terminal's token is ETH, send it in msg.value.
            uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _terminal.addToBalanceOf{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                '',
                _projectMetadata
              );
            else
              _terminal.pay{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          }
        } else {
          unchecked {
            _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
              ? _payoutAmount
              : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
          }

          // This distribution is eligible for a fee since the funds are leaving the ecosystem.
          feeEligibleDistributionAmount += _payoutAmount;

          // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.
          _transferFrom(
            address(this),
            _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),
            _netPayoutAmount
          );
        }

        // Subtract from the amount to be sent to the beneficiary.
        unchecked {
          leftoverAmount = leftoverAmount - _payoutAmount;
        }
      }

      emit DistributeToPayoutSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _netPayoutAmount,
        msg.sender
      );

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID.

    @param _projectId The ID of the project having fees taken from.
    @param _fundingCycle The funding cycle during which the fee is being taken.
    @param _amount The amount of the fee to take, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platforms tokens for.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return feeAmount The amount of the fee taken.
  */
  function _takeFeeFrom(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _amount,
    address _beneficiary,
    uint256 _feeDiscount
  ) internal returns (uint256 feeAmount) {
    feeAmount = _feeAmount(_amount, fee, _feeDiscount);

    if (_fundingCycle.shouldHoldFees()) {
      // Store the held fee.
      _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));

      emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender);
    } else {
      // Process the fee.
      _processFee(feeAmount, _beneficiary); // Take the fee.

      emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender);
    }
  }

  /**
    @notice
    Process a fee of the specified amount.

    @param _amount The fee amount, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platform's tokens for.
  */
  function _processFee(uint256 _amount, address _beneficiary) internal {
    // Get the terminal for the protocol project.
    IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token);

    // When processing the admin fee, save gas if the admin is using this contract as its terminal.
    if (_terminal == this)
      _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call.
    else {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_terminal), _amount);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;

      // Send the payment.
      _terminal.pay{value: _payableValue}(
        _PROTOCOL_PROJECT_ID,
        _amount,
        token,
        _beneficiary,
        0,
        false,
        '',
        bytes('')
      ); // Use the external pay call of the correct terminal.
    }
  }

  /**
    @notice
    Contribute tokens to a project.

    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _payer The address making the payment.
    @param _projectId The ID of the project being paid.
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function _pay(
    uint256 _amount,
    address _payer,
    uint256 _projectId,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 beneficiaryTokenCount) {
    // Cant send tokens to the zero address.
    if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the payment is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope.
    {
      IJBPayDelegate _delegate;
      uint256 _tokenCount;

      // Bundle the amount info into a JBTokenAmount struct.
      JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);

      // Record the payment.
      (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(
        _payer,
        _bundledAmount,
        _projectId,
        baseWeightCurrency,
        _beneficiary,
        _memo,
        _metadata
      );

      // Mint the tokens if needed.
      if (_tokenCount > 0)
        // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.
        beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(
          _projectId,
          _tokenCount,
          _beneficiary,
          '',
          _preferClaimedTokens,
          true
        );

      // The token count for the beneficiary must be greater than or equal to the minimum expected.
      if (beneficiaryTokenCount < _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBPayDelegate(address(0))) {
        JBDidPayData memory _data = JBDidPayData(
          _payer,
          _projectId,
          _fundingCycle.configuration,
          _bundledAmount,
          beneficiaryTokenCount,
          _beneficiary,
          _preferClaimedTokens,
          _memo,
          _metadata
        );

        _delegate.didPay(_data);
        emit DelegateDidPay(_delegate, _data, msg.sender);
      }
    }

    emit Pay(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _payer,
      _beneficiary,
      _amount,
      beneficiaryTokenCount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function _addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    bool _shouldRefundHeldFees,
    string memory _memo,
    bytes memory _metadata
  ) internal {
    // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.
    uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0;

    // Record the added funds with any refunded fees.
    store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);

    emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);
  }

  /**
    @notice
    Refund fees based on the specified amount.

    @param _projectId The project for which fees are being refunded.
    @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.

    @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal
  */
  function _refundHeldFees(uint256 _projectId, uint256 _amount)
    internal
    returns (uint256 refundedFees)
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the current held fees.
    delete _heldFeesOf[_projectId];

    // Get a reference to the leftover amount once all fees have been settled.
    uint256 leftoverAmount = _amount;

    // Push length in stack
    uint256 _heldFeesLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeesLength; ) {
      if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);
      else if (leftoverAmount >= _heldFees[_i].amount) {
        unchecked {
          leftoverAmount = leftoverAmount - _heldFees[_i].amount;
          refundedFees += _feeAmount(
            _heldFees[_i].amount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount
          );
        }
      } else {
        _heldFeesOf[_projectId].push(
          JBFee(
            _heldFees[_i].amount - leftoverAmount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount,
            _heldFees[_i].beneficiary
          )
        );
        unchecked {
          refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);
        }
        leftoverAmount = 0;
      }

      unchecked {
        ++_i;
      }
    }

    emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);
  }

  /** 
    @notice 
    Returns the fee amount based on the provided amount for the specified project.

    @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal.
    @param _fee The percentage of the fee, out of MAX_FEE. 
    @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.

    @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _feeAmount(
    uint256 _amount,
    uint256 _fee,
    uint256 _feeDiscount
  ) internal pure returns (uint256) {
    // Calculate the discounted fee.
    uint256 _discountedFee = _fee -
      PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT);

    // The amount of tokens from the `_amount` to pay as a fee.
    return
      _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);
  }

  /** 
    @notice
    Get the fee discount from the fee gauge for the specified project.

    @param _projectId The ID of the project to get a fee discount for.
    
    @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.
  */
  function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {
    // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.
    if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))
      return JBConstants.MAX_FEE_DISCOUNT;

    // Get the fee discount.
    if (feeGauge == IJBFeeGauge(address(0)))
      feeDiscount = 0;
      // If the guage reverts, set the discount to 0.
    else
      try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {
        feeDiscount = discount;
      } catch {
        feeDiscount = 0;
      }

    // If the fee discount is greater than the max, nullify the discount.
    if (feeDiscount > JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;
  }
}
.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './../interfaces/IJBController.sol';
import './../interfaces/IJBPayoutRedemptionPaymentTerminal.sol';
import './../libraries/JBConstants.sol';
import './../libraries/JBCurrencies.sol';
import './../libraries/JBFixedPointNumber.sol';
import './../libraries/JBFundingCycleMetadataResolver.sol';
import './../libraries/JBOperations.sol';
import './../libraries/JBSplitsGroups.sol';
import './../libraries/JBTokens.sol';
import './../structs/JBTokenAmount.sol';
import './JBOperatable.sol';
import './JBSingleTokenPaymentTerminal.sol';

/**
  @notice
  Generic terminal managing all inflows and outflows of funds into the protocol ecosystem.

  @dev
  A project can transfer its funds, along with the power to reconfigure and mint/burn their tokens, from this contract to another allowed terminal of the same token type contract at any time.

  @dev
  Adheres to -
  IJBPayoutRedemptionPaymentTerminal: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  JBSingleTokenPaymentTerminal: Generic terminal managing all inflows of funds into the protocol ecosystem for one token.
  JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
abstract contract JBPayoutRedemptionPaymentTerminal is
  IJBPayoutRedemptionPaymentTerminal,
  JBSingleTokenPaymentTerminal,
  JBOperatable,
  Ownable,
  ReentrancyGuard
{
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error FEE_TOO_HIGH();
  error INADEQUATE_DISTRIBUTION_AMOUNT();
  error INADEQUATE_RECLAIM_AMOUNT();
  error INADEQUATE_TOKEN_COUNT();
  error NO_MSG_VALUE_ALLOWED();
  error PAY_TO_ZERO_ADDRESS();
  error PROJECT_TERMINAL_MISMATCH();
  error REDEEM_TO_ZERO_ADDRESS();
  error TERMINAL_IN_SPLIT_ZERO_ADDRESS();
  error TERMINAL_TOKENS_INCOMPATIBLE();

  //*********************************************************************//
  // ---------------------------- modifiers ---------------------------- //
  //*********************************************************************//

  /** 
    @notice 
    A modifier that verifies this terminal is a terminal of provided project ID.
  */
  modifier isTerminalOf(uint256 _projectId) {
    if (!directory.isTerminalOf(_projectId, this)) revert PROJECT_TERMINAL_MISMATCH();
    _;
  }

  //*********************************************************************//
  // --------------------- internal stored constants ------------------- //
  //*********************************************************************//

  /**
    @notice
    Maximum fee that can be set for a funding cycle configuration.

    @dev
    Out of MAX_FEE (50_000_000 / 1_000_000_000).
  */
  uint256 internal constant _FEE_CAP = 50_000_000;

  /**
    @notice
    The protocol project ID is 1, as it should be the first project launched during the deployment process.
  */
  uint256 internal constant _PROTOCOL_PROJECT_ID = 1;

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    Fees that are being held to be processed later.

    _projectId The ID of the project for which fees are being held.
  */
  mapping(uint256 => JBFee[]) internal _heldFeesOf;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership and transfers.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  /**
    @notice
    The contract that stores and manages the terminal's data.
  */
  IJBSingleTokenPaymentTerminalStore public immutable override store;

  /**
    @notice
    The currency to base token issuance on.

    @dev
    If this differs from `currency`, there must be a price feed available to convert `currency` to `baseWeightCurrency`.
  */
  uint256 public immutable override baseWeightCurrency;

  /**
    @notice
    The group that payout splits coming from this terminal are identified by.
  */
  uint256 public immutable override payoutSplitsGroup;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The platform fee percent.

    @dev
    Out of MAX_FEE (25_000_000 / 1_000_000_000)
  */
  uint256 public override fee = 25_000_000; // 2.5%

  /**
    @notice
    The data source that returns a discount to apply to a project's fee.
  */
  IJBFeeGauge public override feeGauge;

  /**
    @notice
    Addresses that can be paid towards from this terminal without incurring a fee.

    _address The address that can be paid toward.
  */
  mapping(address => bool) public override isFeelessAddress;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.

    @dev
    The current overflow is represented as a fixed point number with 18 decimals.

    @param _projectId The ID of the project to get overflow for.

    @return The current amount of ETH overflow that project has in this terminal, as a fixed point number with 18 decimals.
  */
  function currentEthOverflowOf(uint256 _projectId)
    external
    view
    virtual
    override
    returns (uint256)
  {
    // Get this terminal's current overflow.
    uint256 _overflow = store.currentOverflowOf(this, _projectId);

    // Adjust the decimals of the fixed point number if needed to have 18 decimals.
    uint256 _adjustedOverflow = (decimals == 18)
      ? _overflow
      : JBFixedPointNumber.adjustDecimals(_overflow, decimals, 18);

    // Return the amount converted to ETH.
    return
      (currency == JBCurrencies.ETH)
        ? _adjustedOverflow
        : PRBMath.mulDiv(
          _adjustedOverflow,
          10**decimals,
          prices.priceFor(currency, JBCurrencies.ETH, decimals)
        );
  }

  /**
    @notice
    The fees that are currently being held to be processed later for each project.

    @param _projectId The ID of the project for which fees are being held.

    @return An array of fees that are being held.
  */
  function heldFeesOf(uint256 _projectId) external view override returns (JBFee[] memory) {
    return _heldFeesOf[_projectId];
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(JBSingleTokenPaymentTerminal, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBPayoutRedemptionPaymentTerminal).interfaceId ||
      _interfaceId == type(IJBPayoutTerminal).interfaceId ||
      _interfaceId == type(IJBAllowanceTerminal).interfaceId ||
      _interfaceId == type(IJBRedemptionTerminal).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _token The token that this terminal manages.
    @param _decimals The number of decimals the token fixed point amounts are expected to have.
    @param _currency The currency that this terminal's token adheres to for price feeds.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _splitsStore A contract that stores splits for each project.
    @param _prices A contract that exposes price feeds.
    @param _store A contract that stores the terminal's data.
    @param _owner The address that will own this contract.
  */
  constructor(
    // payable constructor save the gas used to check msg.value==0
    address _token,
    uint256 _decimals,
    uint256 _currency,
    uint256 _baseWeightCurrency,
    uint256 _payoutSplitsGroup,
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBSplitsStore _splitsStore,
    IJBPrices _prices,
    IJBSingleTokenPaymentTerminalStore _store,
    address _owner
  )
    payable
    JBSingleTokenPaymentTerminal(_token, _decimals, _currency)
    JBOperatable(_operatorStore)
  {
    baseWeightCurrency = _baseWeightCurrency;
    payoutSplitsGroup = _payoutSplitsGroup;
    projects = _projects;
    directory = _directory;
    splitsStore = _splitsStore;
    prices = _prices;
    store = _store;

    transferOwnership(_owner);
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Contribute tokens to a project.

    @param _projectId The ID of the project being paid.
    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _token The token being paid. This terminal ignores this property since it only manages one token. 
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function pay(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) returns (uint256) {
    _token; // Prevents unused var compiler and natspec complaints.

    // ETH shouldn't be sent if this terminal's token isn't ETH.
    if (token != JBTokens.ETH) {
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If this terminal's token is ETH, override _amount with msg.value.
    else _amount = msg.value;

    return
      _pay(
        _amount,
        msg.sender,
        _projectId,
        _beneficiary,
        _minReturnedTokens,
        _preferClaimedTokens,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _token The token being reclaimed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  )
    external
    virtual
    override
    requirePermission(_holder, _projectId, JBOperations.REDEEM)
    returns (uint256 reclaimAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return
      _redeemTokensOf(
        _holder,
        _projectId,
        _tokenCount,
        _minReturnedTokens,
        _beneficiary,
        _memo,
        _metadata
      );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) external virtual override returns (uint256 netLeftoverDistributionAmount) {
    _token; // Prevents unused var compiler and natspec complaints.

    return _distributePayoutsOf(_projectId, _amount, _currency, _minReturnedTokens, _memo);
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _token The token being distributed. This terminal ignores this property since it only manages one token. 
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    address _token,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.USE_ALLOWANCE)
    returns (uint256 netDistributedAmount)
  {
    _token; // Prevents unused var compiler and natspec complaints.

    return _useAllowanceOf(_projectId, _amount, _currency, _minReturnedTokens, _beneficiary, _memo);
  }

  /**
    @notice
    Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project being migrated.
    @param _to The terminal contract that will gain the project's funds.

    @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals as this terminal.
  */
  function migrate(uint256 _projectId, IJBPaymentTerminal _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_TERMINAL)
    returns (uint256 balance)
  {
    // The terminal being migrated to must accept the same token as this terminal.
    if (!_to.acceptsToken(token, _projectId)) revert TERMINAL_TOKENS_INCOMPATIBLE();

    // Record the migration in the store.
    balance = store.recordMigration(_projectId);

    // Transfer the balance if needed.
    if (balance > 0) {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_to), balance);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? balance : 0;

      // Withdraw the balance to transfer to the new terminal;
      _to.addToBalanceOf{value: _payableValue}(_projectId, balance, token, '', bytes(''));
    }

    emit Migrate(_projectId, _to, balance, msg.sender);
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _token The token being paid. This terminal ignores this property since it only manages one currency. 
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    address _token,
    string calldata _memo,
    bytes calldata _metadata
  ) external payable virtual override isTerminalOf(_projectId) {
    _token; // Prevents unused var compiler and natspec complaints.

    // If this terminal's token isn't ETH, make sure no msg.value was sent, then transfer the tokens in from msg.sender.
    if (token != JBTokens.ETH) {
      // Amount must be greater than 0.
      if (msg.value > 0) revert NO_MSG_VALUE_ALLOWED();

      // Transfer tokens to this terminal from the msg sender.
      _transferFrom(msg.sender, payable(address(this)), _amount);
    }
    // If the terminal's token is ETH, override `_amount` with msg.value.
    else _amount = msg.value;

    // Add to balance while only refunding held fees if the funds aren't originating from a feeless terminal.
    _addToBalanceOf(_projectId, _amount, !isFeelessAddress[msg.sender], _memo, _metadata);
  }

  /**
    @notice
    Process any fees that are being held for the project.

    @dev
    Only a project owner, an operator, or the contract's owner can process held fees.

    @param _projectId The ID of the project whos held fees should be processed.
  */
  function processFees(uint256 _projectId)
    external
    virtual
    override
    requirePermissionAllowingOverride(
      projects.ownerOf(_projectId),
      _projectId,
      JBOperations.PROCESS_FEES,
      msg.sender == owner()
    )
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the held fees.
    delete _heldFeesOf[_projectId];

    // Push array length in stack
    uint256 _heldFeeLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeeLength; ) {
      // Get the fee amount.
      uint256 _amount = _feeAmount(
        _heldFees[_i].amount,
        _heldFees[_i].fee,
        _heldFees[_i].feeDiscount
      );

      // Process the fee.
      _processFee(_amount, _heldFees[_i].beneficiary);

      emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Allows the fee to be updated.

    @dev
    Only the owner of this contract can change the fee.

    @param _fee The new fee, out of MAX_FEE.
  */
  function setFee(uint256 _fee) external virtual override onlyOwner {
    // The provided fee must be within the max.
    if (_fee > _FEE_CAP) revert FEE_TOO_HIGH();

    // Store the new fee.
    fee = _fee;

    emit SetFee(_fee, msg.sender);
  }

  /**
    @notice
    Allows the fee gauge to be updated.

    @dev
    Only the owner of this contract can change the fee gauge.

    @dev
    If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.

    @param _feeGauge The new fee gauge.
  */
  function setFeeGauge(IJBFeeGauge _feeGauge) external virtual override onlyOwner {
    // Store the new fee gauge.
    feeGauge = _feeGauge;

    emit SetFeeGauge(_feeGauge, msg.sender);
  }

  /**
    @notice
    Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.

    @dev
    Only the owner of this contract can set addresses as feeless.

    @param _address The address that can be paid towards while still bypassing fees.
    @param _flag A flag indicating whether the terminal should be feeless or not.
  */
  function setFeelessAddress(address _address, bool _flag) external virtual override onlyOwner {
    // Set the flag value.
    isFeelessAddress[_address] = _flag;

    emit SetFeelessAddress(_address, _flag, msg.sender);
  }

  //*********************************************************************//
  // ---------------------- internal transactions ---------------------- //
  //*********************************************************************//

  /** 
    @notice
    Transfers tokens.

    @param _from The address from which the transfer should originate.
    @param _to The address to which the transfer should go.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _transferFrom(
    address _from,
    address payable _to,
    uint256 _amount
  ) internal virtual;

  /** 
    @notice
    Logic to be triggered before transferring tokens from this terminal.

    @param _to The address to which the transfer is going.
    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.
  */
  function _beforeTransferTo(address _to, uint256 _amount) internal virtual;

  /**
    @notice
    Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.

    @dev
    Only a token holder or a designated operator can redeem its tokens.

    @param _holder The account to redeem tokens for.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
    @param _beneficiary The address to send the terminal tokens to.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point number with 18 decimals.
  */
  function _redeemTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 reclaimAmount) {
    // Can't send reclaimed funds to the zero address.
    if (_beneficiary == address(0)) revert REDEEM_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the redemption is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` only used within scope.
    {
      IJBRedemptionDelegate _delegate;

      // Record the redemption.
      (_fundingCycle, reclaimAmount, _delegate, _memo) = store.recordRedemptionFor(
        _holder,
        _projectId,
        _tokenCount,
        _memo,
        _metadata
      );

      // The amount being reclaimed must be at least as much as was expected.
      if (reclaimAmount < _minReturnedTokens) revert INADEQUATE_RECLAIM_AMOUNT();

      // Burn the project tokens.
      if (_tokenCount > 0)
        IJBController(directory.controllerOf(_projectId)).burnTokensOf(
          _holder,
          _projectId,
          _tokenCount,
          '',
          false
        );

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBRedemptionDelegate(address(0))) {
        JBDidRedeemData memory _data = JBDidRedeemData(
          _holder,
          _projectId,
          _fundingCycle.configuration,
          _tokenCount,
          JBTokenAmount(token, reclaimAmount, decimals, currency),
          _beneficiary,
          _memo,
          _metadata
        );
        _delegate.didRedeem(_data);
        emit DelegateDidRedeem(_delegate, _data, msg.sender);
      }
    }

    // Send the reclaimed funds to the beneficiary.
    if (reclaimAmount > 0) _transferFrom(address(this), _beneficiary, reclaimAmount);

    emit RedeemTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _holder,
      _beneficiary,
      _tokenCount,
      reclaimAmount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Distributes payouts for a project with the distribution limit of its current funding cycle.

    @dev
    Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.

    @dev
    Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.

    @dev
    All funds distributed outside of this contract or any feeless terminals incure the protocol fee.

    @param _projectId The ID of the project having its payouts distributed.
    @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
    @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
    @param _memo A memo to pass along to the emitted event.

    @return netLeftoverDistributionAmount The amount that was sent to the project owner, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _distributePayoutsOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    string calldata _memo
  ) internal returns (uint256 netLeftoverDistributionAmount) {
    // Record the distribution.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(
      _projectId,
      _amount,
      _currency
    );

    // The amount being distributed must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Get a reference to the project owner, which will receive tokens from paying the platform fee
    // and receive any extra distributable funds not allocated to payout splits.
    address payable _projectOwner = payable(projects.ownerOf(_projectId));

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the fee amount that was paid.
    uint256 _fee;

    // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope.
    {
      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // The amount distributed that is eligible for incurring fees.
      uint256 _feeEligibleDistributionAmount;

      // The amount leftover after distributing to the splits.
      uint256 _leftoverDistributionAmount;

      // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.
      // Also get a reference to the amount that was distributed to splits from which fees should be taken.
      (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        payoutSplitsGroup,
        _distributedAmount,
        _feeDiscount
      );

      // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.
      unchecked {
        _feeEligibleDistributionAmount += _leftoverDistributionAmount;
      }

      // Take the fee.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0
        ? 0
        : _takeFeeFrom(
          _projectId,
          _fundingCycle,
          _feeEligibleDistributionAmount,
          _projectOwner,
          _feeDiscount
        );

      // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.

      unchecked {
        netLeftoverDistributionAmount = _leftoverDistributionAmount == 0
          ? 0
          : _leftoverDistributionAmount -
            _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);
      }

      // Transfer any remaining balance to the project owner.
      if (netLeftoverDistributionAmount > 0)
        _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount);
    }

    emit DistributePayouts(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _projectOwner,
      _amount,
      _distributedAmount,
      _fee,
      netLeftoverDistributionAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Allows a project to send funds from its overflow up to the preconfigured allowance.

    @dev
    Only a project's owner or a designated operator can use its allowance.

    @dev
    Incurs the protocol fee.

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
    @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
    @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
    @param _beneficiary The address to send the funds to.
    @param _memo A memo to pass along to the emitted event.

    @return netDistributedAmount The amount of tokens that was distributed to the beneficiary, as a fixed point number with the same amount of decimals as the terminal.
  */
  function _useAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency,
    uint256 _minReturnedTokens,
    address payable _beneficiary,
    string memory _memo
  ) internal returns (uint256 netDistributedAmount) {
    // Record the use of the allowance.
    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordUsedAllowanceOf(
      _projectId,
      _amount,
      _currency
    );

    // The amount being withdrawn must be at least as much as was expected.
    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();

    // Scoped section prevents stack too deep. `_fee`, `_projectOwner`, `_feeDiscount`, and `_netAmount` only used within scope.
    {
      // Keep a reference to the fee amount that was paid.
      uint256 _fee;

      // Get a reference to the project owner, which will receive tokens from paying the platform fee.
      address _projectOwner = projects.ownerOf(_projectId);

      // Get the amount of discount that should be applied to any fees taken.
      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.
      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]
        ? JBConstants.MAX_FEE_DISCOUNT
        : _currentFeeDiscount(_projectId);

      // Take a fee from the `_distributedAmount`, if needed.
      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
        ? 0
        : _takeFeeFrom(_projectId, _fundingCycle, _distributedAmount, _projectOwner, _feeDiscount);

      unchecked {
        // The net amount is the withdrawn amount without the fee.
        netDistributedAmount = _distributedAmount - _fee;
      }

      // Transfer any remaining balance to the beneficiary.
      if (netDistributedAmount > 0)
        _transferFrom(address(this), _beneficiary, netDistributedAmount);
    }

    emit UseAllowance(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _beneficiary,
      _amount,
      _distributedAmount,
      netDistributedAmount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Pays out splits for a project's funding cycle configuration.

    @param _projectId The ID of the project for which payout splits are being distributed.
    @param _domain The domain of the splits to distribute the payout between.
    @param _group The group of the splits to distribute the payout between.
    @param _amount The total amount being distributed, as a fixed point number with the same number of decimals as this terminal.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return leftoverAmount If the leftover amount if the splits don't add up to 100%.
    @return feeEligibleDistributionAmount The total amount of distributions that are eligible to have fees taken from.
  */
  function _distributeToPayoutSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount,
    uint256 _feeDiscount
  ) internal returns (uint256 leftoverAmount, uint256 feeEligibleDistributionAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's payout splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    // Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; ) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _payoutAmount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // The payout amount substracting any applicable incurred fees.
      uint256 _netPayoutAmount;

      if (_payoutAmount > 0) {
        // Transfer tokens to the split.
        // If there's an allocator set, transfer to its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0))) {
          // If the split allocator is set as feeless, this distribution is not eligible for a fee.
          if (isFeelessAddress[address(_split.allocator)])
            _netPayoutAmount = _payoutAmount;
            // This distribution is eligible for a fee since the funds are leaving this contract and the allocator isn't listed as feeless.
          else {
            unchecked {
              _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                ? _payoutAmount
                : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
            }

            // This distribution is eligible for a fee since the funds are leaving the ecosystem.
            feeEligibleDistributionAmount += _payoutAmount;
          }

          // Trigger any inherited pre-transfer logic.
          _beforeTransferTo(address(_split.allocator), _netPayoutAmount);

          // If this terminal's token is ETH, send it in msg.value.
          uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

          // Create the data to send to the allocator.
          JBSplitAllocationData memory _data = JBSplitAllocationData(
            token,
            _netPayoutAmount,
            decimals,
            _projectId,
            _group,
            _split
          );

          // Trigger the allocator's `allocate` function.
          _split.allocator.allocate{value: _payableValue}(_data);

          // Otherwise, if a project is specified, make a payment to it.
        } else if (_split.projectId != 0) {
          // Get a reference to the Juicebox terminal being used.
          IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_split.projectId, token);

          // The project must have a terminal to send funds to.
          if (_terminal == IJBPaymentTerminal(address(0))) revert TERMINAL_IN_SPLIT_ZERO_ADDRESS();

          // Save gas if this contract is being used as the terminal.
          if (_terminal == this) {
            // This distribution does not incur a fee.
            _netPayoutAmount = _payoutAmount;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _addToBalanceOf(_split.projectId, _netPayoutAmount, false, '', _projectMetadata);
            else
              _pay(
                _netPayoutAmount,
                address(this),
                _split.projectId,
                (_split.beneficiary != address(0)) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          } else {
            // If the terminal is set as feeless, this distribution is not eligible for a fee.
            if (isFeelessAddress[address(_terminal)])
              _netPayoutAmount = _payoutAmount;
              // This distribution is eligible for a fee since the funds are leaving this contract and the terminal isn't listed as feeless.
            else {
              unchecked {
                _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
                  ? _payoutAmount
                  : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
              }

              feeEligibleDistributionAmount += _payoutAmount;
            }

            // Trigger any inherited pre-transfer logic.
            _beforeTransferTo(address(_terminal), _netPayoutAmount);

            // If this terminal's token is ETH, send it in msg.value.
            uint256 _payableValue = token == JBTokens.ETH ? _netPayoutAmount : 0;

            // Send the projectId in the metadata.
            bytes memory _projectMetadata = new bytes(32);
            _projectMetadata = bytes(abi.encodePacked(_projectId));

            // Add to balance if prefered.
            if (_split.preferAddToBalance)
              _terminal.addToBalanceOf{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                '',
                _projectMetadata
              );
            else
              _terminal.pay{value: _payableValue}(
                _split.projectId,
                _netPayoutAmount,
                token,
                _split.beneficiary != address(0) ? _split.beneficiary : msg.sender,
                0,
                _split.preferClaimed,
                '',
                _projectMetadata
              );
          }
        } else {
          unchecked {
            _netPayoutAmount = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT
              ? _payoutAmount
              : _payoutAmount - _feeAmount(_payoutAmount, fee, _feeDiscount);
          }

          // This distribution is eligible for a fee since the funds are leaving the ecosystem.
          feeEligibleDistributionAmount += _payoutAmount;

          // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the msg.sender.
          _transferFrom(
            address(this),
            _split.beneficiary != address(0) ? _split.beneficiary : payable(msg.sender),
            _netPayoutAmount
          );
        }

        // Subtract from the amount to be sent to the beneficiary.
        unchecked {
          leftoverAmount = leftoverAmount - _payoutAmount;
        }
      }

      emit DistributeToPayoutSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _netPayoutAmount,
        msg.sender
      );

      unchecked {
        ++_i;
      }
    }
  }

  /**
    @notice
    Takes a fee into the platform's project, which has an id of _PROTOCOL_PROJECT_ID.

    @param _projectId The ID of the project having fees taken from.
    @param _fundingCycle The funding cycle during which the fee is being taken.
    @param _amount The amount of the fee to take, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platforms tokens for.
    @param _feeDiscount The amount of discount to apply to the fee, out of the MAX_FEE.

    @return feeAmount The amount of the fee taken.
  */
  function _takeFeeFrom(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _amount,
    address _beneficiary,
    uint256 _feeDiscount
  ) internal returns (uint256 feeAmount) {
    feeAmount = _feeAmount(_amount, fee, _feeDiscount);

    if (_fundingCycle.shouldHoldFees()) {
      // Store the held fee.
      _heldFeesOf[_projectId].push(JBFee(_amount, uint32(fee), uint32(_feeDiscount), _beneficiary));

      emit HoldFee(_projectId, _amount, fee, _feeDiscount, _beneficiary, msg.sender);
    } else {
      // Process the fee.
      _processFee(feeAmount, _beneficiary); // Take the fee.

      emit ProcessFee(_projectId, feeAmount, false, _beneficiary, msg.sender);
    }
  }

  /**
    @notice
    Process a fee of the specified amount.

    @param _amount The fee amount, as a floating point number with 18 decimals.
    @param _beneficiary The address to mint the platform's tokens for.
  */
  function _processFee(uint256 _amount, address _beneficiary) internal {
    // Get the terminal for the protocol project.
    IJBPaymentTerminal _terminal = directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token);

    // When processing the admin fee, save gas if the admin is using this contract as its terminal.
    if (_terminal == this)
      _pay(_amount, address(this), _PROTOCOL_PROJECT_ID, _beneficiary, 0, false, '', bytes('')); // Use the local pay call.
    else {
      // Trigger any inherited pre-transfer logic.
      _beforeTransferTo(address(_terminal), _amount);

      // If this terminal's token is ETH, send it in msg.value.
      uint256 _payableValue = token == JBTokens.ETH ? _amount : 0;

      // Send the payment.
      _terminal.pay{value: _payableValue}(
        _PROTOCOL_PROJECT_ID,
        _amount,
        token,
        _beneficiary,
        0,
        false,
        '',
        bytes('')
      ); // Use the external pay call of the correct terminal.
    }
  }

  /**
    @notice
    Contribute tokens to a project.

    @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
    @param _payer The address making the payment.
    @param _projectId The ID of the project being paid.
    @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
    @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
    @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
    @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
    @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.

    @return beneficiaryTokenCount The number of tokens minted for the beneficiary, as a fixed point number with 18 decimals.
  */
  function _pay(
    uint256 _amount,
    address _payer,
    uint256 _projectId,
    address _beneficiary,
    uint256 _minReturnedTokens,
    bool _preferClaimedTokens,
    string memory _memo,
    bytes memory _metadata
  ) internal returns (uint256 beneficiaryTokenCount) {
    // Cant send tokens to the zero address.
    if (_beneficiary == address(0)) revert PAY_TO_ZERO_ADDRESS();

    // Define variables that will be needed outside the scoped section below.
    // Keep a reference to the funding cycle during which the payment is being made.
    JBFundingCycle memory _fundingCycle;

    // Scoped section prevents stack too deep. `_delegate` and `_tokenCount` only used within scope.
    {
      IJBPayDelegate _delegate;
      uint256 _tokenCount;

      // Bundle the amount info into a JBTokenAmount struct.
      JBTokenAmount memory _bundledAmount = JBTokenAmount(token, _amount, decimals, currency);

      // Record the payment.
      (_fundingCycle, _tokenCount, _delegate, _memo) = store.recordPaymentFrom(
        _payer,
        _bundledAmount,
        _projectId,
        baseWeightCurrency,
        _beneficiary,
        _memo,
        _metadata
      );

      // Mint the tokens if needed.
      if (_tokenCount > 0)
        // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.
        beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(
          _projectId,
          _tokenCount,
          _beneficiary,
          '',
          _preferClaimedTokens,
          true
        );

      // The token count for the beneficiary must be greater than or equal to the minimum expected.
      if (beneficiaryTokenCount < _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();

      // If a delegate was returned by the data source, issue a callback to it.
      if (_delegate != IJBPayDelegate(address(0))) {
        JBDidPayData memory _data = JBDidPayData(
          _payer,
          _projectId,
          _fundingCycle.configuration,
          _bundledAmount,
          beneficiaryTokenCount,
          _beneficiary,
          _preferClaimedTokens,
          _memo,
          _metadata
        );

        _delegate.didPay(_data);
        emit DelegateDidPay(_delegate, _data, msg.sender);
      }
    }

    emit Pay(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _payer,
      _beneficiary,
      _amount,
      beneficiaryTokenCount,
      _memo,
      _metadata,
      msg.sender
    );
  }

  /**
    @notice
    Receives funds belonging to the specified project.

    @param _projectId The ID of the project to which the funds received belong.
    @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
    @param _shouldRefundHeldFees A flag indicating if held fees should be refunded based on the amount being added.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Extra data to pass along to the emitted event.
  */
  function _addToBalanceOf(
    uint256 _projectId,
    uint256 _amount,
    bool _shouldRefundHeldFees,
    string memory _memo,
    bytes memory _metadata
  ) internal {
    // Refund any held fees to make sure the project doesn't pay double for funds going in and out of the protocol.
    uint256 _refundedFees = _shouldRefundHeldFees ? _refundHeldFees(_projectId, _amount) : 0;

    // Record the added funds with any refunded fees.
    store.recordAddedBalanceFor(_projectId, _amount + _refundedFees);

    emit AddToBalance(_projectId, _amount, _refundedFees, _memo, _metadata, msg.sender);
  }

  /**
    @notice
    Refund fees based on the specified amount.

    @param _projectId The project for which fees are being refunded.
    @param _amount The amount to base the refund on, as a fixed point number with the same amount of decimals as this terminal.

    @return refundedFees How much fees were refunded, as a fixed point number with the same number of decimals as this terminal
  */
  function _refundHeldFees(uint256 _projectId, uint256 _amount)
    internal
    returns (uint256 refundedFees)
  {
    // Get a reference to the project's held fees.
    JBFee[] memory _heldFees = _heldFeesOf[_projectId];

    // Delete the current held fees.
    delete _heldFeesOf[_projectId];

    // Get a reference to the leftover amount once all fees have been settled.
    uint256 leftoverAmount = _amount;

    // Push length in stack
    uint256 _heldFeesLength = _heldFees.length;

    // Process each fee.
    for (uint256 _i = 0; _i < _heldFeesLength; ) {
      if (leftoverAmount == 0) _heldFeesOf[_projectId].push(_heldFees[_i]);
      else if (leftoverAmount >= _heldFees[_i].amount) {
        unchecked {
          leftoverAmount = leftoverAmount - _heldFees[_i].amount;
          refundedFees += _feeAmount(
            _heldFees[_i].amount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount
          );
        }
      } else {
        _heldFeesOf[_projectId].push(
          JBFee(
            _heldFees[_i].amount - leftoverAmount,
            _heldFees[_i].fee,
            _heldFees[_i].feeDiscount,
            _heldFees[_i].beneficiary
          )
        );
        unchecked {
          refundedFees += _feeAmount(leftoverAmount, _heldFees[_i].fee, _heldFees[_i].feeDiscount);
        }
        leftoverAmount = 0;
      }

      unchecked {
        ++_i;
      }
    }

    emit RefundHeldFees(_projectId, _amount, refundedFees, leftoverAmount, msg.sender);
  }

  /** 
    @notice 
    Returns the fee amount based on the provided amount for the specified project.

    @param _amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as this terminal.
    @param _fee The percentage of the fee, out of MAX_FEE. 
    @param _feeDiscount The percentage discount that should be applied out of the max amount, out of MAX_FEE_DISCOUNT.

    @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.
  */
  function _feeAmount(
    uint256 _amount,
    uint256 _fee,
    uint256 _feeDiscount
  ) internal pure returns (uint256) {
    // Calculate the discounted fee.
    uint256 _discountedFee = _fee -
      PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT);

    // The amount of tokens from the `_amount` to pay as a fee.
    return
      _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);
  }

  /** 
    @notice
    Get the fee discount from the fee gauge for the specified project.

    @param _projectId The ID of the project to get a fee discount for.
    
    @return feeDiscount The fee discount, which should be interpreted as a percentage out MAX_FEE_DISCOUNT.
  */
  function _currentFeeDiscount(uint256 _projectId) internal view returns (uint256 feeDiscount) {
    // Can't take a fee if the protocol project doesn't have a terminal that accepts the token.
    if (directory.primaryTerminalOf(_PROTOCOL_PROJECT_ID, token) == IJBPaymentTerminal(address(0)))
      return JBConstants.MAX_FEE_DISCOUNT;

    // Get the fee discount.
    if (feeGauge == IJBFeeGauge(address(0)))
      feeDiscount = 0;
      // If the guage reverts, set the discount to 0.
    else
      try feeGauge.currentDiscountFor(_projectId) returns (uint256 discount) {
        feeDiscount = discount;
      } catch {
        feeDiscount = 0;
      }

    // If the fee discount is greater than the max, nullify the discount.
    if (feeDiscount > JBConstants.MAX_FEE_DISCOUNT) feeDiscount = 0;
  }
}
".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

