[2024-01-09 20:35:21 INFO] **[Preprocessing]**

**ChatDev Starts** (20240901203521)

**Timestamp**: 20240901203521

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: //SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "./ERC1155Fuse.sol";
import "./Controllable.sol";
import "./INameWrapper.sol";
import "./INameWrapperUpgrade.sol";
import "./IMetadataService.sol";
import "../registry/ENS.sol";
import "../ethregistrar/IBaseRegistrar.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./BytesUtil.sol";

error Unauthorised(bytes32 node, address addr);
error NameNotFound();
error IncompatibleParent();
error IncompatibleName(bytes name);
error IncorrectTokenType();
error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);
error LabelTooShort();
error LabelTooLong(string label);
error IncorrectTargetOwner(address owner);
error CannotUpgrade();
error InvalidExpiry(bytes32 node, uint64 expiry);

contract NameWrapper is
    Ownable,
    ERC1155Fuse,
    INameWrapper,
    Controllable,
    IERC721Receiver
{
    using BytesUtils for bytes;
    ENS public immutable override ens;
    IBaseRegistrar public immutable override registrar;
    IMetadataService public override metadataService;
    mapping(bytes32 => bytes) public override names;

    bytes32 private constant ETH_NODE =
        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
    bytes32 private constant ROOT_NODE =
        0x0000000000000000000000000000000000000000000000000000000000000000;

    //A contract address to a new upgraded contract if any
    INameWrapperUpgrade public upgradeContract;
    uint64 private constant MAX_EXPIRY = type(uint64).max;

    constructor(
        ENS _ens,
        IBaseRegistrar _registrar,
        IMetadataService _metadataService
    ) {
        ens = _ens;
        registrar = _registrar;
        metadataService = _metadataService;

        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */

        _setData(
            uint256(ETH_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        _setData(
            uint256(ROOT_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        names[ROOT_NODE] = "\x00";
        names[ETH_NODE] = "\x03eth\x00";
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Fuse, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(INameWrapper).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /* ERC1155 */

    function ownerOf(uint256 id)
        public
        view
        override(ERC1155Fuse, INameWrapper)
        returns (address owner)
    {
        return super.ownerOf(id);
    }

    /* Metadata service */

    /**
     * @notice Set the metadata service. Only the owner can do this
     */

    function setMetadataService(IMetadataService _newMetadataService)
        public
        onlyOwner
    {
        metadataService = _newMetadataService;
    }

    /**
     * @notice Get the metadata uri
     * @return String uri of the metadata service
     */

    function uri(uint256 tokenId) public view override returns (string memory) {
        return metadataService.uri(tokenId);
    }

    /**
     * @notice Set the address of the upgradeContract of the contract. only admin can do this
     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time
     * to make the contract not upgradable.
     * @param _upgradeAddress address of an upgraded contract
     */

    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)
        public
        onlyOwner
    {
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), false);
            ens.setApprovalForAll(address(upgradeContract), false);
        }

        upgradeContract = _upgradeAddress;

        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), true);
            ens.setApprovalForAll(address(upgradeContract), true);
        }
    }

    /**
     * @notice Checks if msg.sender is the owner or approved by the owner of a name
     * @param node namehash of the name to check
     */

    modifier onlyTokenOwner(bytes32 node) {
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        _;
    }

    /**
     * @notice Checks if owner or approved by owner
     * @param node namehash of the name to check
     * @param addr which address to check permissions for
     * @return whether or not is owner or approved
     */

    function isTokenOwnerOrApproved(bytes32 node, address addr)
        public
        view
        override
        returns (bool)
    {
        address owner = ownerOf(uint256(node));
        return owner == addr || isApprovedForAll(owner, addr);
    }

    /**
     * @notice Gets fuse permissions for a specific name
     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit
     *      The interface has predefined fuses for all registry permissions, but additional
     *      fuses can be added for other use cases
     *      Also returns expiry, which is when the fuses are set to expire.
     * @param node namehash of the name to check
     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp
     * @return expiry Unix time of when the name expires and fuses are to expire
     */
    function getFuses(bytes32 node)
        public
        view
        override
        returns (uint32 fuses, uint64 expiry)
    {
        (, fuses, expiry) = getData(uint256(node));
        if (fuses == 0 && expiry == 0) {
            bytes memory name = names[node];
            if (name.length == 0) {
                revert NameNotFound();
            }
        }
    }

    /**
     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract
     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar
     * @param label label as a string of the .eth domain to wrap
     * @param wrappedOwner Owner of the name in this contract
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @param resolver resolver contract address
     */

    function wrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) public override returns (uint64) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        address registrant = registrar.ownerOf(tokenId);
        if (
            registrant != msg.sender &&
            !isApprovedForAll(registrant, msg.sender) &&
            !registrar.isApprovedForAll(registrant, msg.sender)
        ) {
            revert Unauthorised(
                _makeNode(ETH_NODE, bytes32(tokenId)),
                msg.sender
            );
        }

        // transfer the token from the user to this contract
        registrar.transferFrom(registrant, address(this), tokenId);

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(tokenId, address(this));

        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Registers a new .eth second-level domain and wraps it.
     *      Only callable by authorised controllers.
     * @param label The label to register (Eg, 'foo' for 'foo.eth').
     * @param wrappedOwner The owner of the wrapped name.
     * @param duration The duration, in seconds, to register the name for.
     * @param resolver The resolver address to set on the ENS registry (optional).
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.
     */

    function registerAndWrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint256 duration,
        address resolver,
        uint32 fuses,
        uint64 expiry
    ) external override onlyController returns (uint256 registrarExpiry) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        registrarExpiry = registrar.register(tokenId, address(this), duration);
        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Renews a .eth second-level domain.
     *      Only callable by authorised controllers.
     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').
     * @param duration The number of seconds to renew the name for.
     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.
     */
    function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));

        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));

        _setData(node, owner, fuses, expiry);
    }

    /**
     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the registry or an authorised caller in the registry
     * @param name The name to wrap, in DNS format
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract address
     */

    function wrap(
        bytes calldata name,
        address wrappedOwner,
        address resolver
    ) public override {
        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
        bytes32 parentNode = name.namehash(offset);
        bytes32 node = _makeNode(parentNode, labelhash);

        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }

        address owner = ens.owner(node);

        if (
            owner != msg.sender &&
            !isApprovedForAll(owner, msg.sender) &&
            !ens.isApprovedForAll(owner, msg.sender)
        ) {
            revert Unauthorised(node, msg.sender);
        }

        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        ens.setOwner(node, address(this));

        _wrap(node, name, wrappedOwner, 0, 0);
    }

    /**
     * @notice Unwraps a .eth domain. e.g. vitalik.eth
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param labelhash labelhash of the .eth domain
     * @param newRegistrant sets the owner in the .eth registrar to this address
     * @param newController sets the owner in the registry to this address
     */

    function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }

    /**
     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param newController sets the owner in the registry to this address
     */

    function unwrap(
        bytes32 parentNode,
        bytes32 labelhash,
        address newController
    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        _unwrap(_makeNode(parentNode, labelhash), newController);
    }

    /**
     * @notice Sets fuses of a name
     * @param node namehash of the name
     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)
     */

    function setFuses(bytes32 node, uint32 fuses)
        public
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_BURN_FUSES)
        returns (uint32)
    {
        if (fuses & PARENT_CANNOT_CONTROL != 0) {
            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.
            revert Unauthorised(node, msg.sender);
        }

        (address owner, uint32 oldFuses, uint64 expiry) = getData(
            uint256(node)
        );

        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
        return fuses;
    }

    /**
     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract
     *     and burning the token of this contract
     * @dev Can be called by the owner of the name in this contract
     * @param label Label as a string of the .eth name to upgrade
     * @param wrappedOwner The owner of the wrapped name
     */

    function upgradeETH2LD(
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);

        upgradeContract.wrapETH2LD(
            label,
            wrappedOwner,
            fuses,
            expiry,
            resolver
        );
    }

    /**
     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner or an authorised caller
     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names
     * @param parentNode namehash of the parent name
     * @param label Label as a string of the name to upgrade
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract for this name
     */

    function upgrade(
        bytes32 parentNode,
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.setSubnodeRecord(
            parentNode,
            label,
            wrappedOwner,
            resolver,
            0,
            fuses,
            expiry
        );
    }

    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param fuses fuses to burn
     * @param expiry when the fuses will expire
     */

    function setChildFuses(
        bytes32 parentNode,
        bytes32 labelhash,
        uint32 fuses,
        uint64 expiry
    ) public {
        bytes32 node = _makeNode(parentNode, labelhash);
        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        uint64 maxExpiry;
        if (parentNode == ETH_NODE) {
            if (!isTokenOwnerOrApproved(node, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            // max expiry is set to the expiry on the registrar
            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        } else {
            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }

            // max expiry is set to the expiry of the parent
            (, , maxExpiry) = getData(uint256(parentNode));
        }

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);

        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed
        if (
            oldFuses & PARENT_CANNOT_CONTROL != 0 &&
            oldFuses | fuses != oldFuses
        ) {
            revert OperationProhibited(node);
        }
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
    }

    /**
     * @notice Sets the subdomain owner in the registry and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry when the fuses will expire
     */

    function setSubnodeOwner(
        bytes32 parentNode,
        string calldata label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
        returns (bytes32 node)
    {
        bytes32 labelhash = keccak256(bytes(label));
        node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);

        if (ens.owner(node) != address(this)) {
            ens.setSubnodeOwner(parentNode, labelhash, address(this));
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param resolver resolver contract in the registry
     * @param ttl ttl in the regsitry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry expiry date for the domain
     */

    function setSubnodeRecord(
        bytes32 parentNode,
        string memory label,
        address newOwner,
        address resolver,
        uint64 ttl,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
    {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets records for the name in the ENS Registry
     * @param node namehash of the name to set a record for
     * @param owner newOwner in the registry
     * @param resolver the resolver contract
     * @param ttl ttl in the registry
     */

    function setRecord(
        bytes32 node,
        address owner,
        address resolver,
        uint64 ttl
    )
        public
        override
        onlyTokenOwner(node)
        operationAllowed(
            node,
            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL
        )
    {
        ens.setRecord(node, address(this), resolver, ttl);
        (address oldOwner, , ) = getData(uint256(node));
        _transfer(oldOwner, owner, uint256(node), 1, "");
    }

    /**
     * @notice Sets resolver contract in the registry
     * @param node namehash of the name
     * @param resolver the resolver contract
     */

    function setResolver(bytes32 node, address resolver)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_RESOLVER)
    {
        ens.setResolver(node, resolver);
    }

    /**
     * @notice Sets TTL in the registry
     * @param node namehash of the name
     * @param ttl TTL in the registry
     */

    function setTTL(bytes32 node, uint64 ttl)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_TTL)
    {
        ens.setTTL(node, ttl);
    }

    /**
     * @dev Allows an operation only if none of the specified fuses are burned.
     * @param node The namehash of the name to check fuses on.
     * @param fuseMask A bitmask of fuses that must not be burned.
     */

    modifier operationAllowed(bytes32 node, uint32 fuseMask) {
        (, uint32 fuses, ) = getData(uint256(node));
        if (fuses & fuseMask != 0) {
            revert OperationProhibited(node);
        }
        _;
    }

    /**
     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord
     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt
     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for
     *      replacing a subdomain. If either conditions are true, then it is possible to call
     *      setSubnodeOwner
     * @param node namehash of the name to check
     * @param labelhash labelhash of the name to check
     */

    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {
        bytes32 subnode = _makeNode(node, labelhash);
        address owner = ens.owner(subnode);

        if (owner == address(0)) {
            (, uint32 fuses, ) = getData(uint256(node));
            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {
                revert OperationProhibited(node);
            }
        } else {
            (, uint32 subnodeFuses, ) = getData(uint256(subnode));
            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {
                revert OperationProhibited(node);
            }
        }

        _;
    }

    /**
     * @notice Checks all Fuses in the mask are burned for the node
     * @param node namehash of the name
     * @param fuseMask the fuses you want to check
     * @return Boolean of whether or not all the selected fuses are burned
     */

    function allFusesBurned(bytes32 node, uint32 fuseMask)
        public
        view
        override
        returns (bool)
    {
        (, uint32 fuses, ) = getData(uint256(node));
        return fuses & fuseMask == fuseMask;
    }

    function onERC721Received(
        address to,
        address,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        //check if it's the eth registrar ERC721
        if (msg.sender != address(registrar)) {
            revert IncorrectTokenType();
        }

        (
            string memory label,
            address owner,
            uint32 fuses,
            uint64 expiry,
            address resolver
        ) = abi.decode(data, (string, address, uint32, uint64, address));

        bytes32 labelhash = bytes32(tokenId);
        bytes32 labelhashFromData = keccak256(bytes(label));

        if (labelhashFromData != labelhash) {
            revert LabelMismatch(labelhashFromData, labelhash);
        }

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(uint256(labelhash), address(this));

        _wrapETH2LD(label, owner, fuses, expiry, resolver);

        return IERC721Receiver(to).onERC721Received.selector;
    }

    /***** Internal functions */

    function _canTransfer(uint32 fuses) internal pure override returns (bool) {
        return fuses & CANNOT_TRANSFER == 0;
    }

    function _makeNode(bytes32 node, bytes32 labelhash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, labelhash));
    }

    function _addLabel(string memory label, bytes memory name)
        internal
        pure
        returns (bytes memory ret)
    {
        if (bytes(label).length < 1) {
            revert LabelTooShort();
        }
        if (bytes(label).length > 255) {
            revert LabelTooLong(label);
        }
        return abi.encodePacked(uint8(bytes(label).length), label, name);
    }

    function _mint(
        bytes32 node,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal override {
        address oldWrappedOwner = ownerOf(uint256(node));
        _canFusesBeBurned(node, fuses);
        if (oldWrappedOwner != address(0)) {
            // burn and unwrap old token of old owner
            _burn(uint256(node));
            emit NameUnwrapped(node, address(0));
        }
        super._mint(node, wrappedOwner, fuses, expiry);
    }

    function _wrap(
        bytes32 node,
        bytes memory name,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        names[node] = name;
        _mint(node, wrappedOwner, fuses, expiry);
        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);
    }

    function _addLabelAndWrap(
        bytes32 parentNode,
        bytes32 node,
        string memory label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        bytes memory name = _addLabel(label, names[parentNode]);
        _wrap(node, name, newOwner, fuses, expiry);
    }

    function _prepareUpgrade(bytes32 node)
        private
        returns (uint32 fuses, uint64 expiry)
    {
        if (address(upgradeContract) == address(0)) {
            revert CannotUpgrade();
        }

        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        (fuses, expiry) = getFuses(node);

        // burn token and fuse data
        _burn(uint256(node));
    }

    function _transferAndBurnFuses(
        bytes32 node,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        (address owner, , ) = getData(uint256(node));
        _transfer(owner, newOwner, uint256(node), 1, "");
        _setFuses(node, newOwner, fuses, expiry);
    }

    // wrapper function for stack limit
    function _getDataAndNormaliseExpiry(
        bytes32 parentNode,
        bytes32 node,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        (, , uint64 maxExpiry) = getData(uint256(parentNode));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _getETH2LDDataAndNormaliseExpiry(
        bytes32 node,
        bytes32 labelhash,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _normaliseExpiry(
        uint64 expiry,
        uint64 oldExpiry,
        uint64 maxExpiry
    ) internal pure returns (uint64) {
        // Expiry cannot be more than maximum allowed
        // .eth names will check registrar, non .eth check parent
        if (expiry > maxExpiry) {
            expiry = maxExpiry;
        }
        // Expiry cannot be less than old expiry
        if (expiry < oldExpiry) {
            expiry = oldExpiry;
        }

        return expiry;
    }

    function _wrapETH2LD(
        string memory label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) private returns (uint64) {
        // Mint a new ERC1155 token with fuses
        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);

        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(
            node,
            labelhash,
            expiry
        );

        _addLabelAndWrap(
            ETH_NODE,
            node,
            label,
            wrappedOwner,
            fuses | PARENT_CANNOT_CONTROL,
            expiry
        );
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        return expiry;
    }

    function _unwrap(bytes32 node, address newOwner) private {
        if (newOwner == address(0x0) || newOwner == address(this)) {
            revert IncorrectTargetOwner(newOwner);
        }

        if (allFusesBurned(node, CANNOT_UNWRAP)) {
            revert OperationProhibited(node);
        }

        // Burn token and fuse data
        _burn(uint256(node));
        ens.setOwner(node, newOwner);

        emit NameUnwrapped(node, newOwner);
    }

    function _setFuses(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _setData(node, owner, fuses, expiry);
        emit FusesSet(node, fuses, expiry);
    }

    function _setData(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _canFusesBeBurned(node, fuses);
        super._setData(uint256(node), owner, fuses, expiry);
    }

    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
        if (
            fuses & ~PARENT_CANNOT_CONTROL != 0 &&
            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
        ) {
            revert OperationProhibited(node);
        }
    }
}


**project_name**: RealWorld_BA_145_NameWrapper

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_145_NameWrapper_RealWord_20240901203521.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-01-09 20:35:21 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | //SPDX-License-Identifier: MIT pragma solidity ^0.8.4; import "./ERC1155Fuse.sol"; import "./Controllable.sol"; import "./INameWrapper.sol"; import "./INameWrapperUpgrade.sol"; import "./IMetadataService.sol"; import "../registry/ENS.sol"; import "../ethregistrar/IBaseRegistrar.sol"; import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "./BytesUtil.sol"; error Unauthorised(bytes32 node, address addr); error NameNotFound(); error IncompatibleParent(); error IncompatibleName(bytes name); error IncorrectTokenType(); error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash); error LabelTooShort(); error LabelTooLong(string label); error IncorrectTargetOwner(address owner); error CannotUpgrade(); error InvalidExpiry(bytes32 node, uint64 expiry); contract NameWrapper is     Ownable,     ERC1155Fuse,     INameWrapper,     Controllable,     IERC721Receiver {     using BytesUtils for bytes;     ENS public immutable override ens;     IBaseRegistrar public immutable override registrar;     IMetadataService public override metadataService;     mapping(bytes32 =&gt; bytes) public override names; bytes32 private constant ETH_NODE =     0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae; bytes32 private constant ROOT_NODE =     0x0000000000000000000000000000000000000000000000000000000000000000;  //A contract address to a new upgraded contract if any INameWrapperUpgrade public upgradeContract; uint64 private constant MAX_EXPIRY = type(uint64).max;  constructor(     ENS _ens,     IBaseRegistrar _registrar,     IMetadataService _metadataService ) {     ens = _ens;     registrar = _registrar;     metadataService = _metadataService;      /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */      _setData(         uint256(ETH_NODE),         address(0),         uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),         MAX_EXPIRY     );     _setData(         uint256(ROOT_NODE),         address(0),         uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),         MAX_EXPIRY     );     names[ROOT_NODE] = "\x00";     names[ETH_NODE] = "\x03eth\x00"; }  function supportsInterface(bytes4 interfaceId)     public     view     virtual     override(ERC1155Fuse, IERC165)     returns (bool) {     return         interfaceId == type(INameWrapper).interfaceId ||         super.supportsInterface(interfaceId); }  /* ERC1155 */  function ownerOf(uint256 id)     public     view     override(ERC1155Fuse, INameWrapper)     returns (address owner) {     return super.ownerOf(id); }  /* Metadata service */  /**  * @notice Set the metadata service. Only the owner can do this  */  function setMetadataService(IMetadataService _newMetadataService)     public     onlyOwner {     metadataService = _newMetadataService; }  /**  * @notice Get the metadata uri  * @return String uri of the metadata service  */  function uri(uint256 tokenId) public view override returns (string memory) {     return metadataService.uri(tokenId); }  /**  * @notice Set the address of the upgradeContract of the contract. only admin can do this  * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time  * to make the contract not upgradable.  * @param _upgradeAddress address of an upgraded contract  */  function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)     public     onlyOwner {     if (address(upgradeContract) != address(0)) {         registrar.setApprovalForAll(address(upgradeContract), false);         ens.setApprovalForAll(address(upgradeContract), false);     }      upgradeContract = _upgradeAddress;      if (address(upgradeContract) != address(0)) {         registrar.setApprovalForAll(address(upgradeContract), true);         ens.setApprovalForAll(address(upgradeContract), true);     } }  /**  * @notice Checks if msg.sender is the owner or approved by the owner of a name  * @param node namehash of the name to check  */  modifier onlyTokenOwner(bytes32 node) {     if (!isTokenOwnerOrApproved(node, msg.sender)) {         revert Unauthorised(node, msg.sender);     }      _; }  /**  * @notice Checks if owner or approved by owner  * @param node namehash of the name to check  * @param addr which address to check permissions for  * @return whether or not is owner or approved  */  function isTokenOwnerOrApproved(bytes32 node, address addr)     public     view     override     returns (bool) {     address owner = ownerOf(uint256(node));     return owner == addr || isApprovedForAll(owner, addr); }  /**  * @notice Gets fuse permissions for a specific name  * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit  *      The interface has predefined fuses for all registry permissions, but additional  *      fuses can be added for other use cases  *      Also returns expiry, which is when the fuses are set to expire.  * @param node namehash of the name to check  * @return fuses A number that represents the permissions a name has. Returns 0 when expiry &lt; block.timestamp  * @return expiry Unix time of when the name expires and fuses are to expire  */ function getFuses(bytes32 node)     public     view     override     returns (uint32 fuses, uint64 expiry) {     (, fuses, expiry) = getData(uint256(node));     if (fuses == 0 &amp;&amp; expiry == 0) {         bytes memory name = names[node];         if (name.length == 0) {             revert NameNotFound();         }     } }  /**  * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract  * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar  * @param label label as a string of the .eth domain to wrap  * @param wrappedOwner Owner of the name in this contract  * @param fuses initial fuses to set  * @param expiry when the fuses will expire  * @param resolver resolver contract address  */  function wrapETH2LD(     string calldata label,     address wrappedOwner,     uint32 fuses,     uint64 expiry,     address resolver ) public override returns (uint64) {     uint256 tokenId = uint256(keccak256(bytes(label)));     address registrant = registrar.ownerOf(tokenId);     if (         registrant != msg.sender &amp;&amp;         !isApprovedForAll(registrant, msg.sender) &amp;&amp;         !registrar.isApprovedForAll(registrant, msg.sender)     ) {         revert Unauthorised(             _makeNode(ETH_NODE, bytes32(tokenId)),             msg.sender         );     }      // transfer the token from the user to this contract     registrar.transferFrom(registrant, address(this), tokenId);      // transfer the ens record back to the new owner (this contract)     registrar.reclaim(tokenId, address(this));      return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver); }  /**  * @dev Registers a new .eth second-level domain and wraps it.  *      Only callable by authorised controllers.  * @param label The label to register (Eg, 'foo' for 'foo.eth').  * @param wrappedOwner The owner of the wrapped name.  * @param duration The duration, in seconds, to register the name for.  * @param resolver The resolver address to set on the ENS registry (optional).  * @param fuses initial fuses to set  * @param expiry when the fuses will expire  * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.  */  function registerAndWrapETH2LD(     string calldata label,     address wrappedOwner,     uint256 duration,     address resolver,     uint32 fuses,     uint64 expiry ) external override onlyController returns (uint256 registrarExpiry) {     uint256 tokenId = uint256(keccak256(bytes(label)));     registrarExpiry = registrar.register(tokenId, address(this), duration);     _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver); }  /**  * @dev Renews a .eth second-level domain.  *      Only callable by authorised controllers.  * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').  * @param duration The number of seconds to renew the name for.  * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.  */ function renew(     uint256 tokenId,     uint256 duration,     uint64 expiry ) external override onlyController returns (uint256 expires) {     bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));      expires = registrar.renew(tokenId, duration);     (address owner, uint32 fuses, uint64 oldExpiry) = getData(         uint256(node)     );     expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));      _setData(node, owner, fuses, expiry); }  /**  * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner in the registry or an authorised caller in the registry  * @param name The name to wrap, in DNS format  * @param wrappedOwner Owner of the name in this contract  * @param resolver resolver contract address  */  function wrap(     bytes calldata name,     address wrappedOwner,     address resolver ) public override {     (bytes32 labelhash, uint256 offset) = name.readLabel(0);     bytes32 parentNode = name.namehash(offset);     bytes32 node = _makeNode(parentNode, labelhash);      if (parentNode == ETH_NODE) {         revert IncompatibleParent();     }      address owner = ens.owner(node);      if (         owner != msg.sender &amp;&amp;         !isApprovedForAll(owner, msg.sender) &amp;&amp;         !ens.isApprovedForAll(owner, msg.sender)     ) {         revert Unauthorised(node, msg.sender);     }      if (resolver != address(0)) {         ens.setResolver(node, resolver);     }      ens.setOwner(node, address(this));      _wrap(node, name, wrappedOwner, 0, 0); }  /**  * @notice Unwraps a .eth domain. e.g. vitalik.eth  * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper  * @param labelhash labelhash of the .eth domain  * @param newRegistrant sets the owner in the .eth registrar to this address  * @param newController sets the owner in the registry to this address  */  function unwrapETH2LD(     bytes32 labelhash,     address newRegistrant,     address newController ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {     _unwrap(_makeNode(ETH_NODE, labelhash), newController);     registrar.transferFrom(         address(this),         newRegistrant,         uint256(labelhash)     ); }  /**  * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper  * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')  * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')  * @param newController sets the owner in the registry to this address  */  function unwrap(     bytes32 parentNode,     bytes32 labelhash,     address newController ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {     if (parentNode == ETH_NODE) {         revert IncompatibleParent();     }     _unwrap(_makeNode(parentNode, labelhash), newController); }  /**  * @notice Sets fuses of a name  * @param node namehash of the name  * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)  */  function setFuses(bytes32 node, uint32 fuses)     public     onlyTokenOwner(node)     operationAllowed(node, CANNOT_BURN_FUSES)     returns (uint32) {     if (fuses &amp; PARENT_CANNOT_CONTROL != 0) {         // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.         revert Unauthorised(node, msg.sender);     }      (address owner, uint32 oldFuses, uint64 expiry) = getData(         uint256(node)     );      fuses |= oldFuses;     _setFuses(node, owner, fuses, expiry);     return fuses; }  /**  * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract  *     and burning the token of this contract  * @dev Can be called by the owner of the name in this contract  * @param label Label as a string of the .eth name to upgrade  * @param wrappedOwner The owner of the wrapped name  */  function upgradeETH2LD(     string calldata label,     address wrappedOwner,     address resolver ) public {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(ETH_NODE, labelhash);     (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);      upgradeContract.wrapETH2LD(         label,         wrappedOwner,         fuses,         expiry,         resolver     ); }  /**  * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner or an authorised caller  * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names  * @param parentNode namehash of the parent name  * @param label Label as a string of the name to upgrade  * @param wrappedOwner Owner of the name in this contract  * @param resolver resolver contract for this name  */  function upgrade(     bytes32 parentNode,     string calldata label,     address wrappedOwner,     address resolver ) public {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(parentNode, labelhash);     (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);     upgradeContract.setSubnodeRecord(         parentNode,         label,         wrappedOwner,         resolver,         0,         fuses,         expiry     ); }  /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name  * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')  * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')  * @param fuses fuses to burn  * @param expiry when the fuses will expire  */  function setChildFuses(     bytes32 parentNode,     bytes32 labelhash,     uint32 fuses,     uint64 expiry ) public {     bytes32 node = _makeNode(parentNode, labelhash);     (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(         uint256(node)     );     uint64 maxExpiry;     if (parentNode == ETH_NODE) {         if (!isTokenOwnerOrApproved(node, msg.sender)) {             revert Unauthorised(node, msg.sender);         }         // max expiry is set to the expiry on the registrar         maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));     } else {         if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {             revert Unauthorised(node, msg.sender);         }          // max expiry is set to the expiry of the parent         (, , maxExpiry) = getData(uint256(parentNode));     }      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);      // if PARENT_CANNOT_CONTROL has been burned and fuses have changed     if (         oldFuses &amp; PARENT_CANNOT_CONTROL != 0 &amp;&amp;         oldFuses | fuses != oldFuses     ) {         revert OperationProhibited(node);     }     fuses |= oldFuses;     _setFuses(node, owner, fuses, expiry); }  /**  * @notice Sets the subdomain owner in the registry and then wraps the subdomain  * @param parentNode parent namehash of the subdomain  * @param label label of the subdomain as a string  * @param newOwner newOwner in the registry  * @param fuses initial fuses for the wrapped subdomain  * @param expiry when the fuses will expire  */  function setSubnodeOwner(     bytes32 parentNode,     string calldata label,     address newOwner,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))     returns (bytes32 node) {     bytes32 labelhash = keccak256(bytes(label));     node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);      if (ens.owner(node) != address(this)) {         ens.setSubnodeOwner(parentNode, labelhash, address(this));         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } }  /**  * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain  * @param parentNode parent namehash of the subdomain  * @param label label of the subdomain as a string  * @param newOwner newOwner in the registry  * @param resolver resolver contract in the registry  * @param ttl ttl in the regsitry  * @param fuses initial fuses for the wrapped subdomain  * @param expiry expiry date for the domain  */  function setSubnodeRecord(     bytes32 parentNode,     string memory label,     address newOwner,     address resolver,     uint64 ttl,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label))) {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);     if (ens.owner(node) != address(this)) {         ens.setSubnodeRecord(             parentNode,             labelhash,             address(this),             resolver,             ttl         );         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         ens.setSubnodeRecord(             parentNode,             labelhash,             address(this),             resolver,             ttl         );         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } }  /**  * @notice Sets records for the name in the ENS Registry  * @param node namehash of the name to set a record for  * @param owner newOwner in the registry  * @param resolver the resolver contract  * @param ttl ttl in the registry  */  function setRecord(     bytes32 node,     address owner,     address resolver,     uint64 ttl )     public     override     onlyTokenOwner(node)     operationAllowed(         node,         CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL     ) {     ens.setRecord(node, address(this), resolver, ttl);     (address oldOwner, , ) = getData(uint256(node));     _transfer(oldOwner, owner, uint256(node), 1, ""); }  /**  * @notice Sets resolver contract in the registry  * @param node namehash of the name  * @param resolver the resolver contract  */  function setResolver(bytes32 node, address resolver)     public     override     onlyTokenOwner(node)     operationAllowed(node, CANNOT_SET_RESOLVER) {     ens.setResolver(node, resolver); }  /**  * @notice Sets TTL in the registry  * @param node namehash of the name  * @param ttl TTL in the registry  */  function setTTL(bytes32 node, uint64 ttl)     public     override     onlyTokenOwner(node)     operationAllowed(node, CANNOT_SET_TTL) {     ens.setTTL(node, ttl); }  /**  * @dev Allows an operation only if none of the specified fuses are burned.  * @param node The namehash of the name to check fuses on.  * @param fuseMask A bitmask of fuses that must not be burned.  */  modifier operationAllowed(bytes32 node, uint32 fuseMask) {     (, uint32 fuses, ) = getData(uint256(node));     if (fuses &amp; fuseMask != 0) {         revert OperationProhibited(node);     }     _; }  /**  * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord  * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt  *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for  *      replacing a subdomain. If either conditions are true, then it is possible to call  *      setSubnodeOwner  * @param node namehash of the name to check  * @param labelhash labelhash of the name to check  */  modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {     bytes32 subnode = _makeNode(node, labelhash);     address owner = ens.owner(subnode);      if (owner == address(0)) {         (, uint32 fuses, ) = getData(uint256(node));         if (fuses &amp; CANNOT_CREATE_SUBDOMAIN != 0) {             revert OperationProhibited(node);         }     } else {         (, uint32 subnodeFuses, ) = getData(uint256(subnode));         if (subnodeFuses &amp; PARENT_CANNOT_CONTROL != 0) {             revert OperationProhibited(node);         }     }      _; }  /**  * @notice Checks all Fuses in the mask are burned for the node  * @param node namehash of the name  * @param fuseMask the fuses you want to check  * @return Boolean of whether or not all the selected fuses are burned  */  function allFusesBurned(bytes32 node, uint32 fuseMask)     public     view     override     returns (bool) {     (, uint32 fuses, ) = getData(uint256(node));     return fuses &amp; fuseMask == fuseMask; }  function onERC721Received(     address to,     address,     uint256 tokenId,     bytes calldata data ) public override returns (bytes4) {     //check if it's the eth registrar ERC721     if (msg.sender != address(registrar)) {         revert IncorrectTokenType();     }      (         string memory label,         address owner,         uint32 fuses,         uint64 expiry,         address resolver     ) = abi.decode(data, (string, address, uint32, uint64, address));      bytes32 labelhash = bytes32(tokenId);     bytes32 labelhashFromData = keccak256(bytes(label));      if (labelhashFromData != labelhash) {         revert LabelMismatch(labelhashFromData, labelhash);     }      // transfer the ens record back to the new owner (this contract)     registrar.reclaim(uint256(labelhash), address(this));      _wrapETH2LD(label, owner, fuses, expiry, resolver);      return IERC721Receiver(to).onERC721Received.selector; }  /***** Internal functions */  function _canTransfer(uint32 fuses) internal pure override returns (bool) {     return fuses &amp; CANNOT_TRANSFER == 0; }  function _makeNode(bytes32 node, bytes32 labelhash)     private     pure     returns (bytes32) {     return keccak256(abi.encodePacked(node, labelhash)); }  function _addLabel(string memory label, bytes memory name)     internal     pure     returns (bytes memory ret) {     if (bytes(label).length &lt; 1) {         revert LabelTooShort();     }     if (bytes(label).length &gt; 255) {         revert LabelTooLong(label);     }     return abi.encodePacked(uint8(bytes(label).length), label, name); }  function _mint(     bytes32 node,     address wrappedOwner,     uint32 fuses,     uint64 expiry ) internal override {     address oldWrappedOwner = ownerOf(uint256(node));     _canFusesBeBurned(node, fuses);     if (oldWrappedOwner != address(0)) {         // burn and unwrap old token of old owner         _burn(uint256(node));         emit NameUnwrapped(node, address(0));     }     super._mint(node, wrappedOwner, fuses, expiry); }  function _wrap(     bytes32 node,     bytes memory name,     address wrappedOwner,     uint32 fuses,     uint64 expiry ) internal {     names[node] = name;     _mint(node, wrappedOwner, fuses, expiry);     emit NameWrapped(node, name, wrappedOwner, fuses, expiry); }  function _addLabelAndWrap(     bytes32 parentNode,     bytes32 node,     string memory label,     address newOwner,     uint32 fuses,     uint64 expiry ) internal {     bytes memory name = _addLabel(label, names[parentNode]);     _wrap(node, name, newOwner, fuses, expiry); }  function _prepareUpgrade(bytes32 node)     private     returns (uint32 fuses, uint64 expiry) {     if (address(upgradeContract) == address(0)) {         revert CannotUpgrade();     }      if (!isTokenOwnerOrApproved(node, msg.sender)) {         revert Unauthorised(node, msg.sender);     }      (fuses, expiry) = getFuses(node);      // burn token and fuse data     _burn(uint256(node)); }  function _transferAndBurnFuses(     bytes32 node,     address newOwner,     uint32 fuses,     uint64 expiry ) internal {     (address owner, , ) = getData(uint256(node));     _transfer(owner, newOwner, uint256(node), 1, "");     _setFuses(node, newOwner, fuses, expiry); }  // wrapper function for stack limit function _getDataAndNormaliseExpiry(     bytes32 parentNode,     bytes32 node,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     (, , uint64 maxExpiry) = getData(uint256(parentNode));      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); }  function _getETH2LDDataAndNormaliseExpiry(     bytes32 node,     bytes32 labelhash,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); }  function _normaliseExpiry(     uint64 expiry,     uint64 oldExpiry,     uint64 maxExpiry ) internal pure returns (uint64) {     // Expiry cannot be more than maximum allowed     // .eth names will check registrar, non .eth check parent     if (expiry &gt; maxExpiry) {         expiry = maxExpiry;     }     // Expiry cannot be less than old expiry     if (expiry &lt; oldExpiry) {         expiry = oldExpiry;     }      return expiry; }  function _wrapETH2LD(     string memory label,     address wrappedOwner,     uint32 fuses,     uint64 expiry,     address resolver ) private returns (uint64) {     // Mint a new ERC1155 token with fuses     // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(ETH_NODE, labelhash);      (, , expiry) = _getETH2LDDataAndNormaliseExpiry(         node,         labelhash,         expiry     );      _addLabelAndWrap(         ETH_NODE,         node,         label,         wrappedOwner,         fuses | PARENT_CANNOT_CONTROL,         expiry     );     if (resolver != address(0)) {         ens.setResolver(node, resolver);     }      return expiry; }  function _unwrap(bytes32 node, address newOwner) private {     if (newOwner == address(0x0) || newOwner == address(this)) {         revert IncorrectTargetOwner(newOwner);     }      if (allFusesBurned(node, CANNOT_UNWRAP)) {         revert OperationProhibited(node);     }      // Burn token and fuse data     _burn(uint256(node));     ens.setOwner(node, newOwner);      emit NameUnwrapped(node, newOwner); }  function _setFuses(     bytes32 node,     address owner,     uint32 fuses,     uint64 expiry ) internal {     _setData(node, owner, fuses, expiry);     emit FusesSet(node, fuses, expiry); }  function _setData(     bytes32 node,     address owner,     uint32 fuses,     uint64 expiry ) internal {     _canFusesBeBurned(node, fuses);     super._setData(uint256(node), owner, fuses, expiry); }  function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {     if (         fuses &amp; ~PARENT_CANNOT_CONTROL != 0 &amp;&amp;         fuses &amp; (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=         (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)     ) {         revert OperationProhibited(node);     } }  } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport "./ERC1155Fuse.sol";\nimport "./Controllable.sol";\nimport "./INameWrapper.sol";\nimport "./INameWrapperUpgrade.sol";\nimport "./IMetadataService.sol";\nimport "../registry/ENS.sol";\nimport "../ethregistrar/IBaseRegistrar.sol";\nimport "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";\nimport "@openzeppelin/contracts/access/Ownable.sol";\nimport "./BytesUtil.sol";\n\nerror Unauthorised(bytes32 node, address addr);\nerror NameNotFound();\nerror IncompatibleParent();\nerror IncompatibleName(bytes name);\nerror IncorrectTokenType();\nerror LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);\nerror LabelTooShort();\nerror LabelTooLong(string label);\nerror IncorrectTargetOwner(address owner);\nerror CannotUpgrade();\nerror InvalidExpiry(bytes32 node, uint64 expiry);\n\ncontract NameWrapper is\n    Ownable,\n    ERC1155Fuse,\n    INameWrapper,\n    Controllable,\n    IERC721Receiver\n{\n    using BytesUtils for bytes;\n    ENS public immutable override ens;\n    IBaseRegistrar public immutable override registrar;\n    IMetadataService public override metadataService;\n    mapping(bytes32 =&gt; bytes) public override names;\n\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n    bytes32 private constant ROOT_NODE =\n        0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    //A contract address to a new upgraded contract if any\n    INameWrapperUpgrade public upgradeContract;\n    uint64 private constant MAX_EXPIRY = type(uint64).max;\n\n    constructor(\n        ENS _ens,\n        IBaseRegistrar _registrar,\n        IMetadataService _metadataService\n    ) {\n        ens = _ens;\n        registrar = _registrar;\n        metadataService = _metadataService;\n\n        / Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE /\n\n        _setData(\n            uint256(ETH_NODE),\n            address(0),\n            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),\n            MAX_EXPIRY\n        );\n        _setData(\n            uint256(ROOT_NODE),\n            address(0),\n            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),\n            MAX_EXPIRY\n        );\n        names[ROOT_NODE] = "\x00";\n        names[ETH_NODE] = "\x03eth\x00";\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC1155Fuse, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(INameWrapper).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    / ERC1155 /\n\n    function ownerOf(uint256 id)\n        public\n        view\n        override(ERC1155Fuse, INameWrapper)\n        returns (address owner)\n    {\n        return super.ownerOf(id);\n    }\n\n    / Metadata service /\n\n    /\n     * @notice Set the metadata service. Only the owner can do this\n     /\n\n    function setMetadataService(IMetadataService _newMetadataService)\n        public\n        onlyOwner\n    {\n        metadataService = _newMetadataService;\n    }\n\n    /\n     * @notice Get the metadata uri\n     * @return String uri of the metadata service\n     */\n\n    function uri(uint256 tokenId) public view override returns (string memory) {\n        return metadataService.uri(tokenId);\n    }\n\n    /\n     * @notice Set the address of the upgradeContract of the contract. only admin can do this\n     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time\n     * to make the contract not upgradable.\n     * @param _upgradeAddress address of an upgraded contract\n     /\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)\n        public\n        onlyOwner\n    {\n        if (address(upgradeContract) != address(0)) {\n            registrar.setApprovalForAll(address(upgradeContract), false);\n            ens.setApprovalForAll(address(upgradeContract), false);\n        }\n\n        upgradeContract = _upgradeAddress;\n\n        if (address(upgradeContract) != address(0)) {\n            registrar.setApprovalForAll(address(upgradeContract), true);\n            ens.setApprovalForAll(address(upgradeContract), true);\n        }\n    }\n\n    /\n     * @notice Checks if msg.sender is the owner or approved by the owner of a name\n     * @param node namehash of the name to check\n     /\n\n    modifier onlyTokenOwner(bytes32 node) {\n        if (!isTokenOwnerOrApproved(node, msg.sender)) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        _;\n    }\n\n    /\n     * @notice Checks if owner or approved by owner\n     * @param node namehash of the name to check\n     * @param addr which address to check permissions for\n     * @return whether or not is owner or approved\n     */\n\n    function isTokenOwnerOrApproved(bytes32 node, address addr)\n        public\n        view\n        override\n        returns (bool)\n    {\n        address owner = ownerOf(uint256(node));\n        return owner == addr || isApprovedForAll(owner, addr);\n    }\n\n    /\n     * @notice Gets fuse permissions for a specific name\n     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit\n     *      The interface has predefined fuses for all registry permissions, but additional\n     *      fuses can be added for other use cases\n     *      Also returns expiry, which is when the fuses are set to expire.\n     * @param node namehash of the name to check\n     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry &lt; block.timestamp\n     * @return expiry Unix time of when the name expires and fuses are to expire\n     /\n    function getFuses(bytes32 node)\n        public\n        view\n        override\n        returns (uint32 fuses, uint64 expiry)\n    {\n        (, fuses, expiry) = getData(uint256(node));\n        if (fuses == 0 &amp;&amp; expiry == 0) {\n            bytes memory name = names[node];\n            if (name.length == 0) {\n                revert NameNotFound();\n            }\n        }\n    }\n\n    /\n     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract\n     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar\n     * @param label label as a string of the .eth domain to wrap\n     * @param wrappedOwner Owner of the name in this contract\n     * @param fuses initial fuses to set\n     * @param expiry when the fuses will expire\n     * @param resolver resolver contract address\n     /\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address resolver\n    ) public override returns (uint64) {\n        uint256 tokenId = uint256(keccak256(bytes(label)));\n        address registrant = registrar.ownerOf(tokenId);\n        if (\n            registrant != msg.sender &amp;&amp;\n            !isApprovedForAll(registrant, msg.sender) &amp;&amp;\n            !registrar.isApprovedForAll(registrant, msg.sender)\n        ) {\n            revert Unauthorised(\n                _makeNode(ETH_NODE, bytes32(tokenId)),\n                msg.sender\n            );\n        }\n\n        // transfer the token from the user to this contract\n        registrar.transferFrom(registrant, address(this), tokenId);\n\n        // transfer the ens record back to the new owner (this contract)\n        registrar.reclaim(tokenId, address(this));\n\n        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);\n    }\n\n    /\n     * @dev Registers a new .eth second-level domain and wraps it.\n     *      Only callable by authorised controllers.\n     * @param label The label to register (Eg, \'foo\' for \'foo.eth\').\n     * @param wrappedOwner The owner of the wrapped name.\n     * @param duration The duration, in seconds, to register the name for.\n     * @param resolver The resolver address to set on the ENS registry (optional).\n     * @param fuses initial fuses to set\n     * @param expiry when the fuses will expire\n     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.\n     */\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint32 fuses,\n        uint64 expiry\n    ) external override onlyController returns (uint256 registrarExpiry) {\n        uint256 tokenId = uint256(keccak256(bytes(label)));\n        registrarExpiry = registrar.register(tokenId, address(this), duration);\n        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);\n    }\n\n    /\n     * @dev Renews a .eth second-level domain.\n     *      Only callable by authorised controllers.\n     * @param tokenId The hash of the label to register (eg, keccak256(\'foo\'), for \'foo.eth\').\n     * @param duration The number of seconds to renew the name for.\n     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.\n     /\n    function renew(\n        uint256 tokenId,\n        uint256 duration,\n        uint64 expiry\n    ) external override onlyController returns (uint256 expires) {\n        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));\n\n        expires = registrar.renew(tokenId, duration);\n        (address owner, uint32 fuses, uint64 oldExpiry) = getData(\n            uint256(node)\n        );\n        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));\n\n        _setData(node, owner, fuses, expiry);\n    }\n\n    /\n     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner in the registry or an authorised caller in the registry\n     * @param name The name to wrap, in DNS format\n     * @param wrappedOwner Owner of the name in this contract\n     * @param resolver resolver contract address\n     /\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) public override {\n        (bytes32 labelhash, uint256 offset) = name.readLabel(0);\n        bytes32 parentNode = name.namehash(offset);\n        bytes32 node = _makeNode(parentNode, labelhash);\n\n        if (parentNode == ETH_NODE) {\n            revert IncompatibleParent();\n        }\n\n        address owner = ens.owner(node);\n\n        if (\n            owner != msg.sender &amp;&amp;\n            !isApprovedForAll(owner, msg.sender) &amp;&amp;\n            !ens.isApprovedForAll(owner, msg.sender)\n        ) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        if (resolver != address(0)) {\n            ens.setResolver(node, resolver);\n        }\n\n        ens.setOwner(node, address(this));\n\n        _wrap(node, name, wrappedOwner, 0, 0);\n    }\n\n    /\n     * @notice Unwraps a .eth domain. e.g. vitalik.eth\n     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper\n     * @param labelhash labelhash of the .eth domain\n     * @param newRegistrant sets the owner in the .eth registrar to this address\n     * @param newController sets the owner in the registry to this address\n     */\n\n    function unwrapETH2LD(\n        bytes32 labelhash,\n        address newRegistrant,\n        address newController\n    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {\n        _unwrap(_makeNode(ETH_NODE, labelhash), newController);\n        registrar.transferFrom(\n            address(this),\n            newRegistrant,\n            uint256(labelhash)\n        );\n    }\n\n    /\n     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper\n     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash(\'xyz\')\n     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256(\'vitalik\')\n     * @param newController sets the owner in the registry to this address\n     /\n\n    function unwrap(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        address newController\n    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {\n        if (parentNode == ETH_NODE) {\n            revert IncompatibleParent();\n        }\n        _unwrap(_makeNode(parentNode, labelhash), newController);\n    }\n\n    /\n     * @notice Sets fuses of a name\n     * @param node namehash of the name\n     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)\n     /\n\n    function setFuses(bytes32 node, uint32 fuses)\n        public\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_BURN_FUSES)\n        returns (uint32)\n    {\n        if (fuses &amp; PARENT_CANNOT_CONTROL != 0) {\n            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.\n            revert Unauthorised(node, msg.sender);\n        }\n\n        (address owner, uint32 oldFuses, uint64 expiry) = getData(\n            uint256(node)\n        );\n\n        fuses |= oldFuses;\n        _setFuses(node, owner, fuses, expiry);\n        return fuses;\n    }\n\n    /\n     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract\n     *     and burning the token of this contract\n     * @dev Can be called by the owner of the name in this contract\n     * @param label Label as a string of the .eth name to upgrade\n     * @param wrappedOwner The owner of the wrapped name\n     */\n\n    function upgradeETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        address resolver\n    ) public {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(ETH_NODE, labelhash);\n        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n\n        upgradeContract.wrapETH2LD(\n            label,\n            wrappedOwner,\n            fuses,\n            expiry,\n            resolver\n        );\n    }\n\n    /\n     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner or an authorised caller\n     * Requires upgraded Namewrapper to permit old Namewrapper to call setSubnodeRecord for all names\n     * @param parentNode namehash of the parent name\n     * @param label Label as a string of the name to upgrade\n     * @param wrappedOwner Owner of the name in this contract\n     * @param resolver resolver contract for this name\n     /\n\n    function upgrade(\n        bytes32 parentNode,\n        string calldata label,\n        address wrappedOwner,\n        address resolver\n    ) public {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n        upgradeContract.setSubnodeRecord(\n            parentNode,\n            label,\n            wrappedOwner,\n            resolver,\n            0,\n            fuses,\n            expiry\n        );\n    }\n\n    / @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name\n     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash(\'xyz\')\n     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256(\'vitalik\')\n     * @param fuses fuses to burn\n     * @param expiry when the fuses will expire\n     /\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) public {\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(\n            uint256(node)\n        );\n        uint64 maxExpiry;\n        if (parentNode == ETH_NODE) {\n            if (!isTokenOwnerOrApproved(node, msg.sender)) {\n                revert Unauthorised(node, msg.sender);\n            }\n            // max expiry is set to the expiry on the registrar\n            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));\n        } else {\n            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {\n                revert Unauthorised(node, msg.sender);\n            }\n\n            // max expiry is set to the expiry of the parent\n            (, , maxExpiry) = getData(uint256(parentNode));\n        }\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n\n        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed\n        if (\n            oldFuses &amp; PARENT_CANNOT_CONTROL != 0 &amp;&amp;\n            oldFuses | fuses != oldFuses\n        ) {\n            revert OperationProhibited(node);\n        }\n        fuses |= oldFuses;\n        _setFuses(node, owner, fuses, expiry);\n    }\n\n    /\n     * @notice Sets the subdomain owner in the registry and then wraps the subdomain\n     * @param parentNode parent namehash of the subdomain\n     * @param label label of the subdomain as a string\n     * @param newOwner newOwner in the registry\n     * @param fuses initial fuses for the wrapped subdomain\n     * @param expiry when the fuses will expire\n     /\n\n    function setSubnodeOwner(\n        bytes32 parentNode,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    )\n        public\n        onlyTokenOwner(parentNode)\n        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))\n        returns (bytes32 node)\n    {\n        bytes32 labelhash = keccak256(bytes(label));\n        node = _makeNode(parentNode, labelhash);\n        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);\n\n        if (ens.owner(node) != address(this)) {\n            ens.setSubnodeOwner(parentNode, labelhash, address(this));\n            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);\n        } else {\n            _transferAndBurnFuses(node, newOwner, fuses, expiry);\n        }\n    }\n\n    /\n     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain\n     * @param parentNode parent namehash of the subdomain\n     * @param label label of the subdomain as a string\n     * @param newOwner newOwner in the registry\n     * @param resolver resolver contract in the registry\n     * @param ttl ttl in the regsitry\n     * @param fuses initial fuses for the wrapped subdomain\n     * @param expiry expiry date for the domain\n     */\n\n    function setSubnodeRecord(\n        bytes32 parentNode,\n        string memory label,\n        address newOwner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    )\n        public\n        onlyTokenOwner(parentNode)\n        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))\n    {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);\n        if (ens.owner(node) != address(this)) {\n            ens.setSubnodeRecord(\n                parentNode,\n                labelhash,\n                address(this),\n                resolver,\n                ttl\n            );\n            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);\n        } else {\n            ens.setSubnodeRecord(\n                parentNode,\n                labelhash,\n                address(this),\n                resolver,\n                ttl\n            );\n            _transferAndBurnFuses(node, newOwner, fuses, expiry);\n        }\n    }\n\n    /\n     * @notice Sets records for the name in the ENS Registry\n     * @param node namehash of the name to set a record for\n     * @param owner newOwner in the registry\n     * @param resolver the resolver contract\n     * @param ttl ttl in the registry\n     /\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    )\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(\n            node,\n            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL\n        )\n    {\n        ens.setRecord(node, address(this), resolver, ttl);\n        (address oldOwner, , ) = getData(uint256(node));\n        _transfer(oldOwner, owner, uint256(node), 1, "");\n    }\n\n    /\n     * @notice Sets resolver contract in the registry\n     * @param node namehash of the name\n     * @param resolver the resolver contract\n     /\n\n    function setResolver(bytes32 node, address resolver)\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_SET_RESOLVER)\n    {\n        ens.setResolver(node, resolver);\n    }\n\n    /\n     * @notice Sets TTL in the registry\n     * @param node namehash of the name\n     * @param ttl TTL in the registry\n     */\n\n    function setTTL(bytes32 node, uint64 ttl)\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_SET_TTL)\n    {\n        ens.setTTL(node, ttl);\n    }\n\n    /\n     * @dev Allows an operation only if none of the specified fuses are burned.\n     * @param node The namehash of the name to check fuses on.\n     * @param fuseMask A bitmask of fuses that must not be burned.\n     /\n\n    modifier operationAllowed(bytes32 node, uint32 fuseMask) {\n        (, uint32 fuses, ) = getData(uint256(node));\n        if (fuses &amp; fuseMask != 0) {\n            revert OperationProhibited(node);\n        }\n        _;\n    }\n\n    /\n     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord\n     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt\n     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for\n     *      replacing a subdomain. If either conditions are true, then it is possible to call\n     *      setSubnodeOwner\n     * @param node namehash of the name to check\n     * @param labelhash labelhash of the name to check\n     /\n\n    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {\n        bytes32 subnode = makeNode(node, labelhash);\n        address owner = ens.owner(subnode);\n\n        if (owner == address(0)) {\n            (, uint32 fuses, ) = getData(uint256(node));\n            if (fuses &amp; CANNOT_CREATE_SUBDOMAIN != 0) {\n                revert OperationProhibited(node);\n            }\n        } else {\n            (, uint32 subnodeFuses, ) = getData(uint256(subnode));\n            if (subnodeFuses &amp; PARENT_CANNOT_CONTROL != 0) {\n                revert OperationProhibited(node);\n            }\n        }\n\n        ;\n    }\n\n    /*\n     * @notice Checks all Fuses in the mask are burned for the node\n     * @param node namehash of the name\n     * @param fuseMask the fuses you want to check\n     * @return Boolean of whether or not all the selected fuses are burned\n     /\n\n    function allFusesBurned(bytes32 node, uint32 fuseMask)\n        public\n        view\n        override\n        returns (bool)\n    {\n        (, uint32 fuses, ) = getData(uint256(node));\n        return fuses &amp; fuseMask == fuseMask;\n    }\n\n    function onERC721Received(\n        address to,\n        address,\n        uint256 tokenId,\n        bytes calldata data\n    ) public override returns (bytes4) {\n        //check if it\'s the eth registrar ERC721\n        if (msg.sender != address(registrar)) {\n            revert IncorrectTokenType();\n        }\n\n        (\n            string memory label,\n            address owner,\n            uint32 fuses,\n            uint64 expiry,\n            address resolver\n        ) = abi.decode(data, (string, address, uint32, uint64, address));\n\n        bytes32 labelhash = bytes32(tokenId);\n        bytes32 labelhashFromData = keccak256(bytes(label));\n\n        if (labelhashFromData != labelhash) {\n            revert LabelMismatch(labelhashFromData, labelhash);\n        }\n\n        // transfer the ens record back to the new owner (this contract)\n        registrar.reclaim(uint256(labelhash), address(this));\n\n        _wrapETH2LD(label, owner, fuses, expiry, resolver);\n\n        return IERC721Receiver(to).onERC721Received.selector;\n    }\n\n    /* Internal functions /\n\n    function _canTransfer(uint32 fuses) internal pure override returns (bool) {\n        return fuses &amp; CANNOT_TRANSFER == 0;\n    }\n\n    function _makeNode(bytes32 node, bytes32 labelhash)\n        private\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(node, labelhash));\n    }\n\n    function _addLabel(string memory label, bytes memory name)\n        internal\n        pure\n        returns (bytes memory ret)\n    {\n        if (bytes(label).length &lt; 1) {\n            revert LabelTooShort();\n        }\n        if (bytes(label).length &gt; 255) {\n            revert LabelTooLong(label);\n        }\n        return abi.encodePacked(uint8(bytes(label).length), label, name);\n    }\n\n    function _mint(\n        bytes32 node,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal override {\n        address oldWrappedOwner = ownerOf(uint256(node));\n        _canFusesBeBurned(node, fuses);\n        if (oldWrappedOwner != address(0)) {\n            // burn and unwrap old token of old owner\n            _burn(uint256(node));\n            emit NameUnwrapped(node, address(0));\n        }\n        super._mint(node, wrappedOwner, fuses, expiry);\n    }\n\n    function _wrap(\n        bytes32 node,\n        bytes memory name,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        names[node] = name;\n        _mint(node, wrappedOwner, fuses, expiry);\n        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);\n    }\n\n    function _addLabelAndWrap(\n        bytes32 parentNode,\n        bytes32 node,\n        string memory label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        bytes memory name = _addLabel(label, names[parentNode]);\n        _wrap(node, name, newOwner, fuses, expiry);\n    }\n\n    function _prepareUpgrade(bytes32 node)\n        private\n        returns (uint32 fuses, uint64 expiry)\n    {\n        if (address(upgradeContract) == address(0)) {\n            revert CannotUpgrade();\n        }\n\n        if (!isTokenOwnerOrApproved(node, msg.sender)) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        (fuses, expiry) = getFuses(node);\n\n        // burn token and fuse data\n        _burn(uint256(node));\n    }\n\n    function _transferAndBurnFuses(\n        bytes32 node,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        (address owner, , ) = getData(uint256(node));\n        _transfer(owner, newOwner, uint256(node), 1, "");\n        _setFuses(node, newOwner, fuses, expiry);\n    }\n\n    // wrapper function for stack limit\n    function _getDataAndNormaliseExpiry(\n        bytes32 parentNode,\n        bytes32 node,\n        uint64 expiry\n    )\n        internal\n        view\n        returns (\n            address owner,\n            uint32 fuses,\n            uint64\n        )\n    {\n        uint64 oldExpiry;\n        (owner, fuses, oldExpiry) = getData(uint256(node));\n        (, , uint64 maxExpiry) = getData(uint256(parentNode));\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n        return (owner, fuses, expiry);\n    }\n\n    function _getETH2LDDataAndNormaliseExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    )\n        internal\n        view\n        returns (\n            address owner,\n            uint32 fuses,\n            uint64\n        )\n    {\n        uint64 oldExpiry;\n        (owner, fuses, oldExpiry) = getData(uint256(node));\n        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n        return (owner, fuses, expiry);\n    }\n\n    function _normaliseExpiry(\n        uint64 expiry,\n        uint64 oldExpiry,\n        uint64 maxExpiry\n    ) internal pure returns (uint64) {\n        // Expiry cannot be more than maximum allowed\n        // .eth names will check registrar, non .eth check parent\n        if (expiry &gt; maxExpiry) {\n            expiry = maxExpiry;\n        }\n        // Expiry cannot be less than old expiry\n        if (expiry &lt; oldExpiry) {\n            expiry = oldExpiry;\n        }\n\n        return expiry;\n    }\n\n    function _wrapETH2LD(\n        string memory label,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address resolver\n    ) private returns (uint64) {\n        // Mint a new ERC1155 token with fuses\n        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(ETH_NODE, labelhash);\n\n        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(\n            node,\n            labelhash,\n            expiry\n        );\n\n        _addLabelAndWrap(\n            ETH_NODE,\n            node,\n            label,\n            wrappedOwner,\n            fuses | PARENT_CANNOT_CONTROL,\n            expiry\n        );\n        if (resolver != address(0)) {\n            ens.setResolver(node, resolver);\n        }\n\n        return expiry;\n    }\n\n    function _unwrap(bytes32 node, address newOwner) private {\n        if (newOwner == address(0x0) || newOwner == address(this)) {\n            revert IncorrectTargetOwner(newOwner);\n        }\n\n        if (allFusesBurned(node, CANNOT_UNWRAP)) {\n            revert OperationProhibited(node);\n        }\n\n        // Burn token and fuse data\n        _burn(uint256(node));\n        ens.setOwner(node, newOwner);\n\n        emit NameUnwrapped(node, newOwner);\n    }\n\n    function _setFuses(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        _setData(node, owner, fuses, expiry);\n        emit FusesSet(node, fuses, expiry);\n    }\n\n    function _setData(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        _canFusesBeBurned(node, fuses);\n        super._setData(uint256(node), owner, fuses, expiry);\n    }\n\n    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {\n        if (\n            fuses &amp; ~PARENT_CANNOT_CONTROL != 0 &amp;&amp;\n            fuses &amp; (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=\n            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)\n        ) {\n            revert OperationProhibited(node);\n        }\n    }\n}\n'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 20:35:21 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | //SPDX-License-Identifier: MIT pragma solidity ^0.8.4; import "./ERC1155Fuse.sol"; import "./Controllable.sol"; import "./INameWrapper.sol"; import "./INameWrapperUpgrade.sol"; import "./IMetadataService.sol"; import "../registry/ENS.sol"; import "../ethregistrar/IBaseRegistrar.sol"; import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "./BytesUtil.sol"; error Unauthorised(bytes32 node, address addr); error NameNotFound(); error IncompatibleParent(); error IncompatibleName(bytes name); error IncorrectTokenType(); error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash); error LabelTooShort(); error LabelTooLong(string label); error IncorrectTargetOwner(address owner); error CannotUpgrade(); error InvalidExpiry(bytes32 node, uint64 expiry); contract NameWrapper is     Ownable,     ERC1155Fuse,     INameWrapper,     Controllable,     IERC721Receiver {     using BytesUtils for bytes;     ENS public immutable override ens;     IBaseRegistrar public immutable override registrar;     IMetadataService public override metadataService;     mapping(bytes32 =&gt; bytes) public override names; bytes32 private constant ETH_NODE =     0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae; bytes32 private constant ROOT_NODE =     0x0000000000000000000000000000000000000000000000000000000000000000;  //A contract address to a new upgraded contract if any INameWrapperUpgrade public upgradeContract; uint64 private constant MAX_EXPIRY = type(uint64).max;  constructor(     ENS _ens,     IBaseRegistrar _registrar,     IMetadataService _metadataService ) {     ens = _ens;     registrar = _registrar;     metadataService = _metadataService;      /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */      _setData(         uint256(ETH_NODE),         address(0),         uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),         MAX_EXPIRY     );     _setData(         uint256(ROOT_NODE),         address(0),         uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),         MAX_EXPIRY     );     names[ROOT_NODE] = "\x00";     names[ETH_NODE] = "\x03eth\x00"; }  function supportsInterface(bytes4 interfaceId)     public     view     virtual     override(ERC1155Fuse, IERC165)     returns (bool) {     return         interfaceId == type(INameWrapper).interfaceId ||         super.supportsInterface(interfaceId); }  /* ERC1155 */  function ownerOf(uint256 id)     public     view     override(ERC1155Fuse, INameWrapper)     returns (address owner) {     return super.ownerOf(id); }  /* Metadata service */  /**  * @notice Set the metadata service. Only the owner can do this  */  function setMetadataService(IMetadataService _newMetadataService)     public     onlyOwner {     metadataService = _newMetadataService; }  /**  * @notice Get the metadata uri  * @return String uri of the metadata service  */  function uri(uint256 tokenId) public view override returns (string memory) {     return metadataService.uri(tokenId); }  /**  * @notice Set the address of the upgradeContract of the contract. only admin can do this  * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time  * to make the contract not upgradable.  * @param _upgradeAddress address of an upgraded contract  */  function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)     public     onlyOwner {     if (address(upgradeContract) != address(0)) {         registrar.setApprovalForAll(address(upgradeContract), false);         ens.setApprovalForAll(address(upgradeContract), false);     }      upgradeContract = _upgradeAddress;      if (address(upgradeContract) != address(0)) {         registrar.setApprovalForAll(address(upgradeContract), true);         ens.setApprovalForAll(address(upgradeContract), true);     } }  /**  * @notice Checks if msg.sender is the owner or approved by the owner of a name  * @param node namehash of the name to check  */  modifier onlyTokenOwner(bytes32 node) {     if (!isTokenOwnerOrApproved(node, msg.sender)) {         revert Unauthorised(node, msg.sender);     }      _; }  /**  * @notice Checks if owner or approved by owner  * @param node namehash of the name to check  * @param addr which address to check permissions for  * @return whether or not is owner or approved  */  function isTokenOwnerOrApproved(bytes32 node, address addr)     public     view     override     returns (bool) {     address owner = ownerOf(uint256(node));     return owner == addr || isApprovedForAll(owner, addr); }  /**  * @notice Gets fuse permissions for a specific name  * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit  *      The interface has predefined fuses for all registry permissions, but additional  *      fuses can be added for other use cases  *      Also returns expiry, which is when the fuses are set to expire.  * @param node namehash of the name to check  * @return fuses A number that represents the permissions a name has. Returns 0 when expiry &lt; block.timestamp  * @return expiry Unix time of when the name expires and fuses are to expire  */ function getFuses(bytes32 node)     public     view     override     returns (uint32 fuses, uint64 expiry) {     (, fuses, expiry) = getData(uint256(node));     if (fuses == 0 &amp;&amp; expiry == 0) {         bytes memory name = names[node];         if (name.length == 0) {             revert NameNotFound();         }     } }  /**  * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract  * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar  * @param label label as a string of the .eth domain to wrap  * @param wrappedOwner Owner of the name in this contract  * @param fuses initial fuses to set  * @param expiry when the fuses will expire  * @param resolver resolver contract address  */  function wrapETH2LD(     string calldata label,     address wrappedOwner,     uint32 fuses,     uint64 expiry,     address resolver ) public override returns (uint64) {     uint256 tokenId = uint256(keccak256(bytes(label)));     address registrant = registrar.ownerOf(tokenId);     if (         registrant != msg.sender &amp;&amp;         !isApprovedForAll(registrant, msg.sender) &amp;&amp;         !registrar.isApprovedForAll(registrant, msg.sender)     ) {         revert Unauthorised(             _makeNode(ETH_NODE, bytes32(tokenId)),             msg.sender         );     }      // transfer the token from the user to this contract     registrar.transferFrom(registrant, address(this), tokenId);      // transfer the ens record back to the new owner (this contract)     registrar.reclaim(tokenId, address(this));      return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver); }  /**  * @dev Registers a new .eth second-level domain and wraps it.  *      Only callable by authorised controllers.  * @param label The label to register (Eg, 'foo' for 'foo.eth').  * @param wrappedOwner The owner of the wrapped name.  * @param duration The duration, in seconds, to register the name for.  * @param resolver The resolver address to set on the ENS registry (optional).  * @param fuses initial fuses to set  * @param expiry when the fuses will expire  * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.  */  function registerAndWrapETH2LD(     string calldata label,     address wrappedOwner,     uint256 duration,     address resolver,     uint32 fuses,     uint64 expiry ) external override onlyController returns (uint256 registrarExpiry) {     uint256 tokenId = uint256(keccak256(bytes(label)));     registrarExpiry = registrar.register(tokenId, address(this), duration);     _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver); }  /**  * @dev Renews a .eth second-level domain.  *      Only callable by authorised controllers.  * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').  * @param duration The number of seconds to renew the name for.  * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.  */ function renew(     uint256 tokenId,     uint256 duration,     uint64 expiry ) external override onlyController returns (uint256 expires) {     bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));      expires = registrar.renew(tokenId, duration);     (address owner, uint32 fuses, uint64 oldExpiry) = getData(         uint256(node)     );     expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));      _setData(node, owner, fuses, expiry); }  /**  * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner in the registry or an authorised caller in the registry  * @param name The name to wrap, in DNS format  * @param wrappedOwner Owner of the name in this contract  * @param resolver resolver contract address  */  function wrap(     bytes calldata name,     address wrappedOwner,     address resolver ) public override {     (bytes32 labelhash, uint256 offset) = name.readLabel(0);     bytes32 parentNode = name.namehash(offset);     bytes32 node = _makeNode(parentNode, labelhash);      if (parentNode == ETH_NODE) {         revert IncompatibleParent();     }      address owner = ens.owner(node);      if (         owner != msg.sender &amp;&amp;         !isApprovedForAll(owner, msg.sender) &amp;&amp;         !ens.isApprovedForAll(owner, msg.sender)     ) {         revert Unauthorised(node, msg.sender);     }      if (resolver != address(0)) {         ens.setResolver(node, resolver);     }      ens.setOwner(node, address(this));      _wrap(node, name, wrappedOwner, 0, 0); }  /**  * @notice Unwraps a .eth domain. e.g. vitalik.eth  * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper  * @param labelhash labelhash of the .eth domain  * @param newRegistrant sets the owner in the .eth registrar to this address  * @param newController sets the owner in the registry to this address  */  function unwrapETH2LD(     bytes32 labelhash,     address newRegistrant,     address newController ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {     _unwrap(_makeNode(ETH_NODE, labelhash), newController);     registrar.transferFrom(         address(this),         newRegistrant,         uint256(labelhash)     ); }  /**  * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper  * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')  * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')  * @param newController sets the owner in the registry to this address  */  function unwrap(     bytes32 parentNode,     bytes32 labelhash,     address newController ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {     if (parentNode == ETH_NODE) {         revert IncompatibleParent();     }     _unwrap(_makeNode(parentNode, labelhash), newController); }  /**  * @notice Sets fuses of a name  * @param node namehash of the name  * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)  */  function setFuses(bytes32 node, uint32 fuses)     public     onlyTokenOwner(node)     operationAllowed(node, CANNOT_BURN_FUSES)     returns (uint32) {     if (fuses &amp; PARENT_CANNOT_CONTROL != 0) {         // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.         revert Unauthorised(node, msg.sender);     }      (address owner, uint32 oldFuses, uint64 expiry) = getData(         uint256(node)     );      fuses |= oldFuses;     _setFuses(node, owner, fuses, expiry);     return fuses; }  /**  * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract  *     and burning the token of this contract  * @dev Can be called by the owner of the name in this contract  * @param label Label as a string of the .eth name to upgrade  * @param wrappedOwner The owner of the wrapped name  */  function upgradeETH2LD(     string calldata label,     address wrappedOwner,     address resolver ) public {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(ETH_NODE, labelhash);     (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);      upgradeContract.wrapETH2LD(         label,         wrappedOwner,         fuses,         expiry,         resolver     ); }  /**  * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner or an authorised caller  * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names  * @param parentNode namehash of the parent name  * @param label Label as a string of the name to upgrade  * @param wrappedOwner Owner of the name in this contract  * @param resolver resolver contract for this name  */  function upgrade(     bytes32 parentNode,     string calldata label,     address wrappedOwner,     address resolver ) public {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(parentNode, labelhash);     (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);     upgradeContract.setSubnodeRecord(         parentNode,         label,         wrappedOwner,         resolver,         0,         fuses,         expiry     ); }  /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name  * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')  * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')  * @param fuses fuses to burn  * @param expiry when the fuses will expire  */  function setChildFuses(     bytes32 parentNode,     bytes32 labelhash,     uint32 fuses,     uint64 expiry ) public {     bytes32 node = _makeNode(parentNode, labelhash);     (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(         uint256(node)     );     uint64 maxExpiry;     if (parentNode == ETH_NODE) {         if (!isTokenOwnerOrApproved(node, msg.sender)) {             revert Unauthorised(node, msg.sender);         }         // max expiry is set to the expiry on the registrar         maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));     } else {         if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {             revert Unauthorised(node, msg.sender);         }          // max expiry is set to the expiry of the parent         (, , maxExpiry) = getData(uint256(parentNode));     }      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);      // if PARENT_CANNOT_CONTROL has been burned and fuses have changed     if (         oldFuses &amp; PARENT_CANNOT_CONTROL != 0 &amp;&amp;         oldFuses | fuses != oldFuses     ) {         revert OperationProhibited(node);     }     fuses |= oldFuses;     _setFuses(node, owner, fuses, expiry); }  /**  * @notice Sets the subdomain owner in the registry and then wraps the subdomain  * @param parentNode parent namehash of the subdomain  * @param label label of the subdomain as a string  * @param newOwner newOwner in the registry  * @param fuses initial fuses for the wrapped subdomain  * @param expiry when the fuses will expire  */  function setSubnodeOwner(     bytes32 parentNode,     string calldata label,     address newOwner,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))     returns (bytes32 node) {     bytes32 labelhash = keccak256(bytes(label));     node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);      if (ens.owner(node) != address(this)) {         ens.setSubnodeOwner(parentNode, labelhash, address(this));         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } }  /**  * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain  * @param parentNode parent namehash of the subdomain  * @param label label of the subdomain as a string  * @param newOwner newOwner in the registry  * @param resolver resolver contract in the registry  * @param ttl ttl in the regsitry  * @param fuses initial fuses for the wrapped subdomain  * @param expiry expiry date for the domain  */  function setSubnodeRecord(     bytes32 parentNode,     string memory label,     address newOwner,     address resolver,     uint64 ttl,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label))) {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);     if (ens.owner(node) != address(this)) {         ens.setSubnodeRecord(             parentNode,             labelhash,             address(this),             resolver,             ttl         );         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         ens.setSubnodeRecord(             parentNode,             labelhash,             address(this),             resolver,             ttl         );         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } }  /**  * @notice Sets records for the name in the ENS Registry  * @param node namehash of the name to set a record for  * @param owner newOwner in the registry  * @param resolver the resolver contract  * @param ttl ttl in the registry  */  function setRecord(     bytes32 node,     address owner,     address resolver,     uint64 ttl )     public     override     onlyTokenOwner(node)     operationAllowed(         node,         CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL     ) {     ens.setRecord(node, address(this), resolver, ttl);     (address oldOwner, , ) = getData(uint256(node));     _transfer(oldOwner, owner, uint256(node), 1, ""); }  /**  * @notice Sets resolver contract in the registry  * @param node namehash of the name  * @param resolver the resolver contract  */  function setResolver(bytes32 node, address resolver)     public     override     onlyTokenOwner(node)     operationAllowed(node, CANNOT_SET_RESOLVER) {     ens.setResolver(node, resolver); }  /**  * @notice Sets TTL in the registry  * @param node namehash of the name  * @param ttl TTL in the registry  */  function setTTL(bytes32 node, uint64 ttl)     public     override     onlyTokenOwner(node)     operationAllowed(node, CANNOT_SET_TTL) {     ens.setTTL(node, ttl); }  /**  * @dev Allows an operation only if none of the specified fuses are burned.  * @param node The namehash of the name to check fuses on.  * @param fuseMask A bitmask of fuses that must not be burned.  */  modifier operationAllowed(bytes32 node, uint32 fuseMask) {     (, uint32 fuses, ) = getData(uint256(node));     if (fuses &amp; fuseMask != 0) {         revert OperationProhibited(node);     }     _; }  /**  * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord  * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt  *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for  *      replacing a subdomain. If either conditions are true, then it is possible to call  *      setSubnodeOwner  * @param node namehash of the name to check  * @param labelhash labelhash of the name to check  */  modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {     bytes32 subnode = _makeNode(node, labelhash);     address owner = ens.owner(subnode);      if (owner == address(0)) {         (, uint32 fuses, ) = getData(uint256(node));         if (fuses &amp; CANNOT_CREATE_SUBDOMAIN != 0) {             revert OperationProhibited(node);         }     } else {         (, uint32 subnodeFuses, ) = getData(uint256(subnode));         if (subnodeFuses &amp; PARENT_CANNOT_CONTROL != 0) {             revert OperationProhibited(node);         }     }      _; }  /**  * @notice Checks all Fuses in the mask are burned for the node  * @param node namehash of the name  * @param fuseMask the fuses you want to check  * @return Boolean of whether or not all the selected fuses are burned  */  function allFusesBurned(bytes32 node, uint32 fuseMask)     public     view     override     returns (bool) {     (, uint32 fuses, ) = getData(uint256(node));     return fuses &amp; fuseMask == fuseMask; }  function onERC721Received(     address to,     address,     uint256 tokenId,     bytes calldata data ) public override returns (bytes4) {     //check if it's the eth registrar ERC721     if (msg.sender != address(registrar)) {         revert IncorrectTokenType();     }      (         string memory label,         address owner,         uint32 fuses,         uint64 expiry,         address resolver     ) = abi.decode(data, (string, address, uint32, uint64, address));      bytes32 labelhash = bytes32(tokenId);     bytes32 labelhashFromData = keccak256(bytes(label));      if (labelhashFromData != labelhash) {         revert LabelMismatch(labelhashFromData, labelhash);     }      // transfer the ens record back to the new owner (this contract)     registrar.reclaim(uint256(labelhash), address(this));      _wrapETH2LD(label, owner, fuses, expiry, resolver);      return IERC721Receiver(to).onERC721Received.selector; }  /***** Internal functions */  function _canTransfer(uint32 fuses) internal pure override returns (bool) {     return fuses &amp; CANNOT_TRANSFER == 0; }  function _makeNode(bytes32 node, bytes32 labelhash)     private     pure     returns (bytes32) {     return keccak256(abi.encodePacked(node, labelhash)); }  function _addLabel(string memory label, bytes memory name)     internal     pure     returns (bytes memory ret) {     if (bytes(label).length &lt; 1) {         revert LabelTooShort();     }     if (bytes(label).length &gt; 255) {         revert LabelTooLong(label);     }     return abi.encodePacked(uint8(bytes(label).length), label, name); }  function _mint(     bytes32 node,     address wrappedOwner,     uint32 fuses,     uint64 expiry ) internal override {     address oldWrappedOwner = ownerOf(uint256(node));     _canFusesBeBurned(node, fuses);     if (oldWrappedOwner != address(0)) {         // burn and unwrap old token of old owner         _burn(uint256(node));         emit NameUnwrapped(node, address(0));     }     super._mint(node, wrappedOwner, fuses, expiry); }  function _wrap(     bytes32 node,     bytes memory name,     address wrappedOwner,     uint32 fuses,     uint64 expiry ) internal {     names[node] = name;     _mint(node, wrappedOwner, fuses, expiry);     emit NameWrapped(node, name, wrappedOwner, fuses, expiry); }  function _addLabelAndWrap(     bytes32 parentNode,     bytes32 node,     string memory label,     address newOwner,     uint32 fuses,     uint64 expiry ) internal {     bytes memory name = _addLabel(label, names[parentNode]);     _wrap(node, name, newOwner, fuses, expiry); }  function _prepareUpgrade(bytes32 node)     private     returns (uint32 fuses, uint64 expiry) {     if (address(upgradeContract) == address(0)) {         revert CannotUpgrade();     }      if (!isTokenOwnerOrApproved(node, msg.sender)) {         revert Unauthorised(node, msg.sender);     }      (fuses, expiry) = getFuses(node);      // burn token and fuse data     _burn(uint256(node)); }  function _transferAndBurnFuses(     bytes32 node,     address newOwner,     uint32 fuses,     uint64 expiry ) internal {     (address owner, , ) = getData(uint256(node));     _transfer(owner, newOwner, uint256(node), 1, "");     _setFuses(node, newOwner, fuses, expiry); }  // wrapper function for stack limit function _getDataAndNormaliseExpiry(     bytes32 parentNode,     bytes32 node,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     (, , uint64 maxExpiry) = getData(uint256(parentNode));      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); }  function _getETH2LDDataAndNormaliseExpiry(     bytes32 node,     bytes32 labelhash,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); }  function _normaliseExpiry(     uint64 expiry,     uint64 oldExpiry,     uint64 maxExpiry ) internal pure returns (uint64) {     // Expiry cannot be more than maximum allowed     // .eth names will check registrar, non .eth check parent     if (expiry &gt; maxExpiry) {         expiry = maxExpiry;     }     // Expiry cannot be less than old expiry     if (expiry &lt; oldExpiry) {         expiry = oldExpiry;     }      return expiry; }  function _wrapETH2LD(     string memory label,     address wrappedOwner,     uint32 fuses,     uint64 expiry,     address resolver ) private returns (uint64) {     // Mint a new ERC1155 token with fuses     // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(ETH_NODE, labelhash);      (, , expiry) = _getETH2LDDataAndNormaliseExpiry(         node,         labelhash,         expiry     );      _addLabelAndWrap(         ETH_NODE,         node,         label,         wrappedOwner,         fuses | PARENT_CANNOT_CONTROL,         expiry     );     if (resolver != address(0)) {         ens.setResolver(node, resolver);     }      return expiry; }  function _unwrap(bytes32 node, address newOwner) private {     if (newOwner == address(0x0) || newOwner == address(this)) {         revert IncorrectTargetOwner(newOwner);     }      if (allFusesBurned(node, CANNOT_UNWRAP)) {         revert OperationProhibited(node);     }      // Burn token and fuse data     _burn(uint256(node));     ens.setOwner(node, newOwner);      emit NameUnwrapped(node, newOwner); }  function _setFuses(     bytes32 node,     address owner,     uint32 fuses,     uint64 expiry ) internal {     _setData(node, owner, fuses, expiry);     emit FusesSet(node, fuses, expiry); }  function _setData(     bytes32 node,     address owner,     uint32 fuses,     uint64 expiry ) internal {     _canFusesBeBurned(node, fuses);     super._setData(uint256(node), owner, fuses, expiry); }  function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {     if (         fuses &amp; ~PARENT_CANNOT_CONTROL != 0 &amp;&amp;         fuses &amp; (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=         (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)     ) {         revert OperationProhibited(node);     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 20:35:22 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: //SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "./ERC1155Fuse.sol";
import "./Controllable.sol";
import "./INameWrapper.sol";
import "./INameWrapperUpgrade.sol";
import "./IMetadataService.sol";
import "../registry/ENS.sol";
import "../ethregistrar/IBaseRegistrar.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./BytesUtil.sol";

error Unauthorised(bytes32 node, address addr);
error NameNotFound();
error IncompatibleParent();
error IncompatibleName(bytes name);
error IncorrectTokenType();
error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);
error LabelTooShort();
error LabelTooLong(string label);
error IncorrectTargetOwner(address owner);
error CannotUpgrade();
error InvalidExpiry(bytes32 node, uint64 expiry);

contract NameWrapper is
    Ownable,
    ERC1155Fuse,
    INameWrapper,
    Controllable,
    IERC721Receiver
{
    using BytesUtils for bytes;
    ENS public immutable override ens;
    IBaseRegistrar public immutable override registrar;
    IMetadataService public override metadataService;
    mapping(bytes32 => bytes) public override names;

    bytes32 private constant ETH_NODE =
        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
    bytes32 private constant ROOT_NODE =
        0x0000000000000000000000000000000000000000000000000000000000000000;

    //A contract address to a new upgraded contract if any
    INameWrapperUpgrade public upgradeContract;
    uint64 private constant MAX_EXPIRY = type(uint64).max;

    constructor(
        ENS _ens,
        IBaseRegistrar _registrar,
        IMetadataService _metadataService
    ) {
        ens = _ens;
        registrar = _registrar;
        metadataService = _metadataService;

        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */

        _setData(
            uint256(ETH_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        _setData(
            uint256(ROOT_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        names[ROOT_NODE] = "\x00";
        names[ETH_NODE] = "\x03eth\x00";
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Fuse, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(INameWrapper).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /* ERC1155 */

    function ownerOf(uint256 id)
        public
        view
        override(ERC1155Fuse, INameWrapper)
        returns (address owner)
    {
        return super.ownerOf(id);
    }

    /* Metadata service */

    /**
     * @notice Set the metadata service. Only the owner can do this
     */

    function setMetadataService(IMetadataService _newMetadataService)
        public
        onlyOwner
    {
        metadataService = _newMetadataService;
    }

    /**
     * @notice Get the metadata uri
     * @return String uri of the metadata service
     */

    function uri(uint256 tokenId) public view override returns (string memory) {
        return metadataService.uri(tokenId);
    }

    /**
     * @notice Set the address of the upgradeContract of the contract. only admin can do this
     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time
     * to make the contract not upgradable.
     * @param _upgradeAddress address of an upgraded contract
     */

    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)
        public
        onlyOwner
    {
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), false);
            ens.setApprovalForAll(address(upgradeContract), false);
        }

        upgradeContract = _upgradeAddress;

        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), true);
            ens.setApprovalForAll(address(upgradeContract), true);
        }
    }

    /**
     * @notice Checks if msg.sender is the owner or approved by the owner of a name
     * @param node namehash of the name to check
     */

    modifier onlyTokenOwner(bytes32 node) {
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        _;
    }

    /**
     * @notice Checks if owner or approved by owner
     * @param node namehash of the name to check
     * @param addr which address to check permissions for
     * @return whether or not is owner or approved
     */

    function isTokenOwnerOrApproved(bytes32 node, address addr)
        public
        view
        override
        returns (bool)
    {
        address owner = ownerOf(uint256(node));
        return owner == addr || isApprovedForAll(owner, addr);
    }

    /**
     * @notice Gets fuse permissions for a specific name
     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit
     *      The interface has predefined fuses for all registry permissions, but additional
     *      fuses can be added for other use cases
     *      Also returns expiry, which is when the fuses are set to expire.
     * @param node namehash of the name to check
     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp
     * @return expiry Unix time of when the name expires and fuses are to expire
     */
    function getFuses(bytes32 node)
        public
        view
        override
        returns (uint32 fuses, uint64 expiry)
    {
        (, fuses, expiry) = getData(uint256(node));
        if (fuses == 0 && expiry == 0) {
            bytes memory name = names[node];
            if (name.length == 0) {
                revert NameNotFound();
            }
        }
    }

    /**
     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract
     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar
     * @param label label as a string of the .eth domain to wrap
     * @param wrappedOwner Owner of the name in this contract
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @param resolver resolver contract address
     */

    function wrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) public override returns (uint64) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        address registrant = registrar.ownerOf(tokenId);
        if (
            registrant != msg.sender &&
            !isApprovedForAll(registrant, msg.sender) &&
            !registrar.isApprovedForAll(registrant, msg.sender)
        ) {
            revert Unauthorised(
                _makeNode(ETH_NODE, bytes32(tokenId)),
                msg.sender
            );
        }

        // transfer the token from the user to this contract
        registrar.transferFrom(registrant, address(this), tokenId);

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(tokenId, address(this));

        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Registers a new .eth second-level domain and wraps it.
     *      Only callable by authorised controllers.
     * @param label The label to register (Eg, 'foo' for 'foo.eth').
     * @param wrappedOwner The owner of the wrapped name.
     * @param duration The duration, in seconds, to register the name for.
     * @param resolver The resolver address to set on the ENS registry (optional).
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.
     */

    function registerAndWrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint256 duration,
        address resolver,
        uint32 fuses,
        uint64 expiry
    ) external override onlyController returns (uint256 registrarExpiry) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        registrarExpiry = registrar.register(tokenId, address(this), duration);
        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Renews a .eth second-level domain.
     *      Only callable by authorised controllers.
     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').
     * @param duration The number of seconds to renew the name for.
     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.
     */
    function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));

        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));

        _setData(node, owner, fuses, expiry);
    }

    /**
     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the registry or an authorised caller in the registry
     * @param name The name to wrap, in DNS format
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract address
     */

    function wrap(
        bytes calldata name,
        address wrappedOwner,
        address resolver
    ) public override {
        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
        bytes32 parentNode = name.namehash(offset);
        bytes32 node = _makeNode(parentNode, labelhash);

        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }

        address owner = ens.owner(node);

        if (
            owner != msg.sender &&
            !isApprovedForAll(owner, msg.sender) &&
            !ens.isApprovedForAll(owner, msg.sender)
        ) {
            revert Unauthorised(node, msg.sender);
        }

        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        ens.setOwner(node, address(this));

        _wrap(node, name, wrappedOwner, 0, 0);
    }

    /**
     * @notice Unwraps a .eth domain. e.g. vitalik.eth
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param labelhash labelhash of the .eth domain
     * @param newRegistrant sets the owner in the .eth registrar to this address
     * @param newController sets the owner in the registry to this address
     */

    function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }

    /**
     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param newController sets the owner in the registry to this address
     */

    function unwrap(
        bytes32 parentNode,
        bytes32 labelhash,
        address newController
    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        _unwrap(_makeNode(parentNode, labelhash), newController);
    }

    /**
     * @notice Sets fuses of a name
     * @param node namehash of the name
     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)
     */

    function setFuses(bytes32 node, uint32 fuses)
        public
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_BURN_FUSES)
        returns (uint32)
    {
        if (fuses & PARENT_CANNOT_CONTROL != 0) {
            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.
            revert Unauthorised(node, msg.sender);
        }

        (address owner, uint32 oldFuses, uint64 expiry) = getData(
            uint256(node)
        );

        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
        return fuses;
    }

    /**
     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract
     *     and burning the token of this contract
     * @dev Can be called by the owner of the name in this contract
     * @param label Label as a string of the .eth name to upgrade
     * @param wrappedOwner The owner of the wrapped name
     */

    function upgradeETH2LD(
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);

        upgradeContract.wrapETH2LD(
            label,
            wrappedOwner,
            fuses,
            expiry,
            resolver
        );
    }

    /**
     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner or an authorised caller
     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names
     * @param parentNode namehash of the parent name
     * @param label Label as a string of the name to upgrade
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract for this name
     */

    function upgrade(
        bytes32 parentNode,
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.setSubnodeRecord(
            parentNode,
            label,
            wrappedOwner,
            resolver,
            0,
            fuses,
            expiry
        );
    }

    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param fuses fuses to burn
     * @param expiry when the fuses will expire
     */

    function setChildFuses(
        bytes32 parentNode,
        bytes32 labelhash,
        uint32 fuses,
        uint64 expiry
    ) public {
        bytes32 node = _makeNode(parentNode, labelhash);
        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        uint64 maxExpiry;
        if (parentNode == ETH_NODE) {
            if (!isTokenOwnerOrApproved(node, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            // max expiry is set to the expiry on the registrar
            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        } else {
            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }

            // max expiry is set to the expiry of the parent
            (, , maxExpiry) = getData(uint256(parentNode));
        }

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);

        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed
        if (
            oldFuses & PARENT_CANNOT_CONTROL != 0 &&
            oldFuses | fuses != oldFuses
        ) {
            revert OperationProhibited(node);
        }
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
    }

    /**
     * @notice Sets the subdomain owner in the registry and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry when the fuses will expire
     */

    function setSubnodeOwner(
        bytes32 parentNode,
        string calldata label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
        returns (bytes32 node)
    {
        bytes32 labelhash = keccak256(bytes(label));
        node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);

        if (ens.owner(node) != address(this)) {
            ens.setSubnodeOwner(parentNode, labelhash, address(this));
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param resolver resolver contract in the registry
     * @param ttl ttl in the regsitry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry expiry date for the domain
     */

    function setSubnodeRecord(
        bytes32 parentNode,
        string memory label,
        address newOwner,
        address resolver,
        uint64 ttl,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
    {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets records for the name in the ENS Registry
     * @param node namehash of the name to set a record for
     * @param owner newOwner in the registry
     * @param resolver the resolver contract
     * @param ttl ttl in the registry
     */

    function setRecord(
        bytes32 node,
        address owner,
        address resolver,
        uint64 ttl
    )
        public
        override
        onlyTokenOwner(node)
        operationAllowed(
            node,
            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL
        )
    {
        ens.setRecord(node, address(this), resolver, ttl);
        (address oldOwner, , ) = getData(uint256(node));
        _transfer(oldOwner, owner, uint256(node), 1, "");
    }

    /**
     * @notice Sets resolver contract in the registry
     * @param node namehash of the name
     * @param resolver the resolver contract
     */

    function setResolver(bytes32 node, address resolver)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_RESOLVER)
    {
        ens.setResolver(node, resolver);
    }

    /**
     * @notice Sets TTL in the registry
     * @param node namehash of the name
     * @param ttl TTL in the registry
     */

    function setTTL(bytes32 node, uint64 ttl)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_TTL)
    {
        ens.setTTL(node, ttl);
    }

    /**
     * @dev Allows an operation only if none of the specified fuses are burned.
     * @param node The namehash of the name to check fuses on.
     * @param fuseMask A bitmask of fuses that must not be burned.
     */

    modifier operationAllowed(bytes32 node, uint32 fuseMask) {
        (, uint32 fuses, ) = getData(uint256(node));
        if (fuses & fuseMask != 0) {
            revert OperationProhibited(node);
        }
        _;
    }

    /**
     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord
     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt
     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for
     *      replacing a subdomain. If either conditions are true, then it is possible to call
     *      setSubnodeOwner
     * @param node namehash of the name to check
     * @param labelhash labelhash of the name to check
     */

    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {
        bytes32 subnode = _makeNode(node, labelhash);
        address owner = ens.owner(subnode);

        if (owner == address(0)) {
            (, uint32 fuses, ) = getData(uint256(node));
            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {
                revert OperationProhibited(node);
            }
        } else {
            (, uint32 subnodeFuses, ) = getData(uint256(subnode));
            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {
                revert OperationProhibited(node);
            }
        }

        _;
    }

    /**
     * @notice Checks all Fuses in the mask are burned for the node
     * @param node namehash of the name
     * @param fuseMask the fuses you want to check
     * @return Boolean of whether or not all the selected fuses are burned
     */

    function allFusesBurned(bytes32 node, uint32 fuseMask)
        public
        view
        override
        returns (bool)
    {
        (, uint32 fuses, ) = getData(uint256(node));
        return fuses & fuseMask == fuseMask;
    }

    function onERC721Received(
        address to,
        address,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        //check if it's the eth registrar ERC721
        if (msg.sender != address(registrar)) {
            revert IncorrectTokenType();
        }

        (
            string memory label,
            address owner,
            uint32 fuses,
            uint64 expiry,
            address resolver
        ) = abi.decode(data, (string, address, uint32, uint64, address));

        bytes32 labelhash = bytes32(tokenId);
        bytes32 labelhashFromData = keccak256(bytes(label));

        if (labelhashFromData != labelhash) {
            revert LabelMismatch(labelhashFromData, labelhash);
        }

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(uint256(labelhash), address(this));

        _wrapETH2LD(label, owner, fuses, expiry, resolver);

        return IERC721Receiver(to).onERC721Received.selector;
    }

    /***** Internal functions */

    function _canTransfer(uint32 fuses) internal pure override returns (bool) {
        return fuses & CANNOT_TRANSFER == 0;
    }

    function _makeNode(bytes32 node, bytes32 labelhash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, labelhash));
    }

    function _addLabel(string memory label, bytes memory name)
        internal
        pure
        returns (bytes memory ret)
    {
        if (bytes(label).length < 1) {
            revert LabelTooShort();
        }
        if (bytes(label).length > 255) {
            revert LabelTooLong(label);
        }
        return abi.encodePacked(uint8(bytes(label).length), label, name);
    }

    function _mint(
        bytes32 node,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal override {
        address oldWrappedOwner = ownerOf(uint256(node));
        _canFusesBeBurned(node, fuses);
        if (oldWrappedOwner != address(0)) {
            // burn and unwrap old token of old owner
            _burn(uint256(node));
            emit NameUnwrapped(node, address(0));
        }
        super._mint(node, wrappedOwner, fuses, expiry);
    }

    function _wrap(
        bytes32 node,
        bytes memory name,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        names[node] = name;
        _mint(node, wrappedOwner, fuses, expiry);
        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);
    }

    function _addLabelAndWrap(
        bytes32 parentNode,
        bytes32 node,
        string memory label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        bytes memory name = _addLabel(label, names[parentNode]);
        _wrap(node, name, newOwner, fuses, expiry);
    }

    function _prepareUpgrade(bytes32 node)
        private
        returns (uint32 fuses, uint64 expiry)
    {
        if (address(upgradeContract) == address(0)) {
            revert CannotUpgrade();
        }

        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        (fuses, expiry) = getFuses(node);

        // burn token and fuse data
        _burn(uint256(node));
    }

    function _transferAndBurnFuses(
        bytes32 node,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        (address owner, , ) = getData(uint256(node));
        _transfer(owner, newOwner, uint256(node), 1, "");
        _setFuses(node, newOwner, fuses, expiry);
    }

    // wrapper function for stack limit
    function _getDataAndNormaliseExpiry(
        bytes32 parentNode,
        bytes32 node,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        (, , uint64 maxExpiry) = getData(uint256(parentNode));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _getETH2LDDataAndNormaliseExpiry(
        bytes32 node,
        bytes32 labelhash,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _normaliseExpiry(
        uint64 expiry,
        uint64 oldExpiry,
        uint64 maxExpiry
    ) internal pure returns (uint64) {
        // Expiry cannot be more than maximum allowed
        // .eth names will check registrar, non .eth check parent
        if (expiry > maxExpiry) {
            expiry = maxExpiry;
        }
        // Expiry cannot be less than old expiry
        if (expiry < oldExpiry) {
            expiry = oldExpiry;
        }

        return expiry;
    }

    function _wrapETH2LD(
        string memory label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) private returns (uint64) {
        // Mint a new ERC1155 token with fuses
        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);

        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(
            node,
            labelhash,
            expiry
        );

        _addLabelAndWrap(
            ETH_NODE,
            node,
            label,
            wrappedOwner,
            fuses | PARENT_CANNOT_CONTROL,
            expiry
        );
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        return expiry;
    }

    function _unwrap(bytes32 node, address newOwner) private {
        if (newOwner == address(0x0) || newOwner == address(this)) {
            revert IncorrectTargetOwner(newOwner);
        }

        if (allFusesBurned(node, CANNOT_UNWRAP)) {
            revert OperationProhibited(node);
        }

        // Burn token and fuse data
        _burn(uint256(node));
        ens.setOwner(node, newOwner);

        emit NameUnwrapped(node, newOwner);
    }

    function _setFuses(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _setData(node, owner, fuses, expiry);
        emit FusesSet(node, fuses, expiry);
    }

    function _setData(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _canFusesBeBurned(node, fuses);
        super._setData(uint256(node), owner, fuses, expiry);
    }

    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
        if (
            fuses & ~PARENT_CANNOT_CONTROL != 0 &&
            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
        ) {
            revert OperationProhibited(node);
        }
    }
}
.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "//SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "./ERC1155Fuse.sol";
import "./Controllable.sol";
import "./INameWrapper.sol";
import "./INameWrapperUpgrade.sol";
import "./IMetadataService.sol";
import "../registry/ENS.sol";
import "../ethregistrar/IBaseRegistrar.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./BytesUtil.sol";

error Unauthorised(bytes32 node, address addr);
error NameNotFound();
error IncompatibleParent();
error IncompatibleName(bytes name);
error IncorrectTokenType();
error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);
error LabelTooShort();
error LabelTooLong(string label);
error IncorrectTargetOwner(address owner);
error CannotUpgrade();
error InvalidExpiry(bytes32 node, uint64 expiry);

contract NameWrapper is
    Ownable,
    ERC1155Fuse,
    INameWrapper,
    Controllable,
    IERC721Receiver
{
    using BytesUtils for bytes;
    ENS public immutable override ens;
    IBaseRegistrar public immutable override registrar;
    IMetadataService public override metadataService;
    mapping(bytes32 => bytes) public override names;

    bytes32 private constant ETH_NODE =
        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
    bytes32 private constant ROOT_NODE =
        0x0000000000000000000000000000000000000000000000000000000000000000;

    //A contract address to a new upgraded contract if any
    INameWrapperUpgrade public upgradeContract;
    uint64 private constant MAX_EXPIRY = type(uint64).max;

    constructor(
        ENS _ens,
        IBaseRegistrar _registrar,
        IMetadataService _metadataService
    ) {
        ens = _ens;
        registrar = _registrar;
        metadataService = _metadataService;

        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */

        _setData(
            uint256(ETH_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        _setData(
            uint256(ROOT_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        names[ROOT_NODE] = "\x00";
        names[ETH_NODE] = "\x03eth\x00";
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Fuse, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(INameWrapper).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /* ERC1155 */

    function ownerOf(uint256 id)
        public
        view
        override(ERC1155Fuse, INameWrapper)
        returns (address owner)
    {
        return super.ownerOf(id);
    }

    /* Metadata service */

    /**
     * @notice Set the metadata service. Only the owner can do this
     */

    function setMetadataService(IMetadataService _newMetadataService)
        public
        onlyOwner
    {
        metadataService = _newMetadataService;
    }

    /**
     * @notice Get the metadata uri
     * @return String uri of the metadata service
     */

    function uri(uint256 tokenId) public view override returns (string memory) {
        return metadataService.uri(tokenId);
    }

    /**
     * @notice Set the address of the upgradeContract of the contract. only admin can do this
     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time
     * to make the contract not upgradable.
     * @param _upgradeAddress address of an upgraded contract
     */

    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)
        public
        onlyOwner
    {
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), false);
            ens.setApprovalForAll(address(upgradeContract), false);
        }

        upgradeContract = _upgradeAddress;

        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), true);
            ens.setApprovalForAll(address(upgradeContract), true);
        }
    }

    /**
     * @notice Checks if msg.sender is the owner or approved by the owner of a name
     * @param node namehash of the name to check
     */

    modifier onlyTokenOwner(bytes32 node) {
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        _;
    }

    /**
     * @notice Checks if owner or approved by owner
     * @param node namehash of the name to check
     * @param addr which address to check permissions for
     * @return whether or not is owner or approved
     */

    function isTokenOwnerOrApproved(bytes32 node, address addr)
        public
        view
        override
        returns (bool)
    {
        address owner = ownerOf(uint256(node));
        return owner == addr || isApprovedForAll(owner, addr);
    }

    /**
     * @notice Gets fuse permissions for a specific name
     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit
     *      The interface has predefined fuses for all registry permissions, but additional
     *      fuses can be added for other use cases
     *      Also returns expiry, which is when the fuses are set to expire.
     * @param node namehash of the name to check
     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp
     * @return expiry Unix time of when the name expires and fuses are to expire
     */
    function getFuses(bytes32 node)
        public
        view
        override
        returns (uint32 fuses, uint64 expiry)
    {
        (, fuses, expiry) = getData(uint256(node));
        if (fuses == 0 && expiry == 0) {
            bytes memory name = names[node];
            if (name.length == 0) {
                revert NameNotFound();
            }
        }
    }

    /**
     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract
     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar
     * @param label label as a string of the .eth domain to wrap
     * @param wrappedOwner Owner of the name in this contract
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @param resolver resolver contract address
     */

    function wrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) public override returns (uint64) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        address registrant = registrar.ownerOf(tokenId);
        if (
            registrant != msg.sender &&
            !isApprovedForAll(registrant, msg.sender) &&
            !registrar.isApprovedForAll(registrant, msg.sender)
        ) {
            revert Unauthorised(
                _makeNode(ETH_NODE, bytes32(tokenId)),
                msg.sender
            );
        }

        // transfer the token from the user to this contract
        registrar.transferFrom(registrant, address(this), tokenId);

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(tokenId, address(this));

        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Registers a new .eth second-level domain and wraps it.
     *      Only callable by authorised controllers.
     * @param label The label to register (Eg, 'foo' for 'foo.eth').
     * @param wrappedOwner The owner of the wrapped name.
     * @param duration The duration, in seconds, to register the name for.
     * @param resolver The resolver address to set on the ENS registry (optional).
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.
     */

    function registerAndWrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint256 duration,
        address resolver,
        uint32 fuses,
        uint64 expiry
    ) external override onlyController returns (uint256 registrarExpiry) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        registrarExpiry = registrar.register(tokenId, address(this), duration);
        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Renews a .eth second-level domain.
     *      Only callable by authorised controllers.
     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').
     * @param duration The number of seconds to renew the name for.
     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.
     */
    function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));

        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));

        _setData(node, owner, fuses, expiry);
    }

    /**
     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the registry or an authorised caller in the registry
     * @param name The name to wrap, in DNS format
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract address
     */

    function wrap(
        bytes calldata name,
        address wrappedOwner,
        address resolver
    ) public override {
        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
        bytes32 parentNode = name.namehash(offset);
        bytes32 node = _makeNode(parentNode, labelhash);

        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }

        address owner = ens.owner(node);

        if (
            owner != msg.sender &&
            !isApprovedForAll(owner, msg.sender) &&
            !ens.isApprovedForAll(owner, msg.sender)
        ) {
            revert Unauthorised(node, msg.sender);
        }

        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        ens.setOwner(node, address(this));

        _wrap(node, name, wrappedOwner, 0, 0);
    }

    /**
     * @notice Unwraps a .eth domain. e.g. vitalik.eth
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param labelhash labelhash of the .eth domain
     * @param newRegistrant sets the owner in the .eth registrar to this address
     * @param newController sets the owner in the registry to this address
     */

    function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }

    /**
     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param newController sets the owner in the registry to this address
     */

    function unwrap(
        bytes32 parentNode,
        bytes32 labelhash,
        address newController
    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        _unwrap(_makeNode(parentNode, labelhash), newController);
    }

    /**
     * @notice Sets fuses of a name
     * @param node namehash of the name
     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)
     */

    function setFuses(bytes32 node, uint32 fuses)
        public
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_BURN_FUSES)
        returns (uint32)
    {
        if (fuses & PARENT_CANNOT_CONTROL != 0) {
            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.
            revert Unauthorised(node, msg.sender);
        }

        (address owner, uint32 oldFuses, uint64 expiry) = getData(
            uint256(node)
        );

        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
        return fuses;
    }

    /**
     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract
     *     and burning the token of this contract
     * @dev Can be called by the owner of the name in this contract
     * @param label Label as a string of the .eth name to upgrade
     * @param wrappedOwner The owner of the wrapped name
     */

    function upgradeETH2LD(
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);

        upgradeContract.wrapETH2LD(
            label,
            wrappedOwner,
            fuses,
            expiry,
            resolver
        );
    }

    /**
     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner or an authorised caller
     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names
     * @param parentNode namehash of the parent name
     * @param label Label as a string of the name to upgrade
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract for this name
     */

    function upgrade(
        bytes32 parentNode,
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.setSubnodeRecord(
            parentNode,
            label,
            wrappedOwner,
            resolver,
            0,
            fuses,
            expiry
        );
    }

    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param fuses fuses to burn
     * @param expiry when the fuses will expire
     */

    function setChildFuses(
        bytes32 parentNode,
        bytes32 labelhash,
        uint32 fuses,
        uint64 expiry
    ) public {
        bytes32 node = _makeNode(parentNode, labelhash);
        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        uint64 maxExpiry;
        if (parentNode == ETH_NODE) {
            if (!isTokenOwnerOrApproved(node, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            // max expiry is set to the expiry on the registrar
            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        } else {
            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }

            // max expiry is set to the expiry of the parent
            (, , maxExpiry) = getData(uint256(parentNode));
        }

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);

        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed
        if (
            oldFuses & PARENT_CANNOT_CONTROL != 0 &&
            oldFuses | fuses != oldFuses
        ) {
            revert OperationProhibited(node);
        }
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
    }

    /**
     * @notice Sets the subdomain owner in the registry and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry when the fuses will expire
     */

    function setSubnodeOwner(
        bytes32 parentNode,
        string calldata label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
        returns (bytes32 node)
    {
        bytes32 labelhash = keccak256(bytes(label));
        node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);

        if (ens.owner(node) != address(this)) {
            ens.setSubnodeOwner(parentNode, labelhash, address(this));
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param resolver resolver contract in the registry
     * @param ttl ttl in the regsitry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry expiry date for the domain
     */

    function setSubnodeRecord(
        bytes32 parentNode,
        string memory label,
        address newOwner,
        address resolver,
        uint64 ttl,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
    {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets records for the name in the ENS Registry
     * @param node namehash of the name to set a record for
     * @param owner newOwner in the registry
     * @param resolver the resolver contract
     * @param ttl ttl in the registry
     */

    function setRecord(
        bytes32 node,
        address owner,
        address resolver,
        uint64 ttl
    )
        public
        override
        onlyTokenOwner(node)
        operationAllowed(
            node,
            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL
        )
    {
        ens.setRecord(node, address(this), resolver, ttl);
        (address oldOwner, , ) = getData(uint256(node));
        _transfer(oldOwner, owner, uint256(node), 1, "");
    }

    /**
     * @notice Sets resolver contract in the registry
     * @param node namehash of the name
     * @param resolver the resolver contract
     */

    function setResolver(bytes32 node, address resolver)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_RESOLVER)
    {
        ens.setResolver(node, resolver);
    }

    /**
     * @notice Sets TTL in the registry
     * @param node namehash of the name
     * @param ttl TTL in the registry
     */

    function setTTL(bytes32 node, uint64 ttl)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_TTL)
    {
        ens.setTTL(node, ttl);
    }

    /**
     * @dev Allows an operation only if none of the specified fuses are burned.
     * @param node The namehash of the name to check fuses on.
     * @param fuseMask A bitmask of fuses that must not be burned.
     */

    modifier operationAllowed(bytes32 node, uint32 fuseMask) {
        (, uint32 fuses, ) = getData(uint256(node));
        if (fuses & fuseMask != 0) {
            revert OperationProhibited(node);
        }
        _;
    }

    /**
     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord
     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt
     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for
     *      replacing a subdomain. If either conditions are true, then it is possible to call
     *      setSubnodeOwner
     * @param node namehash of the name to check
     * @param labelhash labelhash of the name to check
     */

    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {
        bytes32 subnode = _makeNode(node, labelhash);
        address owner = ens.owner(subnode);

        if (owner == address(0)) {
            (, uint32 fuses, ) = getData(uint256(node));
            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {
                revert OperationProhibited(node);
            }
        } else {
            (, uint32 subnodeFuses, ) = getData(uint256(subnode));
            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {
                revert OperationProhibited(node);
            }
        }

        _;
    }

    /**
     * @notice Checks all Fuses in the mask are burned for the node
     * @param node namehash of the name
     * @param fuseMask the fuses you want to check
     * @return Boolean of whether or not all the selected fuses are burned
     */

    function allFusesBurned(bytes32 node, uint32 fuseMask)
        public
        view
        override
        returns (bool)
    {
        (, uint32 fuses, ) = getData(uint256(node));
        return fuses & fuseMask == fuseMask;
    }

    function onERC721Received(
        address to,
        address,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        //check if it's the eth registrar ERC721
        if (msg.sender != address(registrar)) {
            revert IncorrectTokenType();
        }

        (
            string memory label,
            address owner,
            uint32 fuses,
            uint64 expiry,
            address resolver
        ) = abi.decode(data, (string, address, uint32, uint64, address));

        bytes32 labelhash = bytes32(tokenId);
        bytes32 labelhashFromData = keccak256(bytes(label));

        if (labelhashFromData != labelhash) {
            revert LabelMismatch(labelhashFromData, labelhash);
        }

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(uint256(labelhash), address(this));

        _wrapETH2LD(label, owner, fuses, expiry, resolver);

        return IERC721Receiver(to).onERC721Received.selector;
    }

    /***** Internal functions */

    function _canTransfer(uint32 fuses) internal pure override returns (bool) {
        return fuses & CANNOT_TRANSFER == 0;
    }

    function _makeNode(bytes32 node, bytes32 labelhash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, labelhash));
    }

    function _addLabel(string memory label, bytes memory name)
        internal
        pure
        returns (bytes memory ret)
    {
        if (bytes(label).length < 1) {
            revert LabelTooShort();
        }
        if (bytes(label).length > 255) {
            revert LabelTooLong(label);
        }
        return abi.encodePacked(uint8(bytes(label).length), label, name);
    }

    function _mint(
        bytes32 node,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal override {
        address oldWrappedOwner = ownerOf(uint256(node));
        _canFusesBeBurned(node, fuses);
        if (oldWrappedOwner != address(0)) {
            // burn and unwrap old token of old owner
            _burn(uint256(node));
            emit NameUnwrapped(node, address(0));
        }
        super._mint(node, wrappedOwner, fuses, expiry);
    }

    function _wrap(
        bytes32 node,
        bytes memory name,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        names[node] = name;
        _mint(node, wrappedOwner, fuses, expiry);
        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);
    }

    function _addLabelAndWrap(
        bytes32 parentNode,
        bytes32 node,
        string memory label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        bytes memory name = _addLabel(label, names[parentNode]);
        _wrap(node, name, newOwner, fuses, expiry);
    }

    function _prepareUpgrade(bytes32 node)
        private
        returns (uint32 fuses, uint64 expiry)
    {
        if (address(upgradeContract) == address(0)) {
            revert CannotUpgrade();
        }

        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        (fuses, expiry) = getFuses(node);

        // burn token and fuse data
        _burn(uint256(node));
    }

    function _transferAndBurnFuses(
        bytes32 node,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        (address owner, , ) = getData(uint256(node));
        _transfer(owner, newOwner, uint256(node), 1, "");
        _setFuses(node, newOwner, fuses, expiry);
    }

    // wrapper function for stack limit
    function _getDataAndNormaliseExpiry(
        bytes32 parentNode,
        bytes32 node,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        (, , uint64 maxExpiry) = getData(uint256(parentNode));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _getETH2LDDataAndNormaliseExpiry(
        bytes32 node,
        bytes32 labelhash,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _normaliseExpiry(
        uint64 expiry,
        uint64 oldExpiry,
        uint64 maxExpiry
    ) internal pure returns (uint64) {
        // Expiry cannot be more than maximum allowed
        // .eth names will check registrar, non .eth check parent
        if (expiry > maxExpiry) {
            expiry = maxExpiry;
        }
        // Expiry cannot be less than old expiry
        if (expiry < oldExpiry) {
            expiry = oldExpiry;
        }

        return expiry;
    }

    function _wrapETH2LD(
        string memory label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) private returns (uint64) {
        // Mint a new ERC1155 token with fuses
        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);

        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(
            node,
            labelhash,
            expiry
        );

        _addLabelAndWrap(
            ETH_NODE,
            node,
            label,
            wrappedOwner,
            fuses | PARENT_CANNOT_CONTROL,
            expiry
        );
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        return expiry;
    }

    function _unwrap(bytes32 node, address newOwner) private {
        if (newOwner == address(0x0) || newOwner == address(this)) {
            revert IncorrectTargetOwner(newOwner);
        }

        if (allFusesBurned(node, CANNOT_UNWRAP)) {
            revert OperationProhibited(node);
        }

        // Burn token and fuse data
        _burn(uint256(node));
        ens.setOwner(node, newOwner);

        emit NameUnwrapped(node, newOwner);
    }

    function _setFuses(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _setData(node, owner, fuses, expiry);
        emit FusesSet(node, fuses, expiry);
    }

    function _setData(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _canFusesBeBurned(node, fuses);
        super._setData(uint256(node), owner, fuses, expiry);
    }

    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
        if (
            fuses & ~PARENT_CANNOT_CONTROL != 0 &&
            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
        ) {
            revert OperationProhibited(node);
        }
    }
}
".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-01-09 20:35:29 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 20:35:29 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 14290
completion_tokens: 419
total_tokens: 14709
cost: $-1.000000


[2024-01-09 20:35:29 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: //SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "./ERC1155Fuse.sol";
import "./Controllable.sol";
import "./INameWrapper.sol";
import "./INameWrapperUpgrade.sol";
import "./IMetadataService.sol";
import "../registry/ENS.sol";
import "../ethregistrar/IBaseRegistrar.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./BytesUtil.sol";

error Unauthorised(bytes32 node, address addr);
error NameNotFound();
error IncompatibleParent();
error IncompatibleName(bytes name);
error IncorrectTokenType();
error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);
error LabelTooShort();
error LabelTooLong(string label);
error IncorrectTargetOwner(address owner);
error CannotUpgrade();
error InvalidExpiry(bytes32 node, uint64 expiry);

contract NameWrapper is
    Ownable,
    ERC1155Fuse,
    INameWrapper,
    Controllable,
    IERC721Receiver
{
    using BytesUtils for bytes;
    ENS public immutable override ens;
    IBaseRegistrar public immutable override registrar;
    IMetadataService public override metadataService;
    mapping(bytes32 => bytes) public override names;

    bytes32 private constant ETH_NODE =
        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
    bytes32 private constant ROOT_NODE =
        0x0000000000000000000000000000000000000000000000000000000000000000;

    //A contract address to a new upgraded contract if any
    INameWrapperUpgrade public upgradeContract;
    uint64 private constant MAX_EXPIRY = type(uint64).max;

    constructor(
        ENS _ens,
        IBaseRegistrar _registrar,
        IMetadataService _metadataService
    ) {
        ens = _ens;
        registrar = _registrar;
        metadataService = _metadataService;

        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */

        _setData(
            uint256(ETH_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        _setData(
            uint256(ROOT_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        names[ROOT_NODE] = "\x00";
        names[ETH_NODE] = "\x03eth\x00";
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Fuse, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(INameWrapper).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /* ERC1155 */

    function ownerOf(uint256 id)
        public
        view
        override(ERC1155Fuse, INameWrapper)
        returns (address owner)
    {
        return super.ownerOf(id);
    }

    /* Metadata service */

    /**
     * @notice Set the metadata service. Only the owner can do this
     */

    function setMetadataService(IMetadataService _newMetadataService)
        public
        onlyOwner
    {
        metadataService = _newMetadataService;
    }

    /**
     * @notice Get the metadata uri
     * @return String uri of the metadata service
     */

    function uri(uint256 tokenId) public view override returns (string memory) {
        return metadataService.uri(tokenId);
    }

    /**
     * @notice Set the address of the upgradeContract of the contract. only admin can do this
     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time
     * to make the contract not upgradable.
     * @param _upgradeAddress address of an upgraded contract
     */

    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)
        public
        onlyOwner
    {
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), false);
            ens.setApprovalForAll(address(upgradeContract), false);
        }

        upgradeContract = _upgradeAddress;

        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), true);
            ens.setApprovalForAll(address(upgradeContract), true);
        }
    }

    /**
     * @notice Checks if msg.sender is the owner or approved by the owner of a name
     * @param node namehash of the name to check
     */

    modifier onlyTokenOwner(bytes32 node) {
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        _;
    }

    /**
     * @notice Checks if owner or approved by owner
     * @param node namehash of the name to check
     * @param addr which address to check permissions for
     * @return whether or not is owner or approved
     */

    function isTokenOwnerOrApproved(bytes32 node, address addr)
        public
        view
        override
        returns (bool)
    {
        address owner = ownerOf(uint256(node));
        return owner == addr || isApprovedForAll(owner, addr);
    }

    /**
     * @notice Gets fuse permissions for a specific name
     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit
     *      The interface has predefined fuses for all registry permissions, but additional
     *      fuses can be added for other use cases
     *      Also returns expiry, which is when the fuses are set to expire.
     * @param node namehash of the name to check
     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp
     * @return expiry Unix time of when the name expires and fuses are to expire
     */
    function getFuses(bytes32 node)
        public
        view
        override
        returns (uint32 fuses, uint64 expiry)
    {
        (, fuses, expiry) = getData(uint256(node));
        if (fuses == 0 && expiry == 0) {
            bytes memory name = names[node];
            if (name.length == 0) {
                revert NameNotFound();
            }
        }
    }

    /**
     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract
     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar
     * @param label label as a string of the .eth domain to wrap
     * @param wrappedOwner Owner of the name in this contract
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @param resolver resolver contract address
     */

    function wrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) public override returns (uint64) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        address registrant = registrar.ownerOf(tokenId);
        if (
            registrant != msg.sender &&
            !isApprovedForAll(registrant, msg.sender) &&
            !registrar.isApprovedForAll(registrant, msg.sender)
        ) {
            revert Unauthorised(
                _makeNode(ETH_NODE, bytes32(tokenId)),
                msg.sender
            );
        }

        // transfer the token from the user to this contract
        registrar.transferFrom(registrant, address(this), tokenId);

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(tokenId, address(this));

        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Registers a new .eth second-level domain and wraps it.
     *      Only callable by authorised controllers.
     * @param label The label to register (Eg, 'foo' for 'foo.eth').
     * @param wrappedOwner The owner of the wrapped name.
     * @param duration The duration, in seconds, to register the name for.
     * @param resolver The resolver address to set on the ENS registry (optional).
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.
     */

    function registerAndWrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint256 duration,
        address resolver,
        uint32 fuses,
        uint64 expiry
    ) external override onlyController returns (uint256 registrarExpiry) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        registrarExpiry = registrar.register(tokenId, address(this), duration);
        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Renews a .eth second-level domain.
     *      Only callable by authorised controllers.
     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').
     * @param duration The number of seconds to renew the name for.
     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.
     */
    function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));

        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));

        _setData(node, owner, fuses, expiry);
    }

    /**
     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the registry or an authorised caller in the registry
     * @param name The name to wrap, in DNS format
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract address
     */

    function wrap(
        bytes calldata name,
        address wrappedOwner,
        address resolver
    ) public override {
        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
        bytes32 parentNode = name.namehash(offset);
        bytes32 node = _makeNode(parentNode, labelhash);

        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }

        address owner = ens.owner(node);

        if (
            owner != msg.sender &&
            !isApprovedForAll(owner, msg.sender) &&
            !ens.isApprovedForAll(owner, msg.sender)
        ) {
            revert Unauthorised(node, msg.sender);
        }

        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        ens.setOwner(node, address(this));

        _wrap(node, name, wrappedOwner, 0, 0);
    }

    /**
     * @notice Unwraps a .eth domain. e.g. vitalik.eth
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param labelhash labelhash of the .eth domain
     * @param newRegistrant sets the owner in the .eth registrar to this address
     * @param newController sets the owner in the registry to this address
     */

    function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }

    /**
     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param newController sets the owner in the registry to this address
     */

    function unwrap(
        bytes32 parentNode,
        bytes32 labelhash,
        address newController
    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        _unwrap(_makeNode(parentNode, labelhash), newController);
    }

    /**
     * @notice Sets fuses of a name
     * @param node namehash of the name
     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)
     */

    function setFuses(bytes32 node, uint32 fuses)
        public
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_BURN_FUSES)
        returns (uint32)
    {
        if (fuses & PARENT_CANNOT_CONTROL != 0) {
            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.
            revert Unauthorised(node, msg.sender);
        }

        (address owner, uint32 oldFuses, uint64 expiry) = getData(
            uint256(node)
        );

        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
        return fuses;
    }

    /**
     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract
     *     and burning the token of this contract
     * @dev Can be called by the owner of the name in this contract
     * @param label Label as a string of the .eth name to upgrade
     * @param wrappedOwner The owner of the wrapped name
     */

    function upgradeETH2LD(
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);

        upgradeContract.wrapETH2LD(
            label,
            wrappedOwner,
            fuses,
            expiry,
            resolver
        );
    }

    /**
     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner or an authorised caller
     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names
     * @param parentNode namehash of the parent name
     * @param label Label as a string of the name to upgrade
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract for this name
     */

    function upgrade(
        bytes32 parentNode,
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.setSubnodeRecord(
            parentNode,
            label,
            wrappedOwner,
            resolver,
            0,
            fuses,
            expiry
        );
    }

    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param fuses fuses to burn
     * @param expiry when the fuses will expire
     */

    function setChildFuses(
        bytes32 parentNode,
        bytes32 labelhash,
        uint32 fuses,
        uint64 expiry
    ) public {
        bytes32 node = _makeNode(parentNode, labelhash);
        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        uint64 maxExpiry;
        if (parentNode == ETH_NODE) {
            if (!isTokenOwnerOrApproved(node, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            // max expiry is set to the expiry on the registrar
            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        } else {
            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }

            // max expiry is set to the expiry of the parent
            (, , maxExpiry) = getData(uint256(parentNode));
        }

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);

        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed
        if (
            oldFuses & PARENT_CANNOT_CONTROL != 0 &&
            oldFuses | fuses != oldFuses
        ) {
            revert OperationProhibited(node);
        }
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
    }

    /**
     * @notice Sets the subdomain owner in the registry and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry when the fuses will expire
     */

    function setSubnodeOwner(
        bytes32 parentNode,
        string calldata label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
        returns (bytes32 node)
    {
        bytes32 labelhash = keccak256(bytes(label));
        node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);

        if (ens.owner(node) != address(this)) {
            ens.setSubnodeOwner(parentNode, labelhash, address(this));
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param resolver resolver contract in the registry
     * @param ttl ttl in the regsitry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry expiry date for the domain
     */

    function setSubnodeRecord(
        bytes32 parentNode,
        string memory label,
        address newOwner,
        address resolver,
        uint64 ttl,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
    {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets records for the name in the ENS Registry
     * @param node namehash of the name to set a record for
     * @param owner newOwner in the registry
     * @param resolver the resolver contract
     * @param ttl ttl in the registry
     */

    function setRecord(
        bytes32 node,
        address owner,
        address resolver,
        uint64 ttl
    )
        public
        override
        onlyTokenOwner(node)
        operationAllowed(
            node,
            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL
        )
    {
        ens.setRecord(node, address(this), resolver, ttl);
        (address oldOwner, , ) = getData(uint256(node));
        _transfer(oldOwner, owner, uint256(node), 1, "");
    }

    /**
     * @notice Sets resolver contract in the registry
     * @param node namehash of the name
     * @param resolver the resolver contract
     */

    function setResolver(bytes32 node, address resolver)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_RESOLVER)
    {
        ens.setResolver(node, resolver);
    }

    /**
     * @notice Sets TTL in the registry
     * @param node namehash of the name
     * @param ttl TTL in the registry
     */

    function setTTL(bytes32 node, uint64 ttl)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_TTL)
    {
        ens.setTTL(node, ttl);
    }

    /**
     * @dev Allows an operation only if none of the specified fuses are burned.
     * @param node The namehash of the name to check fuses on.
     * @param fuseMask A bitmask of fuses that must not be burned.
     */

    modifier operationAllowed(bytes32 node, uint32 fuseMask) {
        (, uint32 fuses, ) = getData(uint256(node));
        if (fuses & fuseMask != 0) {
            revert OperationProhibited(node);
        }
        _;
    }

    /**
     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord
     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt
     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for
     *      replacing a subdomain. If either conditions are true, then it is possible to call
     *      setSubnodeOwner
     * @param node namehash of the name to check
     * @param labelhash labelhash of the name to check
     */

    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {
        bytes32 subnode = _makeNode(node, labelhash);
        address owner = ens.owner(subnode);

        if (owner == address(0)) {
            (, uint32 fuses, ) = getData(uint256(node));
            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {
                revert OperationProhibited(node);
            }
        } else {
            (, uint32 subnodeFuses, ) = getData(uint256(subnode));
            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {
                revert OperationProhibited(node);
            }
        }

        _;
    }

    /**
     * @notice Checks all Fuses in the mask are burned for the node
     * @param node namehash of the name
     * @param fuseMask the fuses you want to check
     * @return Boolean of whether or not all the selected fuses are burned
     */

    function allFusesBurned(bytes32 node, uint32 fuseMask)
        public
        view
        override
        returns (bool)
    {
        (, uint32 fuses, ) = getData(uint256(node));
        return fuses & fuseMask == fuseMask;
    }

    function onERC721Received(
        address to,
        address,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        //check if it's the eth registrar ERC721
        if (msg.sender != address(registrar)) {
            revert IncorrectTokenType();
        }

        (
            string memory label,
            address owner,
            uint32 fuses,
            uint64 expiry,
            address resolver
        ) = abi.decode(data, (string, address, uint32, uint64, address));

        bytes32 labelhash = bytes32(tokenId);
        bytes32 labelhashFromData = keccak256(bytes(label));

        if (labelhashFromData != labelhash) {
            revert LabelMismatch(labelhashFromData, labelhash);
        }

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(uint256(labelhash), address(this));

        _wrapETH2LD(label, owner, fuses, expiry, resolver);

        return IERC721Receiver(to).onERC721Received.selector;
    }

    /***** Internal functions */

    function _canTransfer(uint32 fuses) internal pure override returns (bool) {
        return fuses & CANNOT_TRANSFER == 0;
    }

    function _makeNode(bytes32 node, bytes32 labelhash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, labelhash));
    }

    function _addLabel(string memory label, bytes memory name)
        internal
        pure
        returns (bytes memory ret)
    {
        if (bytes(label).length < 1) {
            revert LabelTooShort();
        }
        if (bytes(label).length > 255) {
            revert LabelTooLong(label);
        }
        return abi.encodePacked(uint8(bytes(label).length), label, name);
    }

    function _mint(
        bytes32 node,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal override {
        address oldWrappedOwner = ownerOf(uint256(node));
        _canFusesBeBurned(node, fuses);
        if (oldWrappedOwner != address(0)) {
            // burn and unwrap old token of old owner
            _burn(uint256(node));
            emit NameUnwrapped(node, address(0));
        }
        super._mint(node, wrappedOwner, fuses, expiry);
    }

    function _wrap(
        bytes32 node,
        bytes memory name,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        names[node] = name;
        _mint(node, wrappedOwner, fuses, expiry);
        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);
    }

    function _addLabelAndWrap(
        bytes32 parentNode,
        bytes32 node,
        string memory label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        bytes memory name = _addLabel(label, names[parentNode]);
        _wrap(node, name, newOwner, fuses, expiry);
    }

    function _prepareUpgrade(bytes32 node)
        private
        returns (uint32 fuses, uint64 expiry)
    {
        if (address(upgradeContract) == address(0)) {
            revert CannotUpgrade();
        }

        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        (fuses, expiry) = getFuses(node);

        // burn token and fuse data
        _burn(uint256(node));
    }

    function _transferAndBurnFuses(
        bytes32 node,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        (address owner, , ) = getData(uint256(node));
        _transfer(owner, newOwner, uint256(node), 1, "");
        _setFuses(node, newOwner, fuses, expiry);
    }

    // wrapper function for stack limit
    function _getDataAndNormaliseExpiry(
        bytes32 parentNode,
        bytes32 node,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        (, , uint64 maxExpiry) = getData(uint256(parentNode));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _getETH2LDDataAndNormaliseExpiry(
        bytes32 node,
        bytes32 labelhash,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _normaliseExpiry(
        uint64 expiry,
        uint64 oldExpiry,
        uint64 maxExpiry
    ) internal pure returns (uint64) {
        // Expiry cannot be more than maximum allowed
        // .eth names will check registrar, non .eth check parent
        if (expiry > maxExpiry) {
            expiry = maxExpiry;
        }
        // Expiry cannot be less than old expiry
        if (expiry < oldExpiry) {
            expiry = oldExpiry;
        }

        return expiry;
    }

    function _wrapETH2LD(
        string memory label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) private returns (uint64) {
        // Mint a new ERC1155 token with fuses
        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);

        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(
            node,
            labelhash,
            expiry
        );

        _addLabelAndWrap(
            ETH_NODE,
            node,
            label,
            wrappedOwner,
            fuses | PARENT_CANNOT_CONTROL,
            expiry
        );
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        return expiry;
    }

    function _unwrap(bytes32 node, address newOwner) private {
        if (newOwner == address(0x0) || newOwner == address(this)) {
            revert IncorrectTargetOwner(newOwner);
        }

        if (allFusesBurned(node, CANNOT_UNWRAP)) {
            revert OperationProhibited(node);
        }

        // Burn token and fuse data
        _burn(uint256(node));
        ens.setOwner(node, newOwner);

        emit NameUnwrapped(node, newOwner);
    }

    function _setFuses(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _setData(node, owner, fuses, expiry);
        emit FusesSet(node, fuses, expiry);
    }

    function _setData(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _canFusesBeBurned(node, fuses);
        super._setData(uint256(node), owner, fuses, expiry);
    }

    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
        if (
            fuses & ~PARENT_CANNOT_CONTROL != 0 &&
            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
        ) {
            revert OperationProhibited(node);
        }
    }
}
.]

Let's analyze the provided Solidity contract and identify potential areas for improvement or enhancement.

1. **Access Control Enhancements**: While the contract uses the `Ownable` pattern for access control, we could consider implementing a more granular role-based access control (RBAC) system using OpenZeppelin's `AccessControl`. This would allow for multiple roles with different permissions, enhancing security and flexibility.

2. **Gas Optimization**: The contract could be optimized for gas usage. For instance, we could review the functions to minimize state variable writes and redundant calculations. Functions like `_normaliseExpiry` could be optimized to reduce the number of conditional checks.

3. **Event Emissions**: While the contract emits events for significant actions, we could ensure that all state-changing functions emit appropriate events. This would improve transparency and allow for better tracking of contract interactions.

4. **Upgradeability Pattern**: The contract mentions an upgrade mechanism, but we could consider implementing a more robust upgradeability pattern, such as the proxy pattern. This would allow for seamless upgrades without losing state or requiring users to interact with a new contract.

5. **Input Validation**: Additional input validation could be added to functions like `wrapETH2LD` and `registerAndWrapETH2LD` to ensure that the parameters passed (like `wrappedOwner`, `resolver`, etc.) are valid addresses and not zero addresses.

6. **Reentrancy Guard**: Although the contract appears to handle external calls carefully, adding a reentrancy guard to critical functions could further enhance security against potential reentrancy attacks.

7. **Documentation and Comments**: While the contract has some comments, enhancing the documentation, especially around complex functions, would improve maintainability and understanding for future developers.

8. **Testing and Audit**: Ensure that the contract undergoes thorough testing, including unit tests and integration tests, to cover all edge cases. Additionally, an external audit by a reputable firm could provide an extra layer of security assurance.

Which of these suggestions resonates most with you, or do you have any additional ideas to consider?

[2024-01-09 20:35:30 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | //SPDX-License-Identifier: MIT pragma solidity ^0.8.4; import "./ERC1155Fuse.sol"; import "./Controllable.sol"; import "./INameWrapper.sol"; import "./INameWrapperUpgrade.sol"; import "./IMetadataService.sol"; import "../registry/ENS.sol"; import "../ethregistrar/IBaseRegistrar.sol"; import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "./BytesUtil.sol"; error Unauthorised(bytes32 node, address addr); error NameNotFound(); error IncompatibleParent(); error IncompatibleName(bytes name); error IncorrectTokenType(); error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash); error LabelTooShort(); error LabelTooLong(string label); error IncorrectTargetOwner(address owner); error CannotUpgrade(); error InvalidExpiry(bytes32 node, uint64 expiry); contract NameWrapper is     Ownable,     ERC1155Fuse,     INameWrapper,     Controllable,     IERC721Receiver {     using BytesUtils for bytes;     ENS public immutable override ens;     IBaseRegistrar public immutable override registrar;     IMetadataService public override metadataService;     mapping(bytes32 =&gt; bytes) public override names; bytes32 private constant ETH_NODE =     0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae; bytes32 private constant ROOT_NODE =     0x0000000000000000000000000000000000000000000000000000000000000000;  //A contract address to a new upgraded contract if any INameWrapperUpgrade public upgradeContract; uint64 private constant MAX_EXPIRY = type(uint64).max;  constructor(     ENS _ens,     IBaseRegistrar _registrar,     IMetadataService _metadataService ) {     ens = _ens;     registrar = _registrar;     metadataService = _metadataService;      /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */      _setData(         uint256(ETH_NODE),         address(0),         uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),         MAX_EXPIRY     );     _setData(         uint256(ROOT_NODE),         address(0),         uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),         MAX_EXPIRY     );     names[ROOT_NODE] = "\x00";     names[ETH_NODE] = "\x03eth\x00"; }  function supportsInterface(bytes4 interfaceId)     public     view     virtual     override(ERC1155Fuse, IERC165)     returns (bool) {     return         interfaceId == type(INameWrapper).interfaceId ||         super.supportsInterface(interfaceId); }  /* ERC1155 */  function ownerOf(uint256 id)     public     view     override(ERC1155Fuse, INameWrapper)     returns (address owner) {     return super.ownerOf(id); }  /* Metadata service */  /**  * @notice Set the metadata service. Only the owner can do this  */  function setMetadataService(IMetadataService _newMetadataService)     public     onlyOwner {     metadataService = _newMetadataService; }  /**  * @notice Get the metadata uri  * @return String uri of the metadata service  */  function uri(uint256 tokenId) public view override returns (string memory) {     return metadataService.uri(tokenId); }  /**  * @notice Set the address of the upgradeContract of the contract. only admin can do this  * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time  * to make the contract not upgradable.  * @param _upgradeAddress address of an upgraded contract  */  function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)     public     onlyOwner {     if (address(upgradeContract) != address(0)) {         registrar.setApprovalForAll(address(upgradeContract), false);         ens.setApprovalForAll(address(upgradeContract), false);     }      upgradeContract = _upgradeAddress;      if (address(upgradeContract) != address(0)) {         registrar.setApprovalForAll(address(upgradeContract), true);         ens.setApprovalForAll(address(upgradeContract), true);     } }  /**  * @notice Checks if msg.sender is the owner or approved by the owner of a name  * @param node namehash of the name to check  */  modifier onlyTokenOwner(bytes32 node) {     if (!isTokenOwnerOrApproved(node, msg.sender)) {         revert Unauthorised(node, msg.sender);     }      _; }  /**  * @notice Checks if owner or approved by owner  * @param node namehash of the name to check  * @param addr which address to check permissions for  * @return whether or not is owner or approved  */  function isTokenOwnerOrApproved(bytes32 node, address addr)     public     view     override     returns (bool) {     address owner = ownerOf(uint256(node));     return owner == addr || isApprovedForAll(owner, addr); }  /**  * @notice Gets fuse permissions for a specific name  * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit  *      The interface has predefined fuses for all registry permissions, but additional  *      fuses can be added for other use cases  *      Also returns expiry, which is when the fuses are set to expire.  * @param node namehash of the name to check  * @return fuses A number that represents the permissions a name has. Returns 0 when expiry &lt; block.timestamp  * @return expiry Unix time of when the name expires and fuses are to expire  */ function getFuses(bytes32 node)     public     view     override     returns (uint32 fuses, uint64 expiry) {     (, fuses, expiry) = getData(uint256(node));     if (fuses == 0 &amp;&amp; expiry == 0) {         bytes memory name = names[node];         if (name.length == 0) {             revert NameNotFound();         }     } }  /**  * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract  * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar  * @param label label as a string of the .eth domain to wrap  * @param wrappedOwner Owner of the name in this contract  * @param fuses initial fuses to set  * @param expiry when the fuses will expire  * @param resolver resolver contract address  */  function wrapETH2LD(     string calldata label,     address wrappedOwner,     uint32 fuses,     uint64 expiry,     address resolver ) public override returns (uint64) {     uint256 tokenId = uint256(keccak256(bytes(label)));     address registrant = registrar.ownerOf(tokenId);     if (         registrant != msg.sender &amp;&amp;         !isApprovedForAll(registrant, msg.sender) &amp;&amp;         !registrar.isApprovedForAll(registrant, msg.sender)     ) {         revert Unauthorised(             _makeNode(ETH_NODE, bytes32(tokenId)),             msg.sender         );     }      // transfer the token from the user to this contract     registrar.transferFrom(registrant, address(this), tokenId);      // transfer the ens record back to the new owner (this contract)     registrar.reclaim(tokenId, address(this));      return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver); }  /**  * @dev Registers a new .eth second-level domain and wraps it.  *      Only callable by authorised controllers.  * @param label The label to register (Eg, 'foo' for 'foo.eth').  * @param wrappedOwner The owner of the wrapped name.  * @param duration The duration, in seconds, to register the name for.  * @param resolver The resolver address to set on the ENS registry (optional).  * @param fuses initial fuses to set  * @param expiry when the fuses will expire  * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.  */  function registerAndWrapETH2LD(     string calldata label,     address wrappedOwner,     uint256 duration,     address resolver,     uint32 fuses,     uint64 expiry ) external override onlyController returns (uint256 registrarExpiry) {     uint256 tokenId = uint256(keccak256(bytes(label)));     registrarExpiry = registrar.register(tokenId, address(this), duration);     _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver); }  /**  * @dev Renews a .eth second-level domain.  *      Only callable by authorised controllers.  * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').  * @param duration The number of seconds to renew the name for.  * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.  */ function renew(     uint256 tokenId,     uint256 duration,     uint64 expiry ) external override onlyController returns (uint256 expires) {     bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));      expires = registrar.renew(tokenId, duration);     (address owner, uint32 fuses, uint64 oldExpiry) = getData(         uint256(node)     );     expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));      _setData(node, owner, fuses, expiry); }  /**  * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner in the registry or an authorised caller in the registry  * @param name The name to wrap, in DNS format  * @param wrappedOwner Owner of the name in this contract  * @param resolver resolver contract address  */  function wrap(     bytes calldata name,     address wrappedOwner,     address resolver ) public override {     (bytes32 labelhash, uint256 offset) = name.readLabel(0);     bytes32 parentNode = name.namehash(offset);     bytes32 node = _makeNode(parentNode, labelhash);      if (parentNode == ETH_NODE) {         revert IncompatibleParent();     }      address owner = ens.owner(node);      if (         owner != msg.sender &amp;&amp;         !isApprovedForAll(owner, msg.sender) &amp;&amp;         !ens.isApprovedForAll(owner, msg.sender)     ) {         revert Unauthorised(node, msg.sender);     }      if (resolver != address(0)) {         ens.setResolver(node, resolver);     }      ens.setOwner(node, address(this));      _wrap(node, name, wrappedOwner, 0, 0); }  /**  * @notice Unwraps a .eth domain. e.g. vitalik.eth  * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper  * @param labelhash labelhash of the .eth domain  * @param newRegistrant sets the owner in the .eth registrar to this address  * @param newController sets the owner in the registry to this address  */  function unwrapETH2LD(     bytes32 labelhash,     address newRegistrant,     address newController ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {     _unwrap(_makeNode(ETH_NODE, labelhash), newController);     registrar.transferFrom(         address(this),         newRegistrant,         uint256(labelhash)     ); }  /**  * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper  * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')  * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')  * @param newController sets the owner in the registry to this address  */  function unwrap(     bytes32 parentNode,     bytes32 labelhash,     address newController ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {     if (parentNode == ETH_NODE) {         revert IncompatibleParent();     }     _unwrap(_makeNode(parentNode, labelhash), newController); }  /**  * @notice Sets fuses of a name  * @param node namehash of the name  * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)  */  function setFuses(bytes32 node, uint32 fuses)     public     onlyTokenOwner(node)     operationAllowed(node, CANNOT_BURN_FUSES)     returns (uint32) {     if (fuses &amp; PARENT_CANNOT_CONTROL != 0) {         // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.         revert Unauthorised(node, msg.sender);     }      (address owner, uint32 oldFuses, uint64 expiry) = getData(         uint256(node)     );      fuses |= oldFuses;     _setFuses(node, owner, fuses, expiry);     return fuses; }  /**  * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract  *     and burning the token of this contract  * @dev Can be called by the owner of the name in this contract  * @param label Label as a string of the .eth name to upgrade  * @param wrappedOwner The owner of the wrapped name  */  function upgradeETH2LD(     string calldata label,     address wrappedOwner,     address resolver ) public {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(ETH_NODE, labelhash);     (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);      upgradeContract.wrapETH2LD(         label,         wrappedOwner,         fuses,         expiry,         resolver     ); }  /**  * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner or an authorised caller  * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names  * @param parentNode namehash of the parent name  * @param label Label as a string of the name to upgrade  * @param wrappedOwner Owner of the name in this contract  * @param resolver resolver contract for this name  */  function upgrade(     bytes32 parentNode,     string calldata label,     address wrappedOwner,     address resolver ) public {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(parentNode, labelhash);     (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);     upgradeContract.setSubnodeRecord(         parentNode,         label,         wrappedOwner,         resolver,         0,         fuses,         expiry     ); }  /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name  * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')  * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')  * @param fuses fuses to burn  * @param expiry when the fuses will expire  */  function setChildFuses(     bytes32 parentNode,     bytes32 labelhash,     uint32 fuses,     uint64 expiry ) public {     bytes32 node = _makeNode(parentNode, labelhash);     (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(         uint256(node)     );     uint64 maxExpiry;     if (parentNode == ETH_NODE) {         if (!isTokenOwnerOrApproved(node, msg.sender)) {             revert Unauthorised(node, msg.sender);         }         // max expiry is set to the expiry on the registrar         maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));     } else {         if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {             revert Unauthorised(node, msg.sender);         }          // max expiry is set to the expiry of the parent         (, , maxExpiry) = getData(uint256(parentNode));     }      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);      // if PARENT_CANNOT_CONTROL has been burned and fuses have changed     if (         oldFuses &amp; PARENT_CANNOT_CONTROL != 0 &amp;&amp;         oldFuses | fuses != oldFuses     ) {         revert OperationProhibited(node);     }     fuses |= oldFuses;     _setFuses(node, owner, fuses, expiry); }  /**  * @notice Sets the subdomain owner in the registry and then wraps the subdomain  * @param parentNode parent namehash of the subdomain  * @param label label of the subdomain as a string  * @param newOwner newOwner in the registry  * @param fuses initial fuses for the wrapped subdomain  * @param expiry when the fuses will expire  */  function setSubnodeOwner(     bytes32 parentNode,     string calldata label,     address newOwner,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))     returns (bytes32 node) {     bytes32 labelhash = keccak256(bytes(label));     node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);      if (ens.owner(node) != address(this)) {         ens.setSubnodeOwner(parentNode, labelhash, address(this));         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } }  /**  * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain  * @param parentNode parent namehash of the subdomain  * @param label label of the subdomain as a string  * @param newOwner newOwner in the registry  * @param resolver resolver contract in the registry  * @param ttl ttl in the regsitry  * @param fuses initial fuses for the wrapped subdomain  * @param expiry expiry date for the domain  */  function setSubnodeRecord(     bytes32 parentNode,     string memory label,     address newOwner,     address resolver,     uint64 ttl,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label))) {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);     if (ens.owner(node) != address(this)) {         ens.setSubnodeRecord(             parentNode,             labelhash,             address(this),             resolver,             ttl         );         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         ens.setSubnodeRecord(             parentNode,             labelhash,             address(this),             resolver,             ttl         );         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } }  /**  * @notice Sets records for the name in the ENS Registry  * @param node namehash of the name to set a record for  * @param owner newOwner in the registry  * @param resolver the resolver contract  * @param ttl ttl in the registry  */  function setRecord(     bytes32 node,     address owner,     address resolver,     uint64 ttl )     public     override     onlyTokenOwner(node)     operationAllowed(         node,         CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL     ) {     ens.setRecord(node, address(this), resolver, ttl);     (address oldOwner, , ) = getData(uint256(node));     _transfer(oldOwner, owner, uint256(node), 1, ""); }  /**  * @notice Sets resolver contract in the registry  * @param node namehash of the name  * @param resolver the resolver contract  */  function setResolver(bytes32 node, address resolver)     public     override     onlyTokenOwner(node)     operationAllowed(node, CANNOT_SET_RESOLVER) {     ens.setResolver(node, resolver); }  /**  * @notice Sets TTL in the registry  * @param node namehash of the name  * @param ttl TTL in the registry  */  function setTTL(bytes32 node, uint64 ttl)     public     override     onlyTokenOwner(node)     operationAllowed(node, CANNOT_SET_TTL) {     ens.setTTL(node, ttl); }  /**  * @dev Allows an operation only if none of the specified fuses are burned.  * @param node The namehash of the name to check fuses on.  * @param fuseMask A bitmask of fuses that must not be burned.  */  modifier operationAllowed(bytes32 node, uint32 fuseMask) {     (, uint32 fuses, ) = getData(uint256(node));     if (fuses &amp; fuseMask != 0) {         revert OperationProhibited(node);     }     _; }  /**  * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord  * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt  *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for  *      replacing a subdomain. If either conditions are true, then it is possible to call  *      setSubnodeOwner  * @param node namehash of the name to check  * @param labelhash labelhash of the name to check  */  modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {     bytes32 subnode = _makeNode(node, labelhash);     address owner = ens.owner(subnode);      if (owner == address(0)) {         (, uint32 fuses, ) = getData(uint256(node));         if (fuses &amp; CANNOT_CREATE_SUBDOMAIN != 0) {             revert OperationProhibited(node);         }     } else {         (, uint32 subnodeFuses, ) = getData(uint256(subnode));         if (subnodeFuses &amp; PARENT_CANNOT_CONTROL != 0) {             revert OperationProhibited(node);         }     }      _; }  /**  * @notice Checks all Fuses in the mask are burned for the node  * @param node namehash of the name  * @param fuseMask the fuses you want to check  * @return Boolean of whether or not all the selected fuses are burned  */  function allFusesBurned(bytes32 node, uint32 fuseMask)     public     view     override     returns (bool) {     (, uint32 fuses, ) = getData(uint256(node));     return fuses &amp; fuseMask == fuseMask; }  function onERC721Received(     address to,     address,     uint256 tokenId,     bytes calldata data ) public override returns (bytes4) {     //check if it's the eth registrar ERC721     if (msg.sender != address(registrar)) {         revert IncorrectTokenType();     }      (         string memory label,         address owner,         uint32 fuses,         uint64 expiry,         address resolver     ) = abi.decode(data, (string, address, uint32, uint64, address));      bytes32 labelhash = bytes32(tokenId);     bytes32 labelhashFromData = keccak256(bytes(label));      if (labelhashFromData != labelhash) {         revert LabelMismatch(labelhashFromData, labelhash);     }      // transfer the ens record back to the new owner (this contract)     registrar.reclaim(uint256(labelhash), address(this));      _wrapETH2LD(label, owner, fuses, expiry, resolver);      return IERC721Receiver(to).onERC721Received.selector; }  /***** Internal functions */  function _canTransfer(uint32 fuses) internal pure override returns (bool) {     return fuses &amp; CANNOT_TRANSFER == 0; }  function _makeNode(bytes32 node, bytes32 labelhash)     private     pure     returns (bytes32) {     return keccak256(abi.encodePacked(node, labelhash)); }  function _addLabel(string memory label, bytes memory name)     internal     pure     returns (bytes memory ret) {     if (bytes(label).length &lt; 1) {         revert LabelTooShort();     }     if (bytes(label).length &gt; 255) {         revert LabelTooLong(label);     }     return abi.encodePacked(uint8(bytes(label).length), label, name); }  function _mint(     bytes32 node,     address wrappedOwner,     uint32 fuses,     uint64 expiry ) internal override {     address oldWrappedOwner = ownerOf(uint256(node));     _canFusesBeBurned(node, fuses);     if (oldWrappedOwner != address(0)) {         // burn and unwrap old token of old owner         _burn(uint256(node));         emit NameUnwrapped(node, address(0));     }     super._mint(node, wrappedOwner, fuses, expiry); }  function _wrap(     bytes32 node,     bytes memory name,     address wrappedOwner,     uint32 fuses,     uint64 expiry ) internal {     names[node] = name;     _mint(node, wrappedOwner, fuses, expiry);     emit NameWrapped(node, name, wrappedOwner, fuses, expiry); }  function _addLabelAndWrap(     bytes32 parentNode,     bytes32 node,     string memory label,     address newOwner,     uint32 fuses,     uint64 expiry ) internal {     bytes memory name = _addLabel(label, names[parentNode]);     _wrap(node, name, newOwner, fuses, expiry); }  function _prepareUpgrade(bytes32 node)     private     returns (uint32 fuses, uint64 expiry) {     if (address(upgradeContract) == address(0)) {         revert CannotUpgrade();     }      if (!isTokenOwnerOrApproved(node, msg.sender)) {         revert Unauthorised(node, msg.sender);     }      (fuses, expiry) = getFuses(node);      // burn token and fuse data     _burn(uint256(node)); }  function _transferAndBurnFuses(     bytes32 node,     address newOwner,     uint32 fuses,     uint64 expiry ) internal {     (address owner, , ) = getData(uint256(node));     _transfer(owner, newOwner, uint256(node), 1, "");     _setFuses(node, newOwner, fuses, expiry); }  // wrapper function for stack limit function _getDataAndNormaliseExpiry(     bytes32 parentNode,     bytes32 node,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     (, , uint64 maxExpiry) = getData(uint256(parentNode));      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); }  function _getETH2LDDataAndNormaliseExpiry(     bytes32 node,     bytes32 labelhash,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); }  function _normaliseExpiry(     uint64 expiry,     uint64 oldExpiry,     uint64 maxExpiry ) internal pure returns (uint64) {     // Expiry cannot be more than maximum allowed     // .eth names will check registrar, non .eth check parent     if (expiry &gt; maxExpiry) {         expiry = maxExpiry;     }     // Expiry cannot be less than old expiry     if (expiry &lt; oldExpiry) {         expiry = oldExpiry;     }      return expiry; }  function _wrapETH2LD(     string memory label,     address wrappedOwner,     uint32 fuses,     uint64 expiry,     address resolver ) private returns (uint64) {     // Mint a new ERC1155 token with fuses     // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(ETH_NODE, labelhash);      (, , expiry) = _getETH2LDDataAndNormaliseExpiry(         node,         labelhash,         expiry     );      _addLabelAndWrap(         ETH_NODE,         node,         label,         wrappedOwner,         fuses | PARENT_CANNOT_CONTROL,         expiry     );     if (resolver != address(0)) {         ens.setResolver(node, resolver);     }      return expiry; }  function _unwrap(bytes32 node, address newOwner) private {     if (newOwner == address(0x0) || newOwner == address(this)) {         revert IncorrectTargetOwner(newOwner);     }      if (allFusesBurned(node, CANNOT_UNWRAP)) {         revert OperationProhibited(node);     }      // Burn token and fuse data     _burn(uint256(node));     ens.setOwner(node, newOwner);      emit NameUnwrapped(node, newOwner); }  function _setFuses(     bytes32 node,     address owner,     uint32 fuses,     uint64 expiry ) internal {     _setData(node, owner, fuses, expiry);     emit FusesSet(node, fuses, expiry); }  function _setData(     bytes32 node,     address owner,     uint32 fuses,     uint64 expiry ) internal {     _canFusesBeBurned(node, fuses);     super._setData(uint256(node), owner, fuses, expiry); }  function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {     if (         fuses &amp; ~PARENT_CANNOT_CONTROL != 0 &amp;&amp;         fuses &amp; (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=         (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)     ) {         revert OperationProhibited(node);     } }  } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: //SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\nimport "./ERC1155Fuse.sol";\nimport "./Controllable.sol";\nimport "./INameWrapper.sol";\nimport "./INameWrapperUpgrade.sol";\nimport "./IMetadataService.sol";\nimport "../registry/ENS.sol";\nimport "../ethregistrar/IBaseRegistrar.sol";\nimport "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";\nimport "@openzeppelin/contracts/access/Ownable.sol";\nimport "./BytesUtil.sol";\nerror Unauthorised(bytes32 node, address addr);\nerror NameNotFound();\nerror IncompatibleParent();\nerror IncompatibleName(bytes name);\nerror IncorrectTokenType();\nerror LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);\nerror LabelTooShort();\nerror LabelTooLong(string label);\nerror IncorrectTargetOwner(address owner);\nerror CannotUpgrade();\nerror InvalidExpiry(bytes32 node, uint64 expiry);\ncontract NameWrapper is\n    Ownable,\n    ERC1155Fuse,\n    INameWrapper,\n    Controllable,\n    IERC721Receiver\n{\n    using BytesUtils for bytes;\n    ENS public immutable override ens;\n    IBaseRegistrar public immutable override registrar;\n    IMetadataService public override metadataService;\n    mapping(bytes32 =&gt; bytes) public override names;\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n    bytes32 private constant ROOT_NODE =\n        0x0000000000000000000000000000000000000000000000000000000000000000;\n    //A contract address to a new upgraded contract if any\n    INameWrapperUpgrade public upgradeContract;\n    uint64 private constant MAX_EXPIRY = type(uint64).max;\n    constructor(\n        ENS _ens,\n        IBaseRegistrar _registrar,\n        IMetadataService _metadataService\n    ) {\n        ens = _ens;\n        registrar = _registrar;\n        metadataService = _metadataService;\n        / Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE /\n        _setData(\n            uint256(ETH_NODE),\n            address(0),\n            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),\n            MAX_EXPIRY\n        );\n        _setData(\n            uint256(ROOT_NODE),\n            address(0),\n            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),\n            MAX_EXPIRY\n        );\n        names[ROOT_NODE] = "\x00";\n        names[ETH_NODE] = "\x03eth\x00";\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC1155Fuse, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(INameWrapper).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    / ERC1155 /\n    function ownerOf(uint256 id)\n        public\n        view\n        override(ERC1155Fuse, INameWrapper)\n        returns (address owner)\n    {\n        return super.ownerOf(id);\n    }\n    / Metadata service /\n    /\n     * @notice Set the metadata service. Only the owner can do this\n     /\n    function setMetadataService(IMetadataService _newMetadataService)\n        public\n        onlyOwner\n    {\n        metadataService = _newMetadataService;\n    }\n    /\n     * @notice Get the metadata uri\n     * @return String uri of the metadata service\n     */\n    function uri(uint256 tokenId) public view override returns (string memory) {\n        return metadataService.uri(tokenId);\n    }\n    /\n     * @notice Set the address of the upgradeContract of the contract. only admin can do this\n     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time\n     * to make the contract not upgradable.\n     * @param _upgradeAddress address of an upgraded contract\n     /\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)\n        public\n        onlyOwner\n    {\n        if (address(upgradeContract) != address(0)) {\n            registrar.setApprovalForAll(address(upgradeContract), false);\n            ens.setApprovalForAll(address(upgradeContract), false);\n        }\n        upgradeContract = _upgradeAddress;\n        if (address(upgradeContract) != address(0)) {\n            registrar.setApprovalForAll(address(upgradeContract), true);\n            ens.setApprovalForAll(address(upgradeContract), true);\n        }\n    }\n    /\n     * @notice Checks if msg.sender is the owner or approved by the owner of a name\n     * @param node namehash of the name to check\n     /\n    modifier onlyTokenOwner(bytes32 node) {\n        if (!isTokenOwnerOrApproved(node, msg.sender)) {\n            revert Unauthorised(node, msg.sender);\n        }\n        _;\n    }\n    /\n     * @notice Checks if owner or approved by owner\n     * @param node namehash of the name to check\n     * @param addr which address to check permissions for\n     * @return whether or not is owner or approved\n     */\n    function isTokenOwnerOrApproved(bytes32 node, address addr)\n        public\n        view\n        override\n        returns (bool)\n    {\n        address owner = ownerOf(uint256(node));\n        return owner == addr || isApprovedForAll(owner, addr);\n    }\n    /\n     * @notice Gets fuse permissions for a specific name\n     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit\n     *      The interface has predefined fuses for all registry permissions, but additional\n     *      fuses can be added for other use cases\n     *      Also returns expiry, which is when the fuses are set to expire.\n     * @param node namehash of the name to check\n     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry &lt; block.timestamp\n     * @return expiry Unix time of when the name expires and fuses are to expire\n     /\n    function getFuses(bytes32 node)\n        public\n        view\n        override\n        returns (uint32 fuses, uint64 expiry)\n    {\n        (, fuses, expiry) = getData(uint256(node));\n        if (fuses == 0 &amp;&amp; expiry == 0) {\n            bytes memory name = names[node];\n            if (name.length == 0) {\n                revert NameNotFound();\n            }\n        }\n    }\n    /\n     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract\n     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar\n     * @param label label as a string of the .eth domain to wrap\n     * @param wrappedOwner Owner of the name in this contract\n     * @param fuses initial fuses to set\n     * @param expiry when the fuses will expire\n     * @param resolver resolver contract address\n     /\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address resolver\n    ) public override returns (uint64) {\n        uint256 tokenId = uint256(keccak256(bytes(label)));\n        address registrant = registrar.ownerOf(tokenId);\n        if (\n            registrant != msg.sender &amp;&amp;\n            !isApprovedForAll(registrant, msg.sender) &amp;&amp;\n            !registrar.isApprovedForAll(registrant, msg.sender)\n        ) {\n            revert Unauthorised(\n                _makeNode(ETH_NODE, bytes32(tokenId)),\n                msg.sender\n            );\n        }\n        // transfer the token from the user to this contract\n        registrar.transferFrom(registrant, address(this), tokenId);\n        // transfer the ens record back to the new owner (this contract)\n        registrar.reclaim(tokenId, address(this));\n        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);\n    }\n    /\n     * @dev Registers a new .eth second-level domain and wraps it.\n     *      Only callable by authorised controllers.\n     * @param label The label to register (Eg, \'foo\' for \'foo.eth\').\n     * @param wrappedOwner The owner of the wrapped name.\n     * @param duration The duration, in seconds, to register the name for.\n     * @param resolver The resolver address to set on the ENS registry (optional).\n     * @param fuses initial fuses to set\n     * @param expiry when the fuses will expire\n     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.\n     */\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint32 fuses,\n        uint64 expiry\n    ) external override onlyController returns (uint256 registrarExpiry) {\n        uint256 tokenId = uint256(keccak256(bytes(label)));\n        registrarExpiry = registrar.register(tokenId, address(this), duration);\n        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);\n    }\n    /\n     * @dev Renews a .eth second-level domain.\n     *      Only callable by authorised controllers.\n     * @param tokenId The hash of the label to register (eg, keccak256(\'foo\'), for \'foo.eth\').\n     * @param duration The number of seconds to renew the name for.\n     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.\n     /\n    function renew(\n        uint256 tokenId,\n        uint256 duration,\n        uint64 expiry\n    ) external override onlyController returns (uint256 expires) {\n        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));\n        expires = registrar.renew(tokenId, duration);\n        (address owner, uint32 fuses, uint64 oldExpiry) = getData(\n            uint256(node)\n        );\n        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));\n        _setData(node, owner, fuses, expiry);\n    }\n    /\n     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner in the registry or an authorised caller in the registry\n     * @param name The name to wrap, in DNS format\n     * @param wrappedOwner Owner of the name in this contract\n     * @param resolver resolver contract address\n     /\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) public override {\n        (bytes32 labelhash, uint256 offset) = name.readLabel(0);\n        bytes32 parentNode = name.namehash(offset);\n        bytes32 node = _makeNode(parentNode, labelhash);\n        if (parentNode == ETH_NODE) {\n            revert IncompatibleParent();\n        }\n        address owner = ens.owner(node);\n        if (\n            owner != msg.sender &amp;&amp;\n            !isApprovedForAll(owner, msg.sender) &amp;&amp;\n            !ens.isApprovedForAll(owner, msg.sender)\n        ) {\n            revert Unauthorised(node, msg.sender);\n        }\n        if (resolver != address(0)) {\n            ens.setResolver(node, resolver);\n        }\n        ens.setOwner(node, address(this));\n        _wrap(node, name, wrappedOwner, 0, 0);\n    }\n    /\n     * @notice Unwraps a .eth domain. e.g. vitalik.eth\n     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper\n     * @param labelhash labelhash of the .eth domain\n     * @param newRegistrant sets the owner in the .eth registrar to this address\n     * @param newController sets the owner in the registry to this address\n     */\n    function unwrapETH2LD(\n        bytes32 labelhash,\n        address newRegistrant,\n        address newController\n    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {\n        _unwrap(_makeNode(ETH_NODE, labelhash), newController);\n        registrar.transferFrom(\n            address(this),\n            newRegistrant,\n            uint256(labelhash)\n        );\n    }\n    /\n     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper\n     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash(\'xyz\')\n     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256(\'vitalik\')\n     * @param newController sets the owner in the registry to this address\n     /\n    function unwrap(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        address newController\n    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {\n        if (parentNode == ETH_NODE) {\n            revert IncompatibleParent();\n        }\n        _unwrap(_makeNode(parentNode, labelhash), newController);\n    }\n    /\n     * @notice Sets fuses of a name\n     * @param node namehash of the name\n     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)\n     /\n    function setFuses(bytes32 node, uint32 fuses)\n        public\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_BURN_FUSES)\n        returns (uint32)\n    {\n        if (fuses &amp; PARENT_CANNOT_CONTROL != 0) {\n            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.\n            revert Unauthorised(node, msg.sender);\n        }\n        (address owner, uint32 oldFuses, uint64 expiry) = getData(\n            uint256(node)\n        );\n        fuses |= oldFuses;\n        _setFuses(node, owner, fuses, expiry);\n        return fuses;\n    }\n    /\n     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract\n     *     and burning the token of this contract\n     * @dev Can be called by the owner of the name in this contract\n     * @param label Label as a string of the .eth name to upgrade\n     * @param wrappedOwner The owner of the wrapped name\n     */\n    function upgradeETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        address resolver\n    ) public {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(ETH_NODE, labelhash);\n        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n        upgradeContract.wrapETH2LD(\n            label,\n            wrappedOwner,\n            fuses,\n            expiry,\n            resolver\n        );\n    }\n    /\n     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner or an authorised caller\n     * Requires upgraded Namewrapper to permit old Namewrapper to call setSubnodeRecord for all names\n     * @param parentNode namehash of the parent name\n     * @param label Label as a string of the name to upgrade\n     * @param wrappedOwner Owner of the name in this contract\n     * @param resolver resolver contract for this name\n     /\n    function upgrade(\n        bytes32 parentNode,\n        string calldata label,\n        address wrappedOwner,\n        address resolver\n    ) public {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n        upgradeContract.setSubnodeRecord(\n            parentNode,\n            label,\n            wrappedOwner,\n            resolver,\n            0,\n            fuses,\n            expiry\n        );\n    }\n    / @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name\n     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash(\'xyz\')\n     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256(\'vitalik\')\n     * @param fuses fuses to burn\n     * @param expiry when the fuses will expire\n     /\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) public {\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(\n            uint256(node)\n        );\n        uint64 maxExpiry;\n        if (parentNode == ETH_NODE) {\n            if (!isTokenOwnerOrApproved(node, msg.sender)) {\n                revert Unauthorised(node, msg.sender);\n            }\n            // max expiry is set to the expiry on the registrar\n            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));\n        } else {\n            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {\n                revert Unauthorised(node, msg.sender);\n            }\n            // max expiry is set to the expiry of the parent\n            (, , maxExpiry) = getData(uint256(parentNode));\n        }\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed\n        if (\n            oldFuses &amp; PARENT_CANNOT_CONTROL != 0 &amp;&amp;\n            oldFuses | fuses != oldFuses\n        ) {\n            revert OperationProhibited(node);\n        }\n        fuses |= oldFuses;\n        _setFuses(node, owner, fuses, expiry);\n    }\n    /\n     * @notice Sets the subdomain owner in the registry and then wraps the subdomain\n     * @param parentNode parent namehash of the subdomain\n     * @param label label of the subdomain as a string\n     * @param newOwner newOwner in the registry\n     * @param fuses initial fuses for the wrapped subdomain\n     * @param expiry when the fuses will expire\n     /\n    function setSubnodeOwner(\n        bytes32 parentNode,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    )\n        public\n        onlyTokenOwner(parentNode)\n        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))\n        returns (bytes32 node)\n    {\n        bytes32 labelhash = keccak256(bytes(label));\n        node = _makeNode(parentNode, labelhash);\n        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);\n        if (ens.owner(node) != address(this)) {\n            ens.setSubnodeOwner(parentNode, labelhash, address(this));\n            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);\n        } else {\n            _transferAndBurnFuses(node, newOwner, fuses, expiry);\n        }\n    }\n    /\n     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain\n     * @param parentNode parent namehash of the subdomain\n     * @param label label of the subdomain as a string\n     * @param newOwner newOwner in the registry\n     * @param resolver resolver contract in the registry\n     * @param ttl ttl in the regsitry\n     * @param fuses initial fuses for the wrapped subdomain\n     * @param expiry expiry date for the domain\n     */\n    function setSubnodeRecord(\n        bytes32 parentNode,\n        string memory label,\n        address newOwner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    )\n        public\n        onlyTokenOwner(parentNode)\n        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))\n    {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);\n        if (ens.owner(node) != address(this)) {\n            ens.setSubnodeRecord(\n                parentNode,\n                labelhash,\n                address(this),\n                resolver,\n                ttl\n            );\n            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);\n        } else {\n            ens.setSubnodeRecord(\n                parentNode,\n                labelhash,\n                address(this),\n                resolver,\n                ttl\n            );\n            _transferAndBurnFuses(node, newOwner, fuses, expiry);\n        }\n    }\n    /\n     * @notice Sets records for the name in the ENS Registry\n     * @param node namehash of the name to set a record for\n     * @param owner newOwner in the registry\n     * @param resolver the resolver contract\n     * @param ttl ttl in the registry\n     /\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    )\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(\n            node,\n            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL\n        )\n    {\n        ens.setRecord(node, address(this), resolver, ttl);\n        (address oldOwner, , ) = getData(uint256(node));\n        _transfer(oldOwner, owner, uint256(node), 1, "");\n    }\n    /\n     * @notice Sets resolver contract in the registry\n     * @param node namehash of the name\n     * @param resolver the resolver contract\n     /\n    function setResolver(bytes32 node, address resolver)\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_SET_RESOLVER)\n    {\n        ens.setResolver(node, resolver);\n    }\n    /\n     * @notice Sets TTL in the registry\n     * @param node namehash of the name\n     * @param ttl TTL in the registry\n     */\n    function setTTL(bytes32 node, uint64 ttl)\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_SET_TTL)\n    {\n        ens.setTTL(node, ttl);\n    }\n    /\n     * @dev Allows an operation only if none of the specified fuses are burned.\n     * @param node The namehash of the name to check fuses on.\n     * @param fuseMask A bitmask of fuses that must not be burned.\n     /\n    modifier operationAllowed(bytes32 node, uint32 fuseMask) {\n        (, uint32 fuses, ) = getData(uint256(node));\n        if (fuses &amp; fuseMask != 0) {\n            revert OperationProhibited(node);\n        }\n        _;\n    }\n    /\n     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord\n     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt\n     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for\n     *      replacing a subdomain. If either conditions are true, then it is possible to call\n     *      setSubnodeOwner\n     * @param node namehash of the name to check\n     * @param labelhash labelhash of the name to check\n     /\n    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {\n        bytes32 subnode = makeNode(node, labelhash);\n        address owner = ens.owner(subnode);\n        if (owner == address(0)) {\n            (, uint32 fuses, ) = getData(uint256(node));\n            if (fuses &amp; CANNOT_CREATE_SUBDOMAIN != 0) {\n                revert OperationProhibited(node);\n            }\n        } else {\n            (, uint32 subnodeFuses, ) = getData(uint256(subnode));\n            if (subnodeFuses &amp; PARENT_CANNOT_CONTROL != 0) {\n                revert OperationProhibited(node);\n            }\n        }\n        ;\n    }\n    /*\n     * @notice Checks all Fuses in the mask are burned for the node\n     * @param node namehash of the name\n     * @param fuseMask the fuses you want to check\n     * @return Boolean of whether or not all the selected fuses are burned\n     /\n    function allFusesBurned(bytes32 node, uint32 fuseMask)\n        public\n        view\n        override\n        returns (bool)\n    {\n        (, uint32 fuses, ) = getData(uint256(node));\n        return fuses &amp; fuseMask == fuseMask;\n    }\n    function onERC721Received(\n        address to,\n        address,\n        uint256 tokenId,\n        bytes calldata data\n    ) public override returns (bytes4) {\n        //check if it\'s the eth registrar ERC721\n        if (msg.sender != address(registrar)) {\n            revert IncorrectTokenType();\n        }\n        (\n            string memory label,\n            address owner,\n            uint32 fuses,\n            uint64 expiry,\n            address resolver\n        ) = abi.decode(data, (string, address, uint32, uint64, address));\n        bytes32 labelhash = bytes32(tokenId);\n        bytes32 labelhashFromData = keccak256(bytes(label));\n        if (labelhashFromData != labelhash) {\n            revert LabelMismatch(labelhashFromData, labelhash);\n        }\n        // transfer the ens record back to the new owner (this contract)\n        registrar.reclaim(uint256(labelhash), address(this));\n        _wrapETH2LD(label, owner, fuses, expiry, resolver);\n        return IERC721Receiver(to).onERC721Received.selector;\n    }\n    / Internal functions /\n    function _canTransfer(uint32 fuses) internal pure override returns (bool) {\n        return fuses &amp; CANNOT_TRANSFER == 0;\n    }\n    function _makeNode(bytes32 node, bytes32 labelhash)\n        private\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(node, labelhash));\n    }\n    function _addLabel(string memory label, bytes memory name)\n        internal\n        pure\n        returns (bytes memory ret)\n    {\n        if (bytes(label).length &lt; 1) {\n            revert LabelTooShort();\n        }\n        if (bytes(label).length &gt; 255) {\n            revert LabelTooLong(label);\n        }\n        return abi.encodePacked(uint8(bytes(label).length), label, name);\n    }\n    function _mint(\n        bytes32 node,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal override {\n        address oldWrappedOwner = ownerOf(uint256(node));\n        _canFusesBeBurned(node, fuses);\n        if (oldWrappedOwner != address(0)) {\n            // burn and unwrap old token of old owner\n            _burn(uint256(node));\n            emit NameUnwrapped(node, address(0));\n        }\n        super._mint(node, wrappedOwner, fuses, expiry);\n    }\n    function _wrap(\n        bytes32 node,\n        bytes memory name,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        names[node] = name;\n        _mint(node, wrappedOwner, fuses, expiry);\n        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);\n    }\n    function _addLabelAndWrap(\n        bytes32 parentNode,\n        bytes32 node,\n        string memory label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        bytes memory name = _addLabel(label, names[parentNode]);\n        _wrap(node, name, newOwner, fuses, expiry);\n    }\n    function _prepareUpgrade(bytes32 node)\n        private\n        returns (uint32 fuses, uint64 expiry)\n    {\n        if (address(upgradeContract) == address(0)) {\n            revert CannotUpgrade();\n        }\n        if (!isTokenOwnerOrApproved(node, msg.sender)) {\n            revert Unauthorised(node, msg.sender);\n        }\n        (fuses, expiry) = getFuses(node);\n        // burn token and fuse data\n        _burn(uint256(node));\n    }\n    function _transferAndBurnFuses(\n        bytes32 node,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        (address owner, , ) = getData(uint256(node));\n        _transfer(owner, newOwner, uint256(node), 1, "");\n        _setFuses(node, newOwner, fuses, expiry);\n    }\n    // wrapper function for stack limit\n    function _getDataAndNormaliseExpiry(\n        bytes32 parentNode,\n        bytes32 node,\n        uint64 expiry\n    )\n        internal\n        view\n        returns (\n            address owner,\n            uint32 fuses,\n            uint64\n        )\n    {\n        uint64 oldExpiry;\n        (owner, fuses, oldExpiry) = getData(uint256(node));\n        (, , uint64 maxExpiry) = getData(uint256(parentNode));\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n        return (owner, fuses, expiry);\n    }\n    function _getETH2LDDataAndNormaliseExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    )\n        internal\n        view\n        returns (\n            address owner,\n            uint32 fuses,\n            uint64\n        )\n    {\n        uint64 oldExpiry;\n        (owner, fuses, oldExpiry) = getData(uint256(node));\n        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n        return (owner, fuses, expiry);\n    }\n    function _normaliseExpiry(\n        uint64 expiry,\n        uint64 oldExpiry,\n        uint64 maxExpiry\n    ) internal pure returns (uint64) {\n        // Expiry cannot be more than maximum allowed\n        // .eth names will check registrar, non .eth check parent\n        if (expiry &gt; maxExpiry) {\n            expiry = maxExpiry;\n        }\n        // Expiry cannot be less than old expiry\n        if (expiry &lt; oldExpiry) {\n            expiry = oldExpiry;\n        }\n        return expiry;\n    }\n    function _wrapETH2LD(\n        string memory label,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address resolver\n    ) private returns (uint64) {\n        // Mint a new ERC1155 token with fuses\n        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(ETH_NODE, labelhash);\n        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(\n            node,\n            labelhash,\n            expiry\n        );\n        _addLabelAndWrap(\n            ETH_NODE,\n            node,\n            label,\n            wrappedOwner,\n            fuses | PARENT_CANNOT_CONTROL,\n            expiry\n        );\n        if (resolver != address(0)) {\n            ens.setResolver(node, resolver);\n        }\n        return expiry;\n    }\n    function _unwrap(bytes32 node, address newOwner) private {\n        if (newOwner == address(0x0) || newOwner == address(this)) {\n            revert IncorrectTargetOwner(newOwner);\n        }\n        if (allFusesBurned(node, CANNOT_UNWRAP)) {\n            revert OperationProhibited(node);\n        }\n        // Burn token and fuse data\n        _burn(uint256(node));\n        ens.setOwner(node, newOwner);\n        emit NameUnwrapped(node, newOwner);\n    }\n    function _setFuses(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        _setData(node, owner, fuses, expiry);\n        emit FusesSet(node, fuses, expiry);\n    }\n    function _setData(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        _canFusesBeBurned(node, fuses);\n        super._setData(uint256(node), owner, fuses, expiry);\n    }\n    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {\n        if (\n            fuses &amp; ~PARENT_CANNOT_CONTROL != 0 &amp;&amp;\n            fuses &amp; (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=\n            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)\n        ) {\n            revert OperationProhibited(node);\n        }\n    }\n}\n.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\nimport "./ERC1155Fuse.sol";\nimport "./Controllable.sol";\nimport "./INameWrapper.sol";\nimport "./INameWrapperUpgrade.sol";\nimport "./IMetadataService.sol";\nimport "../registry/ENS.sol";\nimport "../ethregistrar/IBaseRegistrar.sol";\nimport "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";\nimport "@openzeppelin/contracts/access/Ownable.sol";\nimport "./BytesUtil.sol";\nerror Unauthorised(bytes32 node, address addr);\nerror NameNotFound();\nerror IncompatibleParent();\nerror IncompatibleName(bytes name);\nerror IncorrectTokenType();\nerror LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);\nerror LabelTooShort();\nerror LabelTooLong(string label);\nerror IncorrectTargetOwner(address owner);\nerror CannotUpgrade();\nerror InvalidExpiry(bytes32 node, uint64 expiry);\ncontract NameWrapper is\n    Ownable,\n    ERC1155Fuse,\n    INameWrapper,\n    Controllable,\n    IERC721Receiver\n{\n    using BytesUtils for bytes;\n    ENS public immutable override ens;\n    IBaseRegistrar public immutable override registrar;\n    IMetadataService public override metadataService;\n    mapping(bytes32 =&gt; bytes) public override names;\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n    bytes32 private constant ROOT_NODE =\n        0x0000000000000000000000000000000000000000000000000000000000000000;\n    //A contract address to a new upgraded contract if any\n    INameWrapperUpgrade public upgradeContract;\n    uint64 private constant MAX_EXPIRY = type(uint64).max;\n    constructor(\n        ENS _ens,\n        IBaseRegistrar _registrar,\n        IMetadataService _metadataService\n    ) {\n        ens = _ens;\n        registrar = _registrar;\n        metadataService = _metadataService;\n        / Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE /\n        _setData(\n            uint256(ETH_NODE),\n            address(0),\n            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),\n            MAX_EXPIRY\n        );\n        _setData(\n            uint256(ROOT_NODE),\n            address(0),\n            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),\n            MAX_EXPIRY\n        );\n        names[ROOT_NODE] = "\x00";\n        names[ETH_NODE] = "\x03eth\x00";\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC1155Fuse, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(INameWrapper).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    / ERC1155 /\n    function ownerOf(uint256 id)\n        public\n        view\n        override(ERC1155Fuse, INameWrapper)\n        returns (address owner)\n    {\n        return super.ownerOf(id);\n    }\n    / Metadata service /\n    /\n     * @notice Set the metadata service. Only the owner can do this\n     */\n    function setMetadataService(IMetadataService _newMetadataService)\n        public\n        onlyOwner\n    {\n        metadataService = _newMetadataService;\n    }\n    /\n     * @notice Get the metadata uri\n     * @return String uri of the metadata service\n     /\n    function uri(uint256 tokenId) public view override returns (string memory) {\n        return metadataService.uri(tokenId);\n    }\n    /\n     * @notice Set the address of the upgradeContract of the contract. only admin can do this\n     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time\n     * to make the contract not upgradable.\n     * @param _upgradeAddress address of an upgraded contract\n     /\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)\n        public\n        onlyOwner\n    {\n        if (address(upgradeContract) != address(0)) {\n            registrar.setApprovalForAll(address(upgradeContract), false);\n            ens.setApprovalForAll(address(upgradeContract), false);\n        }\n        upgradeContract = _upgradeAddress;\n        if (address(upgradeContract) != address(0)) {\n            registrar.setApprovalForAll(address(upgradeContract), true);\n            ens.setApprovalForAll(address(upgradeContract), true);\n        }\n    }\n    /\n     * @notice Checks if msg.sender is the owner or approved by the owner of a name\n     * @param node namehash of the name to check\n     */\n    modifier onlyTokenOwner(bytes32 node) {\n        if (!isTokenOwnerOrApproved(node, msg.sender)) {\n            revert Unauthorised(node, msg.sender);\n        }\n        _;\n    }\n    /\n     * @notice Checks if owner or approved by owner\n     * @param node namehash of the name to check\n     * @param addr which address to check permissions for\n     * @return whether or not is owner or approved\n     /\n    function isTokenOwnerOrApproved(bytes32 node, address addr)\n        public\n        view\n        override\n        returns (bool)\n    {\n        address owner = ownerOf(uint256(node));\n        return owner == addr || isApprovedForAll(owner, addr);\n    }\n    /\n     * @notice Gets fuse permissions for a specific name\n     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit\n     *      The interface has predefined fuses for all registry permissions, but additional\n     *      fuses can be added for other use cases\n     *      Also returns expiry, which is when the fuses are set to expire.\n     * @param node namehash of the name to check\n     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry &lt; block.timestamp\n     * @return expiry Unix time of when the name expires and fuses are to expire\n     /\n    function getFuses(bytes32 node)\n        public\n        view\n        override\n        returns (uint32 fuses, uint64 expiry)\n    {\n        (, fuses, expiry) = getData(uint256(node));\n        if (fuses == 0 &amp;&amp; expiry == 0) {\n            bytes memory name = names[node];\n            if (name.length == 0) {\n                revert NameNotFound();\n            }\n        }\n    }\n    /\n     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract\n     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar\n     * @param label label as a string of the .eth domain to wrap\n     * @param wrappedOwner Owner of the name in this contract\n     * @param fuses initial fuses to set\n     * @param expiry when the fuses will expire\n     * @param resolver resolver contract address\n     */\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address resolver\n    ) public override returns (uint64) {\n        uint256 tokenId = uint256(keccak256(bytes(label)));\n        address registrant = registrar.ownerOf(tokenId);\n        if (\n            registrant != msg.sender &amp;&amp;\n            !isApprovedForAll(registrant, msg.sender) &amp;&amp;\n            !registrar.isApprovedForAll(registrant, msg.sender)\n        ) {\n            revert Unauthorised(\n                _makeNode(ETH_NODE, bytes32(tokenId)),\n                msg.sender\n            );\n        }\n        // transfer the token from the user to this contract\n        registrar.transferFrom(registrant, address(this), tokenId);\n        // transfer the ens record back to the new owner (this contract)\n        registrar.reclaim(tokenId, address(this));\n        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);\n    }\n    /\n     * @dev Registers a new .eth second-level domain and wraps it.\n     *      Only callable by authorised controllers.\n     * @param label The label to register (Eg, \'foo\' for \'foo.eth\').\n     * @param wrappedOwner The owner of the wrapped name.\n     * @param duration The duration, in seconds, to register the name for.\n     * @param resolver The resolver address to set on the ENS registry (optional).\n     * @param fuses initial fuses to set\n     * @param expiry when the fuses will expire\n     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.\n     /\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint32 fuses,\n        uint64 expiry\n    ) external override onlyController returns (uint256 registrarExpiry) {\n        uint256 tokenId = uint256(keccak256(bytes(label)));\n        registrarExpiry = registrar.register(tokenId, address(this), duration);\n        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);\n    }\n    /\n     * @dev Renews a .eth second-level domain.\n     *      Only callable by authorised controllers.\n     * @param tokenId The hash of the label to register (eg, keccak256(\'foo\'), for \'foo.eth\').\n     * @param duration The number of seconds to renew the name for.\n     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.\n     /\n    function renew(\n        uint256 tokenId,\n        uint256 duration,\n        uint64 expiry\n    ) external override onlyController returns (uint256 expires) {\n        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));\n        expires = registrar.renew(tokenId, duration);\n        (address owner, uint32 fuses, uint64 oldExpiry) = getData(\n            uint256(node)\n        );\n        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));\n        _setData(node, owner, fuses, expiry);\n    }\n    /\n     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner in the registry or an authorised caller in the registry\n     * @param name The name to wrap, in DNS format\n     * @param wrappedOwner Owner of the name in this contract\n     * @param resolver resolver contract address\n     */\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) public override {\n        (bytes32 labelhash, uint256 offset) = name.readLabel(0);\n        bytes32 parentNode = name.namehash(offset);\n        bytes32 node = _makeNode(parentNode, labelhash);\n        if (parentNode == ETH_NODE) {\n            revert IncompatibleParent();\n        }\n        address owner = ens.owner(node);\n        if (\n            owner != msg.sender &amp;&amp;\n            !isApprovedForAll(owner, msg.sender) &amp;&amp;\n            !ens.isApprovedForAll(owner, msg.sender)\n        ) {\n            revert Unauthorised(node, msg.sender);\n        }\n        if (resolver != address(0)) {\n            ens.setResolver(node, resolver);\n        }\n        ens.setOwner(node, address(this));\n        _wrap(node, name, wrappedOwner, 0, 0);\n    }\n    /\n     * @notice Unwraps a .eth domain. e.g. vitalik.eth\n     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper\n     * @param labelhash labelhash of the .eth domain\n     * @param newRegistrant sets the owner in the .eth registrar to this address\n     * @param newController sets the owner in the registry to this address\n     /\n    function unwrapETH2LD(\n        bytes32 labelhash,\n        address newRegistrant,\n        address newController\n    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {\n        _unwrap(_makeNode(ETH_NODE, labelhash), newController);\n        registrar.transferFrom(\n            address(this),\n            newRegistrant,\n            uint256(labelhash)\n        );\n    }\n    /\n     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper\n     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash(\'xyz\')\n     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256(\'vitalik\')\n     * @param newController sets the owner in the registry to this address\n     /\n    function unwrap(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        address newController\n    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {\n        if (parentNode == ETH_NODE) {\n            revert IncompatibleParent();\n        }\n        _unwrap(_makeNode(parentNode, labelhash), newController);\n    }\n    /\n     * @notice Sets fuses of a name\n     * @param node namehash of the name\n     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)\n     */\n    function setFuses(bytes32 node, uint32 fuses)\n        public\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_BURN_FUSES)\n        returns (uint32)\n    {\n        if (fuses &amp; PARENT_CANNOT_CONTROL != 0) {\n            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.\n            revert Unauthorised(node, msg.sender);\n        }\n        (address owner, uint32 oldFuses, uint64 expiry) = getData(\n            uint256(node)\n        );\n        fuses |= oldFuses;\n        _setFuses(node, owner, fuses, expiry);\n        return fuses;\n    }\n    /\n     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract\n     *     and burning the token of this contract\n     * @dev Can be called by the owner of the name in this contract\n     * @param label Label as a string of the .eth name to upgrade\n     * @param wrappedOwner The owner of the wrapped name\n     /\n    function upgradeETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        address resolver\n    ) public {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(ETH_NODE, labelhash);\n        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n        upgradeContract.wrapETH2LD(\n            label,\n            wrappedOwner,\n            fuses,\n            expiry,\n            resolver\n        );\n    }\n    /\n     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner or an authorised caller\n     * Requires upgraded Namewrapper to permit old Namewrapper to call setSubnodeRecord for all names\n     * @param parentNode namehash of the parent name\n     * @param label Label as a string of the name to upgrade\n     * @param wrappedOwner Owner of the name in this contract\n     * @param resolver resolver contract for this name\n     /\n    function upgrade(\n        bytes32 parentNode,\n        string calldata label,\n        address wrappedOwner,\n        address resolver\n    ) public {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n        upgradeContract.setSubnodeRecord(\n            parentNode,\n            label,\n            wrappedOwner,\n            resolver,\n            0,\n            fuses,\n            expiry\n        );\n    }\n    / @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name\n     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash(\'xyz\')\n     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256(\'vitalik\')\n     * @param fuses fuses to burn\n     * @param expiry when the fuses will expire\n     /\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) public {\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(\n            uint256(node)\n        );\n        uint64 maxExpiry;\n        if (parentNode == ETH_NODE) {\n            if (!isTokenOwnerOrApproved(node, msg.sender)) {\n                revert Unauthorised(node, msg.sender);\n            }\n            // max expiry is set to the expiry on the registrar\n            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));\n        } else {\n            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {\n                revert Unauthorised(node, msg.sender);\n            }\n            // max expiry is set to the expiry of the parent\n            (, , maxExpiry) = getData(uint256(parentNode));\n        }\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed\n        if (\n            oldFuses &amp; PARENT_CANNOT_CONTROL != 0 &amp;&amp;\n            oldFuses | fuses != oldFuses\n        ) {\n            revert OperationProhibited(node);\n        }\n        fuses |= oldFuses;\n        _setFuses(node, owner, fuses, expiry);\n    }\n    /\n     * @notice Sets the subdomain owner in the registry and then wraps the subdomain\n     * @param parentNode parent namehash of the subdomain\n     * @param label label of the subdomain as a string\n     * @param newOwner newOwner in the registry\n     * @param fuses initial fuses for the wrapped subdomain\n     * @param expiry when the fuses will expire\n     */\n    function setSubnodeOwner(\n        bytes32 parentNode,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    )\n        public\n        onlyTokenOwner(parentNode)\n        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))\n        returns (bytes32 node)\n    {\n        bytes32 labelhash = keccak256(bytes(label));\n        node = _makeNode(parentNode, labelhash);\n        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);\n        if (ens.owner(node) != address(this)) {\n            ens.setSubnodeOwner(parentNode, labelhash, address(this));\n            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);\n        } else {\n            _transferAndBurnFuses(node, newOwner, fuses, expiry);\n        }\n    }\n    /\n     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain\n     * @param parentNode parent namehash of the subdomain\n     * @param label label of the subdomain as a string\n     * @param newOwner newOwner in the registry\n     * @param resolver resolver contract in the registry\n     * @param ttl ttl in the regsitry\n     * @param fuses initial fuses for the wrapped subdomain\n     * @param expiry expiry date for the domain\n     /\n    function setSubnodeRecord(\n        bytes32 parentNode,\n        string memory label,\n        address newOwner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    )\n        public\n        onlyTokenOwner(parentNode)\n        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))\n    {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);\n        if (ens.owner(node) != address(this)) {\n            ens.setSubnodeRecord(\n                parentNode,\n                labelhash,\n                address(this),\n                resolver,\n                ttl\n            );\n            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);\n        } else {\n            ens.setSubnodeRecord(\n                parentNode,\n                labelhash,\n                address(this),\n                resolver,\n                ttl\n            );\n            _transferAndBurnFuses(node, newOwner, fuses, expiry);\n        }\n    }\n    /\n     * @notice Sets records for the name in the ENS Registry\n     * @param node namehash of the name to set a record for\n     * @param owner newOwner in the registry\n     * @param resolver the resolver contract\n     * @param ttl ttl in the registry\n     /\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    )\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(\n            node,\n            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL\n        )\n    {\n        ens.setRecord(node, address(this), resolver, ttl);\n        (address oldOwner, , ) = getData(uint256(node));\n        _transfer(oldOwner, owner, uint256(node), 1, "");\n    }\n    /\n     * @notice Sets resolver contract in the registry\n     * @param node namehash of the name\n     * @param resolver the resolver contract\n     */\n    function setResolver(bytes32 node, address resolver)\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_SET_RESOLVER)\n    {\n        ens.setResolver(node, resolver);\n    }\n    /\n     * @notice Sets TTL in the registry\n     * @param node namehash of the name\n     * @param ttl TTL in the registry\n     /\n    function setTTL(bytes32 node, uint64 ttl)\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_SET_TTL)\n    {\n        ens.setTTL(node, ttl);\n    }\n    /\n     * @dev Allows an operation only if none of the specified fuses are burned.\n     * @param node The namehash of the name to check fuses on.\n     * @param fuseMask A bitmask of fuses that must not be burned.\n     /\n    modifier operationAllowed(bytes32 node, uint32 fuseMask) {\n        (, uint32 fuses, ) = getData(uint256(node));\n        if (fuses &amp; fuseMask != 0) {\n            revert OperationProhibited(node);\n        }\n        _;\n    }\n    /\n     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord\n     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt\n     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for\n     *      replacing a subdomain. If either conditions are true, then it is possible to call\n     *      setSubnodeOwner\n     * @param node namehash of the name to check\n     * @param labelhash labelhash of the name to check\n     */\n    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {\n        bytes32 subnode = makeNode(node, labelhash);\n        address owner = ens.owner(subnode);\n        if (owner == address(0)) {\n            (, uint32 fuses, ) = getData(uint256(node));\n            if (fuses &amp; CANNOT_CREATE_SUBDOMAIN != 0) {\n                revert OperationProhibited(node);\n            }\n        } else {\n            (, uint32 subnodeFuses, ) = getData(uint256(subnode));\n            if (subnodeFuses &amp; PARENT_CANNOT_CONTROL != 0) {\n                revert OperationProhibited(node);\n            }\n        }\n        ;\n    }\n    /\n     * @notice Checks all Fuses in the mask are burned for the node\n     * @param node namehash of the name\n     * @param fuseMask the fuses you want to check\n     * @return Boolean of whether or not all the selected fuses are burned\n     */\n    function allFusesBurned(bytes32 node, uint32 fuseMask)\n        public\n        view\n        override\n        returns (bool)\n    {\n        (, uint32 fuses, ) = getData(uint256(node));\n        return fuses &amp; fuseMask == fuseMask;\n    }\n    function onERC721Received(\n        address to,\n        address,\n        uint256 tokenId,\n        bytes calldata data\n    ) public override returns (bytes4) {\n        //check if it\'s the eth registrar ERC721\n        if (msg.sender != address(registrar)) {\n            revert IncorrectTokenType();\n        }\n        (\n            string memory label,\n            address owner,\n            uint32 fuses,\n            uint64 expiry,\n            address resolver\n        ) = abi.decode(data, (string, address, uint32, uint64, address));\n        bytes32 labelhash = bytes32(tokenId);\n        bytes32 labelhashFromData = keccak256(bytes(label));\n        if (labelhashFromData != labelhash) {\n            revert LabelMismatch(labelhashFromData, labelhash);\n        }\n        // transfer the ens record back to the new owner (this contract)\n        registrar.reclaim(uint256(labelhash), address(this));\n        _wrapETH2LD(label, owner, fuses, expiry, resolver);\n        return IERC721Receiver(to).onERC721Received.selector;\n    }\n    / Internal functions */\n    function _canTransfer(uint32 fuses) internal pure override returns (bool) {\n        return fuses &amp; CANNOT_TRANSFER == 0;\n    }\n    function _makeNode(bytes32 node, bytes32 labelhash)\n        private\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(node, labelhash));\n    }\n    function _addLabel(string memory label, bytes memory name)\n        internal\n        pure\n        returns (bytes memory ret)\n    {\n        if (bytes(label).length &lt; 1) {\n            revert LabelTooShort();\n        }\n        if (bytes(label).length &gt; 255) {\n            revert LabelTooLong(label);\n        }\n        return abi.encodePacked(uint8(bytes(label).length), label, name);\n    }\n    function _mint(\n        bytes32 node,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal override {\n        address oldWrappedOwner = ownerOf(uint256(node));\n        _canFusesBeBurned(node, fuses);\n        if (oldWrappedOwner != address(0)) {\n            // burn and unwrap old token of old owner\n            _burn(uint256(node));\n            emit NameUnwrapped(node, address(0));\n        }\n        super._mint(node, wrappedOwner, fuses, expiry);\n    }\n    function _wrap(\n        bytes32 node,\n        bytes memory name,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        names[node] = name;\n        _mint(node, wrappedOwner, fuses, expiry);\n        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);\n    }\n    function _addLabelAndWrap(\n        bytes32 parentNode,\n        bytes32 node,\n        string memory label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        bytes memory name = _addLabel(label, names[parentNode]);\n        _wrap(node, name, newOwner, fuses, expiry);\n    }\n    function _prepareUpgrade(bytes32 node)\n        private\n        returns (uint32 fuses, uint64 expiry)\n    {\n        if (address(upgradeContract) == address(0)) {\n            revert CannotUpgrade();\n        }\n        if (!isTokenOwnerOrApproved(node, msg.sender)) {\n            revert Unauthorised(node, msg.sender);\n        }\n        (fuses, expiry) = getFuses(node);\n        // burn token and fuse data\n        _burn(uint256(node));\n    }\n    function _transferAndBurnFuses(\n        bytes32 node,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        (address owner, , ) = getData(uint256(node));\n        _transfer(owner, newOwner, uint256(node), 1, "");\n        _setFuses(node, newOwner, fuses, expiry);\n    }\n    // wrapper function for stack limit\n    function _getDataAndNormaliseExpiry(\n        bytes32 parentNode,\n        bytes32 node,\n        uint64 expiry\n    )\n        internal\n        view\n        returns (\n            address owner,\n            uint32 fuses,\n            uint64\n        )\n    {\n        uint64 oldExpiry;\n        (owner, fuses, oldExpiry) = getData(uint256(node));\n        (, , uint64 maxExpiry) = getData(uint256(parentNode));\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n        return (owner, fuses, expiry);\n    }\n    function _getETH2LDDataAndNormaliseExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    )\n        internal\n        view\n        returns (\n            address owner,\n            uint32 fuses,\n            uint64\n        )\n    {\n        uint64 oldExpiry;\n        (owner, fuses, oldExpiry) = getData(uint256(node));\n        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n        return (owner, fuses, expiry);\n    }\n    function _normaliseExpiry(\n        uint64 expiry,\n        uint64 oldExpiry,\n        uint64 maxExpiry\n    ) internal pure returns (uint64) {\n        // Expiry cannot be more than maximum allowed\n        // .eth names will check registrar, non .eth check parent\n        if (expiry &gt; maxExpiry) {\n            expiry = maxExpiry;\n        }\n        // Expiry cannot be less than old expiry\n        if (expiry &lt; oldExpiry) {\n            expiry = oldExpiry;\n        }\n        return expiry;\n    }\n    function _wrapETH2LD(\n        string memory label,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address resolver\n    ) private returns (uint64) {\n        // Mint a new ERC1155 token with fuses\n        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(ETH_NODE, labelhash);\n        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(\n            node,\n            labelhash,\n            expiry\n        );\n        _addLabelAndWrap(\n            ETH_NODE,\n            node,\n            label,\n            wrappedOwner,\n            fuses | PARENT_CANNOT_CONTROL,\n            expiry\n        );\n        if (resolver != address(0)) {\n            ens.setResolver(node, resolver);\n        }\n        return expiry;\n    }\n    function _unwrap(bytes32 node, address newOwner) private {\n        if (newOwner == address(0x0) || newOwner == address(this)) {\n            revert IncorrectTargetOwner(newOwner);\n        }\n        if (allFusesBurned(node, CANNOT_UNWRAP)) {\n            revert OperationProhibited(node);\n        }\n        // Burn token and fuse data\n        _burn(uint256(node));\n        ens.setOwner(node, newOwner);\n        emit NameUnwrapped(node, newOwner);\n    }\n    function _setFuses(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        _setData(node, owner, fuses, expiry);\n        emit FusesSet(node, fuses, expiry);\n    }\n    function _setData(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        _canFusesBeBurned(node, fuses);\n        super._setData(uint256(node), owner, fuses, expiry);\n    }\n    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {\n        if (\n            fuses &amp; ~PARENT_CANNOT_CONTROL != 0 &amp;&amp;\n            fuses &amp; (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=\n            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)\n        ) {\n            revert OperationProhibited(node);\n        }\n    }\n}\n".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s analyze the provided Solidity contract and identify potential areas for improvement or enhancement.\n1. Access Control Enhancements: While the contract uses the Ownable pattern for access control, we could consider implementing a more granular role-based access control (RBAC) system using OpenZeppelin\'s AccessControl. This would allow for multiple roles with different permissions, enhancing security and flexibility.\n2. Gas Optimization: The contract could be optimized for gas usage. For instance, we could review the functions to minimize state variable writes and redundant calculations. Functions like _normaliseExpiry could be optimized to reduce the number of conditional checks.\n3. Event Emissions: While the contract emits events for significant actions, we could ensure that all state-changing functions emit appropriate events. This would improve transparency and allow for better tracking of contract interactions.\n4. Upgradeability Pattern: The contract mentions an upgrade mechanism, but we could consider implementing a more robust upgradeability pattern, such as the proxy pattern. This would allow for seamless upgrades without losing state or requiring users to interact with a new contract.\n5. Input Validation: Additional input validation could be added to functions like wrapETH2LD and registerAndWrapETH2LD to ensure that the parameters passed (like wrappedOwner, resolver, etc.) are valid addresses and not zero addresses.\n6. Reentrancy Guard: Although the contract appears to handle external calls carefully, adding a reentrancy guard to critical functions could further enhance security against potential reentrancy attacks.\n7. Documentation and Comments: While the contract has some comments, enhancing the documentation, especially around complex functions, would improve maintainability and understanding for future developers.\n8. Testing and Audit**: Ensure that the contract undergoes thorough testing, including unit tests and integration tests, to cover all edge cases. Additionally, an external audit by a reputable firm could provide an extra layer of security assurance.\nWhich of these suggestions resonates most with you, or do you have any additional ideas to consider?', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 20:35:30 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | //SPDX-License-Identifier: MIT pragma solidity ^0.8.4; import "./ERC1155Fuse.sol"; import "./Controllable.sol"; import "./INameWrapper.sol"; import "./INameWrapperUpgrade.sol"; import "./IMetadataService.sol"; import "../registry/ENS.sol"; import "../ethregistrar/IBaseRegistrar.sol"; import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "./BytesUtil.sol"; error Unauthorised(bytes32 node, address addr); error NameNotFound(); error IncompatibleParent(); error IncompatibleName(bytes name); error IncorrectTokenType(); error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash); error LabelTooShort(); error LabelTooLong(string label); error IncorrectTargetOwner(address owner); error CannotUpgrade(); error InvalidExpiry(bytes32 node, uint64 expiry); contract NameWrapper is     Ownable,     ERC1155Fuse,     INameWrapper,     Controllable,     IERC721Receiver {     using BytesUtils for bytes;     ENS public immutable override ens;     IBaseRegistrar public immutable override registrar;     IMetadataService public override metadataService;     mapping(bytes32 =&gt; bytes) public override names; bytes32 private constant ETH_NODE =     0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae; bytes32 private constant ROOT_NODE =     0x0000000000000000000000000000000000000000000000000000000000000000;  //A contract address to a new upgraded contract if any INameWrapperUpgrade public upgradeContract; uint64 private constant MAX_EXPIRY = type(uint64).max;  constructor(     ENS _ens,     IBaseRegistrar _registrar,     IMetadataService _metadataService ) {     ens = _ens;     registrar = _registrar;     metadataService = _metadataService;      /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */      _setData(         uint256(ETH_NODE),         address(0),         uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),         MAX_EXPIRY     );     _setData(         uint256(ROOT_NODE),         address(0),         uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),         MAX_EXPIRY     );     names[ROOT_NODE] = "\x00";     names[ETH_NODE] = "\x03eth\x00"; }  function supportsInterface(bytes4 interfaceId)     public     view     virtual     override(ERC1155Fuse, IERC165)     returns (bool) {     return         interfaceId == type(INameWrapper).interfaceId ||         super.supportsInterface(interfaceId); }  /* ERC1155 */  function ownerOf(uint256 id)     public     view     override(ERC1155Fuse, INameWrapper)     returns (address owner) {     return super.ownerOf(id); }  /* Metadata service */  /**  * @notice Set the metadata service. Only the owner can do this  */  function setMetadataService(IMetadataService _newMetadataService)     public     onlyOwner {     metadataService = _newMetadataService; }  /**  * @notice Get the metadata uri  * @return String uri of the metadata service  */  function uri(uint256 tokenId) public view override returns (string memory) {     return metadataService.uri(tokenId); }  /**  * @notice Set the address of the upgradeContract of the contract. only admin can do this  * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time  * to make the contract not upgradable.  * @param _upgradeAddress address of an upgraded contract  */  function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)     public     onlyOwner {     if (address(upgradeContract) != address(0)) {         registrar.setApprovalForAll(address(upgradeContract), false);         ens.setApprovalForAll(address(upgradeContract), false);     }      upgradeContract = _upgradeAddress;      if (address(upgradeContract) != address(0)) {         registrar.setApprovalForAll(address(upgradeContract), true);         ens.setApprovalForAll(address(upgradeContract), true);     } }  /**  * @notice Checks if msg.sender is the owner or approved by the owner of a name  * @param node namehash of the name to check  */  modifier onlyTokenOwner(bytes32 node) {     if (!isTokenOwnerOrApproved(node, msg.sender)) {         revert Unauthorised(node, msg.sender);     }      _; }  /**  * @notice Checks if owner or approved by owner  * @param node namehash of the name to check  * @param addr which address to check permissions for  * @return whether or not is owner or approved  */  function isTokenOwnerOrApproved(bytes32 node, address addr)     public     view     override     returns (bool) {     address owner = ownerOf(uint256(node));     return owner == addr || isApprovedForAll(owner, addr); }  /**  * @notice Gets fuse permissions for a specific name  * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit  *      The interface has predefined fuses for all registry permissions, but additional  *      fuses can be added for other use cases  *      Also returns expiry, which is when the fuses are set to expire.  * @param node namehash of the name to check  * @return fuses A number that represents the permissions a name has. Returns 0 when expiry &lt; block.timestamp  * @return expiry Unix time of when the name expires and fuses are to expire  */ function getFuses(bytes32 node)     public     view     override     returns (uint32 fuses, uint64 expiry) {     (, fuses, expiry) = getData(uint256(node));     if (fuses == 0 &amp;&amp; expiry == 0) {         bytes memory name = names[node];         if (name.length == 0) {             revert NameNotFound();         }     } }  /**  * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract  * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar  * @param label label as a string of the .eth domain to wrap  * @param wrappedOwner Owner of the name in this contract  * @param fuses initial fuses to set  * @param expiry when the fuses will expire  * @param resolver resolver contract address  */  function wrapETH2LD(     string calldata label,     address wrappedOwner,     uint32 fuses,     uint64 expiry,     address resolver ) public override returns (uint64) {     uint256 tokenId = uint256(keccak256(bytes(label)));     address registrant = registrar.ownerOf(tokenId);     if (         registrant != msg.sender &amp;&amp;         !isApprovedForAll(registrant, msg.sender) &amp;&amp;         !registrar.isApprovedForAll(registrant, msg.sender)     ) {         revert Unauthorised(             _makeNode(ETH_NODE, bytes32(tokenId)),             msg.sender         );     }      // transfer the token from the user to this contract     registrar.transferFrom(registrant, address(this), tokenId);      // transfer the ens record back to the new owner (this contract)     registrar.reclaim(tokenId, address(this));      return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver); }  /**  * @dev Registers a new .eth second-level domain and wraps it.  *      Only callable by authorised controllers.  * @param label The label to register (Eg, 'foo' for 'foo.eth').  * @param wrappedOwner The owner of the wrapped name.  * @param duration The duration, in seconds, to register the name for.  * @param resolver The resolver address to set on the ENS registry (optional).  * @param fuses initial fuses to set  * @param expiry when the fuses will expire  * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.  */  function registerAndWrapETH2LD(     string calldata label,     address wrappedOwner,     uint256 duration,     address resolver,     uint32 fuses,     uint64 expiry ) external override onlyController returns (uint256 registrarExpiry) {     uint256 tokenId = uint256(keccak256(bytes(label)));     registrarExpiry = registrar.register(tokenId, address(this), duration);     _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver); }  /**  * @dev Renews a .eth second-level domain.  *      Only callable by authorised controllers.  * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').  * @param duration The number of seconds to renew the name for.  * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.  */ function renew(     uint256 tokenId,     uint256 duration,     uint64 expiry ) external override onlyController returns (uint256 expires) {     bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));      expires = registrar.renew(tokenId, duration);     (address owner, uint32 fuses, uint64 oldExpiry) = getData(         uint256(node)     );     expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));      _setData(node, owner, fuses, expiry); }  /**  * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner in the registry or an authorised caller in the registry  * @param name The name to wrap, in DNS format  * @param wrappedOwner Owner of the name in this contract  * @param resolver resolver contract address  */  function wrap(     bytes calldata name,     address wrappedOwner,     address resolver ) public override {     (bytes32 labelhash, uint256 offset) = name.readLabel(0);     bytes32 parentNode = name.namehash(offset);     bytes32 node = _makeNode(parentNode, labelhash);      if (parentNode == ETH_NODE) {         revert IncompatibleParent();     }      address owner = ens.owner(node);      if (         owner != msg.sender &amp;&amp;         !isApprovedForAll(owner, msg.sender) &amp;&amp;         !ens.isApprovedForAll(owner, msg.sender)     ) {         revert Unauthorised(node, msg.sender);     }      if (resolver != address(0)) {         ens.setResolver(node, resolver);     }      ens.setOwner(node, address(this));      _wrap(node, name, wrappedOwner, 0, 0); }  /**  * @notice Unwraps a .eth domain. e.g. vitalik.eth  * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper  * @param labelhash labelhash of the .eth domain  * @param newRegistrant sets the owner in the .eth registrar to this address  * @param newController sets the owner in the registry to this address  */  function unwrapETH2LD(     bytes32 labelhash,     address newRegistrant,     address newController ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {     _unwrap(_makeNode(ETH_NODE, labelhash), newController);     registrar.transferFrom(         address(this),         newRegistrant,         uint256(labelhash)     ); }  /**  * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper  * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')  * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')  * @param newController sets the owner in the registry to this address  */  function unwrap(     bytes32 parentNode,     bytes32 labelhash,     address newController ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {     if (parentNode == ETH_NODE) {         revert IncompatibleParent();     }     _unwrap(_makeNode(parentNode, labelhash), newController); }  /**  * @notice Sets fuses of a name  * @param node namehash of the name  * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)  */  function setFuses(bytes32 node, uint32 fuses)     public     onlyTokenOwner(node)     operationAllowed(node, CANNOT_BURN_FUSES)     returns (uint32) {     if (fuses &amp; PARENT_CANNOT_CONTROL != 0) {         // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.         revert Unauthorised(node, msg.sender);     }      (address owner, uint32 oldFuses, uint64 expiry) = getData(         uint256(node)     );      fuses |= oldFuses;     _setFuses(node, owner, fuses, expiry);     return fuses; }  /**  * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract  *     and burning the token of this contract  * @dev Can be called by the owner of the name in this contract  * @param label Label as a string of the .eth name to upgrade  * @param wrappedOwner The owner of the wrapped name  */  function upgradeETH2LD(     string calldata label,     address wrappedOwner,     address resolver ) public {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(ETH_NODE, labelhash);     (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);      upgradeContract.wrapETH2LD(         label,         wrappedOwner,         fuses,         expiry,         resolver     ); }  /**  * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner or an authorised caller  * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names  * @param parentNode namehash of the parent name  * @param label Label as a string of the name to upgrade  * @param wrappedOwner Owner of the name in this contract  * @param resolver resolver contract for this name  */  function upgrade(     bytes32 parentNode,     string calldata label,     address wrappedOwner,     address resolver ) public {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(parentNode, labelhash);     (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);     upgradeContract.setSubnodeRecord(         parentNode,         label,         wrappedOwner,         resolver,         0,         fuses,         expiry     ); }  /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name  * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')  * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')  * @param fuses fuses to burn  * @param expiry when the fuses will expire  */  function setChildFuses(     bytes32 parentNode,     bytes32 labelhash,     uint32 fuses,     uint64 expiry ) public {     bytes32 node = _makeNode(parentNode, labelhash);     (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(         uint256(node)     );     uint64 maxExpiry;     if (parentNode == ETH_NODE) {         if (!isTokenOwnerOrApproved(node, msg.sender)) {             revert Unauthorised(node, msg.sender);         }         // max expiry is set to the expiry on the registrar         maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));     } else {         if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {             revert Unauthorised(node, msg.sender);         }          // max expiry is set to the expiry of the parent         (, , maxExpiry) = getData(uint256(parentNode));     }      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);      // if PARENT_CANNOT_CONTROL has been burned and fuses have changed     if (         oldFuses &amp; PARENT_CANNOT_CONTROL != 0 &amp;&amp;         oldFuses | fuses != oldFuses     ) {         revert OperationProhibited(node);     }     fuses |= oldFuses;     _setFuses(node, owner, fuses, expiry); }  /**  * @notice Sets the subdomain owner in the registry and then wraps the subdomain  * @param parentNode parent namehash of the subdomain  * @param label label of the subdomain as a string  * @param newOwner newOwner in the registry  * @param fuses initial fuses for the wrapped subdomain  * @param expiry when the fuses will expire  */  function setSubnodeOwner(     bytes32 parentNode,     string calldata label,     address newOwner,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))     returns (bytes32 node) {     bytes32 labelhash = keccak256(bytes(label));     node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);      if (ens.owner(node) != address(this)) {         ens.setSubnodeOwner(parentNode, labelhash, address(this));         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } }  /**  * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain  * @param parentNode parent namehash of the subdomain  * @param label label of the subdomain as a string  * @param newOwner newOwner in the registry  * @param resolver resolver contract in the registry  * @param ttl ttl in the regsitry  * @param fuses initial fuses for the wrapped subdomain  * @param expiry expiry date for the domain  */  function setSubnodeRecord(     bytes32 parentNode,     string memory label,     address newOwner,     address resolver,     uint64 ttl,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label))) {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);     if (ens.owner(node) != address(this)) {         ens.setSubnodeRecord(             parentNode,             labelhash,             address(this),             resolver,             ttl         );         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         ens.setSubnodeRecord(             parentNode,             labelhash,             address(this),             resolver,             ttl         );         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } }  /**  * @notice Sets records for the name in the ENS Registry  * @param node namehash of the name to set a record for  * @param owner newOwner in the registry  * @param resolver the resolver contract  * @param ttl ttl in the registry  */  function setRecord(     bytes32 node,     address owner,     address resolver,     uint64 ttl )     public     override     onlyTokenOwner(node)     operationAllowed(         node,         CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL     ) {     ens.setRecord(node, address(this), resolver, ttl);     (address oldOwner, , ) = getData(uint256(node));     _transfer(oldOwner, owner, uint256(node), 1, ""); }  /**  * @notice Sets resolver contract in the registry  * @param node namehash of the name  * @param resolver the resolver contract  */  function setResolver(bytes32 node, address resolver)     public     override     onlyTokenOwner(node)     operationAllowed(node, CANNOT_SET_RESOLVER) {     ens.setResolver(node, resolver); }  /**  * @notice Sets TTL in the registry  * @param node namehash of the name  * @param ttl TTL in the registry  */  function setTTL(bytes32 node, uint64 ttl)     public     override     onlyTokenOwner(node)     operationAllowed(node, CANNOT_SET_TTL) {     ens.setTTL(node, ttl); }  /**  * @dev Allows an operation only if none of the specified fuses are burned.  * @param node The namehash of the name to check fuses on.  * @param fuseMask A bitmask of fuses that must not be burned.  */  modifier operationAllowed(bytes32 node, uint32 fuseMask) {     (, uint32 fuses, ) = getData(uint256(node));     if (fuses &amp; fuseMask != 0) {         revert OperationProhibited(node);     }     _; }  /**  * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord  * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt  *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for  *      replacing a subdomain. If either conditions are true, then it is possible to call  *      setSubnodeOwner  * @param node namehash of the name to check  * @param labelhash labelhash of the name to check  */  modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {     bytes32 subnode = _makeNode(node, labelhash);     address owner = ens.owner(subnode);      if (owner == address(0)) {         (, uint32 fuses, ) = getData(uint256(node));         if (fuses &amp; CANNOT_CREATE_SUBDOMAIN != 0) {             revert OperationProhibited(node);         }     } else {         (, uint32 subnodeFuses, ) = getData(uint256(subnode));         if (subnodeFuses &amp; PARENT_CANNOT_CONTROL != 0) {             revert OperationProhibited(node);         }     }      _; }  /**  * @notice Checks all Fuses in the mask are burned for the node  * @param node namehash of the name  * @param fuseMask the fuses you want to check  * @return Boolean of whether or not all the selected fuses are burned  */  function allFusesBurned(bytes32 node, uint32 fuseMask)     public     view     override     returns (bool) {     (, uint32 fuses, ) = getData(uint256(node));     return fuses &amp; fuseMask == fuseMask; }  function onERC721Received(     address to,     address,     uint256 tokenId,     bytes calldata data ) public override returns (bytes4) {     //check if it's the eth registrar ERC721     if (msg.sender != address(registrar)) {         revert IncorrectTokenType();     }      (         string memory label,         address owner,         uint32 fuses,         uint64 expiry,         address resolver     ) = abi.decode(data, (string, address, uint32, uint64, address));      bytes32 labelhash = bytes32(tokenId);     bytes32 labelhashFromData = keccak256(bytes(label));      if (labelhashFromData != labelhash) {         revert LabelMismatch(labelhashFromData, labelhash);     }      // transfer the ens record back to the new owner (this contract)     registrar.reclaim(uint256(labelhash), address(this));      _wrapETH2LD(label, owner, fuses, expiry, resolver);      return IERC721Receiver(to).onERC721Received.selector; }  /***** Internal functions */  function _canTransfer(uint32 fuses) internal pure override returns (bool) {     return fuses &amp; CANNOT_TRANSFER == 0; }  function _makeNode(bytes32 node, bytes32 labelhash)     private     pure     returns (bytes32) {     return keccak256(abi.encodePacked(node, labelhash)); }  function _addLabel(string memory label, bytes memory name)     internal     pure     returns (bytes memory ret) {     if (bytes(label).length &lt; 1) {         revert LabelTooShort();     }     if (bytes(label).length &gt; 255) {         revert LabelTooLong(label);     }     return abi.encodePacked(uint8(bytes(label).length), label, name); }  function _mint(     bytes32 node,     address wrappedOwner,     uint32 fuses,     uint64 expiry ) internal override {     address oldWrappedOwner = ownerOf(uint256(node));     _canFusesBeBurned(node, fuses);     if (oldWrappedOwner != address(0)) {         // burn and unwrap old token of old owner         _burn(uint256(node));         emit NameUnwrapped(node, address(0));     }     super._mint(node, wrappedOwner, fuses, expiry); }  function _wrap(     bytes32 node,     bytes memory name,     address wrappedOwner,     uint32 fuses,     uint64 expiry ) internal {     names[node] = name;     _mint(node, wrappedOwner, fuses, expiry);     emit NameWrapped(node, name, wrappedOwner, fuses, expiry); }  function _addLabelAndWrap(     bytes32 parentNode,     bytes32 node,     string memory label,     address newOwner,     uint32 fuses,     uint64 expiry ) internal {     bytes memory name = _addLabel(label, names[parentNode]);     _wrap(node, name, newOwner, fuses, expiry); }  function _prepareUpgrade(bytes32 node)     private     returns (uint32 fuses, uint64 expiry) {     if (address(upgradeContract) == address(0)) {         revert CannotUpgrade();     }      if (!isTokenOwnerOrApproved(node, msg.sender)) {         revert Unauthorised(node, msg.sender);     }      (fuses, expiry) = getFuses(node);      // burn token and fuse data     _burn(uint256(node)); }  function _transferAndBurnFuses(     bytes32 node,     address newOwner,     uint32 fuses,     uint64 expiry ) internal {     (address owner, , ) = getData(uint256(node));     _transfer(owner, newOwner, uint256(node), 1, "");     _setFuses(node, newOwner, fuses, expiry); }  // wrapper function for stack limit function _getDataAndNormaliseExpiry(     bytes32 parentNode,     bytes32 node,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     (, , uint64 maxExpiry) = getData(uint256(parentNode));      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); }  function _getETH2LDDataAndNormaliseExpiry(     bytes32 node,     bytes32 labelhash,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); }  function _normaliseExpiry(     uint64 expiry,     uint64 oldExpiry,     uint64 maxExpiry ) internal pure returns (uint64) {     // Expiry cannot be more than maximum allowed     // .eth names will check registrar, non .eth check parent     if (expiry &gt; maxExpiry) {         expiry = maxExpiry;     }     // Expiry cannot be less than old expiry     if (expiry &lt; oldExpiry) {         expiry = oldExpiry;     }      return expiry; }  function _wrapETH2LD(     string memory label,     address wrappedOwner,     uint32 fuses,     uint64 expiry,     address resolver ) private returns (uint64) {     // Mint a new ERC1155 token with fuses     // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(ETH_NODE, labelhash);      (, , expiry) = _getETH2LDDataAndNormaliseExpiry(         node,         labelhash,         expiry     );      _addLabelAndWrap(         ETH_NODE,         node,         label,         wrappedOwner,         fuses | PARENT_CANNOT_CONTROL,         expiry     );     if (resolver != address(0)) {         ens.setResolver(node, resolver);     }      return expiry; }  function _unwrap(bytes32 node, address newOwner) private {     if (newOwner == address(0x0) || newOwner == address(this)) {         revert IncorrectTargetOwner(newOwner);     }      if (allFusesBurned(node, CANNOT_UNWRAP)) {         revert OperationProhibited(node);     }      // Burn token and fuse data     _burn(uint256(node));     ens.setOwner(node, newOwner);      emit NameUnwrapped(node, newOwner); }  function _setFuses(     bytes32 node,     address owner,     uint32 fuses,     uint64 expiry ) internal {     _setData(node, owner, fuses, expiry);     emit FusesSet(node, fuses, expiry); }  function _setData(     bytes32 node,     address owner,     uint32 fuses,     uint64 expiry ) internal {     _canFusesBeBurned(node, fuses);     super._setData(uint256(node), owner, fuses, expiry); }  function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {     if (         fuses &amp; ~PARENT_CANNOT_CONTROL != 0 &amp;&amp;         fuses &amp; (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=         (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)     ) {         revert OperationProhibited(node);     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 20:35:30 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: //SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "./ERC1155Fuse.sol";
import "./Controllable.sol";
import "./INameWrapper.sol";
import "./INameWrapperUpgrade.sol";
import "./IMetadataService.sol";
import "../registry/ENS.sol";
import "../ethregistrar/IBaseRegistrar.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./BytesUtil.sol";

error Unauthorised(bytes32 node, address addr);
error NameNotFound();
error IncompatibleParent();
error IncompatibleName(bytes name);
error IncorrectTokenType();
error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);
error LabelTooShort();
error LabelTooLong(string label);
error IncorrectTargetOwner(address owner);
error CannotUpgrade();
error InvalidExpiry(bytes32 node, uint64 expiry);

contract NameWrapper is
    Ownable,
    ERC1155Fuse,
    INameWrapper,
    Controllable,
    IERC721Receiver
{
    using BytesUtils for bytes;
    ENS public immutable override ens;
    IBaseRegistrar public immutable override registrar;
    IMetadataService public override metadataService;
    mapping(bytes32 => bytes) public override names;

    bytes32 private constant ETH_NODE =
        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
    bytes32 private constant ROOT_NODE =
        0x0000000000000000000000000000000000000000000000000000000000000000;

    //A contract address to a new upgraded contract if any
    INameWrapperUpgrade public upgradeContract;
    uint64 private constant MAX_EXPIRY = type(uint64).max;

    constructor(
        ENS _ens,
        IBaseRegistrar _registrar,
        IMetadataService _metadataService
    ) {
        ens = _ens;
        registrar = _registrar;
        metadataService = _metadataService;

        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */

        _setData(
            uint256(ETH_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        _setData(
            uint256(ROOT_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        names[ROOT_NODE] = "\x00";
        names[ETH_NODE] = "\x03eth\x00";
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Fuse, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(INameWrapper).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /* ERC1155 */

    function ownerOf(uint256 id)
        public
        view
        override(ERC1155Fuse, INameWrapper)
        returns (address owner)
    {
        return super.ownerOf(id);
    }

    /* Metadata service */

    /**
     * @notice Set the metadata service. Only the owner can do this
     */

    function setMetadataService(IMetadataService _newMetadataService)
        public
        onlyOwner
    {
        metadataService = _newMetadataService;
    }

    /**
     * @notice Get the metadata uri
     * @return String uri of the metadata service
     */

    function uri(uint256 tokenId) public view override returns (string memory) {
        return metadataService.uri(tokenId);
    }

    /**
     * @notice Set the address of the upgradeContract of the contract. only admin can do this
     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time
     * to make the contract not upgradable.
     * @param _upgradeAddress address of an upgraded contract
     */

    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)
        public
        onlyOwner
    {
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), false);
            ens.setApprovalForAll(address(upgradeContract), false);
        }

        upgradeContract = _upgradeAddress;

        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), true);
            ens.setApprovalForAll(address(upgradeContract), true);
        }
    }

    /**
     * @notice Checks if msg.sender is the owner or approved by the owner of a name
     * @param node namehash of the name to check
     */

    modifier onlyTokenOwner(bytes32 node) {
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        _;
    }

    /**
     * @notice Checks if owner or approved by owner
     * @param node namehash of the name to check
     * @param addr which address to check permissions for
     * @return whether or not is owner or approved
     */

    function isTokenOwnerOrApproved(bytes32 node, address addr)
        public
        view
        override
        returns (bool)
    {
        address owner = ownerOf(uint256(node));
        return owner == addr || isApprovedForAll(owner, addr);
    }

    /**
     * @notice Gets fuse permissions for a specific name
     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit
     *      The interface has predefined fuses for all registry permissions, but additional
     *      fuses can be added for other use cases
     *      Also returns expiry, which is when the fuses are set to expire.
     * @param node namehash of the name to check
     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp
     * @return expiry Unix time of when the name expires and fuses are to expire
     */
    function getFuses(bytes32 node)
        public
        view
        override
        returns (uint32 fuses, uint64 expiry)
    {
        (, fuses, expiry) = getData(uint256(node));
        if (fuses == 0 && expiry == 0) {
            bytes memory name = names[node];
            if (name.length == 0) {
                revert NameNotFound();
            }
        }
    }

    /**
     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract
     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar
     * @param label label as a string of the .eth domain to wrap
     * @param wrappedOwner Owner of the name in this contract
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @param resolver resolver contract address
     */

    function wrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) public override returns (uint64) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        address registrant = registrar.ownerOf(tokenId);
        if (
            registrant != msg.sender &&
            !isApprovedForAll(registrant, msg.sender) &&
            !registrar.isApprovedForAll(registrant, msg.sender)
        ) {
            revert Unauthorised(
                _makeNode(ETH_NODE, bytes32(tokenId)),
                msg.sender
            );
        }

        // transfer the token from the user to this contract
        registrar.transferFrom(registrant, address(this), tokenId);

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(tokenId, address(this));

        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Registers a new .eth second-level domain and wraps it.
     *      Only callable by authorised controllers.
     * @param label The label to register (Eg, 'foo' for 'foo.eth').
     * @param wrappedOwner The owner of the wrapped name.
     * @param duration The duration, in seconds, to register the name for.
     * @param resolver The resolver address to set on the ENS registry (optional).
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.
     */

    function registerAndWrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint256 duration,
        address resolver,
        uint32 fuses,
        uint64 expiry
    ) external override onlyController returns (uint256 registrarExpiry) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        registrarExpiry = registrar.register(tokenId, address(this), duration);
        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Renews a .eth second-level domain.
     *      Only callable by authorised controllers.
     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').
     * @param duration The number of seconds to renew the name for.
     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.
     */
    function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));

        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));

        _setData(node, owner, fuses, expiry);
    }

    /**
     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the registry or an authorised caller in the registry
     * @param name The name to wrap, in DNS format
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract address
     */

    function wrap(
        bytes calldata name,
        address wrappedOwner,
        address resolver
    ) public override {
        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
        bytes32 parentNode = name.namehash(offset);
        bytes32 node = _makeNode(parentNode, labelhash);

        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }

        address owner = ens.owner(node);

        if (
            owner != msg.sender &&
            !isApprovedForAll(owner, msg.sender) &&
            !ens.isApprovedForAll(owner, msg.sender)
        ) {
            revert Unauthorised(node, msg.sender);
        }

        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        ens.setOwner(node, address(this));

        _wrap(node, name, wrappedOwner, 0, 0);
    }

    /**
     * @notice Unwraps a .eth domain. e.g. vitalik.eth
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param labelhash labelhash of the .eth domain
     * @param newRegistrant sets the owner in the .eth registrar to this address
     * @param newController sets the owner in the registry to this address
     */

    function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }

    /**
     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param newController sets the owner in the registry to this address
     */

    function unwrap(
        bytes32 parentNode,
        bytes32 labelhash,
        address newController
    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        _unwrap(_makeNode(parentNode, labelhash), newController);
    }

    /**
     * @notice Sets fuses of a name
     * @param node namehash of the name
     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)
     */

    function setFuses(bytes32 node, uint32 fuses)
        public
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_BURN_FUSES)
        returns (uint32)
    {
        if (fuses & PARENT_CANNOT_CONTROL != 0) {
            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.
            revert Unauthorised(node, msg.sender);
        }

        (address owner, uint32 oldFuses, uint64 expiry) = getData(
            uint256(node)
        );

        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
        return fuses;
    }

    /**
     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract
     *     and burning the token of this contract
     * @dev Can be called by the owner of the name in this contract
     * @param label Label as a string of the .eth name to upgrade
     * @param wrappedOwner The owner of the wrapped name
     */

    function upgradeETH2LD(
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);

        upgradeContract.wrapETH2LD(
            label,
            wrappedOwner,
            fuses,
            expiry,
            resolver
        );
    }

    /**
     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner or an authorised caller
     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names
     * @param parentNode namehash of the parent name
     * @param label Label as a string of the name to upgrade
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract for this name
     */

    function upgrade(
        bytes32 parentNode,
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.setSubnodeRecord(
            parentNode,
            label,
            wrappedOwner,
            resolver,
            0,
            fuses,
            expiry
        );
    }

    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param fuses fuses to burn
     * @param expiry when the fuses will expire
     */

    function setChildFuses(
        bytes32 parentNode,
        bytes32 labelhash,
        uint32 fuses,
        uint64 expiry
    ) public {
        bytes32 node = _makeNode(parentNode, labelhash);
        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        uint64 maxExpiry;
        if (parentNode == ETH_NODE) {
            if (!isTokenOwnerOrApproved(node, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            // max expiry is set to the expiry on the registrar
            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        } else {
            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }

            // max expiry is set to the expiry of the parent
            (, , maxExpiry) = getData(uint256(parentNode));
        }

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);

        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed
        if (
            oldFuses & PARENT_CANNOT_CONTROL != 0 &&
            oldFuses | fuses != oldFuses
        ) {
            revert OperationProhibited(node);
        }
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
    }

    /**
     * @notice Sets the subdomain owner in the registry and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry when the fuses will expire
     */

    function setSubnodeOwner(
        bytes32 parentNode,
        string calldata label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
        returns (bytes32 node)
    {
        bytes32 labelhash = keccak256(bytes(label));
        node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);

        if (ens.owner(node) != address(this)) {
            ens.setSubnodeOwner(parentNode, labelhash, address(this));
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param resolver resolver contract in the registry
     * @param ttl ttl in the regsitry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry expiry date for the domain
     */

    function setSubnodeRecord(
        bytes32 parentNode,
        string memory label,
        address newOwner,
        address resolver,
        uint64 ttl,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
    {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets records for the name in the ENS Registry
     * @param node namehash of the name to set a record for
     * @param owner newOwner in the registry
     * @param resolver the resolver contract
     * @param ttl ttl in the registry
     */

    function setRecord(
        bytes32 node,
        address owner,
        address resolver,
        uint64 ttl
    )
        public
        override
        onlyTokenOwner(node)
        operationAllowed(
            node,
            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL
        )
    {
        ens.setRecord(node, address(this), resolver, ttl);
        (address oldOwner, , ) = getData(uint256(node));
        _transfer(oldOwner, owner, uint256(node), 1, "");
    }

    /**
     * @notice Sets resolver contract in the registry
     * @param node namehash of the name
     * @param resolver the resolver contract
     */

    function setResolver(bytes32 node, address resolver)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_RESOLVER)
    {
        ens.setResolver(node, resolver);
    }

    /**
     * @notice Sets TTL in the registry
     * @param node namehash of the name
     * @param ttl TTL in the registry
     */

    function setTTL(bytes32 node, uint64 ttl)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_TTL)
    {
        ens.setTTL(node, ttl);
    }

    /**
     * @dev Allows an operation only if none of the specified fuses are burned.
     * @param node The namehash of the name to check fuses on.
     * @param fuseMask A bitmask of fuses that must not be burned.
     */

    modifier operationAllowed(bytes32 node, uint32 fuseMask) {
        (, uint32 fuses, ) = getData(uint256(node));
        if (fuses & fuseMask != 0) {
            revert OperationProhibited(node);
        }
        _;
    }

    /**
     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord
     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt
     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for
     *      replacing a subdomain. If either conditions are true, then it is possible to call
     *      setSubnodeOwner
     * @param node namehash of the name to check
     * @param labelhash labelhash of the name to check
     */

    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {
        bytes32 subnode = _makeNode(node, labelhash);
        address owner = ens.owner(subnode);

        if (owner == address(0)) {
            (, uint32 fuses, ) = getData(uint256(node));
            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {
                revert OperationProhibited(node);
            }
        } else {
            (, uint32 subnodeFuses, ) = getData(uint256(subnode));
            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {
                revert OperationProhibited(node);
            }
        }

        _;
    }

    /**
     * @notice Checks all Fuses in the mask are burned for the node
     * @param node namehash of the name
     * @param fuseMask the fuses you want to check
     * @return Boolean of whether or not all the selected fuses are burned
     */

    function allFusesBurned(bytes32 node, uint32 fuseMask)
        public
        view
        override
        returns (bool)
    {
        (, uint32 fuses, ) = getData(uint256(node));
        return fuses & fuseMask == fuseMask;
    }

    function onERC721Received(
        address to,
        address,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        //check if it's the eth registrar ERC721
        if (msg.sender != address(registrar)) {
            revert IncorrectTokenType();
        }

        (
            string memory label,
            address owner,
            uint32 fuses,
            uint64 expiry,
            address resolver
        ) = abi.decode(data, (string, address, uint32, uint64, address));

        bytes32 labelhash = bytes32(tokenId);
        bytes32 labelhashFromData = keccak256(bytes(label));

        if (labelhashFromData != labelhash) {
            revert LabelMismatch(labelhashFromData, labelhash);
        }

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(uint256(labelhash), address(this));

        _wrapETH2LD(label, owner, fuses, expiry, resolver);

        return IERC721Receiver(to).onERC721Received.selector;
    }

    /***** Internal functions */

    function _canTransfer(uint32 fuses) internal pure override returns (bool) {
        return fuses & CANNOT_TRANSFER == 0;
    }

    function _makeNode(bytes32 node, bytes32 labelhash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, labelhash));
    }

    function _addLabel(string memory label, bytes memory name)
        internal
        pure
        returns (bytes memory ret)
    {
        if (bytes(label).length < 1) {
            revert LabelTooShort();
        }
        if (bytes(label).length > 255) {
            revert LabelTooLong(label);
        }
        return abi.encodePacked(uint8(bytes(label).length), label, name);
    }

    function _mint(
        bytes32 node,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal override {
        address oldWrappedOwner = ownerOf(uint256(node));
        _canFusesBeBurned(node, fuses);
        if (oldWrappedOwner != address(0)) {
            // burn and unwrap old token of old owner
            _burn(uint256(node));
            emit NameUnwrapped(node, address(0));
        }
        super._mint(node, wrappedOwner, fuses, expiry);
    }

    function _wrap(
        bytes32 node,
        bytes memory name,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        names[node] = name;
        _mint(node, wrappedOwner, fuses, expiry);
        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);
    }

    function _addLabelAndWrap(
        bytes32 parentNode,
        bytes32 node,
        string memory label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        bytes memory name = _addLabel(label, names[parentNode]);
        _wrap(node, name, newOwner, fuses, expiry);
    }

    function _prepareUpgrade(bytes32 node)
        private
        returns (uint32 fuses, uint64 expiry)
    {
        if (address(upgradeContract) == address(0)) {
            revert CannotUpgrade();
        }

        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        (fuses, expiry) = getFuses(node);

        // burn token and fuse data
        _burn(uint256(node));
    }

    function _transferAndBurnFuses(
        bytes32 node,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        (address owner, , ) = getData(uint256(node));
        _transfer(owner, newOwner, uint256(node), 1, "");
        _setFuses(node, newOwner, fuses, expiry);
    }

    // wrapper function for stack limit
    function _getDataAndNormaliseExpiry(
        bytes32 parentNode,
        bytes32 node,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        (, , uint64 maxExpiry) = getData(uint256(parentNode));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _getETH2LDDataAndNormaliseExpiry(
        bytes32 node,
        bytes32 labelhash,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _normaliseExpiry(
        uint64 expiry,
        uint64 oldExpiry,
        uint64 maxExpiry
    ) internal pure returns (uint64) {
        // Expiry cannot be more than maximum allowed
        // .eth names will check registrar, non .eth check parent
        if (expiry > maxExpiry) {
            expiry = maxExpiry;
        }
        // Expiry cannot be less than old expiry
        if (expiry < oldExpiry) {
            expiry = oldExpiry;
        }

        return expiry;
    }

    function _wrapETH2LD(
        string memory label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) private returns (uint64) {
        // Mint a new ERC1155 token with fuses
        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);

        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(
            node,
            labelhash,
            expiry
        );

        _addLabelAndWrap(
            ETH_NODE,
            node,
            label,
            wrappedOwner,
            fuses | PARENT_CANNOT_CONTROL,
            expiry
        );
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        return expiry;
    }

    function _unwrap(bytes32 node, address newOwner) private {
        if (newOwner == address(0x0) || newOwner == address(this)) {
            revert IncorrectTargetOwner(newOwner);
        }

        if (allFusesBurned(node, CANNOT_UNWRAP)) {
            revert OperationProhibited(node);
        }

        // Burn token and fuse data
        _burn(uint256(node));
        ens.setOwner(node, newOwner);

        emit NameUnwrapped(node, newOwner);
    }

    function _setFuses(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _setData(node, owner, fuses, expiry);
        emit FusesSet(node, fuses, expiry);
    }

    function _setData(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _canFusesBeBurned(node, fuses);
        super._setData(uint256(node), owner, fuses, expiry);
    }

    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
        if (
            fuses & ~PARENT_CANNOT_CONTROL != 0 &&
            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
        ) {
            revert OperationProhibited(node);
        }
    }
}
.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: //SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;
import "./ERC1155Fuse.sol";
import "./Controllable.sol";
import "./INameWrapper.sol";
import "./INameWrapperUpgrade.sol";
import "./IMetadataService.sol";
import "../registry/ENS.sol";
import "../ethregistrar/IBaseRegistrar.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./BytesUtil.sol";
error Unauthorised(bytes32 node, address addr);
error NameNotFound();
error IncompatibleParent();
error IncompatibleName(bytes name);
error IncorrectTokenType();
error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);
error LabelTooShort();
error LabelTooLong(string label);
error IncorrectTargetOwner(address owner);
error CannotUpgrade();
error InvalidExpiry(bytes32 node, uint64 expiry);
contract NameWrapper is
    Ownable,
    ERC1155Fuse,
    INameWrapper,
    Controllable,
    IERC721Receiver
{
    using BytesUtils for bytes;
    ENS public immutable override ens;
    IBaseRegistrar public immutable override registrar;
    IMetadataService public override metadataService;
    mapping(bytes32 => bytes) public override names;
    bytes32 private constant ETH_NODE =
        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
    bytes32 private constant ROOT_NODE =
        0x0000000000000000000000000000000000000000000000000000000000000000;
    //A contract address to a new upgraded contract if any
    INameWrapperUpgrade public upgradeContract;
    uint64 private constant MAX_EXPIRY = type(uint64).max;
    constructor(
        ENS _ens,
        IBaseRegistrar _registrar,
        IMetadataService _metadataService
    ) {
        ens = _ens;
        registrar = _registrar;
        metadataService = _metadataService;
        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */
        _setData(
            uint256(ETH_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        _setData(
            uint256(ROOT_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        names[ROOT_NODE] = "\x00";
        names[ETH_NODE] = "\x03eth\x00";
    }
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Fuse, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(INameWrapper).interfaceId ||
            super.supportsInterface(interfaceId);
    }
    /* ERC1155 */
    function ownerOf(uint256 id)
        public
        view
        override(ERC1155Fuse, INameWrapper)
        returns (address owner)
    {
        return super.ownerOf(id);
    }
    /* Metadata service */
    /**
     * @notice Set the metadata service. Only the owner can do this
     */
    function setMetadataService(IMetadataService _newMetadataService)
        public
        onlyOwner
    {
        metadataService = _newMetadataService;
    }
    /**
     * @notice Get the metadata uri
     * @return String uri of the metadata service
     */
    function uri(uint256 tokenId) public view override returns (string memory) {
        return metadataService.uri(tokenId);
    }
    /**
     * @notice Set the address of the upgradeContract of the contract. only admin can do this
     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time
     * to make the contract not upgradable.
     * @param _upgradeAddress address of an upgraded contract
     */
    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)
        public
        onlyOwner
    {
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), false);
            ens.setApprovalForAll(address(upgradeContract), false);
        }
        upgradeContract = _upgradeAddress;
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), true);
            ens.setApprovalForAll(address(upgradeContract), true);
        }
    }
    /**
     * @notice Checks if msg.sender is the owner or approved by the owner of a name
     * @param node namehash of the name to check
     */
    modifier onlyTokenOwner(bytes32 node) {
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }
        _;
    }
    /**
     * @notice Checks if owner or approved by owner
     * @param node namehash of the name to check
     * @param addr which address to check permissions for
     * @return whether or not is owner or approved
     */
    function isTokenOwnerOrApproved(bytes32 node, address addr)
        public
        view
        override
        returns (bool)
    {
        address owner = ownerOf(uint256(node));
        return owner == addr || isApprovedForAll(owner, addr);
    }
    /**
     * @notice Gets fuse permissions for a specific name
     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit
     *      The interface has predefined fuses for all registry permissions, but additional
     *      fuses can be added for other use cases
     *      Also returns expiry, which is when the fuses are set to expire.
     * @param node namehash of the name to check
     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp
     * @return expiry Unix time of when the name expires and fuses are to expire
     */
    function getFuses(bytes32 node)
        public
        view
        override
        returns (uint32 fuses, uint64 expiry)
    {
        (, fuses, expiry) = getData(uint256(node));
        if (fuses == 0 && expiry == 0) {
            bytes memory name = names[node];
            if (name.length == 0) {
                revert NameNotFound();
            }
        }
    }
    /**
     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract
     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar
     * @param label label as a string of the .eth domain to wrap
     * @param wrappedOwner Owner of the name in this contract
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @param resolver resolver contract address
     */
    function wrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) public override returns (uint64) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        address registrant = registrar.ownerOf(tokenId);
        if (
            registrant != msg.sender &&
            !isApprovedForAll(registrant, msg.sender) &&
            !registrar.isApprovedForAll(registrant, msg.sender)
        ) {
            revert Unauthorised(
                _makeNode(ETH_NODE, bytes32(tokenId)),
                msg.sender
            );
        }
        // transfer the token from the user to this contract
        registrar.transferFrom(registrant, address(this), tokenId);
        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(tokenId, address(this));
        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }
    /**
     * @dev Registers a new .eth second-level domain and wraps it.
     *      Only callable by authorised controllers.
     * @param label The label to register (Eg, 'foo' for 'foo.eth').
     * @param wrappedOwner The owner of the wrapped name.
     * @param duration The duration, in seconds, to register the name for.
     * @param resolver The resolver address to set on the ENS registry (optional).
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.
     */
    function registerAndWrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint256 duration,
        address resolver,
        uint32 fuses,
        uint64 expiry
    ) external override onlyController returns (uint256 registrarExpiry) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        registrarExpiry = registrar.register(tokenId, address(this), duration);
        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }
    /**
     * @dev Renews a .eth second-level domain.
     *      Only callable by authorised controllers.
     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').
     * @param duration The number of seconds to renew the name for.
     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.
     */
    function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));
        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));
        _setData(node, owner, fuses, expiry);
    }
    /**
     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the registry or an authorised caller in the registry
     * @param name The name to wrap, in DNS format
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract address
     */
    function wrap(
        bytes calldata name,
        address wrappedOwner,
        address resolver
    ) public override {
        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
        bytes32 parentNode = name.namehash(offset);
        bytes32 node = _makeNode(parentNode, labelhash);
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        address owner = ens.owner(node);
        if (
            owner != msg.sender &&
            !isApprovedForAll(owner, msg.sender) &&
            !ens.isApprovedForAll(owner, msg.sender)
        ) {
            revert Unauthorised(node, msg.sender);
        }
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }
        ens.setOwner(node, address(this));
        _wrap(node, name, wrappedOwner, 0, 0);
    }
    /**
     * @notice Unwraps a .eth domain. e.g. vitalik.eth
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param labelhash labelhash of the .eth domain
     * @param newRegistrant sets the owner in the .eth registrar to this address
     * @param newController sets the owner in the registry to this address
     */
    function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }
    /**
     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param newController sets the owner in the registry to this address
     */
    function unwrap(
        bytes32 parentNode,
        bytes32 labelhash,
        address newController
    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        _unwrap(_makeNode(parentNode, labelhash), newController);
    }
    /**
     * @notice Sets fuses of a name
     * @param node namehash of the name
     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)
     */
    function setFuses(bytes32 node, uint32 fuses)
        public
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_BURN_FUSES)
        returns (uint32)
    {
        if (fuses & PARENT_CANNOT_CONTROL != 0) {
            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.
            revert Unauthorised(node, msg.sender);
        }
        (address owner, uint32 oldFuses, uint64 expiry) = getData(
            uint256(node)
        );
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
        return fuses;
    }
    /**
     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract
     *     and burning the token of this contract
     * @dev Can be called by the owner of the name in this contract
     * @param label Label as a string of the .eth name to upgrade
     * @param wrappedOwner The owner of the wrapped name
     */
    function upgradeETH2LD(
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.wrapETH2LD(
            label,
            wrappedOwner,
            fuses,
            expiry,
            resolver
        );
    }
    /**
     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner or an authorised caller
     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names
     * @param parentNode namehash of the parent name
     * @param label Label as a string of the name to upgrade
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract for this name
     */
    function upgrade(
        bytes32 parentNode,
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.setSubnodeRecord(
            parentNode,
            label,
            wrappedOwner,
            resolver,
            0,
            fuses,
            expiry
        );
    }
    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param fuses fuses to burn
     * @param expiry when the fuses will expire
     */
    function setChildFuses(
        bytes32 parentNode,
        bytes32 labelhash,
        uint32 fuses,
        uint64 expiry
    ) public {
        bytes32 node = _makeNode(parentNode, labelhash);
        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        uint64 maxExpiry;
        if (parentNode == ETH_NODE) {
            if (!isTokenOwnerOrApproved(node, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            // max expiry is set to the expiry on the registrar
            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        } else {
            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            // max expiry is set to the expiry of the parent
            (, , maxExpiry) = getData(uint256(parentNode));
        }
        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed
        if (
            oldFuses & PARENT_CANNOT_CONTROL != 0 &&
            oldFuses | fuses != oldFuses
        ) {
            revert OperationProhibited(node);
        }
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
    }
    /**
     * @notice Sets the subdomain owner in the registry and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry when the fuses will expire
     */
    function setSubnodeOwner(
        bytes32 parentNode,
        string calldata label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
        returns (bytes32 node)
    {
        bytes32 labelhash = keccak256(bytes(label));
        node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeOwner(parentNode, labelhash, address(this));
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }
    /**
     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param resolver resolver contract in the registry
     * @param ttl ttl in the regsitry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry expiry date for the domain
     */
    function setSubnodeRecord(
        bytes32 parentNode,
        string memory label,
        address newOwner,
        address resolver,
        uint64 ttl,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
    {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }
    /**
     * @notice Sets records for the name in the ENS Registry
     * @param node namehash of the name to set a record for
     * @param owner newOwner in the registry
     * @param resolver the resolver contract
     * @param ttl ttl in the registry
     */
    function setRecord(
        bytes32 node,
        address owner,
        address resolver,
        uint64 ttl
    )
        public
        override
        onlyTokenOwner(node)
        operationAllowed(
            node,
            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL
        )
    {
        ens.setRecord(node, address(this), resolver, ttl);
        (address oldOwner, , ) = getData(uint256(node));
        _transfer(oldOwner, owner, uint256(node), 1, "");
    }
    /**
     * @notice Sets resolver contract in the registry
     * @param node namehash of the name
     * @param resolver the resolver contract
     */
    function setResolver(bytes32 node, address resolver)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_RESOLVER)
    {
        ens.setResolver(node, resolver);
    }
    /**
     * @notice Sets TTL in the registry
     * @param node namehash of the name
     * @param ttl TTL in the registry
     */
    function setTTL(bytes32 node, uint64 ttl)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_TTL)
    {
        ens.setTTL(node, ttl);
    }
    /**
     * @dev Allows an operation only if none of the specified fuses are burned.
     * @param node The namehash of the name to check fuses on.
     * @param fuseMask A bitmask of fuses that must not be burned.
     */
    modifier operationAllowed(bytes32 node, uint32 fuseMask) {
        (, uint32 fuses, ) = getData(uint256(node));
        if (fuses & fuseMask != 0) {
            revert OperationProhibited(node);
        }
        _;
    }
    /**
     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord
     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt
     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for
     *      replacing a subdomain. If either conditions are true, then it is possible to call
     *      setSubnodeOwner
     * @param node namehash of the name to check
     * @param labelhash labelhash of the name to check
     */
    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {
        bytes32 subnode = _makeNode(node, labelhash);
        address owner = ens.owner(subnode);
        if (owner == address(0)) {
            (, uint32 fuses, ) = getData(uint256(node));
            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {
                revert OperationProhibited(node);
            }
        } else {
            (, uint32 subnodeFuses, ) = getData(uint256(subnode));
            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {
                revert OperationProhibited(node);
            }
        }
        _;
    }
    /**
     * @notice Checks all Fuses in the mask are burned for the node
     * @param node namehash of the name
     * @param fuseMask the fuses you want to check
     * @return Boolean of whether or not all the selected fuses are burned
     */
    function allFusesBurned(bytes32 node, uint32 fuseMask)
        public
        view
        override
        returns (bool)
    {
        (, uint32 fuses, ) = getData(uint256(node));
        return fuses & fuseMask == fuseMask;
    }
    function onERC721Received(
        address to,
        address,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        //check if it's the eth registrar ERC721
        if (msg.sender != address(registrar)) {
            revert IncorrectTokenType();
        }
        (
            string memory label,
            address owner,
            uint32 fuses,
            uint64 expiry,
            address resolver
        ) = abi.decode(data, (string, address, uint32, uint64, address));
        bytes32 labelhash = bytes32(tokenId);
        bytes32 labelhashFromData = keccak256(bytes(label));
        if (labelhashFromData != labelhash) {
            revert LabelMismatch(labelhashFromData, labelhash);
        }
        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(uint256(labelhash), address(this));
        _wrapETH2LD(label, owner, fuses, expiry, resolver);
        return IERC721Receiver(to).onERC721Received.selector;
    }
    /***** Internal functions */
    function _canTransfer(uint32 fuses) internal pure override returns (bool) {
        return fuses & CANNOT_TRANSFER == 0;
    }
    function _makeNode(bytes32 node, bytes32 labelhash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, labelhash));
    }
    function _addLabel(string memory label, bytes memory name)
        internal
        pure
        returns (bytes memory ret)
    {
        if (bytes(label).length < 1) {
            revert LabelTooShort();
        }
        if (bytes(label).length > 255) {
            revert LabelTooLong(label);
        }
        return abi.encodePacked(uint8(bytes(label).length), label, name);
    }
    function _mint(
        bytes32 node,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal override {
        address oldWrappedOwner = ownerOf(uint256(node));
        _canFusesBeBurned(node, fuses);
        if (oldWrappedOwner != address(0)) {
            // burn and unwrap old token of old owner
            _burn(uint256(node));
            emit NameUnwrapped(node, address(0));
        }
        super._mint(node, wrappedOwner, fuses, expiry);
    }
    function _wrap(
        bytes32 node,
        bytes memory name,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        names[node] = name;
        _mint(node, wrappedOwner, fuses, expiry);
        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);
    }
    function _addLabelAndWrap(
        bytes32 parentNode,
        bytes32 node,
        string memory label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        bytes memory name = _addLabel(label, names[parentNode]);
        _wrap(node, name, newOwner, fuses, expiry);
    }
    function _prepareUpgrade(bytes32 node)
        private
        returns (uint32 fuses, uint64 expiry)
    {
        if (address(upgradeContract) == address(0)) {
            revert CannotUpgrade();
        }
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }
        (fuses, expiry) = getFuses(node);
        // burn token and fuse data
        _burn(uint256(node));
    }
    function _transferAndBurnFuses(
        bytes32 node,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        (address owner, , ) = getData(uint256(node));
        _transfer(owner, newOwner, uint256(node), 1, "");
        _setFuses(node, newOwner, fuses, expiry);
    }
    // wrapper function for stack limit
    function _getDataAndNormaliseExpiry(
        bytes32 parentNode,
        bytes32 node,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        (, , uint64 maxExpiry) = getData(uint256(parentNode));
        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }
    function _getETH2LDDataAndNormaliseExpiry(
        bytes32 node,
        bytes32 labelhash,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }
    function _normaliseExpiry(
        uint64 expiry,
        uint64 oldExpiry,
        uint64 maxExpiry
    ) internal pure returns (uint64) {
        // Expiry cannot be more than maximum allowed
        // .eth names will check registrar, non .eth check parent
        if (expiry > maxExpiry) {
            expiry = maxExpiry;
        }
        // Expiry cannot be less than old expiry
        if (expiry < oldExpiry) {
            expiry = oldExpiry;
        }
        return expiry;
    }
    function _wrapETH2LD(
        string memory label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) private returns (uint64) {
        // Mint a new ERC1155 token with fuses
        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(
            node,
            labelhash,
            expiry
        );
        _addLabelAndWrap(
            ETH_NODE,
            node,
            label,
            wrappedOwner,
            fuses | PARENT_CANNOT_CONTROL,
            expiry
        );
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }
        return expiry;
    }
    function _unwrap(bytes32 node, address newOwner) private {
        if (newOwner == address(0x0) || newOwner == address(this)) {
            revert IncorrectTargetOwner(newOwner);
        }
        if (allFusesBurned(node, CANNOT_UNWRAP)) {
            revert OperationProhibited(node);
        }
        // Burn token and fuse data
        _burn(uint256(node));
        ens.setOwner(node, newOwner);
        emit NameUnwrapped(node, newOwner);
    }
    function _setFuses(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _setData(node, owner, fuses, expiry);
        emit FusesSet(node, fuses, expiry);
    }
    function _setData(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _canFusesBeBurned(node, fuses);
        super._setData(uint256(node), owner, fuses, expiry);
    }
    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
        if (
            fuses & ~PARENT_CANNOT_CONTROL != 0 &&
            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
        ) {
            revert OperationProhibited(node);
        }
    }
}
.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "//SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;
import "./ERC1155Fuse.sol";
import "./Controllable.sol";
import "./INameWrapper.sol";
import "./INameWrapperUpgrade.sol";
import "./IMetadataService.sol";
import "../registry/ENS.sol";
import "../ethregistrar/IBaseRegistrar.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./BytesUtil.sol";
error Unauthorised(bytes32 node, address addr);
error NameNotFound();
error IncompatibleParent();
error IncompatibleName(bytes name);
error IncorrectTokenType();
error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);
error LabelTooShort();
error LabelTooLong(string label);
error IncorrectTargetOwner(address owner);
error CannotUpgrade();
error InvalidExpiry(bytes32 node, uint64 expiry);
contract NameWrapper is
    Ownable,
    ERC1155Fuse,
    INameWrapper,
    Controllable,
    IERC721Receiver
{
    using BytesUtils for bytes;
    ENS public immutable override ens;
    IBaseRegistrar public immutable override registrar;
    IMetadataService public override metadataService;
    mapping(bytes32 => bytes) public override names;
    bytes32 private constant ETH_NODE =
        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
    bytes32 private constant ROOT_NODE =
        0x0000000000000000000000000000000000000000000000000000000000000000;
    //A contract address to a new upgraded contract if any
    INameWrapperUpgrade public upgradeContract;
    uint64 private constant MAX_EXPIRY = type(uint64).max;
    constructor(
        ENS _ens,
        IBaseRegistrar _registrar,
        IMetadataService _metadataService
    ) {
        ens = _ens;
        registrar = _registrar;
        metadataService = _metadataService;
        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */
        _setData(
            uint256(ETH_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        _setData(
            uint256(ROOT_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        names[ROOT_NODE] = "\x00";
        names[ETH_NODE] = "\x03eth\x00";
    }
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Fuse, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(INameWrapper).interfaceId ||
            super.supportsInterface(interfaceId);
    }
    /* ERC1155 */
    function ownerOf(uint256 id)
        public
        view
        override(ERC1155Fuse, INameWrapper)
        returns (address owner)
    {
        return super.ownerOf(id);
    }
    /* Metadata service */
    /**
     * @notice Set the metadata service. Only the owner can do this
     */
    function setMetadataService(IMetadataService _newMetadataService)
        public
        onlyOwner
    {
        metadataService = _newMetadataService;
    }
    /**
     * @notice Get the metadata uri
     * @return String uri of the metadata service
     */
    function uri(uint256 tokenId) public view override returns (string memory) {
        return metadataService.uri(tokenId);
    }
    /**
     * @notice Set the address of the upgradeContract of the contract. only admin can do this
     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time
     * to make the contract not upgradable.
     * @param _upgradeAddress address of an upgraded contract
     */
    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)
        public
        onlyOwner
    {
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), false);
            ens.setApprovalForAll(address(upgradeContract), false);
        }
        upgradeContract = _upgradeAddress;
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), true);
            ens.setApprovalForAll(address(upgradeContract), true);
        }
    }
    /**
     * @notice Checks if msg.sender is the owner or approved by the owner of a name
     * @param node namehash of the name to check
     */
    modifier onlyTokenOwner(bytes32 node) {
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }
        _;
    }
    /**
     * @notice Checks if owner or approved by owner
     * @param node namehash of the name to check
     * @param addr which address to check permissions for
     * @return whether or not is owner or approved
     */
    function isTokenOwnerOrApproved(bytes32 node, address addr)
        public
        view
        override
        returns (bool)
    {
        address owner = ownerOf(uint256(node));
        return owner == addr || isApprovedForAll(owner, addr);
    }
    /**
     * @notice Gets fuse permissions for a specific name
     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit
     *      The interface has predefined fuses for all registry permissions, but additional
     *      fuses can be added for other use cases
     *      Also returns expiry, which is when the fuses are set to expire.
     * @param node namehash of the name to check
     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp
     * @return expiry Unix time of when the name expires and fuses are to expire
     */
    function getFuses(bytes32 node)
        public
        view
        override
        returns (uint32 fuses, uint64 expiry)
    {
        (, fuses, expiry) = getData(uint256(node));
        if (fuses == 0 && expiry == 0) {
            bytes memory name = names[node];
            if (name.length == 0) {
                revert NameNotFound();
            }
        }
    }
    /**
     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract
     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar
     * @param label label as a string of the .eth domain to wrap
     * @param wrappedOwner Owner of the name in this contract
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @param resolver resolver contract address
     */
    function wrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) public override returns (uint64) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        address registrant = registrar.ownerOf(tokenId);
        if (
            registrant != msg.sender &&
            !isApprovedForAll(registrant, msg.sender) &&
            !registrar.isApprovedForAll(registrant, msg.sender)
        ) {
            revert Unauthorised(
                _makeNode(ETH_NODE, bytes32(tokenId)),
                msg.sender
            );
        }
        // transfer the token from the user to this contract
        registrar.transferFrom(registrant, address(this), tokenId);
        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(tokenId, address(this));
        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }
    /**
     * @dev Registers a new .eth second-level domain and wraps it.
     *      Only callable by authorised controllers.
     * @param label The label to register (Eg, 'foo' for 'foo.eth').
     * @param wrappedOwner The owner of the wrapped name.
     * @param duration The duration, in seconds, to register the name for.
     * @param resolver The resolver address to set on the ENS registry (optional).
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.
     */
    function registerAndWrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint256 duration,
        address resolver,
        uint32 fuses,
        uint64 expiry
    ) external override onlyController returns (uint256 registrarExpiry) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        registrarExpiry = registrar.register(tokenId, address(this), duration);
        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }
    /**
     * @dev Renews a .eth second-level domain.
     *      Only callable by authorised controllers.
     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').
     * @param duration The number of seconds to renew the name for.
     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.
     */
    function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));
        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));
        _setData(node, owner, fuses, expiry);
    }
    /**
     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the registry or an authorised caller in the registry
     * @param name The name to wrap, in DNS format
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract address
     */
    function wrap(
        bytes calldata name,
        address wrappedOwner,
        address resolver
    ) public override {
        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
        bytes32 parentNode = name.namehash(offset);
        bytes32 node = _makeNode(parentNode, labelhash);
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        address owner = ens.owner(node);
        if (
            owner != msg.sender &&
            !isApprovedForAll(owner, msg.sender) &&
            !ens.isApprovedForAll(owner, msg.sender)
        ) {
            revert Unauthorised(node, msg.sender);
        }
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }
        ens.setOwner(node, address(this));
        _wrap(node, name, wrappedOwner, 0, 0);
    }
    /**
     * @notice Unwraps a .eth domain. e.g. vitalik.eth
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param labelhash labelhash of the .eth domain
     * @param newRegistrant sets the owner in the .eth registrar to this address
     * @param newController sets the owner in the registry to this address
     */
    function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }
    /**
     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param newController sets the owner in the registry to this address
     */
    function unwrap(
        bytes32 parentNode,
        bytes32 labelhash,
        address newController
    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        _unwrap(_makeNode(parentNode, labelhash), newController);
    }
    /**
     * @notice Sets fuses of a name
     * @param node namehash of the name
     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)
     */
    function setFuses(bytes32 node, uint32 fuses)
        public
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_BURN_FUSES)
        returns (uint32)
    {
        if (fuses & PARENT_CANNOT_CONTROL != 0) {
            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.
            revert Unauthorised(node, msg.sender);
        }
        (address owner, uint32 oldFuses, uint64 expiry) = getData(
            uint256(node)
        );
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
        return fuses;
    }
    /**
     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract
     *     and burning the token of this contract
     * @dev Can be called by the owner of the name in this contract
     * @param label Label as a string of the .eth name to upgrade
     * @param wrappedOwner The owner of the wrapped name
     */
    function upgradeETH2LD(
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.wrapETH2LD(
            label,
            wrappedOwner,
            fuses,
            expiry,
            resolver
        );
    }
    /**
     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner or an authorised caller
     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names
     * @param parentNode namehash of the parent name
     * @param label Label as a string of the name to upgrade
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract for this name
     */
    function upgrade(
        bytes32 parentNode,
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.setSubnodeRecord(
            parentNode,
            label,
            wrappedOwner,
            resolver,
            0,
            fuses,
            expiry
        );
    }
    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param fuses fuses to burn
     * @param expiry when the fuses will expire
     */
    function setChildFuses(
        bytes32 parentNode,
        bytes32 labelhash,
        uint32 fuses,
        uint64 expiry
    ) public {
        bytes32 node = _makeNode(parentNode, labelhash);
        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        uint64 maxExpiry;
        if (parentNode == ETH_NODE) {
            if (!isTokenOwnerOrApproved(node, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            // max expiry is set to the expiry on the registrar
            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        } else {
            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            // max expiry is set to the expiry of the parent
            (, , maxExpiry) = getData(uint256(parentNode));
        }
        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed
        if (
            oldFuses & PARENT_CANNOT_CONTROL != 0 &&
            oldFuses | fuses != oldFuses
        ) {
            revert OperationProhibited(node);
        }
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
    }
    /**
     * @notice Sets the subdomain owner in the registry and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry when the fuses will expire
     */
    function setSubnodeOwner(
        bytes32 parentNode,
        string calldata label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
        returns (bytes32 node)
    {
        bytes32 labelhash = keccak256(bytes(label));
        node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeOwner(parentNode, labelhash, address(this));
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }
    /**
     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param resolver resolver contract in the registry
     * @param ttl ttl in the regsitry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry expiry date for the domain
     */
    function setSubnodeRecord(
        bytes32 parentNode,
        string memory label,
        address newOwner,
        address resolver,
        uint64 ttl,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
    {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }
    /**
     * @notice Sets records for the name in the ENS Registry
     * @param node namehash of the name to set a record for
     * @param owner newOwner in the registry
     * @param resolver the resolver contract
     * @param ttl ttl in the registry
     */
    function setRecord(
        bytes32 node,
        address owner,
        address resolver,
        uint64 ttl
    )
        public
        override
        onlyTokenOwner(node)
        operationAllowed(
            node,
            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL
        )
    {
        ens.setRecord(node, address(this), resolver, ttl);
        (address oldOwner, , ) = getData(uint256(node));
        _transfer(oldOwner, owner, uint256(node), 1, "");
    }
    /**
     * @notice Sets resolver contract in the registry
     * @param node namehash of the name
     * @param resolver the resolver contract
     */
    function setResolver(bytes32 node, address resolver)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_RESOLVER)
    {
        ens.setResolver(node, resolver);
    }
    /**
     * @notice Sets TTL in the registry
     * @param node namehash of the name
     * @param ttl TTL in the registry
     */
    function setTTL(bytes32 node, uint64 ttl)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_TTL)
    {
        ens.setTTL(node, ttl);
    }
    /**
     * @dev Allows an operation only if none of the specified fuses are burned.
     * @param node The namehash of the name to check fuses on.
     * @param fuseMask A bitmask of fuses that must not be burned.
     */
    modifier operationAllowed(bytes32 node, uint32 fuseMask) {
        (, uint32 fuses, ) = getData(uint256(node));
        if (fuses & fuseMask != 0) {
            revert OperationProhibited(node);
        }
        _;
    }
    /**
     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord
     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt
     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for
     *      replacing a subdomain. If either conditions are true, then it is possible to call
     *      setSubnodeOwner
     * @param node namehash of the name to check
     * @param labelhash labelhash of the name to check
     */
    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {
        bytes32 subnode = _makeNode(node, labelhash);
        address owner = ens.owner(subnode);
        if (owner == address(0)) {
            (, uint32 fuses, ) = getData(uint256(node));
            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {
                revert OperationProhibited(node);
            }
        } else {
            (, uint32 subnodeFuses, ) = getData(uint256(subnode));
            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {
                revert OperationProhibited(node);
            }
        }
        _;
    }
    /**
     * @notice Checks all Fuses in the mask are burned for the node
     * @param node namehash of the name
     * @param fuseMask the fuses you want to check
     * @return Boolean of whether or not all the selected fuses are burned
     */
    function allFusesBurned(bytes32 node, uint32 fuseMask)
        public
        view
        override
        returns (bool)
    {
        (, uint32 fuses, ) = getData(uint256(node));
        return fuses & fuseMask == fuseMask;
    }
    function onERC721Received(
        address to,
        address,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        //check if it's the eth registrar ERC721
        if (msg.sender != address(registrar)) {
            revert IncorrectTokenType();
        }
        (
            string memory label,
            address owner,
            uint32 fuses,
            uint64 expiry,
            address resolver
        ) = abi.decode(data, (string, address, uint32, uint64, address));
        bytes32 labelhash = bytes32(tokenId);
        bytes32 labelhashFromData = keccak256(bytes(label));
        if (labelhashFromData != labelhash) {
            revert LabelMismatch(labelhashFromData, labelhash);
        }
        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(uint256(labelhash), address(this));
        _wrapETH2LD(label, owner, fuses, expiry, resolver);
        return IERC721Receiver(to).onERC721Received.selector;
    }
    /***** Internal functions */
    function _canTransfer(uint32 fuses) internal pure override returns (bool) {
        return fuses & CANNOT_TRANSFER == 0;
    }
    function _makeNode(bytes32 node, bytes32 labelhash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, labelhash));
    }
    function _addLabel(string memory label, bytes memory name)
        internal
        pure
        returns (bytes memory ret)
    {
        if (bytes(label).length < 1) {
            revert LabelTooShort();
        }
        if (bytes(label).length > 255) {
            revert LabelTooLong(label);
        }
        return abi.encodePacked(uint8(bytes(label).length), label, name);
    }
    function _mint(
        bytes32 node,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal override {
        address oldWrappedOwner = ownerOf(uint256(node));
        _canFusesBeBurned(node, fuses);
        if (oldWrappedOwner != address(0)) {
            // burn and unwrap old token of old owner
            _burn(uint256(node));
            emit NameUnwrapped(node, address(0));
        }
        super._mint(node, wrappedOwner, fuses, expiry);
    }
    function _wrap(
        bytes32 node,
        bytes memory name,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        names[node] = name;
        _mint(node, wrappedOwner, fuses, expiry);
        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);
    }
    function _addLabelAndWrap(
        bytes32 parentNode,
        bytes32 node,
        string memory label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        bytes memory name = _addLabel(label, names[parentNode]);
        _wrap(node, name, newOwner, fuses, expiry);
    }
    function _prepareUpgrade(bytes32 node)
        private
        returns (uint32 fuses, uint64 expiry)
    {
        if (address(upgradeContract) == address(0)) {
            revert CannotUpgrade();
        }
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }
        (fuses, expiry) = getFuses(node);
        // burn token and fuse data
        _burn(uint256(node));
    }
    function _transferAndBurnFuses(
        bytes32 node,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        (address owner, , ) = getData(uint256(node));
        _transfer(owner, newOwner, uint256(node), 1, "");
        _setFuses(node, newOwner, fuses, expiry);
    }
    // wrapper function for stack limit
    function _getDataAndNormaliseExpiry(
        bytes32 parentNode,
        bytes32 node,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        (, , uint64 maxExpiry) = getData(uint256(parentNode));
        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }
    function _getETH2LDDataAndNormaliseExpiry(
        bytes32 node,
        bytes32 labelhash,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }
    function _normaliseExpiry(
        uint64 expiry,
        uint64 oldExpiry,
        uint64 maxExpiry
    ) internal pure returns (uint64) {
        // Expiry cannot be more than maximum allowed
        // .eth names will check registrar, non .eth check parent
        if (expiry > maxExpiry) {
            expiry = maxExpiry;
        }
        // Expiry cannot be less than old expiry
        if (expiry < oldExpiry) {
            expiry = oldExpiry;
        }
        return expiry;
    }
    function _wrapETH2LD(
        string memory label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) private returns (uint64) {
        // Mint a new ERC1155 token with fuses
        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(
            node,
            labelhash,
            expiry
        );
        _addLabelAndWrap(
            ETH_NODE,
            node,
            label,
            wrappedOwner,
            fuses | PARENT_CANNOT_CONTROL,
            expiry
        );
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }
        return expiry;
    }
    function _unwrap(bytes32 node, address newOwner) private {
        if (newOwner == address(0x0) || newOwner == address(this)) {
            revert IncorrectTargetOwner(newOwner);
        }
        if (allFusesBurned(node, CANNOT_UNWRAP)) {
            revert OperationProhibited(node);
        }
        // Burn token and fuse data
        _burn(uint256(node));
        ens.setOwner(node, newOwner);
        emit NameUnwrapped(node, newOwner);
    }
    function _setFuses(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _setData(node, owner, fuses, expiry);
        emit FusesSet(node, fuses, expiry);
    }
    function _setData(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _canFusesBeBurned(node, fuses);
        super._setData(uint256(node), owner, fuses, expiry);
    }
    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
        if (
            fuses & ~PARENT_CANNOT_CONTROL != 0 &&
            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
        ) {
            revert OperationProhibited(node);
        }
    }
}
".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's analyze the provided Solidity contract and identify potential areas for improvement or enhancement.
1. **Access Control Enhancements**: While the contract uses the `Ownable` pattern for access control, we could consider implementing a more granular role-based access control (RBAC) system using OpenZeppelin's `AccessControl`. This would allow for multiple roles with different permissions, enhancing security and flexibility.
2. **Gas Optimization**: The contract could be optimized for gas usage. For instance, we could review the functions to minimize state variable writes and redundant calculations. Functions like `_normaliseExpiry` could be optimized to reduce the number of conditional checks.
3. **Event Emissions**: While the contract emits events for significant actions, we could ensure that all state-changing functions emit appropriate events. This would improve transparency and allow for better tracking of contract interactions.
4. **Upgradeability Pattern**: The contract mentions an upgrade mechanism, but we could consider implementing a more robust upgradeability pattern, such as the proxy pattern. This would allow for seamless upgrades without losing state or requiring users to interact with a new contract.
5. **Input Validation**: Additional input validation could be added to functions like `wrapETH2LD` and `registerAndWrapETH2LD` to ensure that the parameters passed (like `wrappedOwner`, `resolver`, etc.) are valid addresses and not zero addresses.
6. **Reentrancy Guard**: Although the contract appears to handle external calls carefully, adding a reentrancy guard to critical functions could further enhance security against potential reentrancy attacks.
7. **Documentation and Comments**: While the contract has some comments, enhancing the documentation, especially around complex functions, would improve maintainability and understanding for future developers.
8. **Testing and Audit**: Ensure that the contract undergoes thorough testing, including unit tests and integration tests, to cover all edge cases. Additionally, an external audit by a reputable firm could provide an extra layer of security assurance.
Which of these suggestions resonates most with you, or do you have any additional ideas to consider? Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-01-09 20:35:33 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 20:35:33 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 21908
completion_tokens: 1
total_tokens: 21909
cost: $-1.000000


[2024-01-09 20:35:33 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: //SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "./ERC1155Fuse.sol";
import "./Controllable.sol";
import "./INameWrapper.sol";
import "./INameWrapperUpgrade.sol";
import "./IMetadataService.sol";
import "../registry/ENS.sol";
import "../ethregistrar/IBaseRegistrar.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./BytesUtil.sol";

error Unauthorised(bytes32 node, address addr);
error NameNotFound();
error IncompatibleParent();
error IncompatibleName(bytes name);
error IncorrectTokenType();
error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);
error LabelTooShort();
error LabelTooLong(string label);
error IncorrectTargetOwner(address owner);
error CannotUpgrade();
error InvalidExpiry(bytes32 node, uint64 expiry);

contract NameWrapper is
    Ownable,
    ERC1155Fuse,
    INameWrapper,
    Controllable,
    IERC721Receiver
{
    using BytesUtils for bytes;
    ENS public immutable override ens;
    IBaseRegistrar public immutable override registrar;
    IMetadataService public override metadataService;
    mapping(bytes32 => bytes) public override names;

    bytes32 private constant ETH_NODE =
        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
    bytes32 private constant ROOT_NODE =
        0x0000000000000000000000000000000000000000000000000000000000000000;

    //A contract address to a new upgraded contract if any
    INameWrapperUpgrade public upgradeContract;
    uint64 private constant MAX_EXPIRY = type(uint64).max;

    constructor(
        ENS _ens,
        IBaseRegistrar _registrar,
        IMetadataService _metadataService
    ) {
        ens = _ens;
        registrar = _registrar;
        metadataService = _metadataService;

        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */

        _setData(
            uint256(ETH_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        _setData(
            uint256(ROOT_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        names[ROOT_NODE] = "\x00";
        names[ETH_NODE] = "\x03eth\x00";
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Fuse, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(INameWrapper).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /* ERC1155 */

    function ownerOf(uint256 id)
        public
        view
        override(ERC1155Fuse, INameWrapper)
        returns (address owner)
    {
        return super.ownerOf(id);
    }

    /* Metadata service */

    /**
     * @notice Set the metadata service. Only the owner can do this
     */

    function setMetadataService(IMetadataService _newMetadataService)
        public
        onlyOwner
    {
        metadataService = _newMetadataService;
    }

    /**
     * @notice Get the metadata uri
     * @return String uri of the metadata service
     */

    function uri(uint256 tokenId) public view override returns (string memory) {
        return metadataService.uri(tokenId);
    }

    /**
     * @notice Set the address of the upgradeContract of the contract. only admin can do this
     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time
     * to make the contract not upgradable.
     * @param _upgradeAddress address of an upgraded contract
     */

    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)
        public
        onlyOwner
    {
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), false);
            ens.setApprovalForAll(address(upgradeContract), false);
        }

        upgradeContract = _upgradeAddress;

        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), true);
            ens.setApprovalForAll(address(upgradeContract), true);
        }
    }

    /**
     * @notice Checks if msg.sender is the owner or approved by the owner of a name
     * @param node namehash of the name to check
     */

    modifier onlyTokenOwner(bytes32 node) {
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        _;
    }

    /**
     * @notice Checks if owner or approved by owner
     * @param node namehash of the name to check
     * @param addr which address to check permissions for
     * @return whether or not is owner or approved
     */

    function isTokenOwnerOrApproved(bytes32 node, address addr)
        public
        view
        override
        returns (bool)
    {
        address owner = ownerOf(uint256(node));
        return owner == addr || isApprovedForAll(owner, addr);
    }

    /**
     * @notice Gets fuse permissions for a specific name
     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit
     *      The interface has predefined fuses for all registry permissions, but additional
     *      fuses can be added for other use cases
     *      Also returns expiry, which is when the fuses are set to expire.
     * @param node namehash of the name to check
     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp
     * @return expiry Unix time of when the name expires and fuses are to expire
     */
    function getFuses(bytes32 node)
        public
        view
        override
        returns (uint32 fuses, uint64 expiry)
    {
        (, fuses, expiry) = getData(uint256(node));
        if (fuses == 0 && expiry == 0) {
            bytes memory name = names[node];
            if (name.length == 0) {
                revert NameNotFound();
            }
        }
    }

    /**
     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract
     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar
     * @param label label as a string of the .eth domain to wrap
     * @param wrappedOwner Owner of the name in this contract
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @param resolver resolver contract address
     */

    function wrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) public override returns (uint64) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        address registrant = registrar.ownerOf(tokenId);
        if (
            registrant != msg.sender &&
            !isApprovedForAll(registrant, msg.sender) &&
            !registrar.isApprovedForAll(registrant, msg.sender)
        ) {
            revert Unauthorised(
                _makeNode(ETH_NODE, bytes32(tokenId)),
                msg.sender
            );
        }

        // transfer the token from the user to this contract
        registrar.transferFrom(registrant, address(this), tokenId);

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(tokenId, address(this));

        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Registers a new .eth second-level domain and wraps it.
     *      Only callable by authorised controllers.
     * @param label The label to register (Eg, 'foo' for 'foo.eth').
     * @param wrappedOwner The owner of the wrapped name.
     * @param duration The duration, in seconds, to register the name for.
     * @param resolver The resolver address to set on the ENS registry (optional).
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.
     */

    function registerAndWrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint256 duration,
        address resolver,
        uint32 fuses,
        uint64 expiry
    ) external override onlyController returns (uint256 registrarExpiry) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        registrarExpiry = registrar.register(tokenId, address(this), duration);
        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Renews a .eth second-level domain.
     *      Only callable by authorised controllers.
     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').
     * @param duration The number of seconds to renew the name for.
     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.
     */
    function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));

        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));

        _setData(node, owner, fuses, expiry);
    }

    /**
     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the registry or an authorised caller in the registry
     * @param name The name to wrap, in DNS format
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract address
     */

    function wrap(
        bytes calldata name,
        address wrappedOwner,
        address resolver
    ) public override {
        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
        bytes32 parentNode = name.namehash(offset);
        bytes32 node = _makeNode(parentNode, labelhash);

        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }

        address owner = ens.owner(node);

        if (
            owner != msg.sender &&
            !isApprovedForAll(owner, msg.sender) &&
            !ens.isApprovedForAll(owner, msg.sender)
        ) {
            revert Unauthorised(node, msg.sender);
        }

        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        ens.setOwner(node, address(this));

        _wrap(node, name, wrappedOwner, 0, 0);
    }

    /**
     * @notice Unwraps a .eth domain. e.g. vitalik.eth
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param labelhash labelhash of the .eth domain
     * @param newRegistrant sets the owner in the .eth registrar to this address
     * @param newController sets the owner in the registry to this address
     */

    function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }

    /**
     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param newController sets the owner in the registry to this address
     */

    function unwrap(
        bytes32 parentNode,
        bytes32 labelhash,
        address newController
    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        _unwrap(_makeNode(parentNode, labelhash), newController);
    }

    /**
     * @notice Sets fuses of a name
     * @param node namehash of the name
     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)
     */

    function setFuses(bytes32 node, uint32 fuses)
        public
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_BURN_FUSES)
        returns (uint32)
    {
        if (fuses & PARENT_CANNOT_CONTROL != 0) {
            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.
            revert Unauthorised(node, msg.sender);
        }

        (address owner, uint32 oldFuses, uint64 expiry) = getData(
            uint256(node)
        );

        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
        return fuses;
    }

    /**
     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract
     *     and burning the token of this contract
     * @dev Can be called by the owner of the name in this contract
     * @param label Label as a string of the .eth name to upgrade
     * @param wrappedOwner The owner of the wrapped name
     */

    function upgradeETH2LD(
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);

        upgradeContract.wrapETH2LD(
            label,
            wrappedOwner,
            fuses,
            expiry,
            resolver
        );
    }

    /**
     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner or an authorised caller
     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names
     * @param parentNode namehash of the parent name
     * @param label Label as a string of the name to upgrade
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract for this name
     */

    function upgrade(
        bytes32 parentNode,
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.setSubnodeRecord(
            parentNode,
            label,
            wrappedOwner,
            resolver,
            0,
            fuses,
            expiry
        );
    }

    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param fuses fuses to burn
     * @param expiry when the fuses will expire
     */

    function setChildFuses(
        bytes32 parentNode,
        bytes32 labelhash,
        uint32 fuses,
        uint64 expiry
    ) public {
        bytes32 node = _makeNode(parentNode, labelhash);
        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        uint64 maxExpiry;
        if (parentNode == ETH_NODE) {
            if (!isTokenOwnerOrApproved(node, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            // max expiry is set to the expiry on the registrar
            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        } else {
            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }

            // max expiry is set to the expiry of the parent
            (, , maxExpiry) = getData(uint256(parentNode));
        }

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);

        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed
        if (
            oldFuses & PARENT_CANNOT_CONTROL != 0 &&
            oldFuses | fuses != oldFuses
        ) {
            revert OperationProhibited(node);
        }
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
    }

    /**
     * @notice Sets the subdomain owner in the registry and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry when the fuses will expire
     */

    function setSubnodeOwner(
        bytes32 parentNode,
        string calldata label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
        returns (bytes32 node)
    {
        bytes32 labelhash = keccak256(bytes(label));
        node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);

        if (ens.owner(node) != address(this)) {
            ens.setSubnodeOwner(parentNode, labelhash, address(this));
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param resolver resolver contract in the registry
     * @param ttl ttl in the regsitry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry expiry date for the domain
     */

    function setSubnodeRecord(
        bytes32 parentNode,
        string memory label,
        address newOwner,
        address resolver,
        uint64 ttl,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
    {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets records for the name in the ENS Registry
     * @param node namehash of the name to set a record for
     * @param owner newOwner in the registry
     * @param resolver the resolver contract
     * @param ttl ttl in the registry
     */

    function setRecord(
        bytes32 node,
        address owner,
        address resolver,
        uint64 ttl
    )
        public
        override
        onlyTokenOwner(node)
        operationAllowed(
            node,
            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL
        )
    {
        ens.setRecord(node, address(this), resolver, ttl);
        (address oldOwner, , ) = getData(uint256(node));
        _transfer(oldOwner, owner, uint256(node), 1, "");
    }

    /**
     * @notice Sets resolver contract in the registry
     * @param node namehash of the name
     * @param resolver the resolver contract
     */

    function setResolver(bytes32 node, address resolver)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_RESOLVER)
    {
        ens.setResolver(node, resolver);
    }

    /**
     * @notice Sets TTL in the registry
     * @param node namehash of the name
     * @param ttl TTL in the registry
     */

    function setTTL(bytes32 node, uint64 ttl)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_TTL)
    {
        ens.setTTL(node, ttl);
    }

    /**
     * @dev Allows an operation only if none of the specified fuses are burned.
     * @param node The namehash of the name to check fuses on.
     * @param fuseMask A bitmask of fuses that must not be burned.
     */

    modifier operationAllowed(bytes32 node, uint32 fuseMask) {
        (, uint32 fuses, ) = getData(uint256(node));
        if (fuses & fuseMask != 0) {
            revert OperationProhibited(node);
        }
        _;
    }

    /**
     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord
     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt
     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for
     *      replacing a subdomain. If either conditions are true, then it is possible to call
     *      setSubnodeOwner
     * @param node namehash of the name to check
     * @param labelhash labelhash of the name to check
     */

    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {
        bytes32 subnode = _makeNode(node, labelhash);
        address owner = ens.owner(subnode);

        if (owner == address(0)) {
            (, uint32 fuses, ) = getData(uint256(node));
            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {
                revert OperationProhibited(node);
            }
        } else {
            (, uint32 subnodeFuses, ) = getData(uint256(subnode));
            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {
                revert OperationProhibited(node);
            }
        }

        _;
    }

    /**
     * @notice Checks all Fuses in the mask are burned for the node
     * @param node namehash of the name
     * @param fuseMask the fuses you want to check
     * @return Boolean of whether or not all the selected fuses are burned
     */

    function allFusesBurned(bytes32 node, uint32 fuseMask)
        public
        view
        override
        returns (bool)
    {
        (, uint32 fuses, ) = getData(uint256(node));
        return fuses & fuseMask == fuseMask;
    }

    function onERC721Received(
        address to,
        address,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        //check if it's the eth registrar ERC721
        if (msg.sender != address(registrar)) {
            revert IncorrectTokenType();
        }

        (
            string memory label,
            address owner,
            uint32 fuses,
            uint64 expiry,
            address resolver
        ) = abi.decode(data, (string, address, uint32, uint64, address));

        bytes32 labelhash = bytes32(tokenId);
        bytes32 labelhashFromData = keccak256(bytes(label));

        if (labelhashFromData != labelhash) {
            revert LabelMismatch(labelhashFromData, labelhash);
        }

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(uint256(labelhash), address(this));

        _wrapETH2LD(label, owner, fuses, expiry, resolver);

        return IERC721Receiver(to).onERC721Received.selector;
    }

    /***** Internal functions */

    function _canTransfer(uint32 fuses) internal pure override returns (bool) {
        return fuses & CANNOT_TRANSFER == 0;
    }

    function _makeNode(bytes32 node, bytes32 labelhash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, labelhash));
    }

    function _addLabel(string memory label, bytes memory name)
        internal
        pure
        returns (bytes memory ret)
    {
        if (bytes(label).length < 1) {
            revert LabelTooShort();
        }
        if (bytes(label).length > 255) {
            revert LabelTooLong(label);
        }
        return abi.encodePacked(uint8(bytes(label).length), label, name);
    }

    function _mint(
        bytes32 node,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal override {
        address oldWrappedOwner = ownerOf(uint256(node));
        _canFusesBeBurned(node, fuses);
        if (oldWrappedOwner != address(0)) {
            // burn and unwrap old token of old owner
            _burn(uint256(node));
            emit NameUnwrapped(node, address(0));
        }
        super._mint(node, wrappedOwner, fuses, expiry);
    }

    function _wrap(
        bytes32 node,
        bytes memory name,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        names[node] = name;
        _mint(node, wrappedOwner, fuses, expiry);
        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);
    }

    function _addLabelAndWrap(
        bytes32 parentNode,
        bytes32 node,
        string memory label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        bytes memory name = _addLabel(label, names[parentNode]);
        _wrap(node, name, newOwner, fuses, expiry);
    }

    function _prepareUpgrade(bytes32 node)
        private
        returns (uint32 fuses, uint64 expiry)
    {
        if (address(upgradeContract) == address(0)) {
            revert CannotUpgrade();
        }

        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        (fuses, expiry) = getFuses(node);

        // burn token and fuse data
        _burn(uint256(node));
    }

    function _transferAndBurnFuses(
        bytes32 node,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        (address owner, , ) = getData(uint256(node));
        _transfer(owner, newOwner, uint256(node), 1, "");
        _setFuses(node, newOwner, fuses, expiry);
    }

    // wrapper function for stack limit
    function _getDataAndNormaliseExpiry(
        bytes32 parentNode,
        bytes32 node,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        (, , uint64 maxExpiry) = getData(uint256(parentNode));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _getETH2LDDataAndNormaliseExpiry(
        bytes32 node,
        bytes32 labelhash,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _normaliseExpiry(
        uint64 expiry,
        uint64 oldExpiry,
        uint64 maxExpiry
    ) internal pure returns (uint64) {
        // Expiry cannot be more than maximum allowed
        // .eth names will check registrar, non .eth check parent
        if (expiry > maxExpiry) {
            expiry = maxExpiry;
        }
        // Expiry cannot be less than old expiry
        if (expiry < oldExpiry) {
            expiry = oldExpiry;
        }

        return expiry;
    }

    function _wrapETH2LD(
        string memory label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) private returns (uint64) {
        // Mint a new ERC1155 token with fuses
        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);

        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(
            node,
            labelhash,
            expiry
        );

        _addLabelAndWrap(
            ETH_NODE,
            node,
            label,
            wrappedOwner,
            fuses | PARENT_CANNOT_CONTROL,
            expiry
        );
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        return expiry;
    }

    function _unwrap(bytes32 node, address newOwner) private {
        if (newOwner == address(0x0) || newOwner == address(this)) {
            revert IncorrectTargetOwner(newOwner);
        }

        if (allFusesBurned(node, CANNOT_UNWRAP)) {
            revert OperationProhibited(node);
        }

        // Burn token and fuse data
        _burn(uint256(node));
        ens.setOwner(node, newOwner);

        emit NameUnwrapped(node, newOwner);
    }

    function _setFuses(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _setData(node, owner, fuses, expiry);
        emit FusesSet(node, fuses, expiry);
    }

    function _setData(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _canFusesBeBurned(node, fuses);
        super._setData(uint256(node), owner, fuses, expiry);
    }

    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
        if (
            fuses & ~PARENT_CANNOT_CONTROL != 0 &&
            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
        ) {
            revert OperationProhibited(node);
        }
    }
}
.]

1

[2024-01-09 20:35:33 INFO] **[Seminar Conclusion]**:

 1

[2024-01-09 20:35:33 INFO] **[Seminar Conclusion]**:

 <INFO> 1

[2024-01-09 20:35:33 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-01-09 20:35:33 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | //SPDX-License-Identifier: MIT pragma solidity ^0.8.4; import "./ERC1155Fuse.sol"; import "./Controllable.sol"; import "./INameWrapper.sol"; import "./INameWrapperUpgrade.sol"; import "./IMetadataService.sol"; import "../registry/ENS.sol"; import "../ethregistrar/IBaseRegistrar.sol"; import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "./BytesUtil.sol"; error Unauthorised(bytes32 node, address addr); error NameNotFound(); error IncompatibleParent(); error IncompatibleName(bytes name); error IncorrectTokenType(); error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash); error LabelTooShort(); error LabelTooLong(string label); error IncorrectTargetOwner(address owner); error CannotUpgrade(); error InvalidExpiry(bytes32 node, uint64 expiry); contract NameWrapper is     Ownable,     ERC1155Fuse,     INameWrapper,     Controllable,     IERC721Receiver {     using BytesUtils for bytes;     ENS public immutable override ens;     IBaseRegistrar public immutable override registrar;     IMetadataService public override metadataService;     mapping(bytes32 =&gt; bytes) public override names; bytes32 private constant ETH_NODE =     0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae; bytes32 private constant ROOT_NODE =     0x0000000000000000000000000000000000000000000000000000000000000000;  //A contract address to a new upgraded contract if any INameWrapperUpgrade public upgradeContract; uint64 private constant MAX_EXPIRY = type(uint64).max;  constructor(     ENS _ens,     IBaseRegistrar _registrar,     IMetadataService _metadataService ) {     ens = _ens;     registrar = _registrar;     metadataService = _metadataService;      /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */      _setData(         uint256(ETH_NODE),         address(0),         uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),         MAX_EXPIRY     );     _setData(         uint256(ROOT_NODE),         address(0),         uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),         MAX_EXPIRY     );     names[ROOT_NODE] = "\x00";     names[ETH_NODE] = "\x03eth\x00"; }  function supportsInterface(bytes4 interfaceId)     public     view     virtual     override(ERC1155Fuse, IERC165)     returns (bool) {     return         interfaceId == type(INameWrapper).interfaceId ||         super.supportsInterface(interfaceId); }  /* ERC1155 */  function ownerOf(uint256 id)     public     view     override(ERC1155Fuse, INameWrapper)     returns (address owner) {     return super.ownerOf(id); }  /* Metadata service */  /**  * @notice Set the metadata service. Only the owner can do this  */  function setMetadataService(IMetadataService _newMetadataService)     public     onlyOwner {     metadataService = _newMetadataService; }  /**  * @notice Get the metadata uri  * @return String uri of the metadata service  */  function uri(uint256 tokenId) public view override returns (string memory) {     return metadataService.uri(tokenId); }  /**  * @notice Set the address of the upgradeContract of the contract. only admin can do this  * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time  * to make the contract not upgradable.  * @param _upgradeAddress address of an upgraded contract  */  function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)     public     onlyOwner {     if (address(upgradeContract) != address(0)) {         registrar.setApprovalForAll(address(upgradeContract), false);         ens.setApprovalForAll(address(upgradeContract), false);     }      upgradeContract = _upgradeAddress;      if (address(upgradeContract) != address(0)) {         registrar.setApprovalForAll(address(upgradeContract), true);         ens.setApprovalForAll(address(upgradeContract), true);     } }  /**  * @notice Checks if msg.sender is the owner or approved by the owner of a name  * @param node namehash of the name to check  */  modifier onlyTokenOwner(bytes32 node) {     if (!isTokenOwnerOrApproved(node, msg.sender)) {         revert Unauthorised(node, msg.sender);     }      _; }  /**  * @notice Checks if owner or approved by owner  * @param node namehash of the name to check  * @param addr which address to check permissions for  * @return whether or not is owner or approved  */  function isTokenOwnerOrApproved(bytes32 node, address addr)     public     view     override     returns (bool) {     address owner = ownerOf(uint256(node));     return owner == addr || isApprovedForAll(owner, addr); }  /**  * @notice Gets fuse permissions for a specific name  * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit  *      The interface has predefined fuses for all registry permissions, but additional  *      fuses can be added for other use cases  *      Also returns expiry, which is when the fuses are set to expire.  * @param node namehash of the name to check  * @return fuses A number that represents the permissions a name has. Returns 0 when expiry &lt; block.timestamp  * @return expiry Unix time of when the name expires and fuses are to expire  */ function getFuses(bytes32 node)     public     view     override     returns (uint32 fuses, uint64 expiry) {     (, fuses, expiry) = getData(uint256(node));     if (fuses == 0 &amp;&amp; expiry == 0) {         bytes memory name = names[node];         if (name.length == 0) {             revert NameNotFound();         }     } }  /**  * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract  * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar  * @param label label as a string of the .eth domain to wrap  * @param wrappedOwner Owner of the name in this contract  * @param fuses initial fuses to set  * @param expiry when the fuses will expire  * @param resolver resolver contract address  */  function wrapETH2LD(     string calldata label,     address wrappedOwner,     uint32 fuses,     uint64 expiry,     address resolver ) public override returns (uint64) {     uint256 tokenId = uint256(keccak256(bytes(label)));     address registrant = registrar.ownerOf(tokenId);     if (         registrant != msg.sender &amp;&amp;         !isApprovedForAll(registrant, msg.sender) &amp;&amp;         !registrar.isApprovedForAll(registrant, msg.sender)     ) {         revert Unauthorised(             _makeNode(ETH_NODE, bytes32(tokenId)),             msg.sender         );     }      // transfer the token from the user to this contract     registrar.transferFrom(registrant, address(this), tokenId);      // transfer the ens record back to the new owner (this contract)     registrar.reclaim(tokenId, address(this));      return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver); }  /**  * @dev Registers a new .eth second-level domain and wraps it.  *      Only callable by authorised controllers.  * @param label The label to register (Eg, 'foo' for 'foo.eth').  * @param wrappedOwner The owner of the wrapped name.  * @param duration The duration, in seconds, to register the name for.  * @param resolver The resolver address to set on the ENS registry (optional).  * @param fuses initial fuses to set  * @param expiry when the fuses will expire  * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.  */  function registerAndWrapETH2LD(     string calldata label,     address wrappedOwner,     uint256 duration,     address resolver,     uint32 fuses,     uint64 expiry ) external override onlyController returns (uint256 registrarExpiry) {     uint256 tokenId = uint256(keccak256(bytes(label)));     registrarExpiry = registrar.register(tokenId, address(this), duration);     _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver); }  /**  * @dev Renews a .eth second-level domain.  *      Only callable by authorised controllers.  * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').  * @param duration The number of seconds to renew the name for.  * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.  */ function renew(     uint256 tokenId,     uint256 duration,     uint64 expiry ) external override onlyController returns (uint256 expires) {     bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));      expires = registrar.renew(tokenId, duration);     (address owner, uint32 fuses, uint64 oldExpiry) = getData(         uint256(node)     );     expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));      _setData(node, owner, fuses, expiry); }  /**  * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner in the registry or an authorised caller in the registry  * @param name The name to wrap, in DNS format  * @param wrappedOwner Owner of the name in this contract  * @param resolver resolver contract address  */  function wrap(     bytes calldata name,     address wrappedOwner,     address resolver ) public override {     (bytes32 labelhash, uint256 offset) = name.readLabel(0);     bytes32 parentNode = name.namehash(offset);     bytes32 node = _makeNode(parentNode, labelhash);      if (parentNode == ETH_NODE) {         revert IncompatibleParent();     }      address owner = ens.owner(node);      if (         owner != msg.sender &amp;&amp;         !isApprovedForAll(owner, msg.sender) &amp;&amp;         !ens.isApprovedForAll(owner, msg.sender)     ) {         revert Unauthorised(node, msg.sender);     }      if (resolver != address(0)) {         ens.setResolver(node, resolver);     }      ens.setOwner(node, address(this));      _wrap(node, name, wrappedOwner, 0, 0); }  /**  * @notice Unwraps a .eth domain. e.g. vitalik.eth  * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper  * @param labelhash labelhash of the .eth domain  * @param newRegistrant sets the owner in the .eth registrar to this address  * @param newController sets the owner in the registry to this address  */  function unwrapETH2LD(     bytes32 labelhash,     address newRegistrant,     address newController ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {     _unwrap(_makeNode(ETH_NODE, labelhash), newController);     registrar.transferFrom(         address(this),         newRegistrant,         uint256(labelhash)     ); }  /**  * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper  * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')  * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')  * @param newController sets the owner in the registry to this address  */  function unwrap(     bytes32 parentNode,     bytes32 labelhash,     address newController ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {     if (parentNode == ETH_NODE) {         revert IncompatibleParent();     }     _unwrap(_makeNode(parentNode, labelhash), newController); }  /**  * @notice Sets fuses of a name  * @param node namehash of the name  * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)  */  function setFuses(bytes32 node, uint32 fuses)     public     onlyTokenOwner(node)     operationAllowed(node, CANNOT_BURN_FUSES)     returns (uint32) {     if (fuses &amp; PARENT_CANNOT_CONTROL != 0) {         // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.         revert Unauthorised(node, msg.sender);     }      (address owner, uint32 oldFuses, uint64 expiry) = getData(         uint256(node)     );      fuses |= oldFuses;     _setFuses(node, owner, fuses, expiry);     return fuses; }  /**  * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract  *     and burning the token of this contract  * @dev Can be called by the owner of the name in this contract  * @param label Label as a string of the .eth name to upgrade  * @param wrappedOwner The owner of the wrapped name  */  function upgradeETH2LD(     string calldata label,     address wrappedOwner,     address resolver ) public {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(ETH_NODE, labelhash);     (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);      upgradeContract.wrapETH2LD(         label,         wrappedOwner,         fuses,         expiry,         resolver     ); }  /**  * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner or an authorised caller  * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names  * @param parentNode namehash of the parent name  * @param label Label as a string of the name to upgrade  * @param wrappedOwner Owner of the name in this contract  * @param resolver resolver contract for this name  */  function upgrade(     bytes32 parentNode,     string calldata label,     address wrappedOwner,     address resolver ) public {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(parentNode, labelhash);     (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);     upgradeContract.setSubnodeRecord(         parentNode,         label,         wrappedOwner,         resolver,         0,         fuses,         expiry     ); }  /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name  * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')  * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')  * @param fuses fuses to burn  * @param expiry when the fuses will expire  */  function setChildFuses(     bytes32 parentNode,     bytes32 labelhash,     uint32 fuses,     uint64 expiry ) public {     bytes32 node = _makeNode(parentNode, labelhash);     (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(         uint256(node)     );     uint64 maxExpiry;     if (parentNode == ETH_NODE) {         if (!isTokenOwnerOrApproved(node, msg.sender)) {             revert Unauthorised(node, msg.sender);         }         // max expiry is set to the expiry on the registrar         maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));     } else {         if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {             revert Unauthorised(node, msg.sender);         }          // max expiry is set to the expiry of the parent         (, , maxExpiry) = getData(uint256(parentNode));     }      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);      // if PARENT_CANNOT_CONTROL has been burned and fuses have changed     if (         oldFuses &amp; PARENT_CANNOT_CONTROL != 0 &amp;&amp;         oldFuses | fuses != oldFuses     ) {         revert OperationProhibited(node);     }     fuses |= oldFuses;     _setFuses(node, owner, fuses, expiry); }  /**  * @notice Sets the subdomain owner in the registry and then wraps the subdomain  * @param parentNode parent namehash of the subdomain  * @param label label of the subdomain as a string  * @param newOwner newOwner in the registry  * @param fuses initial fuses for the wrapped subdomain  * @param expiry when the fuses will expire  */  function setSubnodeOwner(     bytes32 parentNode,     string calldata label,     address newOwner,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))     returns (bytes32 node) {     bytes32 labelhash = keccak256(bytes(label));     node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);      if (ens.owner(node) != address(this)) {         ens.setSubnodeOwner(parentNode, labelhash, address(this));         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } }  /**  * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain  * @param parentNode parent namehash of the subdomain  * @param label label of the subdomain as a string  * @param newOwner newOwner in the registry  * @param resolver resolver contract in the registry  * @param ttl ttl in the regsitry  * @param fuses initial fuses for the wrapped subdomain  * @param expiry expiry date for the domain  */  function setSubnodeRecord(     bytes32 parentNode,     string memory label,     address newOwner,     address resolver,     uint64 ttl,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label))) {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);     if (ens.owner(node) != address(this)) {         ens.setSubnodeRecord(             parentNode,             labelhash,             address(this),             resolver,             ttl         );         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         ens.setSubnodeRecord(             parentNode,             labelhash,             address(this),             resolver,             ttl         );         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } }  /**  * @notice Sets records for the name in the ENS Registry  * @param node namehash of the name to set a record for  * @param owner newOwner in the registry  * @param resolver the resolver contract  * @param ttl ttl in the registry  */  function setRecord(     bytes32 node,     address owner,     address resolver,     uint64 ttl )     public     override     onlyTokenOwner(node)     operationAllowed(         node,         CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL     ) {     ens.setRecord(node, address(this), resolver, ttl);     (address oldOwner, , ) = getData(uint256(node));     _transfer(oldOwner, owner, uint256(node), 1, ""); }  /**  * @notice Sets resolver contract in the registry  * @param node namehash of the name  * @param resolver the resolver contract  */  function setResolver(bytes32 node, address resolver)     public     override     onlyTokenOwner(node)     operationAllowed(node, CANNOT_SET_RESOLVER) {     ens.setResolver(node, resolver); }  /**  * @notice Sets TTL in the registry  * @param node namehash of the name  * @param ttl TTL in the registry  */  function setTTL(bytes32 node, uint64 ttl)     public     override     onlyTokenOwner(node)     operationAllowed(node, CANNOT_SET_TTL) {     ens.setTTL(node, ttl); }  /**  * @dev Allows an operation only if none of the specified fuses are burned.  * @param node The namehash of the name to check fuses on.  * @param fuseMask A bitmask of fuses that must not be burned.  */  modifier operationAllowed(bytes32 node, uint32 fuseMask) {     (, uint32 fuses, ) = getData(uint256(node));     if (fuses &amp; fuseMask != 0) {         revert OperationProhibited(node);     }     _; }  /**  * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord  * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt  *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for  *      replacing a subdomain. If either conditions are true, then it is possible to call  *      setSubnodeOwner  * @param node namehash of the name to check  * @param labelhash labelhash of the name to check  */  modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {     bytes32 subnode = _makeNode(node, labelhash);     address owner = ens.owner(subnode);      if (owner == address(0)) {         (, uint32 fuses, ) = getData(uint256(node));         if (fuses &amp; CANNOT_CREATE_SUBDOMAIN != 0) {             revert OperationProhibited(node);         }     } else {         (, uint32 subnodeFuses, ) = getData(uint256(subnode));         if (subnodeFuses &amp; PARENT_CANNOT_CONTROL != 0) {             revert OperationProhibited(node);         }     }      _; }  /**  * @notice Checks all Fuses in the mask are burned for the node  * @param node namehash of the name  * @param fuseMask the fuses you want to check  * @return Boolean of whether or not all the selected fuses are burned  */  function allFusesBurned(bytes32 node, uint32 fuseMask)     public     view     override     returns (bool) {     (, uint32 fuses, ) = getData(uint256(node));     return fuses &amp; fuseMask == fuseMask; }  function onERC721Received(     address to,     address,     uint256 tokenId,     bytes calldata data ) public override returns (bytes4) {     //check if it's the eth registrar ERC721     if (msg.sender != address(registrar)) {         revert IncorrectTokenType();     }      (         string memory label,         address owner,         uint32 fuses,         uint64 expiry,         address resolver     ) = abi.decode(data, (string, address, uint32, uint64, address));      bytes32 labelhash = bytes32(tokenId);     bytes32 labelhashFromData = keccak256(bytes(label));      if (labelhashFromData != labelhash) {         revert LabelMismatch(labelhashFromData, labelhash);     }      // transfer the ens record back to the new owner (this contract)     registrar.reclaim(uint256(labelhash), address(this));      _wrapETH2LD(label, owner, fuses, expiry, resolver);      return IERC721Receiver(to).onERC721Received.selector; }  /***** Internal functions */  function _canTransfer(uint32 fuses) internal pure override returns (bool) {     return fuses &amp; CANNOT_TRANSFER == 0; }  function _makeNode(bytes32 node, bytes32 labelhash)     private     pure     returns (bytes32) {     return keccak256(abi.encodePacked(node, labelhash)); }  function _addLabel(string memory label, bytes memory name)     internal     pure     returns (bytes memory ret) {     if (bytes(label).length &lt; 1) {         revert LabelTooShort();     }     if (bytes(label).length &gt; 255) {         revert LabelTooLong(label);     }     return abi.encodePacked(uint8(bytes(label).length), label, name); }  function _mint(     bytes32 node,     address wrappedOwner,     uint32 fuses,     uint64 expiry ) internal override {     address oldWrappedOwner = ownerOf(uint256(node));     _canFusesBeBurned(node, fuses);     if (oldWrappedOwner != address(0)) {         // burn and unwrap old token of old owner         _burn(uint256(node));         emit NameUnwrapped(node, address(0));     }     super._mint(node, wrappedOwner, fuses, expiry); }  function _wrap(     bytes32 node,     bytes memory name,     address wrappedOwner,     uint32 fuses,     uint64 expiry ) internal {     names[node] = name;     _mint(node, wrappedOwner, fuses, expiry);     emit NameWrapped(node, name, wrappedOwner, fuses, expiry); }  function _addLabelAndWrap(     bytes32 parentNode,     bytes32 node,     string memory label,     address newOwner,     uint32 fuses,     uint64 expiry ) internal {     bytes memory name = _addLabel(label, names[parentNode]);     _wrap(node, name, newOwner, fuses, expiry); }  function _prepareUpgrade(bytes32 node)     private     returns (uint32 fuses, uint64 expiry) {     if (address(upgradeContract) == address(0)) {         revert CannotUpgrade();     }      if (!isTokenOwnerOrApproved(node, msg.sender)) {         revert Unauthorised(node, msg.sender);     }      (fuses, expiry) = getFuses(node);      // burn token and fuse data     _burn(uint256(node)); }  function _transferAndBurnFuses(     bytes32 node,     address newOwner,     uint32 fuses,     uint64 expiry ) internal {     (address owner, , ) = getData(uint256(node));     _transfer(owner, newOwner, uint256(node), 1, "");     _setFuses(node, newOwner, fuses, expiry); }  // wrapper function for stack limit function _getDataAndNormaliseExpiry(     bytes32 parentNode,     bytes32 node,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     (, , uint64 maxExpiry) = getData(uint256(parentNode));      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); }  function _getETH2LDDataAndNormaliseExpiry(     bytes32 node,     bytes32 labelhash,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); }  function _normaliseExpiry(     uint64 expiry,     uint64 oldExpiry,     uint64 maxExpiry ) internal pure returns (uint64) {     // Expiry cannot be more than maximum allowed     // .eth names will check registrar, non .eth check parent     if (expiry &gt; maxExpiry) {         expiry = maxExpiry;     }     // Expiry cannot be less than old expiry     if (expiry &lt; oldExpiry) {         expiry = oldExpiry;     }      return expiry; }  function _wrapETH2LD(     string memory label,     address wrappedOwner,     uint32 fuses,     uint64 expiry,     address resolver ) private returns (uint64) {     // Mint a new ERC1155 token with fuses     // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(ETH_NODE, labelhash);      (, , expiry) = _getETH2LDDataAndNormaliseExpiry(         node,         labelhash,         expiry     );      _addLabelAndWrap(         ETH_NODE,         node,         label,         wrappedOwner,         fuses | PARENT_CANNOT_CONTROL,         expiry     );     if (resolver != address(0)) {         ens.setResolver(node, resolver);     }      return expiry; }  function _unwrap(bytes32 node, address newOwner) private {     if (newOwner == address(0x0) || newOwner == address(this)) {         revert IncorrectTargetOwner(newOwner);     }      if (allFusesBurned(node, CANNOT_UNWRAP)) {         revert OperationProhibited(node);     }      // Burn token and fuse data     _burn(uint256(node));     ens.setOwner(node, newOwner);      emit NameUnwrapped(node, newOwner); }  function _setFuses(     bytes32 node,     address owner,     uint32 fuses,     uint64 expiry ) internal {     _setData(node, owner, fuses, expiry);     emit FusesSet(node, fuses, expiry); }  function _setData(     bytes32 node,     address owner,     uint32 fuses,     uint64 expiry ) internal {     _canFusesBeBurned(node, fuses);     super._setData(uint256(node), owner, fuses, expiry); }  function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {     if (         fuses &amp; ~PARENT_CANNOT_CONTROL != 0 &amp;&amp;         fuses &amp; (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=         (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)     ) {         revert OperationProhibited(node);     } }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport "./ERC1155Fuse.sol";\nimport "./Controllable.sol";\nimport "./INameWrapper.sol";\nimport "./INameWrapperUpgrade.sol";\nimport "./IMetadataService.sol";\nimport "../registry/ENS.sol";\nimport "../ethregistrar/IBaseRegistrar.sol";\nimport "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";\nimport "@openzeppelin/contracts/access/Ownable.sol";\nimport "./BytesUtil.sol";\n\nerror Unauthorised(bytes32 node, address addr);\nerror NameNotFound();\nerror IncompatibleParent();\nerror IncompatibleName(bytes name);\nerror IncorrectTokenType();\nerror LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);\nerror LabelTooShort();\nerror LabelTooLong(string label);\nerror IncorrectTargetOwner(address owner);\nerror CannotUpgrade();\nerror InvalidExpiry(bytes32 node, uint64 expiry);\n\ncontract NameWrapper is\n    Ownable,\n    ERC1155Fuse,\n    INameWrapper,\n    Controllable,\n    IERC721Receiver\n{\n    using BytesUtils for bytes;\n    ENS public immutable override ens;\n    IBaseRegistrar public immutable override registrar;\n    IMetadataService public override metadataService;\n    mapping(bytes32 =&gt; bytes) public override names;\n\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n    bytes32 private constant ROOT_NODE =\n        0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    //A contract address to a new upgraded contract if any\n    INameWrapperUpgrade public upgradeContract;\n    uint64 private constant MAX_EXPIRY = type(uint64).max;\n\n    constructor(\n        ENS _ens,\n        IBaseRegistrar _registrar,\n        IMetadataService _metadataService\n    ) {\n        ens = _ens;\n        registrar = _registrar;\n        metadataService = _metadataService;\n\n        / Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE /\n\n        _setData(\n            uint256(ETH_NODE),\n            address(0),\n            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),\n            MAX_EXPIRY\n        );\n        _setData(\n            uint256(ROOT_NODE),\n            address(0),\n            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),\n            MAX_EXPIRY\n        );\n        names[ROOT_NODE] = "\x00";\n        names[ETH_NODE] = "\x03eth\x00";\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC1155Fuse, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(INameWrapper).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    / ERC1155 /\n\n    function ownerOf(uint256 id)\n        public\n        view\n        override(ERC1155Fuse, INameWrapper)\n        returns (address owner)\n    {\n        return super.ownerOf(id);\n    }\n\n    / Metadata service /\n\n    /\n     * @notice Set the metadata service. Only the owner can do this\n     /\n\n    function setMetadataService(IMetadataService _newMetadataService)\n        public\n        onlyOwner\n    {\n        metadataService = _newMetadataService;\n    }\n\n    /\n     * @notice Get the metadata uri\n     * @return String uri of the metadata service\n     */\n\n    function uri(uint256 tokenId) public view override returns (string memory) {\n        return metadataService.uri(tokenId);\n    }\n\n    /\n     * @notice Set the address of the upgradeContract of the contract. only admin can do this\n     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time\n     * to make the contract not upgradable.\n     * @param _upgradeAddress address of an upgraded contract\n     /\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)\n        public\n        onlyOwner\n    {\n        if (address(upgradeContract) != address(0)) {\n            registrar.setApprovalForAll(address(upgradeContract), false);\n            ens.setApprovalForAll(address(upgradeContract), false);\n        }\n\n        upgradeContract = _upgradeAddress;\n\n        if (address(upgradeContract) != address(0)) {\n            registrar.setApprovalForAll(address(upgradeContract), true);\n            ens.setApprovalForAll(address(upgradeContract), true);\n        }\n    }\n\n    /\n     * @notice Checks if msg.sender is the owner or approved by the owner of a name\n     * @param node namehash of the name to check\n     /\n\n    modifier onlyTokenOwner(bytes32 node) {\n        if (!isTokenOwnerOrApproved(node, msg.sender)) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        _;\n    }\n\n    /\n     * @notice Checks if owner or approved by owner\n     * @param node namehash of the name to check\n     * @param addr which address to check permissions for\n     * @return whether or not is owner or approved\n     */\n\n    function isTokenOwnerOrApproved(bytes32 node, address addr)\n        public\n        view\n        override\n        returns (bool)\n    {\n        address owner = ownerOf(uint256(node));\n        return owner == addr || isApprovedForAll(owner, addr);\n    }\n\n    /\n     * @notice Gets fuse permissions for a specific name\n     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit\n     *      The interface has predefined fuses for all registry permissions, but additional\n     *      fuses can be added for other use cases\n     *      Also returns expiry, which is when the fuses are set to expire.\n     * @param node namehash of the name to check\n     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry &lt; block.timestamp\n     * @return expiry Unix time of when the name expires and fuses are to expire\n     /\n    function getFuses(bytes32 node)\n        public\n        view\n        override\n        returns (uint32 fuses, uint64 expiry)\n    {\n        (, fuses, expiry) = getData(uint256(node));\n        if (fuses == 0 &amp;&amp; expiry == 0) {\n            bytes memory name = names[node];\n            if (name.length == 0) {\n                revert NameNotFound();\n            }\n        }\n    }\n\n    /\n     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract\n     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar\n     * @param label label as a string of the .eth domain to wrap\n     * @param wrappedOwner Owner of the name in this contract\n     * @param fuses initial fuses to set\n     * @param expiry when the fuses will expire\n     * @param resolver resolver contract address\n     /\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address resolver\n    ) public override returns (uint64) {\n        uint256 tokenId = uint256(keccak256(bytes(label)));\n        address registrant = registrar.ownerOf(tokenId);\n        if (\n            registrant != msg.sender &amp;&amp;\n            !isApprovedForAll(registrant, msg.sender) &amp;&amp;\n            !registrar.isApprovedForAll(registrant, msg.sender)\n        ) {\n            revert Unauthorised(\n                _makeNode(ETH_NODE, bytes32(tokenId)),\n                msg.sender\n            );\n        }\n\n        // transfer the token from the user to this contract\n        registrar.transferFrom(registrant, address(this), tokenId);\n\n        // transfer the ens record back to the new owner (this contract)\n        registrar.reclaim(tokenId, address(this));\n\n        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);\n    }\n\n    /\n     * @dev Registers a new .eth second-level domain and wraps it.\n     *      Only callable by authorised controllers.\n     * @param label The label to register (Eg, \'foo\' for \'foo.eth\').\n     * @param wrappedOwner The owner of the wrapped name.\n     * @param duration The duration, in seconds, to register the name for.\n     * @param resolver The resolver address to set on the ENS registry (optional).\n     * @param fuses initial fuses to set\n     * @param expiry when the fuses will expire\n     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.\n     */\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint32 fuses,\n        uint64 expiry\n    ) external override onlyController returns (uint256 registrarExpiry) {\n        uint256 tokenId = uint256(keccak256(bytes(label)));\n        registrarExpiry = registrar.register(tokenId, address(this), duration);\n        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);\n    }\n\n    /\n     * @dev Renews a .eth second-level domain.\n     *      Only callable by authorised controllers.\n     * @param tokenId The hash of the label to register (eg, keccak256(\'foo\'), for \'foo.eth\').\n     * @param duration The number of seconds to renew the name for.\n     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.\n     /\n    function renew(\n        uint256 tokenId,\n        uint256 duration,\n        uint64 expiry\n    ) external override onlyController returns (uint256 expires) {\n        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));\n\n        expires = registrar.renew(tokenId, duration);\n        (address owner, uint32 fuses, uint64 oldExpiry) = getData(\n            uint256(node)\n        );\n        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));\n\n        _setData(node, owner, fuses, expiry);\n    }\n\n    /\n     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner in the registry or an authorised caller in the registry\n     * @param name The name to wrap, in DNS format\n     * @param wrappedOwner Owner of the name in this contract\n     * @param resolver resolver contract address\n     /\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) public override {\n        (bytes32 labelhash, uint256 offset) = name.readLabel(0);\n        bytes32 parentNode = name.namehash(offset);\n        bytes32 node = _makeNode(parentNode, labelhash);\n\n        if (parentNode == ETH_NODE) {\n            revert IncompatibleParent();\n        }\n\n        address owner = ens.owner(node);\n\n        if (\n            owner != msg.sender &amp;&amp;\n            !isApprovedForAll(owner, msg.sender) &amp;&amp;\n            !ens.isApprovedForAll(owner, msg.sender)\n        ) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        if (resolver != address(0)) {\n            ens.setResolver(node, resolver);\n        }\n\n        ens.setOwner(node, address(this));\n\n        _wrap(node, name, wrappedOwner, 0, 0);\n    }\n\n    /\n     * @notice Unwraps a .eth domain. e.g. vitalik.eth\n     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper\n     * @param labelhash labelhash of the .eth domain\n     * @param newRegistrant sets the owner in the .eth registrar to this address\n     * @param newController sets the owner in the registry to this address\n     */\n\n    function unwrapETH2LD(\n        bytes32 labelhash,\n        address newRegistrant,\n        address newController\n    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {\n        _unwrap(_makeNode(ETH_NODE, labelhash), newController);\n        registrar.transferFrom(\n            address(this),\n            newRegistrant,\n            uint256(labelhash)\n        );\n    }\n\n    /\n     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper\n     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash(\'xyz\')\n     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256(\'vitalik\')\n     * @param newController sets the owner in the registry to this address\n     /\n\n    function unwrap(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        address newController\n    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {\n        if (parentNode == ETH_NODE) {\n            revert IncompatibleParent();\n        }\n        _unwrap(_makeNode(parentNode, labelhash), newController);\n    }\n\n    /\n     * @notice Sets fuses of a name\n     * @param node namehash of the name\n     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)\n     /\n\n    function setFuses(bytes32 node, uint32 fuses)\n        public\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_BURN_FUSES)\n        returns (uint32)\n    {\n        if (fuses &amp; PARENT_CANNOT_CONTROL != 0) {\n            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.\n            revert Unauthorised(node, msg.sender);\n        }\n\n        (address owner, uint32 oldFuses, uint64 expiry) = getData(\n            uint256(node)\n        );\n\n        fuses |= oldFuses;\n        _setFuses(node, owner, fuses, expiry);\n        return fuses;\n    }\n\n    /\n     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract\n     *     and burning the token of this contract\n     * @dev Can be called by the owner of the name in this contract\n     * @param label Label as a string of the .eth name to upgrade\n     * @param wrappedOwner The owner of the wrapped name\n     */\n\n    function upgradeETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        address resolver\n    ) public {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(ETH_NODE, labelhash);\n        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n\n        upgradeContract.wrapETH2LD(\n            label,\n            wrappedOwner,\n            fuses,\n            expiry,\n            resolver\n        );\n    }\n\n    /\n     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner or an authorised caller\n     * Requires upgraded Namewrapper to permit old Namewrapper to call setSubnodeRecord for all names\n     * @param parentNode namehash of the parent name\n     * @param label Label as a string of the name to upgrade\n     * @param wrappedOwner Owner of the name in this contract\n     * @param resolver resolver contract for this name\n     /\n\n    function upgrade(\n        bytes32 parentNode,\n        string calldata label,\n        address wrappedOwner,\n        address resolver\n    ) public {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n        upgradeContract.setSubnodeRecord(\n            parentNode,\n            label,\n            wrappedOwner,\n            resolver,\n            0,\n            fuses,\n            expiry\n        );\n    }\n\n    / @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name\n     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash(\'xyz\')\n     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256(\'vitalik\')\n     * @param fuses fuses to burn\n     * @param expiry when the fuses will expire\n     /\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) public {\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(\n            uint256(node)\n        );\n        uint64 maxExpiry;\n        if (parentNode == ETH_NODE) {\n            if (!isTokenOwnerOrApproved(node, msg.sender)) {\n                revert Unauthorised(node, msg.sender);\n            }\n            // max expiry is set to the expiry on the registrar\n            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));\n        } else {\n            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {\n                revert Unauthorised(node, msg.sender);\n            }\n\n            // max expiry is set to the expiry of the parent\n            (, , maxExpiry) = getData(uint256(parentNode));\n        }\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n\n        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed\n        if (\n            oldFuses &amp; PARENT_CANNOT_CONTROL != 0 &amp;&amp;\n            oldFuses | fuses != oldFuses\n        ) {\n            revert OperationProhibited(node);\n        }\n        fuses |= oldFuses;\n        _setFuses(node, owner, fuses, expiry);\n    }\n\n    /\n     * @notice Sets the subdomain owner in the registry and then wraps the subdomain\n     * @param parentNode parent namehash of the subdomain\n     * @param label label of the subdomain as a string\n     * @param newOwner newOwner in the registry\n     * @param fuses initial fuses for the wrapped subdomain\n     * @param expiry when the fuses will expire\n     /\n\n    function setSubnodeOwner(\n        bytes32 parentNode,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    )\n        public\n        onlyTokenOwner(parentNode)\n        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))\n        returns (bytes32 node)\n    {\n        bytes32 labelhash = keccak256(bytes(label));\n        node = _makeNode(parentNode, labelhash);\n        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);\n\n        if (ens.owner(node) != address(this)) {\n            ens.setSubnodeOwner(parentNode, labelhash, address(this));\n            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);\n        } else {\n            _transferAndBurnFuses(node, newOwner, fuses, expiry);\n        }\n    }\n\n    /\n     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain\n     * @param parentNode parent namehash of the subdomain\n     * @param label label of the subdomain as a string\n     * @param newOwner newOwner in the registry\n     * @param resolver resolver contract in the registry\n     * @param ttl ttl in the regsitry\n     * @param fuses initial fuses for the wrapped subdomain\n     * @param expiry expiry date for the domain\n     */\n\n    function setSubnodeRecord(\n        bytes32 parentNode,\n        string memory label,\n        address newOwner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    )\n        public\n        onlyTokenOwner(parentNode)\n        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))\n    {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);\n        if (ens.owner(node) != address(this)) {\n            ens.setSubnodeRecord(\n                parentNode,\n                labelhash,\n                address(this),\n                resolver,\n                ttl\n            );\n            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);\n        } else {\n            ens.setSubnodeRecord(\n                parentNode,\n                labelhash,\n                address(this),\n                resolver,\n                ttl\n            );\n            _transferAndBurnFuses(node, newOwner, fuses, expiry);\n        }\n    }\n\n    /\n     * @notice Sets records for the name in the ENS Registry\n     * @param node namehash of the name to set a record for\n     * @param owner newOwner in the registry\n     * @param resolver the resolver contract\n     * @param ttl ttl in the registry\n     /\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    )\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(\n            node,\n            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL\n        )\n    {\n        ens.setRecord(node, address(this), resolver, ttl);\n        (address oldOwner, , ) = getData(uint256(node));\n        _transfer(oldOwner, owner, uint256(node), 1, "");\n    }\n\n    /\n     * @notice Sets resolver contract in the registry\n     * @param node namehash of the name\n     * @param resolver the resolver contract\n     /\n\n    function setResolver(bytes32 node, address resolver)\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_SET_RESOLVER)\n    {\n        ens.setResolver(node, resolver);\n    }\n\n    /\n     * @notice Sets TTL in the registry\n     * @param node namehash of the name\n     * @param ttl TTL in the registry\n     */\n\n    function setTTL(bytes32 node, uint64 ttl)\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_SET_TTL)\n    {\n        ens.setTTL(node, ttl);\n    }\n\n    /\n     * @dev Allows an operation only if none of the specified fuses are burned.\n     * @param node The namehash of the name to check fuses on.\n     * @param fuseMask A bitmask of fuses that must not be burned.\n     /\n\n    modifier operationAllowed(bytes32 node, uint32 fuseMask) {\n        (, uint32 fuses, ) = getData(uint256(node));\n        if (fuses &amp; fuseMask != 0) {\n            revert OperationProhibited(node);\n        }\n        _;\n    }\n\n    /\n     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord\n     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt\n     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for\n     *      replacing a subdomain. If either conditions are true, then it is possible to call\n     *      setSubnodeOwner\n     * @param node namehash of the name to check\n     * @param labelhash labelhash of the name to check\n     /\n\n    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {\n        bytes32 subnode = makeNode(node, labelhash);\n        address owner = ens.owner(subnode);\n\n        if (owner == address(0)) {\n            (, uint32 fuses, ) = getData(uint256(node));\n            if (fuses &amp; CANNOT_CREATE_SUBDOMAIN != 0) {\n                revert OperationProhibited(node);\n            }\n        } else {\n            (, uint32 subnodeFuses, ) = getData(uint256(subnode));\n            if (subnodeFuses &amp; PARENT_CANNOT_CONTROL != 0) {\n                revert OperationProhibited(node);\n            }\n        }\n\n        ;\n    }\n\n    /*\n     * @notice Checks all Fuses in the mask are burned for the node\n     * @param node namehash of the name\n     * @param fuseMask the fuses you want to check\n     * @return Boolean of whether or not all the selected fuses are burned\n     /\n\n    function allFusesBurned(bytes32 node, uint32 fuseMask)\n        public\n        view\n        override\n        returns (bool)\n    {\n        (, uint32 fuses, ) = getData(uint256(node));\n        return fuses &amp; fuseMask == fuseMask;\n    }\n\n    function onERC721Received(\n        address to,\n        address,\n        uint256 tokenId,\n        bytes calldata data\n    ) public override returns (bytes4) {\n        //check if it\'s the eth registrar ERC721\n        if (msg.sender != address(registrar)) {\n            revert IncorrectTokenType();\n        }\n\n        (\n            string memory label,\n            address owner,\n            uint32 fuses,\n            uint64 expiry,\n            address resolver\n        ) = abi.decode(data, (string, address, uint32, uint64, address));\n\n        bytes32 labelhash = bytes32(tokenId);\n        bytes32 labelhashFromData = keccak256(bytes(label));\n\n        if (labelhashFromData != labelhash) {\n            revert LabelMismatch(labelhashFromData, labelhash);\n        }\n\n        // transfer the ens record back to the new owner (this contract)\n        registrar.reclaim(uint256(labelhash), address(this));\n\n        _wrapETH2LD(label, owner, fuses, expiry, resolver);\n\n        return IERC721Receiver(to).onERC721Received.selector;\n    }\n\n    /* Internal functions /\n\n    function _canTransfer(uint32 fuses) internal pure override returns (bool) {\n        return fuses &amp; CANNOT_TRANSFER == 0;\n    }\n\n    function _makeNode(bytes32 node, bytes32 labelhash)\n        private\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(node, labelhash));\n    }\n\n    function _addLabel(string memory label, bytes memory name)\n        internal\n        pure\n        returns (bytes memory ret)\n    {\n        if (bytes(label).length &lt; 1) {\n            revert LabelTooShort();\n        }\n        if (bytes(label).length &gt; 255) {\n            revert LabelTooLong(label);\n        }\n        return abi.encodePacked(uint8(bytes(label).length), label, name);\n    }\n\n    function _mint(\n        bytes32 node,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal override {\n        address oldWrappedOwner = ownerOf(uint256(node));\n        _canFusesBeBurned(node, fuses);\n        if (oldWrappedOwner != address(0)) {\n            // burn and unwrap old token of old owner\n            _burn(uint256(node));\n            emit NameUnwrapped(node, address(0));\n        }\n        super._mint(node, wrappedOwner, fuses, expiry);\n    }\n\n    function _wrap(\n        bytes32 node,\n        bytes memory name,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        names[node] = name;\n        _mint(node, wrappedOwner, fuses, expiry);\n        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);\n    }\n\n    function _addLabelAndWrap(\n        bytes32 parentNode,\n        bytes32 node,\n        string memory label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        bytes memory name = _addLabel(label, names[parentNode]);\n        _wrap(node, name, newOwner, fuses, expiry);\n    }\n\n    function _prepareUpgrade(bytes32 node)\n        private\n        returns (uint32 fuses, uint64 expiry)\n    {\n        if (address(upgradeContract) == address(0)) {\n            revert CannotUpgrade();\n        }\n\n        if (!isTokenOwnerOrApproved(node, msg.sender)) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        (fuses, expiry) = getFuses(node);\n\n        // burn token and fuse data\n        _burn(uint256(node));\n    }\n\n    function _transferAndBurnFuses(\n        bytes32 node,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        (address owner, , ) = getData(uint256(node));\n        _transfer(owner, newOwner, uint256(node), 1, "");\n        _setFuses(node, newOwner, fuses, expiry);\n    }\n\n    // wrapper function for stack limit\n    function _getDataAndNormaliseExpiry(\n        bytes32 parentNode,\n        bytes32 node,\n        uint64 expiry\n    )\n        internal\n        view\n        returns (\n            address owner,\n            uint32 fuses,\n            uint64\n        )\n    {\n        uint64 oldExpiry;\n        (owner, fuses, oldExpiry) = getData(uint256(node));\n        (, , uint64 maxExpiry) = getData(uint256(parentNode));\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n        return (owner, fuses, expiry);\n    }\n\n    function _getETH2LDDataAndNormaliseExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    )\n        internal\n        view\n        returns (\n            address owner,\n            uint32 fuses,\n            uint64\n        )\n    {\n        uint64 oldExpiry;\n        (owner, fuses, oldExpiry) = getData(uint256(node));\n        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n        return (owner, fuses, expiry);\n    }\n\n    function _normaliseExpiry(\n        uint64 expiry,\n        uint64 oldExpiry,\n        uint64 maxExpiry\n    ) internal pure returns (uint64) {\n        // Expiry cannot be more than maximum allowed\n        // .eth names will check registrar, non .eth check parent\n        if (expiry &gt; maxExpiry) {\n            expiry = maxExpiry;\n        }\n        // Expiry cannot be less than old expiry\n        if (expiry &lt; oldExpiry) {\n            expiry = oldExpiry;\n        }\n\n        return expiry;\n    }\n\n    function _wrapETH2LD(\n        string memory label,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address resolver\n    ) private returns (uint64) {\n        // Mint a new ERC1155 token with fuses\n        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(ETH_NODE, labelhash);\n\n        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(\n            node,\n            labelhash,\n            expiry\n        );\n\n        _addLabelAndWrap(\n            ETH_NODE,\n            node,\n            label,\n            wrappedOwner,\n            fuses | PARENT_CANNOT_CONTROL,\n            expiry\n        );\n        if (resolver != address(0)) {\n            ens.setResolver(node, resolver);\n        }\n\n        return expiry;\n    }\n\n    function _unwrap(bytes32 node, address newOwner) private {\n        if (newOwner == address(0x0) || newOwner == address(this)) {\n            revert IncorrectTargetOwner(newOwner);\n        }\n\n        if (allFusesBurned(node, CANNOT_UNWRAP)) {\n            revert OperationProhibited(node);\n        }\n\n        // Burn token and fuse data\n        _burn(uint256(node));\n        ens.setOwner(node, newOwner);\n\n        emit NameUnwrapped(node, newOwner);\n    }\n\n    function _setFuses(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        _setData(node, owner, fuses, expiry);\n        emit FusesSet(node, fuses, expiry);\n    }\n\n    function _setData(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        _canFusesBeBurned(node, fuses);\n        super._setData(uint256(node), owner, fuses, expiry);\n    }\n\n    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {\n        if (\n            fuses &amp; ~PARENT_CANNOT_CONTROL != 0 &amp;&amp;\n            fuses &amp; (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=\n            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)\n        ) {\n            revert OperationProhibited(node);\n        }\n    }\n}\n', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 20:35:33 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | //SPDX-License-Identifier: MIT pragma solidity ^0.8.4; import "./ERC1155Fuse.sol"; import "./Controllable.sol"; import "./INameWrapper.sol"; import "./INameWrapperUpgrade.sol"; import "./IMetadataService.sol"; import "../registry/ENS.sol"; import "../ethregistrar/IBaseRegistrar.sol"; import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "./BytesUtil.sol"; error Unauthorised(bytes32 node, address addr); error NameNotFound(); error IncompatibleParent(); error IncompatibleName(bytes name); error IncorrectTokenType(); error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash); error LabelTooShort(); error LabelTooLong(string label); error IncorrectTargetOwner(address owner); error CannotUpgrade(); error InvalidExpiry(bytes32 node, uint64 expiry); contract NameWrapper is     Ownable,     ERC1155Fuse,     INameWrapper,     Controllable,     IERC721Receiver {     using BytesUtils for bytes;     ENS public immutable override ens;     IBaseRegistrar public immutable override registrar;     IMetadataService public override metadataService;     mapping(bytes32 =&gt; bytes) public override names; bytes32 private constant ETH_NODE =     0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae; bytes32 private constant ROOT_NODE =     0x0000000000000000000000000000000000000000000000000000000000000000;  //A contract address to a new upgraded contract if any INameWrapperUpgrade public upgradeContract; uint64 private constant MAX_EXPIRY = type(uint64).max;  constructor(     ENS _ens,     IBaseRegistrar _registrar,     IMetadataService _metadataService ) {     ens = _ens;     registrar = _registrar;     metadataService = _metadataService;      /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */      _setData(         uint256(ETH_NODE),         address(0),         uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),         MAX_EXPIRY     );     _setData(         uint256(ROOT_NODE),         address(0),         uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),         MAX_EXPIRY     );     names[ROOT_NODE] = "\x00";     names[ETH_NODE] = "\x03eth\x00"; }  function supportsInterface(bytes4 interfaceId)     public     view     virtual     override(ERC1155Fuse, IERC165)     returns (bool) {     return         interfaceId == type(INameWrapper).interfaceId ||         super.supportsInterface(interfaceId); }  /* ERC1155 */  function ownerOf(uint256 id)     public     view     override(ERC1155Fuse, INameWrapper)     returns (address owner) {     return super.ownerOf(id); }  /* Metadata service */  /**  * @notice Set the metadata service. Only the owner can do this  */  function setMetadataService(IMetadataService _newMetadataService)     public     onlyOwner {     metadataService = _newMetadataService; }  /**  * @notice Get the metadata uri  * @return String uri of the metadata service  */  function uri(uint256 tokenId) public view override returns (string memory) {     return metadataService.uri(tokenId); }  /**  * @notice Set the address of the upgradeContract of the contract. only admin can do this  * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time  * to make the contract not upgradable.  * @param _upgradeAddress address of an upgraded contract  */  function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)     public     onlyOwner {     if (address(upgradeContract) != address(0)) {         registrar.setApprovalForAll(address(upgradeContract), false);         ens.setApprovalForAll(address(upgradeContract), false);     }      upgradeContract = _upgradeAddress;      if (address(upgradeContract) != address(0)) {         registrar.setApprovalForAll(address(upgradeContract), true);         ens.setApprovalForAll(address(upgradeContract), true);     } }  /**  * @notice Checks if msg.sender is the owner or approved by the owner of a name  * @param node namehash of the name to check  */  modifier onlyTokenOwner(bytes32 node) {     if (!isTokenOwnerOrApproved(node, msg.sender)) {         revert Unauthorised(node, msg.sender);     }      _; }  /**  * @notice Checks if owner or approved by owner  * @param node namehash of the name to check  * @param addr which address to check permissions for  * @return whether or not is owner or approved  */  function isTokenOwnerOrApproved(bytes32 node, address addr)     public     view     override     returns (bool) {     address owner = ownerOf(uint256(node));     return owner == addr || isApprovedForAll(owner, addr); }  /**  * @notice Gets fuse permissions for a specific name  * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit  *      The interface has predefined fuses for all registry permissions, but additional  *      fuses can be added for other use cases  *      Also returns expiry, which is when the fuses are set to expire.  * @param node namehash of the name to check  * @return fuses A number that represents the permissions a name has. Returns 0 when expiry &lt; block.timestamp  * @return expiry Unix time of when the name expires and fuses are to expire  */ function getFuses(bytes32 node)     public     view     override     returns (uint32 fuses, uint64 expiry) {     (, fuses, expiry) = getData(uint256(node));     if (fuses == 0 &amp;&amp; expiry == 0) {         bytes memory name = names[node];         if (name.length == 0) {             revert NameNotFound();         }     } }  /**  * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract  * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar  * @param label label as a string of the .eth domain to wrap  * @param wrappedOwner Owner of the name in this contract  * @param fuses initial fuses to set  * @param expiry when the fuses will expire  * @param resolver resolver contract address  */  function wrapETH2LD(     string calldata label,     address wrappedOwner,     uint32 fuses,     uint64 expiry,     address resolver ) public override returns (uint64) {     uint256 tokenId = uint256(keccak256(bytes(label)));     address registrant = registrar.ownerOf(tokenId);     if (         registrant != msg.sender &amp;&amp;         !isApprovedForAll(registrant, msg.sender) &amp;&amp;         !registrar.isApprovedForAll(registrant, msg.sender)     ) {         revert Unauthorised(             _makeNode(ETH_NODE, bytes32(tokenId)),             msg.sender         );     }      // transfer the token from the user to this contract     registrar.transferFrom(registrant, address(this), tokenId);      // transfer the ens record back to the new owner (this contract)     registrar.reclaim(tokenId, address(this));      return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver); }  /**  * @dev Registers a new .eth second-level domain and wraps it.  *      Only callable by authorised controllers.  * @param label The label to register (Eg, 'foo' for 'foo.eth').  * @param wrappedOwner The owner of the wrapped name.  * @param duration The duration, in seconds, to register the name for.  * @param resolver The resolver address to set on the ENS registry (optional).  * @param fuses initial fuses to set  * @param expiry when the fuses will expire  * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.  */  function registerAndWrapETH2LD(     string calldata label,     address wrappedOwner,     uint256 duration,     address resolver,     uint32 fuses,     uint64 expiry ) external override onlyController returns (uint256 registrarExpiry) {     uint256 tokenId = uint256(keccak256(bytes(label)));     registrarExpiry = registrar.register(tokenId, address(this), duration);     _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver); }  /**  * @dev Renews a .eth second-level domain.  *      Only callable by authorised controllers.  * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').  * @param duration The number of seconds to renew the name for.  * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.  */ function renew(     uint256 tokenId,     uint256 duration,     uint64 expiry ) external override onlyController returns (uint256 expires) {     bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));      expires = registrar.renew(tokenId, duration);     (address owner, uint32 fuses, uint64 oldExpiry) = getData(         uint256(node)     );     expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));      _setData(node, owner, fuses, expiry); }  /**  * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner in the registry or an authorised caller in the registry  * @param name The name to wrap, in DNS format  * @param wrappedOwner Owner of the name in this contract  * @param resolver resolver contract address  */  function wrap(     bytes calldata name,     address wrappedOwner,     address resolver ) public override {     (bytes32 labelhash, uint256 offset) = name.readLabel(0);     bytes32 parentNode = name.namehash(offset);     bytes32 node = _makeNode(parentNode, labelhash);      if (parentNode == ETH_NODE) {         revert IncompatibleParent();     }      address owner = ens.owner(node);      if (         owner != msg.sender &amp;&amp;         !isApprovedForAll(owner, msg.sender) &amp;&amp;         !ens.isApprovedForAll(owner, msg.sender)     ) {         revert Unauthorised(node, msg.sender);     }      if (resolver != address(0)) {         ens.setResolver(node, resolver);     }      ens.setOwner(node, address(this));      _wrap(node, name, wrappedOwner, 0, 0); }  /**  * @notice Unwraps a .eth domain. e.g. vitalik.eth  * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper  * @param labelhash labelhash of the .eth domain  * @param newRegistrant sets the owner in the .eth registrar to this address  * @param newController sets the owner in the registry to this address  */  function unwrapETH2LD(     bytes32 labelhash,     address newRegistrant,     address newController ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {     _unwrap(_makeNode(ETH_NODE, labelhash), newController);     registrar.transferFrom(         address(this),         newRegistrant,         uint256(labelhash)     ); }  /**  * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper  * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')  * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')  * @param newController sets the owner in the registry to this address  */  function unwrap(     bytes32 parentNode,     bytes32 labelhash,     address newController ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {     if (parentNode == ETH_NODE) {         revert IncompatibleParent();     }     _unwrap(_makeNode(parentNode, labelhash), newController); }  /**  * @notice Sets fuses of a name  * @param node namehash of the name  * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)  */  function setFuses(bytes32 node, uint32 fuses)     public     onlyTokenOwner(node)     operationAllowed(node, CANNOT_BURN_FUSES)     returns (uint32) {     if (fuses &amp; PARENT_CANNOT_CONTROL != 0) {         // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.         revert Unauthorised(node, msg.sender);     }      (address owner, uint32 oldFuses, uint64 expiry) = getData(         uint256(node)     );      fuses |= oldFuses;     _setFuses(node, owner, fuses, expiry);     return fuses; }  /**  * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract  *     and burning the token of this contract  * @dev Can be called by the owner of the name in this contract  * @param label Label as a string of the .eth name to upgrade  * @param wrappedOwner The owner of the wrapped name  */  function upgradeETH2LD(     string calldata label,     address wrappedOwner,     address resolver ) public {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(ETH_NODE, labelhash);     (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);      upgradeContract.wrapETH2LD(         label,         wrappedOwner,         fuses,         expiry,         resolver     ); }  /**  * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner or an authorised caller  * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names  * @param parentNode namehash of the parent name  * @param label Label as a string of the name to upgrade  * @param wrappedOwner Owner of the name in this contract  * @param resolver resolver contract for this name  */  function upgrade(     bytes32 parentNode,     string calldata label,     address wrappedOwner,     address resolver ) public {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(parentNode, labelhash);     (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);     upgradeContract.setSubnodeRecord(         parentNode,         label,         wrappedOwner,         resolver,         0,         fuses,         expiry     ); }  /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name  * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')  * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')  * @param fuses fuses to burn  * @param expiry when the fuses will expire  */  function setChildFuses(     bytes32 parentNode,     bytes32 labelhash,     uint32 fuses,     uint64 expiry ) public {     bytes32 node = _makeNode(parentNode, labelhash);     (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(         uint256(node)     );     uint64 maxExpiry;     if (parentNode == ETH_NODE) {         if (!isTokenOwnerOrApproved(node, msg.sender)) {             revert Unauthorised(node, msg.sender);         }         // max expiry is set to the expiry on the registrar         maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));     } else {         if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {             revert Unauthorised(node, msg.sender);         }          // max expiry is set to the expiry of the parent         (, , maxExpiry) = getData(uint256(parentNode));     }      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);      // if PARENT_CANNOT_CONTROL has been burned and fuses have changed     if (         oldFuses &amp; PARENT_CANNOT_CONTROL != 0 &amp;&amp;         oldFuses | fuses != oldFuses     ) {         revert OperationProhibited(node);     }     fuses |= oldFuses;     _setFuses(node, owner, fuses, expiry); }  /**  * @notice Sets the subdomain owner in the registry and then wraps the subdomain  * @param parentNode parent namehash of the subdomain  * @param label label of the subdomain as a string  * @param newOwner newOwner in the registry  * @param fuses initial fuses for the wrapped subdomain  * @param expiry when the fuses will expire  */  function setSubnodeOwner(     bytes32 parentNode,     string calldata label,     address newOwner,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))     returns (bytes32 node) {     bytes32 labelhash = keccak256(bytes(label));     node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);      if (ens.owner(node) != address(this)) {         ens.setSubnodeOwner(parentNode, labelhash, address(this));         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } }  /**  * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain  * @param parentNode parent namehash of the subdomain  * @param label label of the subdomain as a string  * @param newOwner newOwner in the registry  * @param resolver resolver contract in the registry  * @param ttl ttl in the regsitry  * @param fuses initial fuses for the wrapped subdomain  * @param expiry expiry date for the domain  */  function setSubnodeRecord(     bytes32 parentNode,     string memory label,     address newOwner,     address resolver,     uint64 ttl,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label))) {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);     if (ens.owner(node) != address(this)) {         ens.setSubnodeRecord(             parentNode,             labelhash,             address(this),             resolver,             ttl         );         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         ens.setSubnodeRecord(             parentNode,             labelhash,             address(this),             resolver,             ttl         );         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } }  /**  * @notice Sets records for the name in the ENS Registry  * @param node namehash of the name to set a record for  * @param owner newOwner in the registry  * @param resolver the resolver contract  * @param ttl ttl in the registry  */  function setRecord(     bytes32 node,     address owner,     address resolver,     uint64 ttl )     public     override     onlyTokenOwner(node)     operationAllowed(         node,         CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL     ) {     ens.setRecord(node, address(this), resolver, ttl);     (address oldOwner, , ) = getData(uint256(node));     _transfer(oldOwner, owner, uint256(node), 1, ""); }  /**  * @notice Sets resolver contract in the registry  * @param node namehash of the name  * @param resolver the resolver contract  */  function setResolver(bytes32 node, address resolver)     public     override     onlyTokenOwner(node)     operationAllowed(node, CANNOT_SET_RESOLVER) {     ens.setResolver(node, resolver); }  /**  * @notice Sets TTL in the registry  * @param node namehash of the name  * @param ttl TTL in the registry  */  function setTTL(bytes32 node, uint64 ttl)     public     override     onlyTokenOwner(node)     operationAllowed(node, CANNOT_SET_TTL) {     ens.setTTL(node, ttl); }  /**  * @dev Allows an operation only if none of the specified fuses are burned.  * @param node The namehash of the name to check fuses on.  * @param fuseMask A bitmask of fuses that must not be burned.  */  modifier operationAllowed(bytes32 node, uint32 fuseMask) {     (, uint32 fuses, ) = getData(uint256(node));     if (fuses &amp; fuseMask != 0) {         revert OperationProhibited(node);     }     _; }  /**  * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord  * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt  *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for  *      replacing a subdomain. If either conditions are true, then it is possible to call  *      setSubnodeOwner  * @param node namehash of the name to check  * @param labelhash labelhash of the name to check  */  modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {     bytes32 subnode = _makeNode(node, labelhash);     address owner = ens.owner(subnode);      if (owner == address(0)) {         (, uint32 fuses, ) = getData(uint256(node));         if (fuses &amp; CANNOT_CREATE_SUBDOMAIN != 0) {             revert OperationProhibited(node);         }     } else {         (, uint32 subnodeFuses, ) = getData(uint256(subnode));         if (subnodeFuses &amp; PARENT_CANNOT_CONTROL != 0) {             revert OperationProhibited(node);         }     }      _; }  /**  * @notice Checks all Fuses in the mask are burned for the node  * @param node namehash of the name  * @param fuseMask the fuses you want to check  * @return Boolean of whether or not all the selected fuses are burned  */  function allFusesBurned(bytes32 node, uint32 fuseMask)     public     view     override     returns (bool) {     (, uint32 fuses, ) = getData(uint256(node));     return fuses &amp; fuseMask == fuseMask; }  function onERC721Received(     address to,     address,     uint256 tokenId,     bytes calldata data ) public override returns (bytes4) {     //check if it's the eth registrar ERC721     if (msg.sender != address(registrar)) {         revert IncorrectTokenType();     }      (         string memory label,         address owner,         uint32 fuses,         uint64 expiry,         address resolver     ) = abi.decode(data, (string, address, uint32, uint64, address));      bytes32 labelhash = bytes32(tokenId);     bytes32 labelhashFromData = keccak256(bytes(label));      if (labelhashFromData != labelhash) {         revert LabelMismatch(labelhashFromData, labelhash);     }      // transfer the ens record back to the new owner (this contract)     registrar.reclaim(uint256(labelhash), address(this));      _wrapETH2LD(label, owner, fuses, expiry, resolver);      return IERC721Receiver(to).onERC721Received.selector; }  /***** Internal functions */  function _canTransfer(uint32 fuses) internal pure override returns (bool) {     return fuses &amp; CANNOT_TRANSFER == 0; }  function _makeNode(bytes32 node, bytes32 labelhash)     private     pure     returns (bytes32) {     return keccak256(abi.encodePacked(node, labelhash)); }  function _addLabel(string memory label, bytes memory name)     internal     pure     returns (bytes memory ret) {     if (bytes(label).length &lt; 1) {         revert LabelTooShort();     }     if (bytes(label).length &gt; 255) {         revert LabelTooLong(label);     }     return abi.encodePacked(uint8(bytes(label).length), label, name); }  function _mint(     bytes32 node,     address wrappedOwner,     uint32 fuses,     uint64 expiry ) internal override {     address oldWrappedOwner = ownerOf(uint256(node));     _canFusesBeBurned(node, fuses);     if (oldWrappedOwner != address(0)) {         // burn and unwrap old token of old owner         _burn(uint256(node));         emit NameUnwrapped(node, address(0));     }     super._mint(node, wrappedOwner, fuses, expiry); }  function _wrap(     bytes32 node,     bytes memory name,     address wrappedOwner,     uint32 fuses,     uint64 expiry ) internal {     names[node] = name;     _mint(node, wrappedOwner, fuses, expiry);     emit NameWrapped(node, name, wrappedOwner, fuses, expiry); }  function _addLabelAndWrap(     bytes32 parentNode,     bytes32 node,     string memory label,     address newOwner,     uint32 fuses,     uint64 expiry ) internal {     bytes memory name = _addLabel(label, names[parentNode]);     _wrap(node, name, newOwner, fuses, expiry); }  function _prepareUpgrade(bytes32 node)     private     returns (uint32 fuses, uint64 expiry) {     if (address(upgradeContract) == address(0)) {         revert CannotUpgrade();     }      if (!isTokenOwnerOrApproved(node, msg.sender)) {         revert Unauthorised(node, msg.sender);     }      (fuses, expiry) = getFuses(node);      // burn token and fuse data     _burn(uint256(node)); }  function _transferAndBurnFuses(     bytes32 node,     address newOwner,     uint32 fuses,     uint64 expiry ) internal {     (address owner, , ) = getData(uint256(node));     _transfer(owner, newOwner, uint256(node), 1, "");     _setFuses(node, newOwner, fuses, expiry); }  // wrapper function for stack limit function _getDataAndNormaliseExpiry(     bytes32 parentNode,     bytes32 node,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     (, , uint64 maxExpiry) = getData(uint256(parentNode));      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); }  function _getETH2LDDataAndNormaliseExpiry(     bytes32 node,     bytes32 labelhash,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); }  function _normaliseExpiry(     uint64 expiry,     uint64 oldExpiry,     uint64 maxExpiry ) internal pure returns (uint64) {     // Expiry cannot be more than maximum allowed     // .eth names will check registrar, non .eth check parent     if (expiry &gt; maxExpiry) {         expiry = maxExpiry;     }     // Expiry cannot be less than old expiry     if (expiry &lt; oldExpiry) {         expiry = oldExpiry;     }      return expiry; }  function _wrapETH2LD(     string memory label,     address wrappedOwner,     uint32 fuses,     uint64 expiry,     address resolver ) private returns (uint64) {     // Mint a new ERC1155 token with fuses     // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(ETH_NODE, labelhash);      (, , expiry) = _getETH2LDDataAndNormaliseExpiry(         node,         labelhash,         expiry     );      _addLabelAndWrap(         ETH_NODE,         node,         label,         wrappedOwner,         fuses | PARENT_CANNOT_CONTROL,         expiry     );     if (resolver != address(0)) {         ens.setResolver(node, resolver);     }      return expiry; }  function _unwrap(bytes32 node, address newOwner) private {     if (newOwner == address(0x0) || newOwner == address(this)) {         revert IncorrectTargetOwner(newOwner);     }      if (allFusesBurned(node, CANNOT_UNWRAP)) {         revert OperationProhibited(node);     }      // Burn token and fuse data     _burn(uint256(node));     ens.setOwner(node, newOwner);      emit NameUnwrapped(node, newOwner); }  function _setFuses(     bytes32 node,     address owner,     uint32 fuses,     uint64 expiry ) internal {     _setData(node, owner, fuses, expiry);     emit FusesSet(node, fuses, expiry); }  function _setData(     bytes32 node,     address owner,     uint32 fuses,     uint64 expiry ) internal {     _canFusesBeBurned(node, fuses);     super._setData(uint256(node), owner, fuses, expiry); }  function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {     if (         fuses &amp; ~PARENT_CANNOT_CONTROL != 0 &amp;&amp;         fuses &amp; (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=         (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)     ) {         revert OperationProhibited(node);     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 20:35:33 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: //SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "./ERC1155Fuse.sol";
import "./Controllable.sol";
import "./INameWrapper.sol";
import "./INameWrapperUpgrade.sol";
import "./IMetadataService.sol";
import "../registry/ENS.sol";
import "../ethregistrar/IBaseRegistrar.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./BytesUtil.sol";

error Unauthorised(bytes32 node, address addr);
error NameNotFound();
error IncompatibleParent();
error IncompatibleName(bytes name);
error IncorrectTokenType();
error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);
error LabelTooShort();
error LabelTooLong(string label);
error IncorrectTargetOwner(address owner);
error CannotUpgrade();
error InvalidExpiry(bytes32 node, uint64 expiry);

contract NameWrapper is
    Ownable,
    ERC1155Fuse,
    INameWrapper,
    Controllable,
    IERC721Receiver
{
    using BytesUtils for bytes;
    ENS public immutable override ens;
    IBaseRegistrar public immutable override registrar;
    IMetadataService public override metadataService;
    mapping(bytes32 => bytes) public override names;

    bytes32 private constant ETH_NODE =
        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
    bytes32 private constant ROOT_NODE =
        0x0000000000000000000000000000000000000000000000000000000000000000;

    //A contract address to a new upgraded contract if any
    INameWrapperUpgrade public upgradeContract;
    uint64 private constant MAX_EXPIRY = type(uint64).max;

    constructor(
        ENS _ens,
        IBaseRegistrar _registrar,
        IMetadataService _metadataService
    ) {
        ens = _ens;
        registrar = _registrar;
        metadataService = _metadataService;

        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */

        _setData(
            uint256(ETH_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        _setData(
            uint256(ROOT_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        names[ROOT_NODE] = "\x00";
        names[ETH_NODE] = "\x03eth\x00";
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Fuse, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(INameWrapper).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /* ERC1155 */

    function ownerOf(uint256 id)
        public
        view
        override(ERC1155Fuse, INameWrapper)
        returns (address owner)
    {
        return super.ownerOf(id);
    }

    /* Metadata service */

    /**
     * @notice Set the metadata service. Only the owner can do this
     */

    function setMetadataService(IMetadataService _newMetadataService)
        public
        onlyOwner
    {
        metadataService = _newMetadataService;
    }

    /**
     * @notice Get the metadata uri
     * @return String uri of the metadata service
     */

    function uri(uint256 tokenId) public view override returns (string memory) {
        return metadataService.uri(tokenId);
    }

    /**
     * @notice Set the address of the upgradeContract of the contract. only admin can do this
     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time
     * to make the contract not upgradable.
     * @param _upgradeAddress address of an upgraded contract
     */

    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)
        public
        onlyOwner
    {
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), false);
            ens.setApprovalForAll(address(upgradeContract), false);
        }

        upgradeContract = _upgradeAddress;

        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), true);
            ens.setApprovalForAll(address(upgradeContract), true);
        }
    }

    /**
     * @notice Checks if msg.sender is the owner or approved by the owner of a name
     * @param node namehash of the name to check
     */

    modifier onlyTokenOwner(bytes32 node) {
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        _;
    }

    /**
     * @notice Checks if owner or approved by owner
     * @param node namehash of the name to check
     * @param addr which address to check permissions for
     * @return whether or not is owner or approved
     */

    function isTokenOwnerOrApproved(bytes32 node, address addr)
        public
        view
        override
        returns (bool)
    {
        address owner = ownerOf(uint256(node));
        return owner == addr || isApprovedForAll(owner, addr);
    }

    /**
     * @notice Gets fuse permissions for a specific name
     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit
     *      The interface has predefined fuses for all registry permissions, but additional
     *      fuses can be added for other use cases
     *      Also returns expiry, which is when the fuses are set to expire.
     * @param node namehash of the name to check
     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp
     * @return expiry Unix time of when the name expires and fuses are to expire
     */
    function getFuses(bytes32 node)
        public
        view
        override
        returns (uint32 fuses, uint64 expiry)
    {
        (, fuses, expiry) = getData(uint256(node));
        if (fuses == 0 && expiry == 0) {
            bytes memory name = names[node];
            if (name.length == 0) {
                revert NameNotFound();
            }
        }
    }

    /**
     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract
     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar
     * @param label label as a string of the .eth domain to wrap
     * @param wrappedOwner Owner of the name in this contract
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @param resolver resolver contract address
     */

    function wrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) public override returns (uint64) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        address registrant = registrar.ownerOf(tokenId);
        if (
            registrant != msg.sender &&
            !isApprovedForAll(registrant, msg.sender) &&
            !registrar.isApprovedForAll(registrant, msg.sender)
        ) {
            revert Unauthorised(
                _makeNode(ETH_NODE, bytes32(tokenId)),
                msg.sender
            );
        }

        // transfer the token from the user to this contract
        registrar.transferFrom(registrant, address(this), tokenId);

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(tokenId, address(this));

        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Registers a new .eth second-level domain and wraps it.
     *      Only callable by authorised controllers.
     * @param label The label to register (Eg, 'foo' for 'foo.eth').
     * @param wrappedOwner The owner of the wrapped name.
     * @param duration The duration, in seconds, to register the name for.
     * @param resolver The resolver address to set on the ENS registry (optional).
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.
     */

    function registerAndWrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint256 duration,
        address resolver,
        uint32 fuses,
        uint64 expiry
    ) external override onlyController returns (uint256 registrarExpiry) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        registrarExpiry = registrar.register(tokenId, address(this), duration);
        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Renews a .eth second-level domain.
     *      Only callable by authorised controllers.
     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').
     * @param duration The number of seconds to renew the name for.
     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.
     */
    function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));

        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));

        _setData(node, owner, fuses, expiry);
    }

    /**
     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the registry or an authorised caller in the registry
     * @param name The name to wrap, in DNS format
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract address
     */

    function wrap(
        bytes calldata name,
        address wrappedOwner,
        address resolver
    ) public override {
        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
        bytes32 parentNode = name.namehash(offset);
        bytes32 node = _makeNode(parentNode, labelhash);

        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }

        address owner = ens.owner(node);

        if (
            owner != msg.sender &&
            !isApprovedForAll(owner, msg.sender) &&
            !ens.isApprovedForAll(owner, msg.sender)
        ) {
            revert Unauthorised(node, msg.sender);
        }

        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        ens.setOwner(node, address(this));

        _wrap(node, name, wrappedOwner, 0, 0);
    }

    /**
     * @notice Unwraps a .eth domain. e.g. vitalik.eth
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param labelhash labelhash of the .eth domain
     * @param newRegistrant sets the owner in the .eth registrar to this address
     * @param newController sets the owner in the registry to this address
     */

    function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }

    /**
     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param newController sets the owner in the registry to this address
     */

    function unwrap(
        bytes32 parentNode,
        bytes32 labelhash,
        address newController
    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        _unwrap(_makeNode(parentNode, labelhash), newController);
    }

    /**
     * @notice Sets fuses of a name
     * @param node namehash of the name
     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)
     */

    function setFuses(bytes32 node, uint32 fuses)
        public
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_BURN_FUSES)
        returns (uint32)
    {
        if (fuses & PARENT_CANNOT_CONTROL != 0) {
            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.
            revert Unauthorised(node, msg.sender);
        }

        (address owner, uint32 oldFuses, uint64 expiry) = getData(
            uint256(node)
        );

        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
        return fuses;
    }

    /**
     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract
     *     and burning the token of this contract
     * @dev Can be called by the owner of the name in this contract
     * @param label Label as a string of the .eth name to upgrade
     * @param wrappedOwner The owner of the wrapped name
     */

    function upgradeETH2LD(
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);

        upgradeContract.wrapETH2LD(
            label,
            wrappedOwner,
            fuses,
            expiry,
            resolver
        );
    }

    /**
     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner or an authorised caller
     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names
     * @param parentNode namehash of the parent name
     * @param label Label as a string of the name to upgrade
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract for this name
     */

    function upgrade(
        bytes32 parentNode,
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.setSubnodeRecord(
            parentNode,
            label,
            wrappedOwner,
            resolver,
            0,
            fuses,
            expiry
        );
    }

    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param fuses fuses to burn
     * @param expiry when the fuses will expire
     */

    function setChildFuses(
        bytes32 parentNode,
        bytes32 labelhash,
        uint32 fuses,
        uint64 expiry
    ) public {
        bytes32 node = _makeNode(parentNode, labelhash);
        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        uint64 maxExpiry;
        if (parentNode == ETH_NODE) {
            if (!isTokenOwnerOrApproved(node, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            // max expiry is set to the expiry on the registrar
            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        } else {
            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }

            // max expiry is set to the expiry of the parent
            (, , maxExpiry) = getData(uint256(parentNode));
        }

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);

        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed
        if (
            oldFuses & PARENT_CANNOT_CONTROL != 0 &&
            oldFuses | fuses != oldFuses
        ) {
            revert OperationProhibited(node);
        }
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
    }

    /**
     * @notice Sets the subdomain owner in the registry and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry when the fuses will expire
     */

    function setSubnodeOwner(
        bytes32 parentNode,
        string calldata label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
        returns (bytes32 node)
    {
        bytes32 labelhash = keccak256(bytes(label));
        node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);

        if (ens.owner(node) != address(this)) {
            ens.setSubnodeOwner(parentNode, labelhash, address(this));
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param resolver resolver contract in the registry
     * @param ttl ttl in the regsitry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry expiry date for the domain
     */

    function setSubnodeRecord(
        bytes32 parentNode,
        string memory label,
        address newOwner,
        address resolver,
        uint64 ttl,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
    {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets records for the name in the ENS Registry
     * @param node namehash of the name to set a record for
     * @param owner newOwner in the registry
     * @param resolver the resolver contract
     * @param ttl ttl in the registry
     */

    function setRecord(
        bytes32 node,
        address owner,
        address resolver,
        uint64 ttl
    )
        public
        override
        onlyTokenOwner(node)
        operationAllowed(
            node,
            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL
        )
    {
        ens.setRecord(node, address(this), resolver, ttl);
        (address oldOwner, , ) = getData(uint256(node));
        _transfer(oldOwner, owner, uint256(node), 1, "");
    }

    /**
     * @notice Sets resolver contract in the registry
     * @param node namehash of the name
     * @param resolver the resolver contract
     */

    function setResolver(bytes32 node, address resolver)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_RESOLVER)
    {
        ens.setResolver(node, resolver);
    }

    /**
     * @notice Sets TTL in the registry
     * @param node namehash of the name
     * @param ttl TTL in the registry
     */

    function setTTL(bytes32 node, uint64 ttl)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_TTL)
    {
        ens.setTTL(node, ttl);
    }

    /**
     * @dev Allows an operation only if none of the specified fuses are burned.
     * @param node The namehash of the name to check fuses on.
     * @param fuseMask A bitmask of fuses that must not be burned.
     */

    modifier operationAllowed(bytes32 node, uint32 fuseMask) {
        (, uint32 fuses, ) = getData(uint256(node));
        if (fuses & fuseMask != 0) {
            revert OperationProhibited(node);
        }
        _;
    }

    /**
     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord
     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt
     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for
     *      replacing a subdomain. If either conditions are true, then it is possible to call
     *      setSubnodeOwner
     * @param node namehash of the name to check
     * @param labelhash labelhash of the name to check
     */

    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {
        bytes32 subnode = _makeNode(node, labelhash);
        address owner = ens.owner(subnode);

        if (owner == address(0)) {
            (, uint32 fuses, ) = getData(uint256(node));
            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {
                revert OperationProhibited(node);
            }
        } else {
            (, uint32 subnodeFuses, ) = getData(uint256(subnode));
            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {
                revert OperationProhibited(node);
            }
        }

        _;
    }

    /**
     * @notice Checks all Fuses in the mask are burned for the node
     * @param node namehash of the name
     * @param fuseMask the fuses you want to check
     * @return Boolean of whether or not all the selected fuses are burned
     */

    function allFusesBurned(bytes32 node, uint32 fuseMask)
        public
        view
        override
        returns (bool)
    {
        (, uint32 fuses, ) = getData(uint256(node));
        return fuses & fuseMask == fuseMask;
    }

    function onERC721Received(
        address to,
        address,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        //check if it's the eth registrar ERC721
        if (msg.sender != address(registrar)) {
            revert IncorrectTokenType();
        }

        (
            string memory label,
            address owner,
            uint32 fuses,
            uint64 expiry,
            address resolver
        ) = abi.decode(data, (string, address, uint32, uint64, address));

        bytes32 labelhash = bytes32(tokenId);
        bytes32 labelhashFromData = keccak256(bytes(label));

        if (labelhashFromData != labelhash) {
            revert LabelMismatch(labelhashFromData, labelhash);
        }

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(uint256(labelhash), address(this));

        _wrapETH2LD(label, owner, fuses, expiry, resolver);

        return IERC721Receiver(to).onERC721Received.selector;
    }

    /***** Internal functions */

    function _canTransfer(uint32 fuses) internal pure override returns (bool) {
        return fuses & CANNOT_TRANSFER == 0;
    }

    function _makeNode(bytes32 node, bytes32 labelhash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, labelhash));
    }

    function _addLabel(string memory label, bytes memory name)
        internal
        pure
        returns (bytes memory ret)
    {
        if (bytes(label).length < 1) {
            revert LabelTooShort();
        }
        if (bytes(label).length > 255) {
            revert LabelTooLong(label);
        }
        return abi.encodePacked(uint8(bytes(label).length), label, name);
    }

    function _mint(
        bytes32 node,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal override {
        address oldWrappedOwner = ownerOf(uint256(node));
        _canFusesBeBurned(node, fuses);
        if (oldWrappedOwner != address(0)) {
            // burn and unwrap old token of old owner
            _burn(uint256(node));
            emit NameUnwrapped(node, address(0));
        }
        super._mint(node, wrappedOwner, fuses, expiry);
    }

    function _wrap(
        bytes32 node,
        bytes memory name,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        names[node] = name;
        _mint(node, wrappedOwner, fuses, expiry);
        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);
    }

    function _addLabelAndWrap(
        bytes32 parentNode,
        bytes32 node,
        string memory label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        bytes memory name = _addLabel(label, names[parentNode]);
        _wrap(node, name, newOwner, fuses, expiry);
    }

    function _prepareUpgrade(bytes32 node)
        private
        returns (uint32 fuses, uint64 expiry)
    {
        if (address(upgradeContract) == address(0)) {
            revert CannotUpgrade();
        }

        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        (fuses, expiry) = getFuses(node);

        // burn token and fuse data
        _burn(uint256(node));
    }

    function _transferAndBurnFuses(
        bytes32 node,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        (address owner, , ) = getData(uint256(node));
        _transfer(owner, newOwner, uint256(node), 1, "");
        _setFuses(node, newOwner, fuses, expiry);
    }

    // wrapper function for stack limit
    function _getDataAndNormaliseExpiry(
        bytes32 parentNode,
        bytes32 node,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        (, , uint64 maxExpiry) = getData(uint256(parentNode));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _getETH2LDDataAndNormaliseExpiry(
        bytes32 node,
        bytes32 labelhash,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _normaliseExpiry(
        uint64 expiry,
        uint64 oldExpiry,
        uint64 maxExpiry
    ) internal pure returns (uint64) {
        // Expiry cannot be more than maximum allowed
        // .eth names will check registrar, non .eth check parent
        if (expiry > maxExpiry) {
            expiry = maxExpiry;
        }
        // Expiry cannot be less than old expiry
        if (expiry < oldExpiry) {
            expiry = oldExpiry;
        }

        return expiry;
    }

    function _wrapETH2LD(
        string memory label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) private returns (uint64) {
        // Mint a new ERC1155 token with fuses
        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);

        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(
            node,
            labelhash,
            expiry
        );

        _addLabelAndWrap(
            ETH_NODE,
            node,
            label,
            wrappedOwner,
            fuses | PARENT_CANNOT_CONTROL,
            expiry
        );
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        return expiry;
    }

    function _unwrap(bytes32 node, address newOwner) private {
        if (newOwner == address(0x0) || newOwner == address(this)) {
            revert IncorrectTargetOwner(newOwner);
        }

        if (allFusesBurned(node, CANNOT_UNWRAP)) {
            revert OperationProhibited(node);
        }

        // Burn token and fuse data
        _burn(uint256(node));
        ens.setOwner(node, newOwner);

        emit NameUnwrapped(node, newOwner);
    }

    function _setFuses(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _setData(node, owner, fuses, expiry);
        emit FusesSet(node, fuses, expiry);
    }

    function _setData(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _canFusesBeBurned(node, fuses);
        super._setData(uint256(node), owner, fuses, expiry);
    }

    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
        if (
            fuses & ~PARENT_CANNOT_CONTROL != 0 &&
            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
        ) {
            revert OperationProhibited(node);
        }
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "//SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "./ERC1155Fuse.sol";
import "./Controllable.sol";
import "./INameWrapper.sol";
import "./INameWrapperUpgrade.sol";
import "./IMetadataService.sol";
import "../registry/ENS.sol";
import "../ethregistrar/IBaseRegistrar.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./BytesUtil.sol";

error Unauthorised(bytes32 node, address addr);
error NameNotFound();
error IncompatibleParent();
error IncompatibleName(bytes name);
error IncorrectTokenType();
error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);
error LabelTooShort();
error LabelTooLong(string label);
error IncorrectTargetOwner(address owner);
error CannotUpgrade();
error InvalidExpiry(bytes32 node, uint64 expiry);

contract NameWrapper is
    Ownable,
    ERC1155Fuse,
    INameWrapper,
    Controllable,
    IERC721Receiver
{
    using BytesUtils for bytes;
    ENS public immutable override ens;
    IBaseRegistrar public immutable override registrar;
    IMetadataService public override metadataService;
    mapping(bytes32 => bytes) public override names;

    bytes32 private constant ETH_NODE =
        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
    bytes32 private constant ROOT_NODE =
        0x0000000000000000000000000000000000000000000000000000000000000000;

    //A contract address to a new upgraded contract if any
    INameWrapperUpgrade public upgradeContract;
    uint64 private constant MAX_EXPIRY = type(uint64).max;

    constructor(
        ENS _ens,
        IBaseRegistrar _registrar,
        IMetadataService _metadataService
    ) {
        ens = _ens;
        registrar = _registrar;
        metadataService = _metadataService;

        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */

        _setData(
            uint256(ETH_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        _setData(
            uint256(ROOT_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        names[ROOT_NODE] = "\x00";
        names[ETH_NODE] = "\x03eth\x00";
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Fuse, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(INameWrapper).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /* ERC1155 */

    function ownerOf(uint256 id)
        public
        view
        override(ERC1155Fuse, INameWrapper)
        returns (address owner)
    {
        return super.ownerOf(id);
    }

    /* Metadata service */

    /**
     * @notice Set the metadata service. Only the owner can do this
     */

    function setMetadataService(IMetadataService _newMetadataService)
        public
        onlyOwner
    {
        metadataService = _newMetadataService;
    }

    /**
     * @notice Get the metadata uri
     * @return String uri of the metadata service
     */

    function uri(uint256 tokenId) public view override returns (string memory) {
        return metadataService.uri(tokenId);
    }

    /**
     * @notice Set the address of the upgradeContract of the contract. only admin can do this
     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time
     * to make the contract not upgradable.
     * @param _upgradeAddress address of an upgraded contract
     */

    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)
        public
        onlyOwner
    {
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), false);
            ens.setApprovalForAll(address(upgradeContract), false);
        }

        upgradeContract = _upgradeAddress;

        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), true);
            ens.setApprovalForAll(address(upgradeContract), true);
        }
    }

    /**
     * @notice Checks if msg.sender is the owner or approved by the owner of a name
     * @param node namehash of the name to check
     */

    modifier onlyTokenOwner(bytes32 node) {
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        _;
    }

    /**
     * @notice Checks if owner or approved by owner
     * @param node namehash of the name to check
     * @param addr which address to check permissions for
     * @return whether or not is owner or approved
     */

    function isTokenOwnerOrApproved(bytes32 node, address addr)
        public
        view
        override
        returns (bool)
    {
        address owner = ownerOf(uint256(node));
        return owner == addr || isApprovedForAll(owner, addr);
    }

    /**
     * @notice Gets fuse permissions for a specific name
     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit
     *      The interface has predefined fuses for all registry permissions, but additional
     *      fuses can be added for other use cases
     *      Also returns expiry, which is when the fuses are set to expire.
     * @param node namehash of the name to check
     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp
     * @return expiry Unix time of when the name expires and fuses are to expire
     */
    function getFuses(bytes32 node)
        public
        view
        override
        returns (uint32 fuses, uint64 expiry)
    {
        (, fuses, expiry) = getData(uint256(node));
        if (fuses == 0 && expiry == 0) {
            bytes memory name = names[node];
            if (name.length == 0) {
                revert NameNotFound();
            }
        }
    }

    /**
     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract
     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar
     * @param label label as a string of the .eth domain to wrap
     * @param wrappedOwner Owner of the name in this contract
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @param resolver resolver contract address
     */

    function wrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) public override returns (uint64) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        address registrant = registrar.ownerOf(tokenId);
        if (
            registrant != msg.sender &&
            !isApprovedForAll(registrant, msg.sender) &&
            !registrar.isApprovedForAll(registrant, msg.sender)
        ) {
            revert Unauthorised(
                _makeNode(ETH_NODE, bytes32(tokenId)),
                msg.sender
            );
        }

        // transfer the token from the user to this contract
        registrar.transferFrom(registrant, address(this), tokenId);

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(tokenId, address(this));

        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Registers a new .eth second-level domain and wraps it.
     *      Only callable by authorised controllers.
     * @param label The label to register (Eg, 'foo' for 'foo.eth').
     * @param wrappedOwner The owner of the wrapped name.
     * @param duration The duration, in seconds, to register the name for.
     * @param resolver The resolver address to set on the ENS registry (optional).
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.
     */

    function registerAndWrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint256 duration,
        address resolver,
        uint32 fuses,
        uint64 expiry
    ) external override onlyController returns (uint256 registrarExpiry) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        registrarExpiry = registrar.register(tokenId, address(this), duration);
        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Renews a .eth second-level domain.
     *      Only callable by authorised controllers.
     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').
     * @param duration The number of seconds to renew the name for.
     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.
     */
    function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));

        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));

        _setData(node, owner, fuses, expiry);
    }

    /**
     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the registry or an authorised caller in the registry
     * @param name The name to wrap, in DNS format
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract address
     */

    function wrap(
        bytes calldata name,
        address wrappedOwner,
        address resolver
    ) public override {
        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
        bytes32 parentNode = name.namehash(offset);
        bytes32 node = _makeNode(parentNode, labelhash);

        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }

        address owner = ens.owner(node);

        if (
            owner != msg.sender &&
            !isApprovedForAll(owner, msg.sender) &&
            !ens.isApprovedForAll(owner, msg.sender)
        ) {
            revert Unauthorised(node, msg.sender);
        }

        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        ens.setOwner(node, address(this));

        _wrap(node, name, wrappedOwner, 0, 0);
    }

    /**
     * @notice Unwraps a .eth domain. e.g. vitalik.eth
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param labelhash labelhash of the .eth domain
     * @param newRegistrant sets the owner in the .eth registrar to this address
     * @param newController sets the owner in the registry to this address
     */

    function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }

    /**
     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param newController sets the owner in the registry to this address
     */

    function unwrap(
        bytes32 parentNode,
        bytes32 labelhash,
        address newController
    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        _unwrap(_makeNode(parentNode, labelhash), newController);
    }

    /**
     * @notice Sets fuses of a name
     * @param node namehash of the name
     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)
     */

    function setFuses(bytes32 node, uint32 fuses)
        public
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_BURN_FUSES)
        returns (uint32)
    {
        if (fuses & PARENT_CANNOT_CONTROL != 0) {
            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.
            revert Unauthorised(node, msg.sender);
        }

        (address owner, uint32 oldFuses, uint64 expiry) = getData(
            uint256(node)
        );

        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
        return fuses;
    }

    /**
     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract
     *     and burning the token of this contract
     * @dev Can be called by the owner of the name in this contract
     * @param label Label as a string of the .eth name to upgrade
     * @param wrappedOwner The owner of the wrapped name
     */

    function upgradeETH2LD(
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);

        upgradeContract.wrapETH2LD(
            label,
            wrappedOwner,
            fuses,
            expiry,
            resolver
        );
    }

    /**
     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner or an authorised caller
     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names
     * @param parentNode namehash of the parent name
     * @param label Label as a string of the name to upgrade
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract for this name
     */

    function upgrade(
        bytes32 parentNode,
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.setSubnodeRecord(
            parentNode,
            label,
            wrappedOwner,
            resolver,
            0,
            fuses,
            expiry
        );
    }

    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param fuses fuses to burn
     * @param expiry when the fuses will expire
     */

    function setChildFuses(
        bytes32 parentNode,
        bytes32 labelhash,
        uint32 fuses,
        uint64 expiry
    ) public {
        bytes32 node = _makeNode(parentNode, labelhash);
        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        uint64 maxExpiry;
        if (parentNode == ETH_NODE) {
            if (!isTokenOwnerOrApproved(node, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            // max expiry is set to the expiry on the registrar
            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        } else {
            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }

            // max expiry is set to the expiry of the parent
            (, , maxExpiry) = getData(uint256(parentNode));
        }

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);

        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed
        if (
            oldFuses & PARENT_CANNOT_CONTROL != 0 &&
            oldFuses | fuses != oldFuses
        ) {
            revert OperationProhibited(node);
        }
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
    }

    /**
     * @notice Sets the subdomain owner in the registry and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry when the fuses will expire
     */

    function setSubnodeOwner(
        bytes32 parentNode,
        string calldata label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
        returns (bytes32 node)
    {
        bytes32 labelhash = keccak256(bytes(label));
        node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);

        if (ens.owner(node) != address(this)) {
            ens.setSubnodeOwner(parentNode, labelhash, address(this));
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param resolver resolver contract in the registry
     * @param ttl ttl in the regsitry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry expiry date for the domain
     */

    function setSubnodeRecord(
        bytes32 parentNode,
        string memory label,
        address newOwner,
        address resolver,
        uint64 ttl,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
    {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets records for the name in the ENS Registry
     * @param node namehash of the name to set a record for
     * @param owner newOwner in the registry
     * @param resolver the resolver contract
     * @param ttl ttl in the registry
     */

    function setRecord(
        bytes32 node,
        address owner,
        address resolver,
        uint64 ttl
    )
        public
        override
        onlyTokenOwner(node)
        operationAllowed(
            node,
            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL
        )
    {
        ens.setRecord(node, address(this), resolver, ttl);
        (address oldOwner, , ) = getData(uint256(node));
        _transfer(oldOwner, owner, uint256(node), 1, "");
    }

    /**
     * @notice Sets resolver contract in the registry
     * @param node namehash of the name
     * @param resolver the resolver contract
     */

    function setResolver(bytes32 node, address resolver)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_RESOLVER)
    {
        ens.setResolver(node, resolver);
    }

    /**
     * @notice Sets TTL in the registry
     * @param node namehash of the name
     * @param ttl TTL in the registry
     */

    function setTTL(bytes32 node, uint64 ttl)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_TTL)
    {
        ens.setTTL(node, ttl);
    }

    /**
     * @dev Allows an operation only if none of the specified fuses are burned.
     * @param node The namehash of the name to check fuses on.
     * @param fuseMask A bitmask of fuses that must not be burned.
     */

    modifier operationAllowed(bytes32 node, uint32 fuseMask) {
        (, uint32 fuses, ) = getData(uint256(node));
        if (fuses & fuseMask != 0) {
            revert OperationProhibited(node);
        }
        _;
    }

    /**
     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord
     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt
     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for
     *      replacing a subdomain. If either conditions are true, then it is possible to call
     *      setSubnodeOwner
     * @param node namehash of the name to check
     * @param labelhash labelhash of the name to check
     */

    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {
        bytes32 subnode = _makeNode(node, labelhash);
        address owner = ens.owner(subnode);

        if (owner == address(0)) {
            (, uint32 fuses, ) = getData(uint256(node));
            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {
                revert OperationProhibited(node);
            }
        } else {
            (, uint32 subnodeFuses, ) = getData(uint256(subnode));
            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {
                revert OperationProhibited(node);
            }
        }

        _;
    }

    /**
     * @notice Checks all Fuses in the mask are burned for the node
     * @param node namehash of the name
     * @param fuseMask the fuses you want to check
     * @return Boolean of whether or not all the selected fuses are burned
     */

    function allFusesBurned(bytes32 node, uint32 fuseMask)
        public
        view
        override
        returns (bool)
    {
        (, uint32 fuses, ) = getData(uint256(node));
        return fuses & fuseMask == fuseMask;
    }

    function onERC721Received(
        address to,
        address,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        //check if it's the eth registrar ERC721
        if (msg.sender != address(registrar)) {
            revert IncorrectTokenType();
        }

        (
            string memory label,
            address owner,
            uint32 fuses,
            uint64 expiry,
            address resolver
        ) = abi.decode(data, (string, address, uint32, uint64, address));

        bytes32 labelhash = bytes32(tokenId);
        bytes32 labelhashFromData = keccak256(bytes(label));

        if (labelhashFromData != labelhash) {
            revert LabelMismatch(labelhashFromData, labelhash);
        }

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(uint256(labelhash), address(this));

        _wrapETH2LD(label, owner, fuses, expiry, resolver);

        return IERC721Receiver(to).onERC721Received.selector;
    }

    /***** Internal functions */

    function _canTransfer(uint32 fuses) internal pure override returns (bool) {
        return fuses & CANNOT_TRANSFER == 0;
    }

    function _makeNode(bytes32 node, bytes32 labelhash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, labelhash));
    }

    function _addLabel(string memory label, bytes memory name)
        internal
        pure
        returns (bytes memory ret)
    {
        if (bytes(label).length < 1) {
            revert LabelTooShort();
        }
        if (bytes(label).length > 255) {
            revert LabelTooLong(label);
        }
        return abi.encodePacked(uint8(bytes(label).length), label, name);
    }

    function _mint(
        bytes32 node,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal override {
        address oldWrappedOwner = ownerOf(uint256(node));
        _canFusesBeBurned(node, fuses);
        if (oldWrappedOwner != address(0)) {
            // burn and unwrap old token of old owner
            _burn(uint256(node));
            emit NameUnwrapped(node, address(0));
        }
        super._mint(node, wrappedOwner, fuses, expiry);
    }

    function _wrap(
        bytes32 node,
        bytes memory name,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        names[node] = name;
        _mint(node, wrappedOwner, fuses, expiry);
        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);
    }

    function _addLabelAndWrap(
        bytes32 parentNode,
        bytes32 node,
        string memory label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        bytes memory name = _addLabel(label, names[parentNode]);
        _wrap(node, name, newOwner, fuses, expiry);
    }

    function _prepareUpgrade(bytes32 node)
        private
        returns (uint32 fuses, uint64 expiry)
    {
        if (address(upgradeContract) == address(0)) {
            revert CannotUpgrade();
        }

        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        (fuses, expiry) = getFuses(node);

        // burn token and fuse data
        _burn(uint256(node));
    }

    function _transferAndBurnFuses(
        bytes32 node,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        (address owner, , ) = getData(uint256(node));
        _transfer(owner, newOwner, uint256(node), 1, "");
        _setFuses(node, newOwner, fuses, expiry);
    }

    // wrapper function for stack limit
    function _getDataAndNormaliseExpiry(
        bytes32 parentNode,
        bytes32 node,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        (, , uint64 maxExpiry) = getData(uint256(parentNode));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _getETH2LDDataAndNormaliseExpiry(
        bytes32 node,
        bytes32 labelhash,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _normaliseExpiry(
        uint64 expiry,
        uint64 oldExpiry,
        uint64 maxExpiry
    ) internal pure returns (uint64) {
        // Expiry cannot be more than maximum allowed
        // .eth names will check registrar, non .eth check parent
        if (expiry > maxExpiry) {
            expiry = maxExpiry;
        }
        // Expiry cannot be less than old expiry
        if (expiry < oldExpiry) {
            expiry = oldExpiry;
        }

        return expiry;
    }

    function _wrapETH2LD(
        string memory label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) private returns (uint64) {
        // Mint a new ERC1155 token with fuses
        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);

        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(
            node,
            labelhash,
            expiry
        );

        _addLabelAndWrap(
            ETH_NODE,
            node,
            label,
            wrappedOwner,
            fuses | PARENT_CANNOT_CONTROL,
            expiry
        );
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        return expiry;
    }

    function _unwrap(bytes32 node, address newOwner) private {
        if (newOwner == address(0x0) || newOwner == address(this)) {
            revert IncorrectTargetOwner(newOwner);
        }

        if (allFusesBurned(node, CANNOT_UNWRAP)) {
            revert OperationProhibited(node);
        }

        // Burn token and fuse data
        _burn(uint256(node));
        ens.setOwner(node, newOwner);

        emit NameUnwrapped(node, newOwner);
    }

    function _setFuses(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _setData(node, owner, fuses, expiry);
        emit FusesSet(node, fuses, expiry);
    }

    function _setData(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _canFusesBeBurned(node, fuses);
        super._setData(uint256(node), owner, fuses, expiry);
    }

    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
        if (
            fuses & ~PARENT_CANNOT_CONTROL != 0 &&
            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
        ) {
            revert OperationProhibited(node);
        }
    }
}
".
Ideas: " 1".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-01-09 20:35:48 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 20:35:48 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 14282
completion_tokens: 984
total_tokens: 15266
cost: $-1.000000


[2024-01-09 20:35:48 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: //SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "./ERC1155Fuse.sol";
import "./Controllable.sol";
import "./INameWrapper.sol";
import "./INameWrapperUpgrade.sol";
import "./IMetadataService.sol";
import "../registry/ENS.sol";
import "../ethregistrar/IBaseRegistrar.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./BytesUtil.sol";

error Unauthorised(bytes32 node, address addr);
error NameNotFound();
error IncompatibleParent();
error IncompatibleName(bytes name);
error IncorrectTokenType();
error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);
error LabelTooShort();
error LabelTooLong(string label);
error IncorrectTargetOwner(address owner);
error CannotUpgrade();
error InvalidExpiry(bytes32 node, uint64 expiry);

contract NameWrapper is
    Ownable,
    ERC1155Fuse,
    INameWrapper,
    Controllable,
    IERC721Receiver
{
    using BytesUtils for bytes;
    ENS public immutable override ens;
    IBaseRegistrar public immutable override registrar;
    IMetadataService public override metadataService;
    mapping(bytes32 => bytes) public override names;

    bytes32 private constant ETH_NODE =
        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
    bytes32 private constant ROOT_NODE =
        0x0000000000000000000000000000000000000000000000000000000000000000;

    //A contract address to a new upgraded contract if any
    INameWrapperUpgrade public upgradeContract;
    uint64 private constant MAX_EXPIRY = type(uint64).max;

    constructor(
        ENS _ens,
        IBaseRegistrar _registrar,
        IMetadataService _metadataService
    ) {
        ens = _ens;
        registrar = _registrar;
        metadataService = _metadataService;

        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */

        _setData(
            uint256(ETH_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        _setData(
            uint256(ROOT_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        names[ROOT_NODE] = "\x00";
        names[ETH_NODE] = "\x03eth\x00";
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Fuse, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(INameWrapper).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /* ERC1155 */

    function ownerOf(uint256 id)
        public
        view
        override(ERC1155Fuse, INameWrapper)
        returns (address owner)
    {
        return super.ownerOf(id);
    }

    /* Metadata service */

    /**
     * @notice Set the metadata service. Only the owner can do this
     */

    function setMetadataService(IMetadataService _newMetadataService)
        public
        onlyOwner
    {
        metadataService = _newMetadataService;
    }

    /**
     * @notice Get the metadata uri
     * @return String uri of the metadata service
     */

    function uri(uint256 tokenId) public view override returns (string memory) {
        return metadataService.uri(tokenId);
    }

    /**
     * @notice Set the address of the upgradeContract of the contract. only admin can do this
     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time
     * to make the contract not upgradable.
     * @param _upgradeAddress address of an upgraded contract
     */

    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)
        public
        onlyOwner
    {
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), false);
            ens.setApprovalForAll(address(upgradeContract), false);
        }

        upgradeContract = _upgradeAddress;

        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), true);
            ens.setApprovalForAll(address(upgradeContract), true);
        }
    }

    /**
     * @notice Checks if msg.sender is the owner or approved by the owner of a name
     * @param node namehash of the name to check
     */

    modifier onlyTokenOwner(bytes32 node) {
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        _;
    }

    /**
     * @notice Checks if owner or approved by owner
     * @param node namehash of the name to check
     * @param addr which address to check permissions for
     * @return whether or not is owner or approved
     */

    function isTokenOwnerOrApproved(bytes32 node, address addr)
        public
        view
        override
        returns (bool)
    {
        address owner = ownerOf(uint256(node));
        return owner == addr || isApprovedForAll(owner, addr);
    }

    /**
     * @notice Gets fuse permissions for a specific name
     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit
     *      The interface has predefined fuses for all registry permissions, but additional
     *      fuses can be added for other use cases
     *      Also returns expiry, which is when the fuses are set to expire.
     * @param node namehash of the name to check
     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp
     * @return expiry Unix time of when the name expires and fuses are to expire
     */
    function getFuses(bytes32 node)
        public
        view
        override
        returns (uint32 fuses, uint64 expiry)
    {
        (, fuses, expiry) = getData(uint256(node));
        if (fuses == 0 && expiry == 0) {
            bytes memory name = names[node];
            if (name.length == 0) {
                revert NameNotFound();
            }
        }
    }

    /**
     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract
     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar
     * @param label label as a string of the .eth domain to wrap
     * @param wrappedOwner Owner of the name in this contract
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @param resolver resolver contract address
     */

    function wrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) public override returns (uint64) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        address registrant = registrar.ownerOf(tokenId);
        if (
            registrant != msg.sender &&
            !isApprovedForAll(registrant, msg.sender) &&
            !registrar.isApprovedForAll(registrant, msg.sender)
        ) {
            revert Unauthorised(
                _makeNode(ETH_NODE, bytes32(tokenId)),
                msg.sender
            );
        }

        // transfer the token from the user to this contract
        registrar.transferFrom(registrant, address(this), tokenId);

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(tokenId, address(this));

        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Registers a new .eth second-level domain and wraps it.
     *      Only callable by authorised controllers.
     * @param label The label to register (Eg, 'foo' for 'foo.eth').
     * @param wrappedOwner The owner of the wrapped name.
     * @param duration The duration, in seconds, to register the name for.
     * @param resolver The resolver address to set on the ENS registry (optional).
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.
     */

    function registerAndWrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint256 duration,
        address resolver,
        uint32 fuses,
        uint64 expiry
    ) external override onlyController returns (uint256 registrarExpiry) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        registrarExpiry = registrar.register(tokenId, address(this), duration);
        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Renews a .eth second-level domain.
     *      Only callable by authorised controllers.
     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').
     * @param duration The number of seconds to renew the name for.
     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.
     */
    function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));

        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));

        _setData(node, owner, fuses, expiry);
    }

    /**
     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the registry or an authorised caller in the registry
     * @param name The name to wrap, in DNS format
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract address
     */

    function wrap(
        bytes calldata name,
        address wrappedOwner,
        address resolver
    ) public override {
        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
        bytes32 parentNode = name.namehash(offset);
        bytes32 node = _makeNode(parentNode, labelhash);

        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }

        address owner = ens.owner(node);

        if (
            owner != msg.sender &&
            !isApprovedForAll(owner, msg.sender) &&
            !ens.isApprovedForAll(owner, msg.sender)
        ) {
            revert Unauthorised(node, msg.sender);
        }

        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        ens.setOwner(node, address(this));

        _wrap(node, name, wrappedOwner, 0, 0);
    }

    /**
     * @notice Unwraps a .eth domain. e.g. vitalik.eth
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param labelhash labelhash of the .eth domain
     * @param newRegistrant sets the owner in the .eth registrar to this address
     * @param newController sets the owner in the registry to this address
     */

    function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }

    /**
     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param newController sets the owner in the registry to this address
     */

    function unwrap(
        bytes32 parentNode,
        bytes32 labelhash,
        address newController
    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        _unwrap(_makeNode(parentNode, labelhash), newController);
    }

    /**
     * @notice Sets fuses of a name
     * @param node namehash of the name
     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)
     */

    function setFuses(bytes32 node, uint32 fuses)
        public
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_BURN_FUSES)
        returns (uint32)
    {
        if (fuses & PARENT_CANNOT_CONTROL != 0) {
            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.
            revert Unauthorised(node, msg.sender);
        }

        (address owner, uint32 oldFuses, uint64 expiry) = getData(
            uint256(node)
        );

        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
        return fuses;
    }

    /**
     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract
     *     and burning the token of this contract
     * @dev Can be called by the owner of the name in this contract
     * @param label Label as a string of the .eth name to upgrade
     * @param wrappedOwner The owner of the wrapped name
     */

    function upgradeETH2LD(
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);

        upgradeContract.wrapETH2LD(
            label,
            wrappedOwner,
            fuses,
            expiry,
            resolver
        );
    }

    /**
     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner or an authorised caller
     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names
     * @param parentNode namehash of the parent name
     * @param label Label as a string of the name to upgrade
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract for this name
     */

    function upgrade(
        bytes32 parentNode,
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.setSubnodeRecord(
            parentNode,
            label,
            wrappedOwner,
            resolver,
            0,
            fuses,
            expiry
        );
    }

    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param fuses fuses to burn
     * @param expiry when the fuses will expire
     */

    function setChildFuses(
        bytes32 parentNode,
        bytes32 labelhash,
        uint32 fuses,
        uint64 expiry
    ) public {
        bytes32 node = _makeNode(parentNode, labelhash);
        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        uint64 maxExpiry;
        if (parentNode == ETH_NODE) {
            if (!isTokenOwnerOrApproved(node, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            // max expiry is set to the expiry on the registrar
            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        } else {
            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }

            // max expiry is set to the expiry of the parent
            (, , maxExpiry) = getData(uint256(parentNode));
        }

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);

        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed
        if (
            oldFuses & PARENT_CANNOT_CONTROL != 0 &&
            oldFuses | fuses != oldFuses
        ) {
            revert OperationProhibited(node);
        }
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
    }

    /**
     * @notice Sets the subdomain owner in the registry and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry when the fuses will expire
     */

    function setSubnodeOwner(
        bytes32 parentNode,
        string calldata label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
        returns (bytes32 node)
    {
        bytes32 labelhash = keccak256(bytes(label));
        node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);

        if (ens.owner(node) != address(this)) {
            ens.setSubnodeOwner(parentNode, labelhash, address(this));
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param resolver resolver contract in the registry
     * @param ttl ttl in the regsitry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry expiry date for the domain
     */

    function setSubnodeRecord(
        bytes32 parentNode,
        string memory label,
        address newOwner,
        address resolver,
        uint64 ttl,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
    {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets records for the name in the ENS Registry
     * @param node namehash of the name to set a record for
     * @param owner newOwner in the registry
     * @param resolver the resolver contract
     * @param ttl ttl in the registry
     */

    function setRecord(
        bytes32 node,
        address owner,
        address resolver,
        uint64 ttl
    )
        public
        override
        onlyTokenOwner(node)
        operationAllowed(
            node,
            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL
        )
    {
        ens.setRecord(node, address(this), resolver, ttl);
        (address oldOwner, , ) = getData(uint256(node));
        _transfer(oldOwner, owner, uint256(node), 1, "");
    }

    /**
     * @notice Sets resolver contract in the registry
     * @param node namehash of the name
     * @param resolver the resolver contract
     */

    function setResolver(bytes32 node, address resolver)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_RESOLVER)
    {
        ens.setResolver(node, resolver);
    }

    /**
     * @notice Sets TTL in the registry
     * @param node namehash of the name
     * @param ttl TTL in the registry
     */

    function setTTL(bytes32 node, uint64 ttl)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_TTL)
    {
        ens.setTTL(node, ttl);
    }

    /**
     * @dev Allows an operation only if none of the specified fuses are burned.
     * @param node The namehash of the name to check fuses on.
     * @param fuseMask A bitmask of fuses that must not be burned.
     */

    modifier operationAllowed(bytes32 node, uint32 fuseMask) {
        (, uint32 fuses, ) = getData(uint256(node));
        if (fuses & fuseMask != 0) {
            revert OperationProhibited(node);
        }
        _;
    }

    /**
     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord
     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt
     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for
     *      replacing a subdomain. If either conditions are true, then it is possible to call
     *      setSubnodeOwner
     * @param node namehash of the name to check
     * @param labelhash labelhash of the name to check
     */

    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {
        bytes32 subnode = _makeNode(node, labelhash);
        address owner = ens.owner(subnode);

        if (owner == address(0)) {
            (, uint32 fuses, ) = getData(uint256(node));
            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {
                revert OperationProhibited(node);
            }
        } else {
            (, uint32 subnodeFuses, ) = getData(uint256(subnode));
            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {
                revert OperationProhibited(node);
            }
        }

        _;
    }

    /**
     * @notice Checks all Fuses in the mask are burned for the node
     * @param node namehash of the name
     * @param fuseMask the fuses you want to check
     * @return Boolean of whether or not all the selected fuses are burned
     */

    function allFusesBurned(bytes32 node, uint32 fuseMask)
        public
        view
        override
        returns (bool)
    {
        (, uint32 fuses, ) = getData(uint256(node));
        return fuses & fuseMask == fuseMask;
    }

    function onERC721Received(
        address to,
        address,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        //check if it's the eth registrar ERC721
        if (msg.sender != address(registrar)) {
            revert IncorrectTokenType();
        }

        (
            string memory label,
            address owner,
            uint32 fuses,
            uint64 expiry,
            address resolver
        ) = abi.decode(data, (string, address, uint32, uint64, address));

        bytes32 labelhash = bytes32(tokenId);
        bytes32 labelhashFromData = keccak256(bytes(label));

        if (labelhashFromData != labelhash) {
            revert LabelMismatch(labelhashFromData, labelhash);
        }

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(uint256(labelhash), address(this));

        _wrapETH2LD(label, owner, fuses, expiry, resolver);

        return IERC721Receiver(to).onERC721Received.selector;
    }

    /***** Internal functions */

    function _canTransfer(uint32 fuses) internal pure override returns (bool) {
        return fuses & CANNOT_TRANSFER == 0;
    }

    function _makeNode(bytes32 node, bytes32 labelhash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, labelhash));
    }

    function _addLabel(string memory label, bytes memory name)
        internal
        pure
        returns (bytes memory ret)
    {
        if (bytes(label).length < 1) {
            revert LabelTooShort();
        }
        if (bytes(label).length > 255) {
            revert LabelTooLong(label);
        }
        return abi.encodePacked(uint8(bytes(label).length), label, name);
    }

    function _mint(
        bytes32 node,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal override {
        address oldWrappedOwner = ownerOf(uint256(node));
        _canFusesBeBurned(node, fuses);
        if (oldWrappedOwner != address(0)) {
            // burn and unwrap old token of old owner
            _burn(uint256(node));
            emit NameUnwrapped(node, address(0));
        }
        super._mint(node, wrappedOwner, fuses, expiry);
    }

    function _wrap(
        bytes32 node,
        bytes memory name,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        names[node] = name;
        _mint(node, wrappedOwner, fuses, expiry);
        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);
    }

    function _addLabelAndWrap(
        bytes32 parentNode,
        bytes32 node,
        string memory label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        bytes memory name = _addLabel(label, names[parentNode]);
        _wrap(node, name, newOwner, fuses, expiry);
    }

    function _prepareUpgrade(bytes32 node)
        private
        returns (uint32 fuses, uint64 expiry)
    {
        if (address(upgradeContract) == address(0)) {
            revert CannotUpgrade();
        }

        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        (fuses, expiry) = getFuses(node);

        // burn token and fuse data
        _burn(uint256(node));
    }

    function _transferAndBurnFuses(
        bytes32 node,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        (address owner, , ) = getData(uint256(node));
        _transfer(owner, newOwner, uint256(node), 1, "");
        _setFuses(node, newOwner, fuses, expiry);
    }

    // wrapper function for stack limit
    function _getDataAndNormaliseExpiry(
        bytes32 parentNode,
        bytes32 node,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        (, , uint64 maxExpiry) = getData(uint256(parentNode));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _getETH2LDDataAndNormaliseExpiry(
        bytes32 node,
        bytes32 labelhash,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _normaliseExpiry(
        uint64 expiry,
        uint64 oldExpiry,
        uint64 maxExpiry
    ) internal pure returns (uint64) {
        // Expiry cannot be more than maximum allowed
        // .eth names will check registrar, non .eth check parent
        if (expiry > maxExpiry) {
            expiry = maxExpiry;
        }
        // Expiry cannot be less than old expiry
        if (expiry < oldExpiry) {
            expiry = oldExpiry;
        }

        return expiry;
    }

    function _wrapETH2LD(
        string memory label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) private returns (uint64) {
        // Mint a new ERC1155 token with fuses
        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);

        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(
            node,
            labelhash,
            expiry
        );

        _addLabelAndWrap(
            ETH_NODE,
            node,
            label,
            wrappedOwner,
            fuses | PARENT_CANNOT_CONTROL,
            expiry
        );
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        return expiry;
    }

    function _unwrap(bytes32 node, address newOwner) private {
        if (newOwner == address(0x0) || newOwner == address(this)) {
            revert IncorrectTargetOwner(newOwner);
        }

        if (allFusesBurned(node, CANNOT_UNWRAP)) {
            revert OperationProhibited(node);
        }

        // Burn token and fuse data
        _burn(uint256(node));
        ens.setOwner(node, newOwner);

        emit NameUnwrapped(node, newOwner);
    }

    function _setFuses(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _setData(node, owner, fuses, expiry);
        emit FusesSet(node, fuses, expiry);
    }

    function _setData(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _canFusesBeBurned(node, fuses);
        super._setData(uint256(node), owner, fuses, expiry);
    }

    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
        if (
            fuses & ~PARENT_CANNOT_CONTROL != 0 &&
            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
        ) {
            revert OperationProhibited(node);
        }
    }
}
.]

### VULNERABILITY: Reentrancy Attack
```
DETAILED DESCRIPTION: The contract does not implement any reentrancy guards in functions that transfer tokens or call external contracts (e.g., `wrapETH2LD`, `unwrapETH2LD`, `setRecord`). This could allow an attacker to exploit the contract by recursively calling these functions before the state changes are finalized, potentially draining funds or manipulating state.

RECOMMENDED MITIGATION: Implement a reentrancy guard using a mutex or the Checks-Effects-Interactions pattern. Ensure that state changes occur before any external calls, and consider using OpenZeppelin's ReentrancyGuard contract.
```

### VULNERABILITY: Improper Access Control
```
DETAILED DESCRIPTION: The `setUpgradeContract` function allows the owner to set an upgrade contract without any checks on the validity of the contract address. If an invalid or malicious contract is set, it could lead to unauthorized access or manipulation of the contract's state.

RECOMMENDED MITIGATION: Validate the address of the `_upgradeAddress` parameter to ensure it is a contract and not a zero address. This can be done using `require(_upgradeAddress.isContract())` or similar checks.
```

### VULNERABILITY: Lack of Input Validation
```
DETAILED DESCRIPTION: Functions like `wrapETH2LD`, `registerAndWrapETH2LD`, and `setFuses` do not adequately validate inputs such as `expiry` and `fuses`. This could allow for invalid or malicious data to be processed, leading to unexpected behavior or state corruption.

RECOMMENDED MITIGATION: Implement input validation checks to ensure that `expiry` is within acceptable bounds (e.g., not in the past) and that `fuses` do not contain invalid bits. Use `require` statements to enforce these checks.
```

### VULNERABILITY: Potential Integer Overflow/Underflow
```
DETAILED DESCRIPTION: Although Solidity 0.8.0 and above has built-in overflow and underflow checks, there are still areas where calculations could lead to unexpected results, particularly in the `_normaliseExpiry` function. If not handled properly, this could lead to incorrect expiry values.

RECOMMENDED MITIGATION: Ensure that all arithmetic operations are carefully checked and validated. Although Solidity handles this, additional checks can be added to ensure that values remain within expected ranges.
```

### VULNERABILITY: Unchecked External Calls
```
DETAILED DESCRIPTION: The contract makes several external calls (e.g., `registrar.transferFrom`, `ens.setOwner`) without checking the return values. If these calls fail, the contract may enter an inconsistent state.

RECOMMENDED MITIGATION: Always check the return values of external calls and revert the transaction if they fail. This ensures that the contract state remains consistent and prevents partial state changes.
```

### VULNERABILITY: Gas Limit and Loops
```
DETAILED DESCRIPTION: Functions that involve loops or multiple external calls (e.g., `setSubnodeRecord`) could run into gas limit issues if the number of iterations is large. This could lead to failed transactions.

RECOMMENDED MITIGATION: Avoid unbounded loops and consider breaking up operations into smaller chunks or using events to log progress. Ensure that the contract can handle gas limits gracefully.
```

### VULNERABILITY: Missing Events
```
DETAILED DESCRIPTION: The contract does not emit events for critical state changes, such as when a name is wrapped or unwrapped. This makes it difficult to track changes and can hinder debugging and monitoring.

RECOMMENDED MITIGATION: Emit events for all significant state changes, including wrapping, unwrapping, and setting fuses. This will improve transparency and allow for better tracking of contract activity.
```

### VULNERABILITY: Potential for Denial of Service (DoS)
```
DETAILED DESCRIPTION: The contract relies on external contracts (e.g., ENS, registrar) for critical operations. If these contracts become unavailable or behave unexpectedly, it could lead to a denial of service for users trying to interact with the NameWrapper contract.

RECOMMENDED MITIGATION: Implement fallback mechanisms or circuit breakers to handle failures gracefully. Consider using a pattern that allows for recovery or alternative paths in case of external contract failures.
```

### VULNERABILITY: Insufficient Ownership Checks
```
DETAILED DESCRIPTION: The `onlyTokenOwner` modifier checks ownership but does not account for the possibility of an address being approved for the token. This could lead to unauthorized access if the approval mechanism is not properly managed.

RECOMMENDED MITIGATION: Ensure that the `onlyTokenOwner` modifier checks both ownership and approval status correctly. This can be done by refining the logic to ensure that both conditions are satisfied.
```

<INFO> Analysis Complete.

[2024-01-09 20:35:48 INFO] **[Seminar Conclusion]**:

 ### VULNERABILITY: Reentrancy Attack
```
DETAILED DESCRIPTION: The contract does not implement any reentrancy guards in functions that transfer tokens or call external contracts (e.g., `wrapETH2LD`, `unwrapETH2LD`, `setRecord`). This could allow an attacker to exploit the contract by recursively calling these functions before the state changes are finalized, potentially draining funds or manipulating state.

RECOMMENDED MITIGATION: Implement a reentrancy guard using a mutex or the Checks-Effects-Interactions pattern. Ensure that state changes occur before any external calls, and consider using OpenZeppelin's ReentrancyGuard contract.
```

### VULNERABILITY: Improper Access Control
```
DETAILED DESCRIPTION: The `setUpgradeContract` function allows the owner to set an upgrade contract without any checks on the validity of the contract address. If an invalid or malicious contract is set, it could lead to unauthorized access or manipulation of the contract's state.

RECOMMENDED MITIGATION: Validate the address of the `_upgradeAddress` parameter to ensure it is a contract and not a zero address. This can be done using `require(_upgradeAddress.isContract())` or similar checks.
```

### VULNERABILITY: Lack of Input Validation
```
DETAILED DESCRIPTION: Functions like `wrapETH2LD`, `registerAndWrapETH2LD`, and `setFuses` do not adequately validate inputs such as `expiry` and `fuses`. This could allow for invalid or malicious data to be processed, leading to unexpected behavior or state corruption.

RECOMMENDED MITIGATION: Implement input validation checks to ensure that `expiry` is within acceptable bounds (e.g., not in the past) and that `fuses` do not contain invalid bits. Use `require` statements to enforce these checks.
```

### VULNERABILITY: Potential Integer Overflow/Underflow
```
DETAILED DESCRIPTION: Although Solidity 0.8.0 and above has built-in overflow and underflow checks, there are still areas where calculations could lead to unexpected results, particularly in the `_normaliseExpiry` function. If not handled properly, this could lead to incorrect expiry values.

RECOMMENDED MITIGATION: Ensure that all arithmetic operations are carefully checked and validated. Although Solidity handles this, additional checks can be added to ensure that values remain within expected ranges.
```

### VULNERABILITY: Unchecked External Calls
```
DETAILED DESCRIPTION: The contract makes several external calls (e.g., `registrar.transferFrom`, `ens.setOwner`) without checking the return values. If these calls fail, the contract may enter an inconsistent state.

RECOMMENDED MITIGATION: Always check the return values of external calls and revert the transaction if they fail. This ensures that the contract state remains consistent and prevents partial state changes.
```

### VULNERABILITY: Gas Limit and Loops
```
DETAILED DESCRIPTION: Functions that involve loops or multiple external calls (e.g., `setSubnodeRecord`) could run into gas limit issues if the number of iterations is large. This could lead to failed transactions.

RECOMMENDED MITIGATION: Avoid unbounded loops and consider breaking up operations into smaller chunks or using events to log progress. Ensure that the contract can handle gas limits gracefully.
```

### VULNERABILITY: Missing Events
```
DETAILED DESCRIPTION: The contract does not emit events for critical state changes, such as when a name is wrapped or unwrapped. This makes it difficult to track changes and can hinder debugging and monitoring.

RECOMMENDED MITIGATION: Emit events for all significant state changes, including wrapping, unwrapping, and setting fuses. This will improve transparency and allow for better tracking of contract activity.
```

### VULNERABILITY: Potential for Denial of Service (DoS)
```
DETAILED DESCRIPTION: The contract relies on external contracts (e.g., ENS, registrar) for critical operations. If these contracts become unavailable or behave unexpectedly, it could lead to a denial of service for users trying to interact with the NameWrapper contract.

RECOMMENDED MITIGATION: Implement fallback mechanisms or circuit breakers to handle failures gracefully. Consider using a pattern that allows for recovery or alternative paths in case of external contract failures.
```

### VULNERABILITY: Insufficient Ownership Checks
```
DETAILED DESCRIPTION: The `onlyTokenOwner` modifier checks ownership but does not account for the possibility of an address being approved for the token. This could lead to unauthorized access if the approval mechanism is not properly managed.

RECOMMENDED MITIGATION: Ensure that the `onlyTokenOwner` modifier checks both ownership and approval status correctly. This can be done by refining the logic to ensure that both conditions are satisfied.
```

<INFO> Analysis Complete.

[2024-01-09 20:35:48 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-01-09 20:35:48 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | //SPDX-License-Identifier: MIT pragma solidity ^0.8.4; import "./ERC1155Fuse.sol"; import "./Controllable.sol"; import "./INameWrapper.sol"; import "./INameWrapperUpgrade.sol"; import "./IMetadataService.sol"; import "../registry/ENS.sol"; import "../ethregistrar/IBaseRegistrar.sol"; import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "./BytesUtil.sol"; error Unauthorised(bytes32 node, address addr); error NameNotFound(); error IncompatibleParent(); error IncompatibleName(bytes name); error IncorrectTokenType(); error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash); error LabelTooShort(); error LabelTooLong(string label); error IncorrectTargetOwner(address owner); error CannotUpgrade(); error InvalidExpiry(bytes32 node, uint64 expiry); contract NameWrapper is     Ownable,     ERC1155Fuse,     INameWrapper,     Controllable,     IERC721Receiver {     using BytesUtils for bytes;     ENS public immutable override ens;     IBaseRegistrar public immutable override registrar;     IMetadataService public override metadataService;     mapping(bytes32 =&gt; bytes) public override names; bytes32 private constant ETH_NODE =     0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae; bytes32 private constant ROOT_NODE =     0x0000000000000000000000000000000000000000000000000000000000000000;  //A contract address to a new upgraded contract if any INameWrapperUpgrade public upgradeContract; uint64 private constant MAX_EXPIRY = type(uint64).max;  constructor(     ENS _ens,     IBaseRegistrar _registrar,     IMetadataService _metadataService ) {     ens = _ens;     registrar = _registrar;     metadataService = _metadataService;      /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */      _setData(         uint256(ETH_NODE),         address(0),         uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),         MAX_EXPIRY     );     _setData(         uint256(ROOT_NODE),         address(0),         uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),         MAX_EXPIRY     );     names[ROOT_NODE] = "\x00";     names[ETH_NODE] = "\x03eth\x00"; }  function supportsInterface(bytes4 interfaceId)     public     view     virtual     override(ERC1155Fuse, IERC165)     returns (bool) {     return         interfaceId == type(INameWrapper).interfaceId ||         super.supportsInterface(interfaceId); }  /* ERC1155 */  function ownerOf(uint256 id)     public     view     override(ERC1155Fuse, INameWrapper)     returns (address owner) {     return super.ownerOf(id); }  /* Metadata service */  /**  * @notice Set the metadata service. Only the owner can do this  */  function setMetadataService(IMetadataService _newMetadataService)     public     onlyOwner {     metadataService = _newMetadataService; }  /**  * @notice Get the metadata uri  * @return String uri of the metadata service  */  function uri(uint256 tokenId) public view override returns (string memory) {     return metadataService.uri(tokenId); }  /**  * @notice Set the address of the upgradeContract of the contract. only admin can do this  * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time  * to make the contract not upgradable.  * @param _upgradeAddress address of an upgraded contract  */  function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)     public     onlyOwner {     if (address(upgradeContract) != address(0)) {         registrar.setApprovalForAll(address(upgradeContract), false);         ens.setApprovalForAll(address(upgradeContract), false);     }      upgradeContract = _upgradeAddress;      if (address(upgradeContract) != address(0)) {         registrar.setApprovalForAll(address(upgradeContract), true);         ens.setApprovalForAll(address(upgradeContract), true);     } }  /**  * @notice Checks if msg.sender is the owner or approved by the owner of a name  * @param node namehash of the name to check  */  modifier onlyTokenOwner(bytes32 node) {     if (!isTokenOwnerOrApproved(node, msg.sender)) {         revert Unauthorised(node, msg.sender);     }      _; }  /**  * @notice Checks if owner or approved by owner  * @param node namehash of the name to check  * @param addr which address to check permissions for  * @return whether or not is owner or approved  */  function isTokenOwnerOrApproved(bytes32 node, address addr)     public     view     override     returns (bool) {     address owner = ownerOf(uint256(node));     return owner == addr || isApprovedForAll(owner, addr); }  /**  * @notice Gets fuse permissions for a specific name  * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit  *      The interface has predefined fuses for all registry permissions, but additional  *      fuses can be added for other use cases  *      Also returns expiry, which is when the fuses are set to expire.  * @param node namehash of the name to check  * @return fuses A number that represents the permissions a name has. Returns 0 when expiry &lt; block.timestamp  * @return expiry Unix time of when the name expires and fuses are to expire  */ function getFuses(bytes32 node)     public     view     override     returns (uint32 fuses, uint64 expiry) {     (, fuses, expiry) = getData(uint256(node));     if (fuses == 0 &amp;&amp; expiry == 0) {         bytes memory name = names[node];         if (name.length == 0) {             revert NameNotFound();         }     } }  /**  * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract  * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar  * @param label label as a string of the .eth domain to wrap  * @param wrappedOwner Owner of the name in this contract  * @param fuses initial fuses to set  * @param expiry when the fuses will expire  * @param resolver resolver contract address  */  function wrapETH2LD(     string calldata label,     address wrappedOwner,     uint32 fuses,     uint64 expiry,     address resolver ) public override returns (uint64) {     uint256 tokenId = uint256(keccak256(bytes(label)));     address registrant = registrar.ownerOf(tokenId);     if (         registrant != msg.sender &amp;&amp;         !isApprovedForAll(registrant, msg.sender) &amp;&amp;         !registrar.isApprovedForAll(registrant, msg.sender)     ) {         revert Unauthorised(             _makeNode(ETH_NODE, bytes32(tokenId)),             msg.sender         );     }      // transfer the token from the user to this contract     registrar.transferFrom(registrant, address(this), tokenId);      // transfer the ens record back to the new owner (this contract)     registrar.reclaim(tokenId, address(this));      return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver); }  /**  * @dev Registers a new .eth second-level domain and wraps it.  *      Only callable by authorised controllers.  * @param label The label to register (Eg, 'foo' for 'foo.eth').  * @param wrappedOwner The owner of the wrapped name.  * @param duration The duration, in seconds, to register the name for.  * @param resolver The resolver address to set on the ENS registry (optional).  * @param fuses initial fuses to set  * @param expiry when the fuses will expire  * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.  */  function registerAndWrapETH2LD(     string calldata label,     address wrappedOwner,     uint256 duration,     address resolver,     uint32 fuses,     uint64 expiry ) external override onlyController returns (uint256 registrarExpiry) {     uint256 tokenId = uint256(keccak256(bytes(label)));     registrarExpiry = registrar.register(tokenId, address(this), duration);     _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver); }  /**  * @dev Renews a .eth second-level domain.  *      Only callable by authorised controllers.  * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').  * @param duration The number of seconds to renew the name for.  * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.  */ function renew(     uint256 tokenId,     uint256 duration,     uint64 expiry ) external override onlyController returns (uint256 expires) {     bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));      expires = registrar.renew(tokenId, duration);     (address owner, uint32 fuses, uint64 oldExpiry) = getData(         uint256(node)     );     expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));      _setData(node, owner, fuses, expiry); }  /**  * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner in the registry or an authorised caller in the registry  * @param name The name to wrap, in DNS format  * @param wrappedOwner Owner of the name in this contract  * @param resolver resolver contract address  */  function wrap(     bytes calldata name,     address wrappedOwner,     address resolver ) public override {     (bytes32 labelhash, uint256 offset) = name.readLabel(0);     bytes32 parentNode = name.namehash(offset);     bytes32 node = _makeNode(parentNode, labelhash);      if (parentNode == ETH_NODE) {         revert IncompatibleParent();     }      address owner = ens.owner(node);      if (         owner != msg.sender &amp;&amp;         !isApprovedForAll(owner, msg.sender) &amp;&amp;         !ens.isApprovedForAll(owner, msg.sender)     ) {         revert Unauthorised(node, msg.sender);     }      if (resolver != address(0)) {         ens.setResolver(node, resolver);     }      ens.setOwner(node, address(this));      _wrap(node, name, wrappedOwner, 0, 0); }  /**  * @notice Unwraps a .eth domain. e.g. vitalik.eth  * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper  * @param labelhash labelhash of the .eth domain  * @param newRegistrant sets the owner in the .eth registrar to this address  * @param newController sets the owner in the registry to this address  */  function unwrapETH2LD(     bytes32 labelhash,     address newRegistrant,     address newController ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {     _unwrap(_makeNode(ETH_NODE, labelhash), newController);     registrar.transferFrom(         address(this),         newRegistrant,         uint256(labelhash)     ); }  /**  * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper  * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')  * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')  * @param newController sets the owner in the registry to this address  */  function unwrap(     bytes32 parentNode,     bytes32 labelhash,     address newController ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {     if (parentNode == ETH_NODE) {         revert IncompatibleParent();     }     _unwrap(_makeNode(parentNode, labelhash), newController); }  /**  * @notice Sets fuses of a name  * @param node namehash of the name  * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)  */  function setFuses(bytes32 node, uint32 fuses)     public     onlyTokenOwner(node)     operationAllowed(node, CANNOT_BURN_FUSES)     returns (uint32) {     if (fuses &amp; PARENT_CANNOT_CONTROL != 0) {         // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.         revert Unauthorised(node, msg.sender);     }      (address owner, uint32 oldFuses, uint64 expiry) = getData(         uint256(node)     );      fuses |= oldFuses;     _setFuses(node, owner, fuses, expiry);     return fuses; }  /**  * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract  *     and burning the token of this contract  * @dev Can be called by the owner of the name in this contract  * @param label Label as a string of the .eth name to upgrade  * @param wrappedOwner The owner of the wrapped name  */  function upgradeETH2LD(     string calldata label,     address wrappedOwner,     address resolver ) public {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(ETH_NODE, labelhash);     (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);      upgradeContract.wrapETH2LD(         label,         wrappedOwner,         fuses,         expiry,         resolver     ); }  /**  * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner or an authorised caller  * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names  * @param parentNode namehash of the parent name  * @param label Label as a string of the name to upgrade  * @param wrappedOwner Owner of the name in this contract  * @param resolver resolver contract for this name  */  function upgrade(     bytes32 parentNode,     string calldata label,     address wrappedOwner,     address resolver ) public {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(parentNode, labelhash);     (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);     upgradeContract.setSubnodeRecord(         parentNode,         label,         wrappedOwner,         resolver,         0,         fuses,         expiry     ); }  /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name  * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')  * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')  * @param fuses fuses to burn  * @param expiry when the fuses will expire  */  function setChildFuses(     bytes32 parentNode,     bytes32 labelhash,     uint32 fuses,     uint64 expiry ) public {     bytes32 node = _makeNode(parentNode, labelhash);     (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(         uint256(node)     );     uint64 maxExpiry;     if (parentNode == ETH_NODE) {         if (!isTokenOwnerOrApproved(node, msg.sender)) {             revert Unauthorised(node, msg.sender);         }         // max expiry is set to the expiry on the registrar         maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));     } else {         if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {             revert Unauthorised(node, msg.sender);         }          // max expiry is set to the expiry of the parent         (, , maxExpiry) = getData(uint256(parentNode));     }      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);      // if PARENT_CANNOT_CONTROL has been burned and fuses have changed     if (         oldFuses &amp; PARENT_CANNOT_CONTROL != 0 &amp;&amp;         oldFuses | fuses != oldFuses     ) {         revert OperationProhibited(node);     }     fuses |= oldFuses;     _setFuses(node, owner, fuses, expiry); }  /**  * @notice Sets the subdomain owner in the registry and then wraps the subdomain  * @param parentNode parent namehash of the subdomain  * @param label label of the subdomain as a string  * @param newOwner newOwner in the registry  * @param fuses initial fuses for the wrapped subdomain  * @param expiry when the fuses will expire  */  function setSubnodeOwner(     bytes32 parentNode,     string calldata label,     address newOwner,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))     returns (bytes32 node) {     bytes32 labelhash = keccak256(bytes(label));     node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);      if (ens.owner(node) != address(this)) {         ens.setSubnodeOwner(parentNode, labelhash, address(this));         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } }  /**  * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain  * @param parentNode parent namehash of the subdomain  * @param label label of the subdomain as a string  * @param newOwner newOwner in the registry  * @param resolver resolver contract in the registry  * @param ttl ttl in the regsitry  * @param fuses initial fuses for the wrapped subdomain  * @param expiry expiry date for the domain  */  function setSubnodeRecord(     bytes32 parentNode,     string memory label,     address newOwner,     address resolver,     uint64 ttl,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label))) {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);     if (ens.owner(node) != address(this)) {         ens.setSubnodeRecord(             parentNode,             labelhash,             address(this),             resolver,             ttl         );         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         ens.setSubnodeRecord(             parentNode,             labelhash,             address(this),             resolver,             ttl         );         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } }  /**  * @notice Sets records for the name in the ENS Registry  * @param node namehash of the name to set a record for  * @param owner newOwner in the registry  * @param resolver the resolver contract  * @param ttl ttl in the registry  */  function setRecord(     bytes32 node,     address owner,     address resolver,     uint64 ttl )     public     override     onlyTokenOwner(node)     operationAllowed(         node,         CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL     ) {     ens.setRecord(node, address(this), resolver, ttl);     (address oldOwner, , ) = getData(uint256(node));     _transfer(oldOwner, owner, uint256(node), 1, ""); }  /**  * @notice Sets resolver contract in the registry  * @param node namehash of the name  * @param resolver the resolver contract  */  function setResolver(bytes32 node, address resolver)     public     override     onlyTokenOwner(node)     operationAllowed(node, CANNOT_SET_RESOLVER) {     ens.setResolver(node, resolver); }  /**  * @notice Sets TTL in the registry  * @param node namehash of the name  * @param ttl TTL in the registry  */  function setTTL(bytes32 node, uint64 ttl)     public     override     onlyTokenOwner(node)     operationAllowed(node, CANNOT_SET_TTL) {     ens.setTTL(node, ttl); }  /**  * @dev Allows an operation only if none of the specified fuses are burned.  * @param node The namehash of the name to check fuses on.  * @param fuseMask A bitmask of fuses that must not be burned.  */  modifier operationAllowed(bytes32 node, uint32 fuseMask) {     (, uint32 fuses, ) = getData(uint256(node));     if (fuses &amp; fuseMask != 0) {         revert OperationProhibited(node);     }     _; }  /**  * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord  * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt  *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for  *      replacing a subdomain. If either conditions are true, then it is possible to call  *      setSubnodeOwner  * @param node namehash of the name to check  * @param labelhash labelhash of the name to check  */  modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {     bytes32 subnode = _makeNode(node, labelhash);     address owner = ens.owner(subnode);      if (owner == address(0)) {         (, uint32 fuses, ) = getData(uint256(node));         if (fuses &amp; CANNOT_CREATE_SUBDOMAIN != 0) {             revert OperationProhibited(node);         }     } else {         (, uint32 subnodeFuses, ) = getData(uint256(subnode));         if (subnodeFuses &amp; PARENT_CANNOT_CONTROL != 0) {             revert OperationProhibited(node);         }     }      _; }  /**  * @notice Checks all Fuses in the mask are burned for the node  * @param node namehash of the name  * @param fuseMask the fuses you want to check  * @return Boolean of whether or not all the selected fuses are burned  */  function allFusesBurned(bytes32 node, uint32 fuseMask)     public     view     override     returns (bool) {     (, uint32 fuses, ) = getData(uint256(node));     return fuses &amp; fuseMask == fuseMask; }  function onERC721Received(     address to,     address,     uint256 tokenId,     bytes calldata data ) public override returns (bytes4) {     //check if it's the eth registrar ERC721     if (msg.sender != address(registrar)) {         revert IncorrectTokenType();     }      (         string memory label,         address owner,         uint32 fuses,         uint64 expiry,         address resolver     ) = abi.decode(data, (string, address, uint32, uint64, address));      bytes32 labelhash = bytes32(tokenId);     bytes32 labelhashFromData = keccak256(bytes(label));      if (labelhashFromData != labelhash) {         revert LabelMismatch(labelhashFromData, labelhash);     }      // transfer the ens record back to the new owner (this contract)     registrar.reclaim(uint256(labelhash), address(this));      _wrapETH2LD(label, owner, fuses, expiry, resolver);      return IERC721Receiver(to).onERC721Received.selector; }  /***** Internal functions */  function _canTransfer(uint32 fuses) internal pure override returns (bool) {     return fuses &amp; CANNOT_TRANSFER == 0; }  function _makeNode(bytes32 node, bytes32 labelhash)     private     pure     returns (bytes32) {     return keccak256(abi.encodePacked(node, labelhash)); }  function _addLabel(string memory label, bytes memory name)     internal     pure     returns (bytes memory ret) {     if (bytes(label).length &lt; 1) {         revert LabelTooShort();     }     if (bytes(label).length &gt; 255) {         revert LabelTooLong(label);     }     return abi.encodePacked(uint8(bytes(label).length), label, name); }  function _mint(     bytes32 node,     address wrappedOwner,     uint32 fuses,     uint64 expiry ) internal override {     address oldWrappedOwner = ownerOf(uint256(node));     _canFusesBeBurned(node, fuses);     if (oldWrappedOwner != address(0)) {         // burn and unwrap old token of old owner         _burn(uint256(node));         emit NameUnwrapped(node, address(0));     }     super._mint(node, wrappedOwner, fuses, expiry); }  function _wrap(     bytes32 node,     bytes memory name,     address wrappedOwner,     uint32 fuses,     uint64 expiry ) internal {     names[node] = name;     _mint(node, wrappedOwner, fuses, expiry);     emit NameWrapped(node, name, wrappedOwner, fuses, expiry); }  function _addLabelAndWrap(     bytes32 parentNode,     bytes32 node,     string memory label,     address newOwner,     uint32 fuses,     uint64 expiry ) internal {     bytes memory name = _addLabel(label, names[parentNode]);     _wrap(node, name, newOwner, fuses, expiry); }  function _prepareUpgrade(bytes32 node)     private     returns (uint32 fuses, uint64 expiry) {     if (address(upgradeContract) == address(0)) {         revert CannotUpgrade();     }      if (!isTokenOwnerOrApproved(node, msg.sender)) {         revert Unauthorised(node, msg.sender);     }      (fuses, expiry) = getFuses(node);      // burn token and fuse data     _burn(uint256(node)); }  function _transferAndBurnFuses(     bytes32 node,     address newOwner,     uint32 fuses,     uint64 expiry ) internal {     (address owner, , ) = getData(uint256(node));     _transfer(owner, newOwner, uint256(node), 1, "");     _setFuses(node, newOwner, fuses, expiry); }  // wrapper function for stack limit function _getDataAndNormaliseExpiry(     bytes32 parentNode,     bytes32 node,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     (, , uint64 maxExpiry) = getData(uint256(parentNode));      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); }  function _getETH2LDDataAndNormaliseExpiry(     bytes32 node,     bytes32 labelhash,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); }  function _normaliseExpiry(     uint64 expiry,     uint64 oldExpiry,     uint64 maxExpiry ) internal pure returns (uint64) {     // Expiry cannot be more than maximum allowed     // .eth names will check registrar, non .eth check parent     if (expiry &gt; maxExpiry) {         expiry = maxExpiry;     }     // Expiry cannot be less than old expiry     if (expiry &lt; oldExpiry) {         expiry = oldExpiry;     }      return expiry; }  function _wrapETH2LD(     string memory label,     address wrappedOwner,     uint32 fuses,     uint64 expiry,     address resolver ) private returns (uint64) {     // Mint a new ERC1155 token with fuses     // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(ETH_NODE, labelhash);      (, , expiry) = _getETH2LDDataAndNormaliseExpiry(         node,         labelhash,         expiry     );      _addLabelAndWrap(         ETH_NODE,         node,         label,         wrappedOwner,         fuses | PARENT_CANNOT_CONTROL,         expiry     );     if (resolver != address(0)) {         ens.setResolver(node, resolver);     }      return expiry; }  function _unwrap(bytes32 node, address newOwner) private {     if (newOwner == address(0x0) || newOwner == address(this)) {         revert IncorrectTargetOwner(newOwner);     }      if (allFusesBurned(node, CANNOT_UNWRAP)) {         revert OperationProhibited(node);     }      // Burn token and fuse data     _burn(uint256(node));     ens.setOwner(node, newOwner);      emit NameUnwrapped(node, newOwner); }  function _setFuses(     bytes32 node,     address owner,     uint32 fuses,     uint64 expiry ) internal {     _setData(node, owner, fuses, expiry);     emit FusesSet(node, fuses, expiry); }  function _setData(     bytes32 node,     address owner,     uint32 fuses,     uint64 expiry ) internal {     _canFusesBeBurned(node, fuses);     super._setData(uint256(node), owner, fuses, expiry); }  function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {     if (         fuses &amp; ~PARENT_CANNOT_CONTROL != 0 &amp;&amp;         fuses &amp; (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=         (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)     ) {         revert OperationProhibited(node);     } }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 20:35:48 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | //SPDX-License-Identifier: MIT pragma solidity ^0.8.4; import "./ERC1155Fuse.sol"; import "./Controllable.sol"; import "./INameWrapper.sol"; import "./INameWrapperUpgrade.sol"; import "./IMetadataService.sol"; import "../registry/ENS.sol"; import "../ethregistrar/IBaseRegistrar.sol"; import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "./BytesUtil.sol"; error Unauthorised(bytes32 node, address addr); error NameNotFound(); error IncompatibleParent(); error IncompatibleName(bytes name); error IncorrectTokenType(); error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash); error LabelTooShort(); error LabelTooLong(string label); error IncorrectTargetOwner(address owner); error CannotUpgrade(); error InvalidExpiry(bytes32 node, uint64 expiry); contract NameWrapper is     Ownable,     ERC1155Fuse,     INameWrapper,     Controllable,     IERC721Receiver {     using BytesUtils for bytes;     ENS public immutable override ens;     IBaseRegistrar public immutable override registrar;     IMetadataService public override metadataService;     mapping(bytes32 =&gt; bytes) public override names; bytes32 private constant ETH_NODE =     0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae; bytes32 private constant ROOT_NODE =     0x0000000000000000000000000000000000000000000000000000000000000000;  //A contract address to a new upgraded contract if any INameWrapperUpgrade public upgradeContract; uint64 private constant MAX_EXPIRY = type(uint64).max;  constructor(     ENS _ens,     IBaseRegistrar _registrar,     IMetadataService _metadataService ) {     ens = _ens;     registrar = _registrar;     metadataService = _metadataService;      /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */      _setData(         uint256(ETH_NODE),         address(0),         uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),         MAX_EXPIRY     );     _setData(         uint256(ROOT_NODE),         address(0),         uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),         MAX_EXPIRY     );     names[ROOT_NODE] = "\x00";     names[ETH_NODE] = "\x03eth\x00"; }  function supportsInterface(bytes4 interfaceId)     public     view     virtual     override(ERC1155Fuse, IERC165)     returns (bool) {     return         interfaceId == type(INameWrapper).interfaceId ||         super.supportsInterface(interfaceId); }  /* ERC1155 */  function ownerOf(uint256 id)     public     view     override(ERC1155Fuse, INameWrapper)     returns (address owner) {     return super.ownerOf(id); }  /* Metadata service */  /**  * @notice Set the metadata service. Only the owner can do this  */  function setMetadataService(IMetadataService _newMetadataService)     public     onlyOwner {     metadataService = _newMetadataService; }  /**  * @notice Get the metadata uri  * @return String uri of the metadata service  */  function uri(uint256 tokenId) public view override returns (string memory) {     return metadataService.uri(tokenId); }  /**  * @notice Set the address of the upgradeContract of the contract. only admin can do this  * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time  * to make the contract not upgradable.  * @param _upgradeAddress address of an upgraded contract  */  function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)     public     onlyOwner {     if (address(upgradeContract) != address(0)) {         registrar.setApprovalForAll(address(upgradeContract), false);         ens.setApprovalForAll(address(upgradeContract), false);     }      upgradeContract = _upgradeAddress;      if (address(upgradeContract) != address(0)) {         registrar.setApprovalForAll(address(upgradeContract), true);         ens.setApprovalForAll(address(upgradeContract), true);     } }  /**  * @notice Checks if msg.sender is the owner or approved by the owner of a name  * @param node namehash of the name to check  */  modifier onlyTokenOwner(bytes32 node) {     if (!isTokenOwnerOrApproved(node, msg.sender)) {         revert Unauthorised(node, msg.sender);     }      _; }  /**  * @notice Checks if owner or approved by owner  * @param node namehash of the name to check  * @param addr which address to check permissions for  * @return whether or not is owner or approved  */  function isTokenOwnerOrApproved(bytes32 node, address addr)     public     view     override     returns (bool) {     address owner = ownerOf(uint256(node));     return owner == addr || isApprovedForAll(owner, addr); }  /**  * @notice Gets fuse permissions for a specific name  * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit  *      The interface has predefined fuses for all registry permissions, but additional  *      fuses can be added for other use cases  *      Also returns expiry, which is when the fuses are set to expire.  * @param node namehash of the name to check  * @return fuses A number that represents the permissions a name has. Returns 0 when expiry &lt; block.timestamp  * @return expiry Unix time of when the name expires and fuses are to expire  */ function getFuses(bytes32 node)     public     view     override     returns (uint32 fuses, uint64 expiry) {     (, fuses, expiry) = getData(uint256(node));     if (fuses == 0 &amp;&amp; expiry == 0) {         bytes memory name = names[node];         if (name.length == 0) {             revert NameNotFound();         }     } }  /**  * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract  * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar  * @param label label as a string of the .eth domain to wrap  * @param wrappedOwner Owner of the name in this contract  * @param fuses initial fuses to set  * @param expiry when the fuses will expire  * @param resolver resolver contract address  */  function wrapETH2LD(     string calldata label,     address wrappedOwner,     uint32 fuses,     uint64 expiry,     address resolver ) public override returns (uint64) {     uint256 tokenId = uint256(keccak256(bytes(label)));     address registrant = registrar.ownerOf(tokenId);     if (         registrant != msg.sender &amp;&amp;         !isApprovedForAll(registrant, msg.sender) &amp;&amp;         !registrar.isApprovedForAll(registrant, msg.sender)     ) {         revert Unauthorised(             _makeNode(ETH_NODE, bytes32(tokenId)),             msg.sender         );     }      // transfer the token from the user to this contract     registrar.transferFrom(registrant, address(this), tokenId);      // transfer the ens record back to the new owner (this contract)     registrar.reclaim(tokenId, address(this));      return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver); }  /**  * @dev Registers a new .eth second-level domain and wraps it.  *      Only callable by authorised controllers.  * @param label The label to register (Eg, 'foo' for 'foo.eth').  * @param wrappedOwner The owner of the wrapped name.  * @param duration The duration, in seconds, to register the name for.  * @param resolver The resolver address to set on the ENS registry (optional).  * @param fuses initial fuses to set  * @param expiry when the fuses will expire  * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.  */  function registerAndWrapETH2LD(     string calldata label,     address wrappedOwner,     uint256 duration,     address resolver,     uint32 fuses,     uint64 expiry ) external override onlyController returns (uint256 registrarExpiry) {     uint256 tokenId = uint256(keccak256(bytes(label)));     registrarExpiry = registrar.register(tokenId, address(this), duration);     _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver); }  /**  * @dev Renews a .eth second-level domain.  *      Only callable by authorised controllers.  * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').  * @param duration The number of seconds to renew the name for.  * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.  */ function renew(     uint256 tokenId,     uint256 duration,     uint64 expiry ) external override onlyController returns (uint256 expires) {     bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));      expires = registrar.renew(tokenId, duration);     (address owner, uint32 fuses, uint64 oldExpiry) = getData(         uint256(node)     );     expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));      _setData(node, owner, fuses, expiry); }  /**  * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner in the registry or an authorised caller in the registry  * @param name The name to wrap, in DNS format  * @param wrappedOwner Owner of the name in this contract  * @param resolver resolver contract address  */  function wrap(     bytes calldata name,     address wrappedOwner,     address resolver ) public override {     (bytes32 labelhash, uint256 offset) = name.readLabel(0);     bytes32 parentNode = name.namehash(offset);     bytes32 node = _makeNode(parentNode, labelhash);      if (parentNode == ETH_NODE) {         revert IncompatibleParent();     }      address owner = ens.owner(node);      if (         owner != msg.sender &amp;&amp;         !isApprovedForAll(owner, msg.sender) &amp;&amp;         !ens.isApprovedForAll(owner, msg.sender)     ) {         revert Unauthorised(node, msg.sender);     }      if (resolver != address(0)) {         ens.setResolver(node, resolver);     }      ens.setOwner(node, address(this));      _wrap(node, name, wrappedOwner, 0, 0); }  /**  * @notice Unwraps a .eth domain. e.g. vitalik.eth  * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper  * @param labelhash labelhash of the .eth domain  * @param newRegistrant sets the owner in the .eth registrar to this address  * @param newController sets the owner in the registry to this address  */  function unwrapETH2LD(     bytes32 labelhash,     address newRegistrant,     address newController ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {     _unwrap(_makeNode(ETH_NODE, labelhash), newController);     registrar.transferFrom(         address(this),         newRegistrant,         uint256(labelhash)     ); }  /**  * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper  * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')  * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')  * @param newController sets the owner in the registry to this address  */  function unwrap(     bytes32 parentNode,     bytes32 labelhash,     address newController ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {     if (parentNode == ETH_NODE) {         revert IncompatibleParent();     }     _unwrap(_makeNode(parentNode, labelhash), newController); }  /**  * @notice Sets fuses of a name  * @param node namehash of the name  * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)  */  function setFuses(bytes32 node, uint32 fuses)     public     onlyTokenOwner(node)     operationAllowed(node, CANNOT_BURN_FUSES)     returns (uint32) {     if (fuses &amp; PARENT_CANNOT_CONTROL != 0) {         // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.         revert Unauthorised(node, msg.sender);     }      (address owner, uint32 oldFuses, uint64 expiry) = getData(         uint256(node)     );      fuses |= oldFuses;     _setFuses(node, owner, fuses, expiry);     return fuses; }  /**  * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract  *     and burning the token of this contract  * @dev Can be called by the owner of the name in this contract  * @param label Label as a string of the .eth name to upgrade  * @param wrappedOwner The owner of the wrapped name  */  function upgradeETH2LD(     string calldata label,     address wrappedOwner,     address resolver ) public {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(ETH_NODE, labelhash);     (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);      upgradeContract.wrapETH2LD(         label,         wrappedOwner,         fuses,         expiry,         resolver     ); }  /**  * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner or an authorised caller  * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names  * @param parentNode namehash of the parent name  * @param label Label as a string of the name to upgrade  * @param wrappedOwner Owner of the name in this contract  * @param resolver resolver contract for this name  */  function upgrade(     bytes32 parentNode,     string calldata label,     address wrappedOwner,     address resolver ) public {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(parentNode, labelhash);     (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);     upgradeContract.setSubnodeRecord(         parentNode,         label,         wrappedOwner,         resolver,         0,         fuses,         expiry     ); }  /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name  * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')  * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')  * @param fuses fuses to burn  * @param expiry when the fuses will expire  */  function setChildFuses(     bytes32 parentNode,     bytes32 labelhash,     uint32 fuses,     uint64 expiry ) public {     bytes32 node = _makeNode(parentNode, labelhash);     (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(         uint256(node)     );     uint64 maxExpiry;     if (parentNode == ETH_NODE) {         if (!isTokenOwnerOrApproved(node, msg.sender)) {             revert Unauthorised(node, msg.sender);         }         // max expiry is set to the expiry on the registrar         maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));     } else {         if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {             revert Unauthorised(node, msg.sender);         }          // max expiry is set to the expiry of the parent         (, , maxExpiry) = getData(uint256(parentNode));     }      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);      // if PARENT_CANNOT_CONTROL has been burned and fuses have changed     if (         oldFuses &amp; PARENT_CANNOT_CONTROL != 0 &amp;&amp;         oldFuses | fuses != oldFuses     ) {         revert OperationProhibited(node);     }     fuses |= oldFuses;     _setFuses(node, owner, fuses, expiry); }  /**  * @notice Sets the subdomain owner in the registry and then wraps the subdomain  * @param parentNode parent namehash of the subdomain  * @param label label of the subdomain as a string  * @param newOwner newOwner in the registry  * @param fuses initial fuses for the wrapped subdomain  * @param expiry when the fuses will expire  */  function setSubnodeOwner(     bytes32 parentNode,     string calldata label,     address newOwner,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))     returns (bytes32 node) {     bytes32 labelhash = keccak256(bytes(label));     node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);      if (ens.owner(node) != address(this)) {         ens.setSubnodeOwner(parentNode, labelhash, address(this));         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } }  /**  * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain  * @param parentNode parent namehash of the subdomain  * @param label label of the subdomain as a string  * @param newOwner newOwner in the registry  * @param resolver resolver contract in the registry  * @param ttl ttl in the regsitry  * @param fuses initial fuses for the wrapped subdomain  * @param expiry expiry date for the domain  */  function setSubnodeRecord(     bytes32 parentNode,     string memory label,     address newOwner,     address resolver,     uint64 ttl,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label))) {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);     if (ens.owner(node) != address(this)) {         ens.setSubnodeRecord(             parentNode,             labelhash,             address(this),             resolver,             ttl         );         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         ens.setSubnodeRecord(             parentNode,             labelhash,             address(this),             resolver,             ttl         );         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } }  /**  * @notice Sets records for the name in the ENS Registry  * @param node namehash of the name to set a record for  * @param owner newOwner in the registry  * @param resolver the resolver contract  * @param ttl ttl in the registry  */  function setRecord(     bytes32 node,     address owner,     address resolver,     uint64 ttl )     public     override     onlyTokenOwner(node)     operationAllowed(         node,         CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL     ) {     ens.setRecord(node, address(this), resolver, ttl);     (address oldOwner, , ) = getData(uint256(node));     _transfer(oldOwner, owner, uint256(node), 1, ""); }  /**  * @notice Sets resolver contract in the registry  * @param node namehash of the name  * @param resolver the resolver contract  */  function setResolver(bytes32 node, address resolver)     public     override     onlyTokenOwner(node)     operationAllowed(node, CANNOT_SET_RESOLVER) {     ens.setResolver(node, resolver); }  /**  * @notice Sets TTL in the registry  * @param node namehash of the name  * @param ttl TTL in the registry  */  function setTTL(bytes32 node, uint64 ttl)     public     override     onlyTokenOwner(node)     operationAllowed(node, CANNOT_SET_TTL) {     ens.setTTL(node, ttl); }  /**  * @dev Allows an operation only if none of the specified fuses are burned.  * @param node The namehash of the name to check fuses on.  * @param fuseMask A bitmask of fuses that must not be burned.  */  modifier operationAllowed(bytes32 node, uint32 fuseMask) {     (, uint32 fuses, ) = getData(uint256(node));     if (fuses &amp; fuseMask != 0) {         revert OperationProhibited(node);     }     _; }  /**  * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord  * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt  *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for  *      replacing a subdomain. If either conditions are true, then it is possible to call  *      setSubnodeOwner  * @param node namehash of the name to check  * @param labelhash labelhash of the name to check  */  modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {     bytes32 subnode = _makeNode(node, labelhash);     address owner = ens.owner(subnode);      if (owner == address(0)) {         (, uint32 fuses, ) = getData(uint256(node));         if (fuses &amp; CANNOT_CREATE_SUBDOMAIN != 0) {             revert OperationProhibited(node);         }     } else {         (, uint32 subnodeFuses, ) = getData(uint256(subnode));         if (subnodeFuses &amp; PARENT_CANNOT_CONTROL != 0) {             revert OperationProhibited(node);         }     }      _; }  /**  * @notice Checks all Fuses in the mask are burned for the node  * @param node namehash of the name  * @param fuseMask the fuses you want to check  * @return Boolean of whether or not all the selected fuses are burned  */  function allFusesBurned(bytes32 node, uint32 fuseMask)     public     view     override     returns (bool) {     (, uint32 fuses, ) = getData(uint256(node));     return fuses &amp; fuseMask == fuseMask; }  function onERC721Received(     address to,     address,     uint256 tokenId,     bytes calldata data ) public override returns (bytes4) {     //check if it's the eth registrar ERC721     if (msg.sender != address(registrar)) {         revert IncorrectTokenType();     }      (         string memory label,         address owner,         uint32 fuses,         uint64 expiry,         address resolver     ) = abi.decode(data, (string, address, uint32, uint64, address));      bytes32 labelhash = bytes32(tokenId);     bytes32 labelhashFromData = keccak256(bytes(label));      if (labelhashFromData != labelhash) {         revert LabelMismatch(labelhashFromData, labelhash);     }      // transfer the ens record back to the new owner (this contract)     registrar.reclaim(uint256(labelhash), address(this));      _wrapETH2LD(label, owner, fuses, expiry, resolver);      return IERC721Receiver(to).onERC721Received.selector; }  /***** Internal functions */  function _canTransfer(uint32 fuses) internal pure override returns (bool) {     return fuses &amp; CANNOT_TRANSFER == 0; }  function _makeNode(bytes32 node, bytes32 labelhash)     private     pure     returns (bytes32) {     return keccak256(abi.encodePacked(node, labelhash)); }  function _addLabel(string memory label, bytes memory name)     internal     pure     returns (bytes memory ret) {     if (bytes(label).length &lt; 1) {         revert LabelTooShort();     }     if (bytes(label).length &gt; 255) {         revert LabelTooLong(label);     }     return abi.encodePacked(uint8(bytes(label).length), label, name); }  function _mint(     bytes32 node,     address wrappedOwner,     uint32 fuses,     uint64 expiry ) internal override {     address oldWrappedOwner = ownerOf(uint256(node));     _canFusesBeBurned(node, fuses);     if (oldWrappedOwner != address(0)) {         // burn and unwrap old token of old owner         _burn(uint256(node));         emit NameUnwrapped(node, address(0));     }     super._mint(node, wrappedOwner, fuses, expiry); }  function _wrap(     bytes32 node,     bytes memory name,     address wrappedOwner,     uint32 fuses,     uint64 expiry ) internal {     names[node] = name;     _mint(node, wrappedOwner, fuses, expiry);     emit NameWrapped(node, name, wrappedOwner, fuses, expiry); }  function _addLabelAndWrap(     bytes32 parentNode,     bytes32 node,     string memory label,     address newOwner,     uint32 fuses,     uint64 expiry ) internal {     bytes memory name = _addLabel(label, names[parentNode]);     _wrap(node, name, newOwner, fuses, expiry); }  function _prepareUpgrade(bytes32 node)     private     returns (uint32 fuses, uint64 expiry) {     if (address(upgradeContract) == address(0)) {         revert CannotUpgrade();     }      if (!isTokenOwnerOrApproved(node, msg.sender)) {         revert Unauthorised(node, msg.sender);     }      (fuses, expiry) = getFuses(node);      // burn token and fuse data     _burn(uint256(node)); }  function _transferAndBurnFuses(     bytes32 node,     address newOwner,     uint32 fuses,     uint64 expiry ) internal {     (address owner, , ) = getData(uint256(node));     _transfer(owner, newOwner, uint256(node), 1, "");     _setFuses(node, newOwner, fuses, expiry); }  // wrapper function for stack limit function _getDataAndNormaliseExpiry(     bytes32 parentNode,     bytes32 node,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     (, , uint64 maxExpiry) = getData(uint256(parentNode));      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); }  function _getETH2LDDataAndNormaliseExpiry(     bytes32 node,     bytes32 labelhash,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); }  function _normaliseExpiry(     uint64 expiry,     uint64 oldExpiry,     uint64 maxExpiry ) internal pure returns (uint64) {     // Expiry cannot be more than maximum allowed     // .eth names will check registrar, non .eth check parent     if (expiry &gt; maxExpiry) {         expiry = maxExpiry;     }     // Expiry cannot be less than old expiry     if (expiry &lt; oldExpiry) {         expiry = oldExpiry;     }      return expiry; }  function _wrapETH2LD(     string memory label,     address wrappedOwner,     uint32 fuses,     uint64 expiry,     address resolver ) private returns (uint64) {     // Mint a new ERC1155 token with fuses     // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(ETH_NODE, labelhash);      (, , expiry) = _getETH2LDDataAndNormaliseExpiry(         node,         labelhash,         expiry     );      _addLabelAndWrap(         ETH_NODE,         node,         label,         wrappedOwner,         fuses | PARENT_CANNOT_CONTROL,         expiry     );     if (resolver != address(0)) {         ens.setResolver(node, resolver);     }      return expiry; }  function _unwrap(bytes32 node, address newOwner) private {     if (newOwner == address(0x0) || newOwner == address(this)) {         revert IncorrectTargetOwner(newOwner);     }      if (allFusesBurned(node, CANNOT_UNWRAP)) {         revert OperationProhibited(node);     }      // Burn token and fuse data     _burn(uint256(node));     ens.setOwner(node, newOwner);      emit NameUnwrapped(node, newOwner); }  function _setFuses(     bytes32 node,     address owner,     uint32 fuses,     uint64 expiry ) internal {     _setData(node, owner, fuses, expiry);     emit FusesSet(node, fuses, expiry); }  function _setData(     bytes32 node,     address owner,     uint32 fuses,     uint64 expiry ) internal {     _canFusesBeBurned(node, fuses);     super._setData(uint256(node), owner, fuses, expiry); }  function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {     if (         fuses &amp; ~PARENT_CANNOT_CONTROL != 0 &amp;&amp;         fuses &amp; (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=         (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)     ) {         revert OperationProhibited(node);     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 20:35:48 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: //SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "./ERC1155Fuse.sol";
import "./Controllable.sol";
import "./INameWrapper.sol";
import "./INameWrapperUpgrade.sol";
import "./IMetadataService.sol";
import "../registry/ENS.sol";
import "../ethregistrar/IBaseRegistrar.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./BytesUtil.sol";

error Unauthorised(bytes32 node, address addr);
error NameNotFound();
error IncompatibleParent();
error IncompatibleName(bytes name);
error IncorrectTokenType();
error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);
error LabelTooShort();
error LabelTooLong(string label);
error IncorrectTargetOwner(address owner);
error CannotUpgrade();
error InvalidExpiry(bytes32 node, uint64 expiry);

contract NameWrapper is
    Ownable,
    ERC1155Fuse,
    INameWrapper,
    Controllable,
    IERC721Receiver
{
    using BytesUtils for bytes;
    ENS public immutable override ens;
    IBaseRegistrar public immutable override registrar;
    IMetadataService public override metadataService;
    mapping(bytes32 => bytes) public override names;

    bytes32 private constant ETH_NODE =
        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
    bytes32 private constant ROOT_NODE =
        0x0000000000000000000000000000000000000000000000000000000000000000;

    //A contract address to a new upgraded contract if any
    INameWrapperUpgrade public upgradeContract;
    uint64 private constant MAX_EXPIRY = type(uint64).max;

    constructor(
        ENS _ens,
        IBaseRegistrar _registrar,
        IMetadataService _metadataService
    ) {
        ens = _ens;
        registrar = _registrar;
        metadataService = _metadataService;

        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */

        _setData(
            uint256(ETH_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        _setData(
            uint256(ROOT_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        names[ROOT_NODE] = "\x00";
        names[ETH_NODE] = "\x03eth\x00";
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Fuse, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(INameWrapper).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /* ERC1155 */

    function ownerOf(uint256 id)
        public
        view
        override(ERC1155Fuse, INameWrapper)
        returns (address owner)
    {
        return super.ownerOf(id);
    }

    /* Metadata service */

    /**
     * @notice Set the metadata service. Only the owner can do this
     */

    function setMetadataService(IMetadataService _newMetadataService)
        public
        onlyOwner
    {
        metadataService = _newMetadataService;
    }

    /**
     * @notice Get the metadata uri
     * @return String uri of the metadata service
     */

    function uri(uint256 tokenId) public view override returns (string memory) {
        return metadataService.uri(tokenId);
    }

    /**
     * @notice Set the address of the upgradeContract of the contract. only admin can do this
     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time
     * to make the contract not upgradable.
     * @param _upgradeAddress address of an upgraded contract
     */

    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)
        public
        onlyOwner
    {
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), false);
            ens.setApprovalForAll(address(upgradeContract), false);
        }

        upgradeContract = _upgradeAddress;

        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), true);
            ens.setApprovalForAll(address(upgradeContract), true);
        }
    }

    /**
     * @notice Checks if msg.sender is the owner or approved by the owner of a name
     * @param node namehash of the name to check
     */

    modifier onlyTokenOwner(bytes32 node) {
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        _;
    }

    /**
     * @notice Checks if owner or approved by owner
     * @param node namehash of the name to check
     * @param addr which address to check permissions for
     * @return whether or not is owner or approved
     */

    function isTokenOwnerOrApproved(bytes32 node, address addr)
        public
        view
        override
        returns (bool)
    {
        address owner = ownerOf(uint256(node));
        return owner == addr || isApprovedForAll(owner, addr);
    }

    /**
     * @notice Gets fuse permissions for a specific name
     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit
     *      The interface has predefined fuses for all registry permissions, but additional
     *      fuses can be added for other use cases
     *      Also returns expiry, which is when the fuses are set to expire.
     * @param node namehash of the name to check
     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp
     * @return expiry Unix time of when the name expires and fuses are to expire
     */
    function getFuses(bytes32 node)
        public
        view
        override
        returns (uint32 fuses, uint64 expiry)
    {
        (, fuses, expiry) = getData(uint256(node));
        if (fuses == 0 && expiry == 0) {
            bytes memory name = names[node];
            if (name.length == 0) {
                revert NameNotFound();
            }
        }
    }

    /**
     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract
     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar
     * @param label label as a string of the .eth domain to wrap
     * @param wrappedOwner Owner of the name in this contract
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @param resolver resolver contract address
     */

    function wrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) public override returns (uint64) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        address registrant = registrar.ownerOf(tokenId);
        if (
            registrant != msg.sender &&
            !isApprovedForAll(registrant, msg.sender) &&
            !registrar.isApprovedForAll(registrant, msg.sender)
        ) {
            revert Unauthorised(
                _makeNode(ETH_NODE, bytes32(tokenId)),
                msg.sender
            );
        }

        // transfer the token from the user to this contract
        registrar.transferFrom(registrant, address(this), tokenId);

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(tokenId, address(this));

        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Registers a new .eth second-level domain and wraps it.
     *      Only callable by authorised controllers.
     * @param label The label to register (Eg, 'foo' for 'foo.eth').
     * @param wrappedOwner The owner of the wrapped name.
     * @param duration The duration, in seconds, to register the name for.
     * @param resolver The resolver address to set on the ENS registry (optional).
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.
     */

    function registerAndWrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint256 duration,
        address resolver,
        uint32 fuses,
        uint64 expiry
    ) external override onlyController returns (uint256 registrarExpiry) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        registrarExpiry = registrar.register(tokenId, address(this), duration);
        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Renews a .eth second-level domain.
     *      Only callable by authorised controllers.
     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').
     * @param duration The number of seconds to renew the name for.
     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.
     */
    function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));

        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));

        _setData(node, owner, fuses, expiry);
    }

    /**
     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the registry or an authorised caller in the registry
     * @param name The name to wrap, in DNS format
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract address
     */

    function wrap(
        bytes calldata name,
        address wrappedOwner,
        address resolver
    ) public override {
        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
        bytes32 parentNode = name.namehash(offset);
        bytes32 node = _makeNode(parentNode, labelhash);

        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }

        address owner = ens.owner(node);

        if (
            owner != msg.sender &&
            !isApprovedForAll(owner, msg.sender) &&
            !ens.isApprovedForAll(owner, msg.sender)
        ) {
            revert Unauthorised(node, msg.sender);
        }

        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        ens.setOwner(node, address(this));

        _wrap(node, name, wrappedOwner, 0, 0);
    }

    /**
     * @notice Unwraps a .eth domain. e.g. vitalik.eth
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param labelhash labelhash of the .eth domain
     * @param newRegistrant sets the owner in the .eth registrar to this address
     * @param newController sets the owner in the registry to this address
     */

    function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }

    /**
     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param newController sets the owner in the registry to this address
     */

    function unwrap(
        bytes32 parentNode,
        bytes32 labelhash,
        address newController
    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        _unwrap(_makeNode(parentNode, labelhash), newController);
    }

    /**
     * @notice Sets fuses of a name
     * @param node namehash of the name
     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)
     */

    function setFuses(bytes32 node, uint32 fuses)
        public
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_BURN_FUSES)
        returns (uint32)
    {
        if (fuses & PARENT_CANNOT_CONTROL != 0) {
            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.
            revert Unauthorised(node, msg.sender);
        }

        (address owner, uint32 oldFuses, uint64 expiry) = getData(
            uint256(node)
        );

        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
        return fuses;
    }

    /**
     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract
     *     and burning the token of this contract
     * @dev Can be called by the owner of the name in this contract
     * @param label Label as a string of the .eth name to upgrade
     * @param wrappedOwner The owner of the wrapped name
     */

    function upgradeETH2LD(
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);

        upgradeContract.wrapETH2LD(
            label,
            wrappedOwner,
            fuses,
            expiry,
            resolver
        );
    }

    /**
     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner or an authorised caller
     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names
     * @param parentNode namehash of the parent name
     * @param label Label as a string of the name to upgrade
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract for this name
     */

    function upgrade(
        bytes32 parentNode,
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.setSubnodeRecord(
            parentNode,
            label,
            wrappedOwner,
            resolver,
            0,
            fuses,
            expiry
        );
    }

    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param fuses fuses to burn
     * @param expiry when the fuses will expire
     */

    function setChildFuses(
        bytes32 parentNode,
        bytes32 labelhash,
        uint32 fuses,
        uint64 expiry
    ) public {
        bytes32 node = _makeNode(parentNode, labelhash);
        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        uint64 maxExpiry;
        if (parentNode == ETH_NODE) {
            if (!isTokenOwnerOrApproved(node, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            // max expiry is set to the expiry on the registrar
            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        } else {
            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }

            // max expiry is set to the expiry of the parent
            (, , maxExpiry) = getData(uint256(parentNode));
        }

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);

        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed
        if (
            oldFuses & PARENT_CANNOT_CONTROL != 0 &&
            oldFuses | fuses != oldFuses
        ) {
            revert OperationProhibited(node);
        }
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
    }

    /**
     * @notice Sets the subdomain owner in the registry and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry when the fuses will expire
     */

    function setSubnodeOwner(
        bytes32 parentNode,
        string calldata label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
        returns (bytes32 node)
    {
        bytes32 labelhash = keccak256(bytes(label));
        node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);

        if (ens.owner(node) != address(this)) {
            ens.setSubnodeOwner(parentNode, labelhash, address(this));
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param resolver resolver contract in the registry
     * @param ttl ttl in the regsitry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry expiry date for the domain
     */

    function setSubnodeRecord(
        bytes32 parentNode,
        string memory label,
        address newOwner,
        address resolver,
        uint64 ttl,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
    {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets records for the name in the ENS Registry
     * @param node namehash of the name to set a record for
     * @param owner newOwner in the registry
     * @param resolver the resolver contract
     * @param ttl ttl in the registry
     */

    function setRecord(
        bytes32 node,
        address owner,
        address resolver,
        uint64 ttl
    )
        public
        override
        onlyTokenOwner(node)
        operationAllowed(
            node,
            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL
        )
    {
        ens.setRecord(node, address(this), resolver, ttl);
        (address oldOwner, , ) = getData(uint256(node));
        _transfer(oldOwner, owner, uint256(node), 1, "");
    }

    /**
     * @notice Sets resolver contract in the registry
     * @param node namehash of the name
     * @param resolver the resolver contract
     */

    function setResolver(bytes32 node, address resolver)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_RESOLVER)
    {
        ens.setResolver(node, resolver);
    }

    /**
     * @notice Sets TTL in the registry
     * @param node namehash of the name
     * @param ttl TTL in the registry
     */

    function setTTL(bytes32 node, uint64 ttl)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_TTL)
    {
        ens.setTTL(node, ttl);
    }

    /**
     * @dev Allows an operation only if none of the specified fuses are burned.
     * @param node The namehash of the name to check fuses on.
     * @param fuseMask A bitmask of fuses that must not be burned.
     */

    modifier operationAllowed(bytes32 node, uint32 fuseMask) {
        (, uint32 fuses, ) = getData(uint256(node));
        if (fuses & fuseMask != 0) {
            revert OperationProhibited(node);
        }
        _;
    }

    /**
     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord
     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt
     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for
     *      replacing a subdomain. If either conditions are true, then it is possible to call
     *      setSubnodeOwner
     * @param node namehash of the name to check
     * @param labelhash labelhash of the name to check
     */

    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {
        bytes32 subnode = _makeNode(node, labelhash);
        address owner = ens.owner(subnode);

        if (owner == address(0)) {
            (, uint32 fuses, ) = getData(uint256(node));
            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {
                revert OperationProhibited(node);
            }
        } else {
            (, uint32 subnodeFuses, ) = getData(uint256(subnode));
            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {
                revert OperationProhibited(node);
            }
        }

        _;
    }

    /**
     * @notice Checks all Fuses in the mask are burned for the node
     * @param node namehash of the name
     * @param fuseMask the fuses you want to check
     * @return Boolean of whether or not all the selected fuses are burned
     */

    function allFusesBurned(bytes32 node, uint32 fuseMask)
        public
        view
        override
        returns (bool)
    {
        (, uint32 fuses, ) = getData(uint256(node));
        return fuses & fuseMask == fuseMask;
    }

    function onERC721Received(
        address to,
        address,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        //check if it's the eth registrar ERC721
        if (msg.sender != address(registrar)) {
            revert IncorrectTokenType();
        }

        (
            string memory label,
            address owner,
            uint32 fuses,
            uint64 expiry,
            address resolver
        ) = abi.decode(data, (string, address, uint32, uint64, address));

        bytes32 labelhash = bytes32(tokenId);
        bytes32 labelhashFromData = keccak256(bytes(label));

        if (labelhashFromData != labelhash) {
            revert LabelMismatch(labelhashFromData, labelhash);
        }

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(uint256(labelhash), address(this));

        _wrapETH2LD(label, owner, fuses, expiry, resolver);

        return IERC721Receiver(to).onERC721Received.selector;
    }

    /***** Internal functions */

    function _canTransfer(uint32 fuses) internal pure override returns (bool) {
        return fuses & CANNOT_TRANSFER == 0;
    }

    function _makeNode(bytes32 node, bytes32 labelhash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, labelhash));
    }

    function _addLabel(string memory label, bytes memory name)
        internal
        pure
        returns (bytes memory ret)
    {
        if (bytes(label).length < 1) {
            revert LabelTooShort();
        }
        if (bytes(label).length > 255) {
            revert LabelTooLong(label);
        }
        return abi.encodePacked(uint8(bytes(label).length), label, name);
    }

    function _mint(
        bytes32 node,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal override {
        address oldWrappedOwner = ownerOf(uint256(node));
        _canFusesBeBurned(node, fuses);
        if (oldWrappedOwner != address(0)) {
            // burn and unwrap old token of old owner
            _burn(uint256(node));
            emit NameUnwrapped(node, address(0));
        }
        super._mint(node, wrappedOwner, fuses, expiry);
    }

    function _wrap(
        bytes32 node,
        bytes memory name,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        names[node] = name;
        _mint(node, wrappedOwner, fuses, expiry);
        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);
    }

    function _addLabelAndWrap(
        bytes32 parentNode,
        bytes32 node,
        string memory label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        bytes memory name = _addLabel(label, names[parentNode]);
        _wrap(node, name, newOwner, fuses, expiry);
    }

    function _prepareUpgrade(bytes32 node)
        private
        returns (uint32 fuses, uint64 expiry)
    {
        if (address(upgradeContract) == address(0)) {
            revert CannotUpgrade();
        }

        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        (fuses, expiry) = getFuses(node);

        // burn token and fuse data
        _burn(uint256(node));
    }

    function _transferAndBurnFuses(
        bytes32 node,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        (address owner, , ) = getData(uint256(node));
        _transfer(owner, newOwner, uint256(node), 1, "");
        _setFuses(node, newOwner, fuses, expiry);
    }

    // wrapper function for stack limit
    function _getDataAndNormaliseExpiry(
        bytes32 parentNode,
        bytes32 node,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        (, , uint64 maxExpiry) = getData(uint256(parentNode));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _getETH2LDDataAndNormaliseExpiry(
        bytes32 node,
        bytes32 labelhash,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _normaliseExpiry(
        uint64 expiry,
        uint64 oldExpiry,
        uint64 maxExpiry
    ) internal pure returns (uint64) {
        // Expiry cannot be more than maximum allowed
        // .eth names will check registrar, non .eth check parent
        if (expiry > maxExpiry) {
            expiry = maxExpiry;
        }
        // Expiry cannot be less than old expiry
        if (expiry < oldExpiry) {
            expiry = oldExpiry;
        }

        return expiry;
    }

    function _wrapETH2LD(
        string memory label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) private returns (uint64) {
        // Mint a new ERC1155 token with fuses
        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);

        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(
            node,
            labelhash,
            expiry
        );

        _addLabelAndWrap(
            ETH_NODE,
            node,
            label,
            wrappedOwner,
            fuses | PARENT_CANNOT_CONTROL,
            expiry
        );
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        return expiry;
    }

    function _unwrap(bytes32 node, address newOwner) private {
        if (newOwner == address(0x0) || newOwner == address(this)) {
            revert IncorrectTargetOwner(newOwner);
        }

        if (allFusesBurned(node, CANNOT_UNWRAP)) {
            revert OperationProhibited(node);
        }

        // Burn token and fuse data
        _burn(uint256(node));
        ens.setOwner(node, newOwner);

        emit NameUnwrapped(node, newOwner);
    }

    function _setFuses(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _setData(node, owner, fuses, expiry);
        emit FusesSet(node, fuses, expiry);
    }

    function _setData(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _canFusesBeBurned(node, fuses);
        super._setData(uint256(node), owner, fuses, expiry);
    }

    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
        if (
            fuses & ~PARENT_CANNOT_CONTROL != 0 &&
            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
        ) {
            revert OperationProhibited(node);
        }
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-01-09 20:35:58 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 20:35:58 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 7200
completion_tokens: 824
total_tokens: 8024
cost: $-1.000000


[2024-01-09 20:35:58 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: //SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "./ERC1155Fuse.sol";
import "./Controllable.sol";
import "./INameWrapper.sol";
import "./INameWrapperUpgrade.sol";
import "./IMetadataService.sol";
import "../registry/ENS.sol";
import "../ethregistrar/IBaseRegistrar.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./BytesUtil.sol";

error Unauthorised(bytes32 node, address addr);
error NameNotFound();
error IncompatibleParent();
error IncompatibleName(bytes name);
error IncorrectTokenType();
error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);
error LabelTooShort();
error LabelTooLong(string label);
error IncorrectTargetOwner(address owner);
error CannotUpgrade();
error InvalidExpiry(bytes32 node, uint64 expiry);

contract NameWrapper is
    Ownable,
    ERC1155Fuse,
    INameWrapper,
    Controllable,
    IERC721Receiver
{
    using BytesUtils for bytes;
    ENS public immutable override ens;
    IBaseRegistrar public immutable override registrar;
    IMetadataService public override metadataService;
    mapping(bytes32 => bytes) public override names;

    bytes32 private constant ETH_NODE =
        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
    bytes32 private constant ROOT_NODE =
        0x0000000000000000000000000000000000000000000000000000000000000000;

    //A contract address to a new upgraded contract if any
    INameWrapperUpgrade public upgradeContract;
    uint64 private constant MAX_EXPIRY = type(uint64).max;

    constructor(
        ENS _ens,
        IBaseRegistrar _registrar,
        IMetadataService _metadataService
    ) {
        ens = _ens;
        registrar = _registrar;
        metadataService = _metadataService;

        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */

        _setData(
            uint256(ETH_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        _setData(
            uint256(ROOT_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        names[ROOT_NODE] = "\x00";
        names[ETH_NODE] = "\x03eth\x00";
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Fuse, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(INameWrapper).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /* ERC1155 */

    function ownerOf(uint256 id)
        public
        view
        override(ERC1155Fuse, INameWrapper)
        returns (address owner)
    {
        return super.ownerOf(id);
    }

    /* Metadata service */

    /**
     * @notice Set the metadata service. Only the owner can do this
     */

    function setMetadataService(IMetadataService _newMetadataService)
        public
        onlyOwner
    {
        metadataService = _newMetadataService;
    }

    /**
     * @notice Get the metadata uri
     * @return String uri of the metadata service
     */

    function uri(uint256 tokenId) public view override returns (string memory) {
        return metadataService.uri(tokenId);
    }

    /**
     * @notice Set the address of the upgradeContract of the contract. only admin can do this
     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time
     * to make the contract not upgradable.
     * @param _upgradeAddress address of an upgraded contract
     */

    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)
        public
        onlyOwner
    {
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), false);
            ens.setApprovalForAll(address(upgradeContract), false);
        }

        upgradeContract = _upgradeAddress;

        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), true);
            ens.setApprovalForAll(address(upgradeContract), true);
        }
    }

    /**
     * @notice Checks if msg.sender is the owner or approved by the owner of a name
     * @param node namehash of the name to check
     */

    modifier onlyTokenOwner(bytes32 node) {
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        _;
    }

    /**
     * @notice Checks if owner or approved by owner
     * @param node namehash of the name to check
     * @param addr which address to check permissions for
     * @return whether or not is owner or approved
     */

    function isTokenOwnerOrApproved(bytes32 node, address addr)
        public
        view
        override
        returns (bool)
    {
        address owner = ownerOf(uint256(node));
        return owner == addr || isApprovedForAll(owner, addr);
    }

    /**
     * @notice Gets fuse permissions for a specific name
     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit
     *      The interface has predefined fuses for all registry permissions, but additional
     *      fuses can be added for other use cases
     *      Also returns expiry, which is when the fuses are set to expire.
     * @param node namehash of the name to check
     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp
     * @return expiry Unix time of when the name expires and fuses are to expire
     */
    function getFuses(bytes32 node)
        public
        view
        override
        returns (uint32 fuses, uint64 expiry)
    {
        (, fuses, expiry) = getData(uint256(node));
        if (fuses == 0 && expiry == 0) {
            bytes memory name = names[node];
            if (name.length == 0) {
                revert NameNotFound();
            }
        }
    }

    /**
     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract
     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar
     * @param label label as a string of the .eth domain to wrap
     * @param wrappedOwner Owner of the name in this contract
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @param resolver resolver contract address
     */

    function wrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) public override returns (uint64) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        address registrant = registrar.ownerOf(tokenId);
        if (
            registrant != msg.sender &&
            !isApprovedForAll(registrant, msg.sender) &&
            !registrar.isApprovedForAll(registrant, msg.sender)
        ) {
            revert Unauthorised(
                _makeNode(ETH_NODE, bytes32(tokenId)),
                msg.sender
            );
        }

        // transfer the token from the user to this contract
        registrar.transferFrom(registrant, address(this), tokenId);

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(tokenId, address(this));

        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Registers a new .eth second-level domain and wraps it.
     *      Only callable by authorised controllers.
     * @param label The label to register (Eg, 'foo' for 'foo.eth').
     * @param wrappedOwner The owner of the wrapped name.
     * @param duration The duration, in seconds, to register the name for.
     * @param resolver The resolver address to set on the ENS registry (optional).
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.
     */

    function registerAndWrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint256 duration,
        address resolver,
        uint32 fuses,
        uint64 expiry
    ) external override onlyController returns (uint256 registrarExpiry) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        registrarExpiry = registrar.register(tokenId, address(this), duration);
        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Renews a .eth second-level domain.
     *      Only callable by authorised controllers.
     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').
     * @param duration The number of seconds to renew the name for.
     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.
     */
    function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));

        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));

        _setData(node, owner, fuses, expiry);
    }

    /**
     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the registry or an authorised caller in the registry
     * @param name The name to wrap, in DNS format
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract address
     */

    function wrap(
        bytes calldata name,
        address wrappedOwner,
        address resolver
    ) public override {
        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
        bytes32 parentNode = name.namehash(offset);
        bytes32 node = _makeNode(parentNode, labelhash);

        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }

        address owner = ens.owner(node);

        if (
            owner != msg.sender &&
            !isApprovedForAll(owner, msg.sender) &&
            !ens.isApprovedForAll(owner, msg.sender)
        ) {
            revert Unauthorised(node, msg.sender);
        }

        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        ens.setOwner(node, address(this));

        _wrap(node, name, wrappedOwner, 0, 0);
    }

    /**
     * @notice Unwraps a .eth domain. e.g. vitalik.eth
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param labelhash labelhash of the .eth domain
     * @param newRegistrant sets the owner in the .eth registrar to this address
     * @param newController sets the owner in the registry to this address
     */

    function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }

    /**
     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param newController sets the owner in the registry to this address
     */

    function unwrap(
        bytes32 parentNode,
        bytes32 labelhash,
        address newController
    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        _unwrap(_makeNode(parentNode, labelhash), newController);
    }

    /**
     * @notice Sets fuses of a name
     * @param node namehash of the name
     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)
     */

    function setFuses(bytes32 node, uint32 fuses)
        public
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_BURN_FUSES)
        returns (uint32)
    {
        if (fuses & PARENT_CANNOT_CONTROL != 0) {
            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.
            revert Unauthorised(node, msg.sender);
        }

        (address owner, uint32 oldFuses, uint64 expiry) = getData(
            uint256(node)
        );

        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
        return fuses;
    }

    /**
     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract
     *     and burning the token of this contract
     * @dev Can be called by the owner of the name in this contract
     * @param label Label as a string of the .eth name to upgrade
     * @param wrappedOwner The owner of the wrapped name
     */

    function upgradeETH2LD(
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);

        upgradeContract.wrapETH2LD(
            label,
            wrappedOwner,
            fuses,
            expiry,
            resolver
        );
    }

    /**
     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner or an authorised caller
     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names
     * @param parentNode namehash of the parent name
     * @param label Label as a string of the name to upgrade
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract for this name
     */

    function upgrade(
        bytes32 parentNode,
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.setSubnodeRecord(
            parentNode,
            label,
            wrappedOwner,
            resolver,
            0,
            fuses,
            expiry
        );
    }

    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param fuses fuses to burn
     * @param expiry when the fuses will expire
     */

    function setChildFuses(
        bytes32 parentNode,
        bytes32 labelhash,
        uint32 fuses,
        uint64 expiry
    ) public {
        bytes32 node = _makeNode(parentNode, labelhash);
        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        uint64 maxExpiry;
        if (parentNode == ETH_NODE) {
            if (!isTokenOwnerOrApproved(node, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            // max expiry is set to the expiry on the registrar
            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        } else {
            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }

            // max expiry is set to the expiry of the parent
            (, , maxExpiry) = getData(uint256(parentNode));
        }

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);

        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed
        if (
            oldFuses & PARENT_CANNOT_CONTROL != 0 &&
            oldFuses | fuses != oldFuses
        ) {
            revert OperationProhibited(node);
        }
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
    }

    /**
     * @notice Sets the subdomain owner in the registry and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry when the fuses will expire
     */

    function setSubnodeOwner(
        bytes32 parentNode,
        string calldata label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
        returns (bytes32 node)
    {
        bytes32 labelhash = keccak256(bytes(label));
        node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);

        if (ens.owner(node) != address(this)) {
            ens.setSubnodeOwner(parentNode, labelhash, address(this));
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param resolver resolver contract in the registry
     * @param ttl ttl in the regsitry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry expiry date for the domain
     */

    function setSubnodeRecord(
        bytes32 parentNode,
        string memory label,
        address newOwner,
        address resolver,
        uint64 ttl,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
    {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets records for the name in the ENS Registry
     * @param node namehash of the name to set a record for
     * @param owner newOwner in the registry
     * @param resolver the resolver contract
     * @param ttl ttl in the registry
     */

    function setRecord(
        bytes32 node,
        address owner,
        address resolver,
        uint64 ttl
    )
        public
        override
        onlyTokenOwner(node)
        operationAllowed(
            node,
            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL
        )
    {
        ens.setRecord(node, address(this), resolver, ttl);
        (address oldOwner, , ) = getData(uint256(node));
        _transfer(oldOwner, owner, uint256(node), 1, "");
    }

    /**
     * @notice Sets resolver contract in the registry
     * @param node namehash of the name
     * @param resolver the resolver contract
     */

    function setResolver(bytes32 node, address resolver)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_RESOLVER)
    {
        ens.setResolver(node, resolver);
    }

    /**
     * @notice Sets TTL in the registry
     * @param node namehash of the name
     * @param ttl TTL in the registry
     */

    function setTTL(bytes32 node, uint64 ttl)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_TTL)
    {
        ens.setTTL(node, ttl);
    }

    /**
     * @dev Allows an operation only if none of the specified fuses are burned.
     * @param node The namehash of the name to check fuses on.
     * @param fuseMask A bitmask of fuses that must not be burned.
     */

    modifier operationAllowed(bytes32 node, uint32 fuseMask) {
        (, uint32 fuses, ) = getData(uint256(node));
        if (fuses & fuseMask != 0) {
            revert OperationProhibited(node);
        }
        _;
    }

    /**
     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord
     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt
     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for
     *      replacing a subdomain. If either conditions are true, then it is possible to call
     *      setSubnodeOwner
     * @param node namehash of the name to check
     * @param labelhash labelhash of the name to check
     */

    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {
        bytes32 subnode = _makeNode(node, labelhash);
        address owner = ens.owner(subnode);

        if (owner == address(0)) {
            (, uint32 fuses, ) = getData(uint256(node));
            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {
                revert OperationProhibited(node);
            }
        } else {
            (, uint32 subnodeFuses, ) = getData(uint256(subnode));
            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {
                revert OperationProhibited(node);
            }
        }

        _;
    }

    /**
     * @notice Checks all Fuses in the mask are burned for the node
     * @param node namehash of the name
     * @param fuseMask the fuses you want to check
     * @return Boolean of whether or not all the selected fuses are burned
     */

    function allFusesBurned(bytes32 node, uint32 fuseMask)
        public
        view
        override
        returns (bool)
    {
        (, uint32 fuses, ) = getData(uint256(node));
        return fuses & fuseMask == fuseMask;
    }

    function onERC721Received(
        address to,
        address,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        //check if it's the eth registrar ERC721
        if (msg.sender != address(registrar)) {
            revert IncorrectTokenType();
        }

        (
            string memory label,
            address owner,
            uint32 fuses,
            uint64 expiry,
            address resolver
        ) = abi.decode(data, (string, address, uint32, uint64, address));

        bytes32 labelhash = bytes32(tokenId);
        bytes32 labelhashFromData = keccak256(bytes(label));

        if (labelhashFromData != labelhash) {
            revert LabelMismatch(labelhashFromData, labelhash);
        }

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(uint256(labelhash), address(this));

        _wrapETH2LD(label, owner, fuses, expiry, resolver);

        return IERC721Receiver(to).onERC721Received.selector;
    }

    /***** Internal functions */

    function _canTransfer(uint32 fuses) internal pure override returns (bool) {
        return fuses & CANNOT_TRANSFER == 0;
    }

    function _makeNode(bytes32 node, bytes32 labelhash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, labelhash));
    }

    function _addLabel(string memory label, bytes memory name)
        internal
        pure
        returns (bytes memory ret)
    {
        if (bytes(label).length < 1) {
            revert LabelTooShort();
        }
        if (bytes(label).length > 255) {
            revert LabelTooLong(label);
        }
        return abi.encodePacked(uint8(bytes(label).length), label, name);
    }

    function _mint(
        bytes32 node,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal override {
        address oldWrappedOwner = ownerOf(uint256(node));
        _canFusesBeBurned(node, fuses);
        if (oldWrappedOwner != address(0)) {
            // burn and unwrap old token of old owner
            _burn(uint256(node));
            emit NameUnwrapped(node, address(0));
        }
        super._mint(node, wrappedOwner, fuses, expiry);
    }

    function _wrap(
        bytes32 node,
        bytes memory name,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        names[node] = name;
        _mint(node, wrappedOwner, fuses, expiry);
        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);
    }

    function _addLabelAndWrap(
        bytes32 parentNode,
        bytes32 node,
        string memory label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        bytes memory name = _addLabel(label, names[parentNode]);
        _wrap(node, name, newOwner, fuses, expiry);
    }

    function _prepareUpgrade(bytes32 node)
        private
        returns (uint32 fuses, uint64 expiry)
    {
        if (address(upgradeContract) == address(0)) {
            revert CannotUpgrade();
        }

        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        (fuses, expiry) = getFuses(node);

        // burn token and fuse data
        _burn(uint256(node));
    }

    function _transferAndBurnFuses(
        bytes32 node,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        (address owner, , ) = getData(uint256(node));
        _transfer(owner, newOwner, uint256(node), 1, "");
        _setFuses(node, newOwner, fuses, expiry);
    }

    // wrapper function for stack limit
    function _getDataAndNormaliseExpiry(
        bytes32 parentNode,
        bytes32 node,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        (, , uint64 maxExpiry) = getData(uint256(parentNode));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _getETH2LDDataAndNormaliseExpiry(
        bytes32 node,
        bytes32 labelhash,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _normaliseExpiry(
        uint64 expiry,
        uint64 oldExpiry,
        uint64 maxExpiry
    ) internal pure returns (uint64) {
        // Expiry cannot be more than maximum allowed
        // .eth names will check registrar, non .eth check parent
        if (expiry > maxExpiry) {
            expiry = maxExpiry;
        }
        // Expiry cannot be less than old expiry
        if (expiry < oldExpiry) {
            expiry = oldExpiry;
        }

        return expiry;
    }

    function _wrapETH2LD(
        string memory label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) private returns (uint64) {
        // Mint a new ERC1155 token with fuses
        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);

        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(
            node,
            labelhash,
            expiry
        );

        _addLabelAndWrap(
            ETH_NODE,
            node,
            label,
            wrappedOwner,
            fuses | PARENT_CANNOT_CONTROL,
            expiry
        );
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        return expiry;
    }

    function _unwrap(bytes32 node, address newOwner) private {
        if (newOwner == address(0x0) || newOwner == address(this)) {
            revert IncorrectTargetOwner(newOwner);
        }

        if (allFusesBurned(node, CANNOT_UNWRAP)) {
            revert OperationProhibited(node);
        }

        // Burn token and fuse data
        _burn(uint256(node));
        ens.setOwner(node, newOwner);

        emit NameUnwrapped(node, newOwner);
    }

    function _setFuses(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _setData(node, owner, fuses, expiry);
        emit FusesSet(node, fuses, expiry);
    }

    function _setData(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _canFusesBeBurned(node, fuses);
        super._setData(uint256(node), owner, fuses, expiry);
    }

    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
        if (
            fuses & ~PARENT_CANNOT_CONTROL != 0 &&
            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
        ) {
            revert OperationProhibited(node);
        }
    }
}
.]

Based on the provided smart contract code for the `NameWrapper` contract, here is a succinct summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**: 
   - The contract does not implement any reentrancy guards in functions that involve transferring tokens or calling external contracts. This could allow an attacker to exploit the contract by re-entering a function before the previous execution is completed.

2. **Access Control Issues**:
   - The `onlyController` modifier is used in several functions, but it is unclear how the controller addresses are managed. If not properly controlled, unauthorized users could gain access to sensitive functions.
   - The `onlyTokenOwner` modifier checks ownership but does not account for potential changes in ownership during execution, which could lead to unauthorized access.

3. **Improper Error Handling**:
   - The contract uses `revert` statements for error handling, which is good practice, but it lacks detailed error messages in some cases, making it harder to debug issues.

4. **Token Transfer Risks**:
   - Functions that involve transferring tokens (e.g., `unwrapETH2LD`, `unwrap`, and `setRecord`) do not adequately check for the success of the transfer operations. If a transfer fails, the contract state may become inconsistent.

5. **Lack of Input Validation**:
   - Functions that accept user input (e.g., `wrap`, `setSubnodeOwner`, etc.) do not have sufficient validation checks for the parameters, which could lead to unexpected behavior or vulnerabilities.

6. **Potential for Denial of Service (DoS)**:
   - If an external contract called by this contract fails or reverts, it could prevent the execution of critical functions, leading to a denial of service for legitimate users.

7. **Upgradeability Risks**:
   - The contract allows for an upgradeable pattern through the `upgradeContract` variable. If the upgrade contract is compromised or malicious, it could lead to significant vulnerabilities in the `NameWrapper` contract.

8. **Gas Limit Issues**:
   - Some functions may consume a significant amount of gas, especially those that involve loops or multiple external calls. This could lead to transaction failures if the gas limit is exceeded.

### Comprehensive Analysis Report

The `NameWrapper` contract is a complex implementation that interacts with various external contracts, including the ENS registry and ERC721 tokens. While it provides essential functionalities for wrapping and managing domain names, several security vulnerabilities have been identified that could potentially compromise the integrity and availability of the contract.

1. **Reentrancy and Access Control**: The absence of reentrancy guards and unclear access control mechanisms pose significant risks. It is crucial to implement checks and balances to ensure that only authorized users can execute sensitive functions.

2. **Error Handling and Input Validation**: Improved error handling and input validation are necessary to prevent unexpected behaviors and to enhance the contract's resilience against malicious inputs.

3. **Token Transfer and DoS Risks**: The contract should ensure that all token transfers are successful and handle failures gracefully to avoid denial of service scenarios.

4. **Upgradeability Concerns**: The upgradeable nature of the contract introduces risks that must be managed carefully. A thorough review of the upgrade contract's code is essential to mitigate potential vulnerabilities.

5. **Gas Limit Considerations**: Functions should be optimized to minimize gas consumption, ensuring that users can interact with the contract without encountering transaction failures due to gas limits.

### Recommendations

- Implement reentrancy guards in critical functions.
- Enhance access control mechanisms to ensure only authorized users can execute sensitive operations.
- Improve error handling and provide detailed error messages.
- Validate all user inputs rigorously.
- Ensure that token transfers are checked for success and handle failures appropriately.
- Review and secure the upgrade contract to prevent exploitation.
- Optimize functions to reduce gas consumption and avoid potential transaction failures.

By addressing these vulnerabilities, the `NameWrapper` contract can be made more secure and robust, ensuring the safety of user assets and the integrity of the domain management process.

[2024-01-09 20:35:58 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for the `NameWrapper` contract, here is a succinct summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**: 
   - The contract does not implement any reentrancy guards in functions that involve transferring tokens or calling external contracts. This could allow an attacker to exploit the contract by re-entering a function before the previous execution is completed.

2. **Access Control Issues**:
   - The `onlyController` modifier is used in several functions, but it is unclear how the controller addresses are managed. If not properly controlled, unauthorized users could gain access to sensitive functions.
   - The `onlyTokenOwner` modifier checks ownership but does not account for potential changes in ownership during execution, which could lead to unauthorized access.

3. **Improper Error Handling**:
   - The contract uses `revert` statements for error handling, which is good practice, but it lacks detailed error messages in some cases, making it harder to debug issues.

4. **Token Transfer Risks**:
   - Functions that involve transferring tokens (e.g., `unwrapETH2LD`, `unwrap`, and `setRecord`) do not adequately check for the success of the transfer operations. If a transfer fails, the contract state may become inconsistent.

5. **Lack of Input Validation**:
   - Functions that accept user input (e.g., `wrap`, `setSubnodeOwner`, etc.) do not have sufficient validation checks for the parameters, which could lead to unexpected behavior or vulnerabilities.

6. **Potential for Denial of Service (DoS)**:
   - If an external contract called by this contract fails or reverts, it could prevent the execution of critical functions, leading to a denial of service for legitimate users.

7. **Upgradeability Risks**:
   - The contract allows for an upgradeable pattern through the `upgradeContract` variable. If the upgrade contract is compromised or malicious, it could lead to significant vulnerabilities in the `NameWrapper` contract.

8. **Gas Limit Issues**:
   - Some functions may consume a significant amount of gas, especially those that involve loops or multiple external calls. This could lead to transaction failures if the gas limit is exceeded.

### Comprehensive Analysis Report

The `NameWrapper` contract is a complex implementation that interacts with various external contracts, including the ENS registry and ERC721 tokens. While it provides essential functionalities for wrapping and managing domain names, several security vulnerabilities have been identified that could potentially compromise the integrity and availability of the contract.

1. **Reentrancy and Access Control**: The absence of reentrancy guards and unclear access control mechanisms pose significant risks. It is crucial to implement checks and balances to ensure that only authorized users can execute sensitive functions.

2. **Error Handling and Input Validation**: Improved error handling and input validation are necessary to prevent unexpected behaviors and to enhance the contract's resilience against malicious inputs.

3. **Token Transfer and DoS Risks**: The contract should ensure that all token transfers are successful and handle failures gracefully to avoid denial of service scenarios.

4. **Upgradeability Concerns**: The upgradeable nature of the contract introduces risks that must be managed carefully. A thorough review of the upgrade contract's code is essential to mitigate potential vulnerabilities.

5. **Gas Limit Considerations**: Functions should be optimized to minimize gas consumption, ensuring that users can interact with the contract without encountering transaction failures due to gas limits.

### Recommendations

- Implement reentrancy guards in critical functions.
- Enhance access control mechanisms to ensure only authorized users can execute sensitive operations.
- Improve error handling and provide detailed error messages.
- Validate all user inputs rigorously.
- Ensure that token transfers are checked for success and handle failures appropriately.
- Review and secure the upgrade contract to prevent exploitation.
- Optimize functions to reduce gas consumption and avoid potential transaction failures.

By addressing these vulnerabilities, the `NameWrapper` contract can be made more secure and robust, ensuring the safety of user assets and the integrity of the domain management process.

[2024-01-09 20:35:58 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-01-09 20:35:59 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | //SPDX-License-Identifier: MIT pragma solidity ^0.8.4; import "./ERC1155Fuse.sol"; import "./Controllable.sol"; import "./INameWrapper.sol"; import "./INameWrapperUpgrade.sol"; import "./IMetadataService.sol"; import "../registry/ENS.sol"; import "../ethregistrar/IBaseRegistrar.sol"; import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "./BytesUtil.sol"; error Unauthorised(bytes32 node, address addr); error NameNotFound(); error IncompatibleParent(); error IncompatibleName(bytes name); error IncorrectTokenType(); error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash); error LabelTooShort(); error LabelTooLong(string label); error IncorrectTargetOwner(address owner); error CannotUpgrade(); error InvalidExpiry(bytes32 node, uint64 expiry); contract NameWrapper is     Ownable,     ERC1155Fuse,     INameWrapper,     Controllable,     IERC721Receiver {     using BytesUtils for bytes;     ENS public immutable override ens;     IBaseRegistrar public immutable override registrar;     IMetadataService public override metadataService;     mapping(bytes32 =&gt; bytes) public override names; bytes32 private constant ETH_NODE =     0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae; bytes32 private constant ROOT_NODE =     0x0000000000000000000000000000000000000000000000000000000000000000;  //A contract address to a new upgraded contract if any INameWrapperUpgrade public upgradeContract; uint64 private constant MAX_EXPIRY = type(uint64).max;  constructor(     ENS _ens,     IBaseRegistrar _registrar,     IMetadataService _metadataService ) {     ens = _ens;     registrar = _registrar;     metadataService = _metadataService;      /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */      _setData(         uint256(ETH_NODE),         address(0),         uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),         MAX_EXPIRY     );     _setData(         uint256(ROOT_NODE),         address(0),         uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),         MAX_EXPIRY     );     names[ROOT_NODE] = "\x00";     names[ETH_NODE] = "\x03eth\x00"; }  function supportsInterface(bytes4 interfaceId)     public     view     virtual     override(ERC1155Fuse, IERC165)     returns (bool) {     return         interfaceId == type(INameWrapper).interfaceId ||         super.supportsInterface(interfaceId); }  /* ERC1155 */  function ownerOf(uint256 id)     public     view     override(ERC1155Fuse, INameWrapper)     returns (address owner) {     return super.ownerOf(id); }  /* Metadata service */  /**  * @notice Set the metadata service. Only the owner can do this  */  function setMetadataService(IMetadataService _newMetadataService)     public     onlyOwner {     metadataService = _newMetadataService; }  /**  * @notice Get the metadata uri  * @return String uri of the metadata service  */  function uri(uint256 tokenId) public view override returns (string memory) {     return metadataService.uri(tokenId); }  /**  * @notice Set the address of the upgradeContract of the contract. only admin can do this  * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time  * to make the contract not upgradable.  * @param _upgradeAddress address of an upgraded contract  */  function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)     public     onlyOwner {     if (address(upgradeContract) != address(0)) {         registrar.setApprovalForAll(address(upgradeContract), false);         ens.setApprovalForAll(address(upgradeContract), false);     }      upgradeContract = _upgradeAddress;      if (address(upgradeContract) != address(0)) {         registrar.setApprovalForAll(address(upgradeContract), true);         ens.setApprovalForAll(address(upgradeContract), true);     } }  /**  * @notice Checks if msg.sender is the owner or approved by the owner of a name  * @param node namehash of the name to check  */  modifier onlyTokenOwner(bytes32 node) {     if (!isTokenOwnerOrApproved(node, msg.sender)) {         revert Unauthorised(node, msg.sender);     }      _; }  /**  * @notice Checks if owner or approved by owner  * @param node namehash of the name to check  * @param addr which address to check permissions for  * @return whether or not is owner or approved  */  function isTokenOwnerOrApproved(bytes32 node, address addr)     public     view     override     returns (bool) {     address owner = ownerOf(uint256(node));     return owner == addr || isApprovedForAll(owner, addr); }  /**  * @notice Gets fuse permissions for a specific name  * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit  *      The interface has predefined fuses for all registry permissions, but additional  *      fuses can be added for other use cases  *      Also returns expiry, which is when the fuses are set to expire.  * @param node namehash of the name to check  * @return fuses A number that represents the permissions a name has. Returns 0 when expiry &lt; block.timestamp  * @return expiry Unix time of when the name expires and fuses are to expire  */ function getFuses(bytes32 node)     public     view     override     returns (uint32 fuses, uint64 expiry) {     (, fuses, expiry) = getData(uint256(node));     if (fuses == 0 &amp;&amp; expiry == 0) {         bytes memory name = names[node];         if (name.length == 0) {             revert NameNotFound();         }     } }  /**  * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract  * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar  * @param label label as a string of the .eth domain to wrap  * @param wrappedOwner Owner of the name in this contract  * @param fuses initial fuses to set  * @param expiry when the fuses will expire  * @param resolver resolver contract address  */  function wrapETH2LD(     string calldata label,     address wrappedOwner,     uint32 fuses,     uint64 expiry,     address resolver ) public override returns (uint64) {     uint256 tokenId = uint256(keccak256(bytes(label)));     address registrant = registrar.ownerOf(tokenId);     if (         registrant != msg.sender &amp;&amp;         !isApprovedForAll(registrant, msg.sender) &amp;&amp;         !registrar.isApprovedForAll(registrant, msg.sender)     ) {         revert Unauthorised(             _makeNode(ETH_NODE, bytes32(tokenId)),             msg.sender         );     }      // transfer the token from the user to this contract     registrar.transferFrom(registrant, address(this), tokenId);      // transfer the ens record back to the new owner (this contract)     registrar.reclaim(tokenId, address(this));      return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver); }  /**  * @dev Registers a new .eth second-level domain and wraps it.  *      Only callable by authorised controllers.  * @param label The label to register (Eg, 'foo' for 'foo.eth').  * @param wrappedOwner The owner of the wrapped name.  * @param duration The duration, in seconds, to register the name for.  * @param resolver The resolver address to set on the ENS registry (optional).  * @param fuses initial fuses to set  * @param expiry when the fuses will expire  * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.  */  function registerAndWrapETH2LD(     string calldata label,     address wrappedOwner,     uint256 duration,     address resolver,     uint32 fuses,     uint64 expiry ) external override onlyController returns (uint256 registrarExpiry) {     uint256 tokenId = uint256(keccak256(bytes(label)));     registrarExpiry = registrar.register(tokenId, address(this), duration);     _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver); }  /**  * @dev Renews a .eth second-level domain.  *      Only callable by authorised controllers.  * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').  * @param duration The number of seconds to renew the name for.  * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.  */ function renew(     uint256 tokenId,     uint256 duration,     uint64 expiry ) external override onlyController returns (uint256 expires) {     bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));      expires = registrar.renew(tokenId, duration);     (address owner, uint32 fuses, uint64 oldExpiry) = getData(         uint256(node)     );     expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));      _setData(node, owner, fuses, expiry); }  /**  * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner in the registry or an authorised caller in the registry  * @param name The name to wrap, in DNS format  * @param wrappedOwner Owner of the name in this contract  * @param resolver resolver contract address  */  function wrap(     bytes calldata name,     address wrappedOwner,     address resolver ) public override {     (bytes32 labelhash, uint256 offset) = name.readLabel(0);     bytes32 parentNode = name.namehash(offset);     bytes32 node = _makeNode(parentNode, labelhash);      if (parentNode == ETH_NODE) {         revert IncompatibleParent();     }      address owner = ens.owner(node);      if (         owner != msg.sender &amp;&amp;         !isApprovedForAll(owner, msg.sender) &amp;&amp;         !ens.isApprovedForAll(owner, msg.sender)     ) {         revert Unauthorised(node, msg.sender);     }      if (resolver != address(0)) {         ens.setResolver(node, resolver);     }      ens.setOwner(node, address(this));      _wrap(node, name, wrappedOwner, 0, 0); }  /**  * @notice Unwraps a .eth domain. e.g. vitalik.eth  * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper  * @param labelhash labelhash of the .eth domain  * @param newRegistrant sets the owner in the .eth registrar to this address  * @param newController sets the owner in the registry to this address  */  function unwrapETH2LD(     bytes32 labelhash,     address newRegistrant,     address newController ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {     _unwrap(_makeNode(ETH_NODE, labelhash), newController);     registrar.transferFrom(         address(this),         newRegistrant,         uint256(labelhash)     ); }  /**  * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper  * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')  * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')  * @param newController sets the owner in the registry to this address  */  function unwrap(     bytes32 parentNode,     bytes32 labelhash,     address newController ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {     if (parentNode == ETH_NODE) {         revert IncompatibleParent();     }     _unwrap(_makeNode(parentNode, labelhash), newController); }  /**  * @notice Sets fuses of a name  * @param node namehash of the name  * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)  */  function setFuses(bytes32 node, uint32 fuses)     public     onlyTokenOwner(node)     operationAllowed(node, CANNOT_BURN_FUSES)     returns (uint32) {     if (fuses &amp; PARENT_CANNOT_CONTROL != 0) {         // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.         revert Unauthorised(node, msg.sender);     }      (address owner, uint32 oldFuses, uint64 expiry) = getData(         uint256(node)     );      fuses |= oldFuses;     _setFuses(node, owner, fuses, expiry);     return fuses; }  /**  * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract  *     and burning the token of this contract  * @dev Can be called by the owner of the name in this contract  * @param label Label as a string of the .eth name to upgrade  * @param wrappedOwner The owner of the wrapped name  */  function upgradeETH2LD(     string calldata label,     address wrappedOwner,     address resolver ) public {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(ETH_NODE, labelhash);     (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);      upgradeContract.wrapETH2LD(         label,         wrappedOwner,         fuses,         expiry,         resolver     ); }  /**  * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner or an authorised caller  * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names  * @param parentNode namehash of the parent name  * @param label Label as a string of the name to upgrade  * @param wrappedOwner Owner of the name in this contract  * @param resolver resolver contract for this name  */  function upgrade(     bytes32 parentNode,     string calldata label,     address wrappedOwner,     address resolver ) public {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(parentNode, labelhash);     (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);     upgradeContract.setSubnodeRecord(         parentNode,         label,         wrappedOwner,         resolver,         0,         fuses,         expiry     ); }  /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name  * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')  * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')  * @param fuses fuses to burn  * @param expiry when the fuses will expire  */  function setChildFuses(     bytes32 parentNode,     bytes32 labelhash,     uint32 fuses,     uint64 expiry ) public {     bytes32 node = _makeNode(parentNode, labelhash);     (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(         uint256(node)     );     uint64 maxExpiry;     if (parentNode == ETH_NODE) {         if (!isTokenOwnerOrApproved(node, msg.sender)) {             revert Unauthorised(node, msg.sender);         }         // max expiry is set to the expiry on the registrar         maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));     } else {         if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {             revert Unauthorised(node, msg.sender);         }          // max expiry is set to the expiry of the parent         (, , maxExpiry) = getData(uint256(parentNode));     }      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);      // if PARENT_CANNOT_CONTROL has been burned and fuses have changed     if (         oldFuses &amp; PARENT_CANNOT_CONTROL != 0 &amp;&amp;         oldFuses | fuses != oldFuses     ) {         revert OperationProhibited(node);     }     fuses |= oldFuses;     _setFuses(node, owner, fuses, expiry); }  /**  * @notice Sets the subdomain owner in the registry and then wraps the subdomain  * @param parentNode parent namehash of the subdomain  * @param label label of the subdomain as a string  * @param newOwner newOwner in the registry  * @param fuses initial fuses for the wrapped subdomain  * @param expiry when the fuses will expire  */  function setSubnodeOwner(     bytes32 parentNode,     string calldata label,     address newOwner,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))     returns (bytes32 node) {     bytes32 labelhash = keccak256(bytes(label));     node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);      if (ens.owner(node) != address(this)) {         ens.setSubnodeOwner(parentNode, labelhash, address(this));         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } }  /**  * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain  * @param parentNode parent namehash of the subdomain  * @param label label of the subdomain as a string  * @param newOwner newOwner in the registry  * @param resolver resolver contract in the registry  * @param ttl ttl in the regsitry  * @param fuses initial fuses for the wrapped subdomain  * @param expiry expiry date for the domain  */  function setSubnodeRecord(     bytes32 parentNode,     string memory label,     address newOwner,     address resolver,     uint64 ttl,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label))) {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);     if (ens.owner(node) != address(this)) {         ens.setSubnodeRecord(             parentNode,             labelhash,             address(this),             resolver,             ttl         );         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         ens.setSubnodeRecord(             parentNode,             labelhash,             address(this),             resolver,             ttl         );         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } }  /**  * @notice Sets records for the name in the ENS Registry  * @param node namehash of the name to set a record for  * @param owner newOwner in the registry  * @param resolver the resolver contract  * @param ttl ttl in the registry  */  function setRecord(     bytes32 node,     address owner,     address resolver,     uint64 ttl )     public     override     onlyTokenOwner(node)     operationAllowed(         node,         CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL     ) {     ens.setRecord(node, address(this), resolver, ttl);     (address oldOwner, , ) = getData(uint256(node));     _transfer(oldOwner, owner, uint256(node), 1, ""); }  /**  * @notice Sets resolver contract in the registry  * @param node namehash of the name  * @param resolver the resolver contract  */  function setResolver(bytes32 node, address resolver)     public     override     onlyTokenOwner(node)     operationAllowed(node, CANNOT_SET_RESOLVER) {     ens.setResolver(node, resolver); }  /**  * @notice Sets TTL in the registry  * @param node namehash of the name  * @param ttl TTL in the registry  */  function setTTL(bytes32 node, uint64 ttl)     public     override     onlyTokenOwner(node)     operationAllowed(node, CANNOT_SET_TTL) {     ens.setTTL(node, ttl); }  /**  * @dev Allows an operation only if none of the specified fuses are burned.  * @param node The namehash of the name to check fuses on.  * @param fuseMask A bitmask of fuses that must not be burned.  */  modifier operationAllowed(bytes32 node, uint32 fuseMask) {     (, uint32 fuses, ) = getData(uint256(node));     if (fuses &amp; fuseMask != 0) {         revert OperationProhibited(node);     }     _; }  /**  * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord  * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt  *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for  *      replacing a subdomain. If either conditions are true, then it is possible to call  *      setSubnodeOwner  * @param node namehash of the name to check  * @param labelhash labelhash of the name to check  */  modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {     bytes32 subnode = _makeNode(node, labelhash);     address owner = ens.owner(subnode);      if (owner == address(0)) {         (, uint32 fuses, ) = getData(uint256(node));         if (fuses &amp; CANNOT_CREATE_SUBDOMAIN != 0) {             revert OperationProhibited(node);         }     } else {         (, uint32 subnodeFuses, ) = getData(uint256(subnode));         if (subnodeFuses &amp; PARENT_CANNOT_CONTROL != 0) {             revert OperationProhibited(node);         }     }      _; }  /**  * @notice Checks all Fuses in the mask are burned for the node  * @param node namehash of the name  * @param fuseMask the fuses you want to check  * @return Boolean of whether or not all the selected fuses are burned  */  function allFusesBurned(bytes32 node, uint32 fuseMask)     public     view     override     returns (bool) {     (, uint32 fuses, ) = getData(uint256(node));     return fuses &amp; fuseMask == fuseMask; }  function onERC721Received(     address to,     address,     uint256 tokenId,     bytes calldata data ) public override returns (bytes4) {     //check if it's the eth registrar ERC721     if (msg.sender != address(registrar)) {         revert IncorrectTokenType();     }      (         string memory label,         address owner,         uint32 fuses,         uint64 expiry,         address resolver     ) = abi.decode(data, (string, address, uint32, uint64, address));      bytes32 labelhash = bytes32(tokenId);     bytes32 labelhashFromData = keccak256(bytes(label));      if (labelhashFromData != labelhash) {         revert LabelMismatch(labelhashFromData, labelhash);     }      // transfer the ens record back to the new owner (this contract)     registrar.reclaim(uint256(labelhash), address(this));      _wrapETH2LD(label, owner, fuses, expiry, resolver);      return IERC721Receiver(to).onERC721Received.selector; }  /***** Internal functions */  function _canTransfer(uint32 fuses) internal pure override returns (bool) {     return fuses &amp; CANNOT_TRANSFER == 0; }  function _makeNode(bytes32 node, bytes32 labelhash)     private     pure     returns (bytes32) {     return keccak256(abi.encodePacked(node, labelhash)); }  function _addLabel(string memory label, bytes memory name)     internal     pure     returns (bytes memory ret) {     if (bytes(label).length &lt; 1) {         revert LabelTooShort();     }     if (bytes(label).length &gt; 255) {         revert LabelTooLong(label);     }     return abi.encodePacked(uint8(bytes(label).length), label, name); }  function _mint(     bytes32 node,     address wrappedOwner,     uint32 fuses,     uint64 expiry ) internal override {     address oldWrappedOwner = ownerOf(uint256(node));     _canFusesBeBurned(node, fuses);     if (oldWrappedOwner != address(0)) {         // burn and unwrap old token of old owner         _burn(uint256(node));         emit NameUnwrapped(node, address(0));     }     super._mint(node, wrappedOwner, fuses, expiry); }  function _wrap(     bytes32 node,     bytes memory name,     address wrappedOwner,     uint32 fuses,     uint64 expiry ) internal {     names[node] = name;     _mint(node, wrappedOwner, fuses, expiry);     emit NameWrapped(node, name, wrappedOwner, fuses, expiry); }  function _addLabelAndWrap(     bytes32 parentNode,     bytes32 node,     string memory label,     address newOwner,     uint32 fuses,     uint64 expiry ) internal {     bytes memory name = _addLabel(label, names[parentNode]);     _wrap(node, name, newOwner, fuses, expiry); }  function _prepareUpgrade(bytes32 node)     private     returns (uint32 fuses, uint64 expiry) {     if (address(upgradeContract) == address(0)) {         revert CannotUpgrade();     }      if (!isTokenOwnerOrApproved(node, msg.sender)) {         revert Unauthorised(node, msg.sender);     }      (fuses, expiry) = getFuses(node);      // burn token and fuse data     _burn(uint256(node)); }  function _transferAndBurnFuses(     bytes32 node,     address newOwner,     uint32 fuses,     uint64 expiry ) internal {     (address owner, , ) = getData(uint256(node));     _transfer(owner, newOwner, uint256(node), 1, "");     _setFuses(node, newOwner, fuses, expiry); }  // wrapper function for stack limit function _getDataAndNormaliseExpiry(     bytes32 parentNode,     bytes32 node,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     (, , uint64 maxExpiry) = getData(uint256(parentNode));      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); }  function _getETH2LDDataAndNormaliseExpiry(     bytes32 node,     bytes32 labelhash,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); }  function _normaliseExpiry(     uint64 expiry,     uint64 oldExpiry,     uint64 maxExpiry ) internal pure returns (uint64) {     // Expiry cannot be more than maximum allowed     // .eth names will check registrar, non .eth check parent     if (expiry &gt; maxExpiry) {         expiry = maxExpiry;     }     // Expiry cannot be less than old expiry     if (expiry &lt; oldExpiry) {         expiry = oldExpiry;     }      return expiry; }  function _wrapETH2LD(     string memory label,     address wrappedOwner,     uint32 fuses,     uint64 expiry,     address resolver ) private returns (uint64) {     // Mint a new ERC1155 token with fuses     // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(ETH_NODE, labelhash);      (, , expiry) = _getETH2LDDataAndNormaliseExpiry(         node,         labelhash,         expiry     );      _addLabelAndWrap(         ETH_NODE,         node,         label,         wrappedOwner,         fuses | PARENT_CANNOT_CONTROL,         expiry     );     if (resolver != address(0)) {         ens.setResolver(node, resolver);     }      return expiry; }  function _unwrap(bytes32 node, address newOwner) private {     if (newOwner == address(0x0) || newOwner == address(this)) {         revert IncorrectTargetOwner(newOwner);     }      if (allFusesBurned(node, CANNOT_UNWRAP)) {         revert OperationProhibited(node);     }      // Burn token and fuse data     _burn(uint256(node));     ens.setOwner(node, newOwner);      emit NameUnwrapped(node, newOwner); }  function _setFuses(     bytes32 node,     address owner,     uint32 fuses,     uint64 expiry ) internal {     _setData(node, owner, fuses, expiry);     emit FusesSet(node, fuses, expiry); }  function _setData(     bytes32 node,     address owner,     uint32 fuses,     uint64 expiry ) internal {     _canFusesBeBurned(node, fuses);     super._setData(uint256(node), owner, fuses, expiry); }  function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {     if (         fuses &amp; ~PARENT_CANNOT_CONTROL != 0 &amp;&amp;         fuses &amp; (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=         (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)     ) {         revert OperationProhibited(node);     } }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport "./ERC1155Fuse.sol";\nimport "./Controllable.sol";\nimport "./INameWrapper.sol";\nimport "./INameWrapperUpgrade.sol";\nimport "./IMetadataService.sol";\nimport "../registry/ENS.sol";\nimport "../ethregistrar/IBaseRegistrar.sol";\nimport "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";\nimport "@openzeppelin/contracts/access/Ownable.sol";\nimport "./BytesUtil.sol";\n\nerror Unauthorised(bytes32 node, address addr);\nerror NameNotFound();\nerror IncompatibleParent();\nerror IncompatibleName(bytes name);\nerror IncorrectTokenType();\nerror LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);\nerror LabelTooShort();\nerror LabelTooLong(string label);\nerror IncorrectTargetOwner(address owner);\nerror CannotUpgrade();\nerror InvalidExpiry(bytes32 node, uint64 expiry);\n\ncontract NameWrapper is\n    Ownable,\n    ERC1155Fuse,\n    INameWrapper,\n    Controllable,\n    IERC721Receiver\n{\n    using BytesUtils for bytes;\n    ENS public immutable override ens;\n    IBaseRegistrar public immutable override registrar;\n    IMetadataService public override metadataService;\n    mapping(bytes32 =&gt; bytes) public override names;\n\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n    bytes32 private constant ROOT_NODE =\n        0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    //A contract address to a new upgraded contract if any\n    INameWrapperUpgrade public upgradeContract;\n    uint64 private constant MAX_EXPIRY = type(uint64).max;\n\n    constructor(\n        ENS _ens,\n        IBaseRegistrar _registrar,\n        IMetadataService _metadataService\n    ) {\n        ens = _ens;\n        registrar = _registrar;\n        metadataService = _metadataService;\n\n        / Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE /\n\n        _setData(\n            uint256(ETH_NODE),\n            address(0),\n            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),\n            MAX_EXPIRY\n        );\n        _setData(\n            uint256(ROOT_NODE),\n            address(0),\n            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),\n            MAX_EXPIRY\n        );\n        names[ROOT_NODE] = "\x00";\n        names[ETH_NODE] = "\x03eth\x00";\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC1155Fuse, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(INameWrapper).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    / ERC1155 /\n\n    function ownerOf(uint256 id)\n        public\n        view\n        override(ERC1155Fuse, INameWrapper)\n        returns (address owner)\n    {\n        return super.ownerOf(id);\n    }\n\n    / Metadata service /\n\n    /\n     * @notice Set the metadata service. Only the owner can do this\n     /\n\n    function setMetadataService(IMetadataService _newMetadataService)\n        public\n        onlyOwner\n    {\n        metadataService = _newMetadataService;\n    }\n\n    /\n     * @notice Get the metadata uri\n     * @return String uri of the metadata service\n     */\n\n    function uri(uint256 tokenId) public view override returns (string memory) {\n        return metadataService.uri(tokenId);\n    }\n\n    /\n     * @notice Set the address of the upgradeContract of the contract. only admin can do this\n     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time\n     * to make the contract not upgradable.\n     * @param _upgradeAddress address of an upgraded contract\n     /\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)\n        public\n        onlyOwner\n    {\n        if (address(upgradeContract) != address(0)) {\n            registrar.setApprovalForAll(address(upgradeContract), false);\n            ens.setApprovalForAll(address(upgradeContract), false);\n        }\n\n        upgradeContract = _upgradeAddress;\n\n        if (address(upgradeContract) != address(0)) {\n            registrar.setApprovalForAll(address(upgradeContract), true);\n            ens.setApprovalForAll(address(upgradeContract), true);\n        }\n    }\n\n    /\n     * @notice Checks if msg.sender is the owner or approved by the owner of a name\n     * @param node namehash of the name to check\n     /\n\n    modifier onlyTokenOwner(bytes32 node) {\n        if (!isTokenOwnerOrApproved(node, msg.sender)) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        _;\n    }\n\n    /\n     * @notice Checks if owner or approved by owner\n     * @param node namehash of the name to check\n     * @param addr which address to check permissions for\n     * @return whether or not is owner or approved\n     */\n\n    function isTokenOwnerOrApproved(bytes32 node, address addr)\n        public\n        view\n        override\n        returns (bool)\n    {\n        address owner = ownerOf(uint256(node));\n        return owner == addr || isApprovedForAll(owner, addr);\n    }\n\n    /\n     * @notice Gets fuse permissions for a specific name\n     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit\n     *      The interface has predefined fuses for all registry permissions, but additional\n     *      fuses can be added for other use cases\n     *      Also returns expiry, which is when the fuses are set to expire.\n     * @param node namehash of the name to check\n     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry &lt; block.timestamp\n     * @return expiry Unix time of when the name expires and fuses are to expire\n     /\n    function getFuses(bytes32 node)\n        public\n        view\n        override\n        returns (uint32 fuses, uint64 expiry)\n    {\n        (, fuses, expiry) = getData(uint256(node));\n        if (fuses == 0 &amp;&amp; expiry == 0) {\n            bytes memory name = names[node];\n            if (name.length == 0) {\n                revert NameNotFound();\n            }\n        }\n    }\n\n    /\n     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract\n     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar\n     * @param label label as a string of the .eth domain to wrap\n     * @param wrappedOwner Owner of the name in this contract\n     * @param fuses initial fuses to set\n     * @param expiry when the fuses will expire\n     * @param resolver resolver contract address\n     /\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address resolver\n    ) public override returns (uint64) {\n        uint256 tokenId = uint256(keccak256(bytes(label)));\n        address registrant = registrar.ownerOf(tokenId);\n        if (\n            registrant != msg.sender &amp;&amp;\n            !isApprovedForAll(registrant, msg.sender) &amp;&amp;\n            !registrar.isApprovedForAll(registrant, msg.sender)\n        ) {\n            revert Unauthorised(\n                _makeNode(ETH_NODE, bytes32(tokenId)),\n                msg.sender\n            );\n        }\n\n        // transfer the token from the user to this contract\n        registrar.transferFrom(registrant, address(this), tokenId);\n\n        // transfer the ens record back to the new owner (this contract)\n        registrar.reclaim(tokenId, address(this));\n\n        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);\n    }\n\n    /\n     * @dev Registers a new .eth second-level domain and wraps it.\n     *      Only callable by authorised controllers.\n     * @param label The label to register (Eg, \'foo\' for \'foo.eth\').\n     * @param wrappedOwner The owner of the wrapped name.\n     * @param duration The duration, in seconds, to register the name for.\n     * @param resolver The resolver address to set on the ENS registry (optional).\n     * @param fuses initial fuses to set\n     * @param expiry when the fuses will expire\n     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.\n     */\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint32 fuses,\n        uint64 expiry\n    ) external override onlyController returns (uint256 registrarExpiry) {\n        uint256 tokenId = uint256(keccak256(bytes(label)));\n        registrarExpiry = registrar.register(tokenId, address(this), duration);\n        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);\n    }\n\n    /\n     * @dev Renews a .eth second-level domain.\n     *      Only callable by authorised controllers.\n     * @param tokenId The hash of the label to register (eg, keccak256(\'foo\'), for \'foo.eth\').\n     * @param duration The number of seconds to renew the name for.\n     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.\n     /\n    function renew(\n        uint256 tokenId,\n        uint256 duration,\n        uint64 expiry\n    ) external override onlyController returns (uint256 expires) {\n        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));\n\n        expires = registrar.renew(tokenId, duration);\n        (address owner, uint32 fuses, uint64 oldExpiry) = getData(\n            uint256(node)\n        );\n        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));\n\n        _setData(node, owner, fuses, expiry);\n    }\n\n    /\n     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner in the registry or an authorised caller in the registry\n     * @param name The name to wrap, in DNS format\n     * @param wrappedOwner Owner of the name in this contract\n     * @param resolver resolver contract address\n     /\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) public override {\n        (bytes32 labelhash, uint256 offset) = name.readLabel(0);\n        bytes32 parentNode = name.namehash(offset);\n        bytes32 node = _makeNode(parentNode, labelhash);\n\n        if (parentNode == ETH_NODE) {\n            revert IncompatibleParent();\n        }\n\n        address owner = ens.owner(node);\n\n        if (\n            owner != msg.sender &amp;&amp;\n            !isApprovedForAll(owner, msg.sender) &amp;&amp;\n            !ens.isApprovedForAll(owner, msg.sender)\n        ) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        if (resolver != address(0)) {\n            ens.setResolver(node, resolver);\n        }\n\n        ens.setOwner(node, address(this));\n\n        _wrap(node, name, wrappedOwner, 0, 0);\n    }\n\n    /\n     * @notice Unwraps a .eth domain. e.g. vitalik.eth\n     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper\n     * @param labelhash labelhash of the .eth domain\n     * @param newRegistrant sets the owner in the .eth registrar to this address\n     * @param newController sets the owner in the registry to this address\n     */\n\n    function unwrapETH2LD(\n        bytes32 labelhash,\n        address newRegistrant,\n        address newController\n    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {\n        _unwrap(_makeNode(ETH_NODE, labelhash), newController);\n        registrar.transferFrom(\n            address(this),\n            newRegistrant,\n            uint256(labelhash)\n        );\n    }\n\n    /\n     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper\n     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash(\'xyz\')\n     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256(\'vitalik\')\n     * @param newController sets the owner in the registry to this address\n     /\n\n    function unwrap(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        address newController\n    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {\n        if (parentNode == ETH_NODE) {\n            revert IncompatibleParent();\n        }\n        _unwrap(_makeNode(parentNode, labelhash), newController);\n    }\n\n    /\n     * @notice Sets fuses of a name\n     * @param node namehash of the name\n     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)\n     /\n\n    function setFuses(bytes32 node, uint32 fuses)\n        public\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_BURN_FUSES)\n        returns (uint32)\n    {\n        if (fuses &amp; PARENT_CANNOT_CONTROL != 0) {\n            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.\n            revert Unauthorised(node, msg.sender);\n        }\n\n        (address owner, uint32 oldFuses, uint64 expiry) = getData(\n            uint256(node)\n        );\n\n        fuses |= oldFuses;\n        _setFuses(node, owner, fuses, expiry);\n        return fuses;\n    }\n\n    /\n     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract\n     *     and burning the token of this contract\n     * @dev Can be called by the owner of the name in this contract\n     * @param label Label as a string of the .eth name to upgrade\n     * @param wrappedOwner The owner of the wrapped name\n     */\n\n    function upgradeETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        address resolver\n    ) public {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(ETH_NODE, labelhash);\n        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n\n        upgradeContract.wrapETH2LD(\n            label,\n            wrappedOwner,\n            fuses,\n            expiry,\n            resolver\n        );\n    }\n\n    /\n     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner or an authorised caller\n     * Requires upgraded Namewrapper to permit old Namewrapper to call setSubnodeRecord for all names\n     * @param parentNode namehash of the parent name\n     * @param label Label as a string of the name to upgrade\n     * @param wrappedOwner Owner of the name in this contract\n     * @param resolver resolver contract for this name\n     /\n\n    function upgrade(\n        bytes32 parentNode,\n        string calldata label,\n        address wrappedOwner,\n        address resolver\n    ) public {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n        upgradeContract.setSubnodeRecord(\n            parentNode,\n            label,\n            wrappedOwner,\n            resolver,\n            0,\n            fuses,\n            expiry\n        );\n    }\n\n    / @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name\n     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash(\'xyz\')\n     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256(\'vitalik\')\n     * @param fuses fuses to burn\n     * @param expiry when the fuses will expire\n     /\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) public {\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(\n            uint256(node)\n        );\n        uint64 maxExpiry;\n        if (parentNode == ETH_NODE) {\n            if (!isTokenOwnerOrApproved(node, msg.sender)) {\n                revert Unauthorised(node, msg.sender);\n            }\n            // max expiry is set to the expiry on the registrar\n            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));\n        } else {\n            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {\n                revert Unauthorised(node, msg.sender);\n            }\n\n            // max expiry is set to the expiry of the parent\n            (, , maxExpiry) = getData(uint256(parentNode));\n        }\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n\n        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed\n        if (\n            oldFuses &amp; PARENT_CANNOT_CONTROL != 0 &amp;&amp;\n            oldFuses | fuses != oldFuses\n        ) {\n            revert OperationProhibited(node);\n        }\n        fuses |= oldFuses;\n        _setFuses(node, owner, fuses, expiry);\n    }\n\n    /\n     * @notice Sets the subdomain owner in the registry and then wraps the subdomain\n     * @param parentNode parent namehash of the subdomain\n     * @param label label of the subdomain as a string\n     * @param newOwner newOwner in the registry\n     * @param fuses initial fuses for the wrapped subdomain\n     * @param expiry when the fuses will expire\n     /\n\n    function setSubnodeOwner(\n        bytes32 parentNode,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    )\n        public\n        onlyTokenOwner(parentNode)\n        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))\n        returns (bytes32 node)\n    {\n        bytes32 labelhash = keccak256(bytes(label));\n        node = _makeNode(parentNode, labelhash);\n        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);\n\n        if (ens.owner(node) != address(this)) {\n            ens.setSubnodeOwner(parentNode, labelhash, address(this));\n            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);\n        } else {\n            _transferAndBurnFuses(node, newOwner, fuses, expiry);\n        }\n    }\n\n    /\n     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain\n     * @param parentNode parent namehash of the subdomain\n     * @param label label of the subdomain as a string\n     * @param newOwner newOwner in the registry\n     * @param resolver resolver contract in the registry\n     * @param ttl ttl in the regsitry\n     * @param fuses initial fuses for the wrapped subdomain\n     * @param expiry expiry date for the domain\n     */\n\n    function setSubnodeRecord(\n        bytes32 parentNode,\n        string memory label,\n        address newOwner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    )\n        public\n        onlyTokenOwner(parentNode)\n        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))\n    {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);\n        if (ens.owner(node) != address(this)) {\n            ens.setSubnodeRecord(\n                parentNode,\n                labelhash,\n                address(this),\n                resolver,\n                ttl\n            );\n            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);\n        } else {\n            ens.setSubnodeRecord(\n                parentNode,\n                labelhash,\n                address(this),\n                resolver,\n                ttl\n            );\n            _transferAndBurnFuses(node, newOwner, fuses, expiry);\n        }\n    }\n\n    /\n     * @notice Sets records for the name in the ENS Registry\n     * @param node namehash of the name to set a record for\n     * @param owner newOwner in the registry\n     * @param resolver the resolver contract\n     * @param ttl ttl in the registry\n     /\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    )\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(\n            node,\n            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL\n        )\n    {\n        ens.setRecord(node, address(this), resolver, ttl);\n        (address oldOwner, , ) = getData(uint256(node));\n        _transfer(oldOwner, owner, uint256(node), 1, "");\n    }\n\n    /\n     * @notice Sets resolver contract in the registry\n     * @param node namehash of the name\n     * @param resolver the resolver contract\n     /\n\n    function setResolver(bytes32 node, address resolver)\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_SET_RESOLVER)\n    {\n        ens.setResolver(node, resolver);\n    }\n\n    /\n     * @notice Sets TTL in the registry\n     * @param node namehash of the name\n     * @param ttl TTL in the registry\n     */\n\n    function setTTL(bytes32 node, uint64 ttl)\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_SET_TTL)\n    {\n        ens.setTTL(node, ttl);\n    }\n\n    /\n     * @dev Allows an operation only if none of the specified fuses are burned.\n     * @param node The namehash of the name to check fuses on.\n     * @param fuseMask A bitmask of fuses that must not be burned.\n     /\n\n    modifier operationAllowed(bytes32 node, uint32 fuseMask) {\n        (, uint32 fuses, ) = getData(uint256(node));\n        if (fuses &amp; fuseMask != 0) {\n            revert OperationProhibited(node);\n        }\n        _;\n    }\n\n    /\n     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord\n     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt\n     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for\n     *      replacing a subdomain. If either conditions are true, then it is possible to call\n     *      setSubnodeOwner\n     * @param node namehash of the name to check\n     * @param labelhash labelhash of the name to check\n     /\n\n    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {\n        bytes32 subnode = makeNode(node, labelhash);\n        address owner = ens.owner(subnode);\n\n        if (owner == address(0)) {\n            (, uint32 fuses, ) = getData(uint256(node));\n            if (fuses &amp; CANNOT_CREATE_SUBDOMAIN != 0) {\n                revert OperationProhibited(node);\n            }\n        } else {\n            (, uint32 subnodeFuses, ) = getData(uint256(subnode));\n            if (subnodeFuses &amp; PARENT_CANNOT_CONTROL != 0) {\n                revert OperationProhibited(node);\n            }\n        }\n\n        ;\n    }\n\n    /*\n     * @notice Checks all Fuses in the mask are burned for the node\n     * @param node namehash of the name\n     * @param fuseMask the fuses you want to check\n     * @return Boolean of whether or not all the selected fuses are burned\n     /\n\n    function allFusesBurned(bytes32 node, uint32 fuseMask)\n        public\n        view\n        override\n        returns (bool)\n    {\n        (, uint32 fuses, ) = getData(uint256(node));\n        return fuses &amp; fuseMask == fuseMask;\n    }\n\n    function onERC721Received(\n        address to,\n        address,\n        uint256 tokenId,\n        bytes calldata data\n    ) public override returns (bytes4) {\n        //check if it\'s the eth registrar ERC721\n        if (msg.sender != address(registrar)) {\n            revert IncorrectTokenType();\n        }\n\n        (\n            string memory label,\n            address owner,\n            uint32 fuses,\n            uint64 expiry,\n            address resolver\n        ) = abi.decode(data, (string, address, uint32, uint64, address));\n\n        bytes32 labelhash = bytes32(tokenId);\n        bytes32 labelhashFromData = keccak256(bytes(label));\n\n        if (labelhashFromData != labelhash) {\n            revert LabelMismatch(labelhashFromData, labelhash);\n        }\n\n        // transfer the ens record back to the new owner (this contract)\n        registrar.reclaim(uint256(labelhash), address(this));\n\n        _wrapETH2LD(label, owner, fuses, expiry, resolver);\n\n        return IERC721Receiver(to).onERC721Received.selector;\n    }\n\n    /* Internal functions /\n\n    function _canTransfer(uint32 fuses) internal pure override returns (bool) {\n        return fuses &amp; CANNOT_TRANSFER == 0;\n    }\n\n    function _makeNode(bytes32 node, bytes32 labelhash)\n        private\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(node, labelhash));\n    }\n\n    function _addLabel(string memory label, bytes memory name)\n        internal\n        pure\n        returns (bytes memory ret)\n    {\n        if (bytes(label).length &lt; 1) {\n            revert LabelTooShort();\n        }\n        if (bytes(label).length &gt; 255) {\n            revert LabelTooLong(label);\n        }\n        return abi.encodePacked(uint8(bytes(label).length), label, name);\n    }\n\n    function _mint(\n        bytes32 node,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal override {\n        address oldWrappedOwner = ownerOf(uint256(node));\n        _canFusesBeBurned(node, fuses);\n        if (oldWrappedOwner != address(0)) {\n            // burn and unwrap old token of old owner\n            _burn(uint256(node));\n            emit NameUnwrapped(node, address(0));\n        }\n        super._mint(node, wrappedOwner, fuses, expiry);\n    }\n\n    function _wrap(\n        bytes32 node,\n        bytes memory name,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        names[node] = name;\n        _mint(node, wrappedOwner, fuses, expiry);\n        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);\n    }\n\n    function _addLabelAndWrap(\n        bytes32 parentNode,\n        bytes32 node,\n        string memory label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        bytes memory name = _addLabel(label, names[parentNode]);\n        _wrap(node, name, newOwner, fuses, expiry);\n    }\n\n    function _prepareUpgrade(bytes32 node)\n        private\n        returns (uint32 fuses, uint64 expiry)\n    {\n        if (address(upgradeContract) == address(0)) {\n            revert CannotUpgrade();\n        }\n\n        if (!isTokenOwnerOrApproved(node, msg.sender)) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        (fuses, expiry) = getFuses(node);\n\n        // burn token and fuse data\n        _burn(uint256(node));\n    }\n\n    function _transferAndBurnFuses(\n        bytes32 node,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        (address owner, , ) = getData(uint256(node));\n        _transfer(owner, newOwner, uint256(node), 1, "");\n        _setFuses(node, newOwner, fuses, expiry);\n    }\n\n    // wrapper function for stack limit\n    function _getDataAndNormaliseExpiry(\n        bytes32 parentNode,\n        bytes32 node,\n        uint64 expiry\n    )\n        internal\n        view\n        returns (\n            address owner,\n            uint32 fuses,\n            uint64\n        )\n    {\n        uint64 oldExpiry;\n        (owner, fuses, oldExpiry) = getData(uint256(node));\n        (, , uint64 maxExpiry) = getData(uint256(parentNode));\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n        return (owner, fuses, expiry);\n    }\n\n    function _getETH2LDDataAndNormaliseExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    )\n        internal\n        view\n        returns (\n            address owner,\n            uint32 fuses,\n            uint64\n        )\n    {\n        uint64 oldExpiry;\n        (owner, fuses, oldExpiry) = getData(uint256(node));\n        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n        return (owner, fuses, expiry);\n    }\n\n    function _normaliseExpiry(\n        uint64 expiry,\n        uint64 oldExpiry,\n        uint64 maxExpiry\n    ) internal pure returns (uint64) {\n        // Expiry cannot be more than maximum allowed\n        // .eth names will check registrar, non .eth check parent\n        if (expiry &gt; maxExpiry) {\n            expiry = maxExpiry;\n        }\n        // Expiry cannot be less than old expiry\n        if (expiry &lt; oldExpiry) {\n            expiry = oldExpiry;\n        }\n\n        return expiry;\n    }\n\n    function _wrapETH2LD(\n        string memory label,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address resolver\n    ) private returns (uint64) {\n        // Mint a new ERC1155 token with fuses\n        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(ETH_NODE, labelhash);\n\n        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(\n            node,\n            labelhash,\n            expiry\n        );\n\n        _addLabelAndWrap(\n            ETH_NODE,\n            node,\n            label,\n            wrappedOwner,\n            fuses | PARENT_CANNOT_CONTROL,\n            expiry\n        );\n        if (resolver != address(0)) {\n            ens.setResolver(node, resolver);\n        }\n\n        return expiry;\n    }\n\n    function _unwrap(bytes32 node, address newOwner) private {\n        if (newOwner == address(0x0) || newOwner == address(this)) {\n            revert IncorrectTargetOwner(newOwner);\n        }\n\n        if (allFusesBurned(node, CANNOT_UNWRAP)) {\n            revert OperationProhibited(node);\n        }\n\n        // Burn token and fuse data\n        _burn(uint256(node));\n        ens.setOwner(node, newOwner);\n\n        emit NameUnwrapped(node, newOwner);\n    }\n\n    function _setFuses(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        _setData(node, owner, fuses, expiry);\n        emit FusesSet(node, fuses, expiry);\n    }\n\n    function _setData(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        _canFusesBeBurned(node, fuses);\n        super._setData(uint256(node), owner, fuses, expiry);\n    }\n\n    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {\n        if (\n            fuses &amp; ~PARENT_CANNOT_CONTROL != 0 &amp;&amp;\n            fuses &amp; (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=\n            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)\n        ) {\n            revert OperationProhibited(node);\n        }\n    }\n}\n', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 20:35:59 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | //SPDX-License-Identifier: MIT pragma solidity ^0.8.4; import "./ERC1155Fuse.sol"; import "./Controllable.sol"; import "./INameWrapper.sol"; import "./INameWrapperUpgrade.sol"; import "./IMetadataService.sol"; import "../registry/ENS.sol"; import "../ethregistrar/IBaseRegistrar.sol"; import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "./BytesUtil.sol"; error Unauthorised(bytes32 node, address addr); error NameNotFound(); error IncompatibleParent(); error IncompatibleName(bytes name); error IncorrectTokenType(); error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash); error LabelTooShort(); error LabelTooLong(string label); error IncorrectTargetOwner(address owner); error CannotUpgrade(); error InvalidExpiry(bytes32 node, uint64 expiry); contract NameWrapper is     Ownable,     ERC1155Fuse,     INameWrapper,     Controllable,     IERC721Receiver {     using BytesUtils for bytes;     ENS public immutable override ens;     IBaseRegistrar public immutable override registrar;     IMetadataService public override metadataService;     mapping(bytes32 =&gt; bytes) public override names; bytes32 private constant ETH_NODE =     0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae; bytes32 private constant ROOT_NODE =     0x0000000000000000000000000000000000000000000000000000000000000000;  //A contract address to a new upgraded contract if any INameWrapperUpgrade public upgradeContract; uint64 private constant MAX_EXPIRY = type(uint64).max;  constructor(     ENS _ens,     IBaseRegistrar _registrar,     IMetadataService _metadataService ) {     ens = _ens;     registrar = _registrar;     metadataService = _metadataService;      /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */      _setData(         uint256(ETH_NODE),         address(0),         uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),         MAX_EXPIRY     );     _setData(         uint256(ROOT_NODE),         address(0),         uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),         MAX_EXPIRY     );     names[ROOT_NODE] = "\x00";     names[ETH_NODE] = "\x03eth\x00"; }  function supportsInterface(bytes4 interfaceId)     public     view     virtual     override(ERC1155Fuse, IERC165)     returns (bool) {     return         interfaceId == type(INameWrapper).interfaceId ||         super.supportsInterface(interfaceId); }  /* ERC1155 */  function ownerOf(uint256 id)     public     view     override(ERC1155Fuse, INameWrapper)     returns (address owner) {     return super.ownerOf(id); }  /* Metadata service */  /**  * @notice Set the metadata service. Only the owner can do this  */  function setMetadataService(IMetadataService _newMetadataService)     public     onlyOwner {     metadataService = _newMetadataService; }  /**  * @notice Get the metadata uri  * @return String uri of the metadata service  */  function uri(uint256 tokenId) public view override returns (string memory) {     return metadataService.uri(tokenId); }  /**  * @notice Set the address of the upgradeContract of the contract. only admin can do this  * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time  * to make the contract not upgradable.  * @param _upgradeAddress address of an upgraded contract  */  function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)     public     onlyOwner {     if (address(upgradeContract) != address(0)) {         registrar.setApprovalForAll(address(upgradeContract), false);         ens.setApprovalForAll(address(upgradeContract), false);     }      upgradeContract = _upgradeAddress;      if (address(upgradeContract) != address(0)) {         registrar.setApprovalForAll(address(upgradeContract), true);         ens.setApprovalForAll(address(upgradeContract), true);     } }  /**  * @notice Checks if msg.sender is the owner or approved by the owner of a name  * @param node namehash of the name to check  */  modifier onlyTokenOwner(bytes32 node) {     if (!isTokenOwnerOrApproved(node, msg.sender)) {         revert Unauthorised(node, msg.sender);     }      _; }  /**  * @notice Checks if owner or approved by owner  * @param node namehash of the name to check  * @param addr which address to check permissions for  * @return whether or not is owner or approved  */  function isTokenOwnerOrApproved(bytes32 node, address addr)     public     view     override     returns (bool) {     address owner = ownerOf(uint256(node));     return owner == addr || isApprovedForAll(owner, addr); }  /**  * @notice Gets fuse permissions for a specific name  * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit  *      The interface has predefined fuses for all registry permissions, but additional  *      fuses can be added for other use cases  *      Also returns expiry, which is when the fuses are set to expire.  * @param node namehash of the name to check  * @return fuses A number that represents the permissions a name has. Returns 0 when expiry &lt; block.timestamp  * @return expiry Unix time of when the name expires and fuses are to expire  */ function getFuses(bytes32 node)     public     view     override     returns (uint32 fuses, uint64 expiry) {     (, fuses, expiry) = getData(uint256(node));     if (fuses == 0 &amp;&amp; expiry == 0) {         bytes memory name = names[node];         if (name.length == 0) {             revert NameNotFound();         }     } }  /**  * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract  * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar  * @param label label as a string of the .eth domain to wrap  * @param wrappedOwner Owner of the name in this contract  * @param fuses initial fuses to set  * @param expiry when the fuses will expire  * @param resolver resolver contract address  */  function wrapETH2LD(     string calldata label,     address wrappedOwner,     uint32 fuses,     uint64 expiry,     address resolver ) public override returns (uint64) {     uint256 tokenId = uint256(keccak256(bytes(label)));     address registrant = registrar.ownerOf(tokenId);     if (         registrant != msg.sender &amp;&amp;         !isApprovedForAll(registrant, msg.sender) &amp;&amp;         !registrar.isApprovedForAll(registrant, msg.sender)     ) {         revert Unauthorised(             _makeNode(ETH_NODE, bytes32(tokenId)),             msg.sender         );     }      // transfer the token from the user to this contract     registrar.transferFrom(registrant, address(this), tokenId);      // transfer the ens record back to the new owner (this contract)     registrar.reclaim(tokenId, address(this));      return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver); }  /**  * @dev Registers a new .eth second-level domain and wraps it.  *      Only callable by authorised controllers.  * @param label The label to register (Eg, 'foo' for 'foo.eth').  * @param wrappedOwner The owner of the wrapped name.  * @param duration The duration, in seconds, to register the name for.  * @param resolver The resolver address to set on the ENS registry (optional).  * @param fuses initial fuses to set  * @param expiry when the fuses will expire  * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.  */  function registerAndWrapETH2LD(     string calldata label,     address wrappedOwner,     uint256 duration,     address resolver,     uint32 fuses,     uint64 expiry ) external override onlyController returns (uint256 registrarExpiry) {     uint256 tokenId = uint256(keccak256(bytes(label)));     registrarExpiry = registrar.register(tokenId, address(this), duration);     _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver); }  /**  * @dev Renews a .eth second-level domain.  *      Only callable by authorised controllers.  * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').  * @param duration The number of seconds to renew the name for.  * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.  */ function renew(     uint256 tokenId,     uint256 duration,     uint64 expiry ) external override onlyController returns (uint256 expires) {     bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));      expires = registrar.renew(tokenId, duration);     (address owner, uint32 fuses, uint64 oldExpiry) = getData(         uint256(node)     );     expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));      _setData(node, owner, fuses, expiry); }  /**  * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner in the registry or an authorised caller in the registry  * @param name The name to wrap, in DNS format  * @param wrappedOwner Owner of the name in this contract  * @param resolver resolver contract address  */  function wrap(     bytes calldata name,     address wrappedOwner,     address resolver ) public override {     (bytes32 labelhash, uint256 offset) = name.readLabel(0);     bytes32 parentNode = name.namehash(offset);     bytes32 node = _makeNode(parentNode, labelhash);      if (parentNode == ETH_NODE) {         revert IncompatibleParent();     }      address owner = ens.owner(node);      if (         owner != msg.sender &amp;&amp;         !isApprovedForAll(owner, msg.sender) &amp;&amp;         !ens.isApprovedForAll(owner, msg.sender)     ) {         revert Unauthorised(node, msg.sender);     }      if (resolver != address(0)) {         ens.setResolver(node, resolver);     }      ens.setOwner(node, address(this));      _wrap(node, name, wrappedOwner, 0, 0); }  /**  * @notice Unwraps a .eth domain. e.g. vitalik.eth  * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper  * @param labelhash labelhash of the .eth domain  * @param newRegistrant sets the owner in the .eth registrar to this address  * @param newController sets the owner in the registry to this address  */  function unwrapETH2LD(     bytes32 labelhash,     address newRegistrant,     address newController ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {     _unwrap(_makeNode(ETH_NODE, labelhash), newController);     registrar.transferFrom(         address(this),         newRegistrant,         uint256(labelhash)     ); }  /**  * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper  * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')  * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')  * @param newController sets the owner in the registry to this address  */  function unwrap(     bytes32 parentNode,     bytes32 labelhash,     address newController ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {     if (parentNode == ETH_NODE) {         revert IncompatibleParent();     }     _unwrap(_makeNode(parentNode, labelhash), newController); }  /**  * @notice Sets fuses of a name  * @param node namehash of the name  * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)  */  function setFuses(bytes32 node, uint32 fuses)     public     onlyTokenOwner(node)     operationAllowed(node, CANNOT_BURN_FUSES)     returns (uint32) {     if (fuses &amp; PARENT_CANNOT_CONTROL != 0) {         // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.         revert Unauthorised(node, msg.sender);     }      (address owner, uint32 oldFuses, uint64 expiry) = getData(         uint256(node)     );      fuses |= oldFuses;     _setFuses(node, owner, fuses, expiry);     return fuses; }  /**  * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract  *     and burning the token of this contract  * @dev Can be called by the owner of the name in this contract  * @param label Label as a string of the .eth name to upgrade  * @param wrappedOwner The owner of the wrapped name  */  function upgradeETH2LD(     string calldata label,     address wrappedOwner,     address resolver ) public {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(ETH_NODE, labelhash);     (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);      upgradeContract.wrapETH2LD(         label,         wrappedOwner,         fuses,         expiry,         resolver     ); }  /**  * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner or an authorised caller  * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names  * @param parentNode namehash of the parent name  * @param label Label as a string of the name to upgrade  * @param wrappedOwner Owner of the name in this contract  * @param resolver resolver contract for this name  */  function upgrade(     bytes32 parentNode,     string calldata label,     address wrappedOwner,     address resolver ) public {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(parentNode, labelhash);     (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);     upgradeContract.setSubnodeRecord(         parentNode,         label,         wrappedOwner,         resolver,         0,         fuses,         expiry     ); }  /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name  * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')  * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')  * @param fuses fuses to burn  * @param expiry when the fuses will expire  */  function setChildFuses(     bytes32 parentNode,     bytes32 labelhash,     uint32 fuses,     uint64 expiry ) public {     bytes32 node = _makeNode(parentNode, labelhash);     (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(         uint256(node)     );     uint64 maxExpiry;     if (parentNode == ETH_NODE) {         if (!isTokenOwnerOrApproved(node, msg.sender)) {             revert Unauthorised(node, msg.sender);         }         // max expiry is set to the expiry on the registrar         maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));     } else {         if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {             revert Unauthorised(node, msg.sender);         }          // max expiry is set to the expiry of the parent         (, , maxExpiry) = getData(uint256(parentNode));     }      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);      // if PARENT_CANNOT_CONTROL has been burned and fuses have changed     if (         oldFuses &amp; PARENT_CANNOT_CONTROL != 0 &amp;&amp;         oldFuses | fuses != oldFuses     ) {         revert OperationProhibited(node);     }     fuses |= oldFuses;     _setFuses(node, owner, fuses, expiry); }  /**  * @notice Sets the subdomain owner in the registry and then wraps the subdomain  * @param parentNode parent namehash of the subdomain  * @param label label of the subdomain as a string  * @param newOwner newOwner in the registry  * @param fuses initial fuses for the wrapped subdomain  * @param expiry when the fuses will expire  */  function setSubnodeOwner(     bytes32 parentNode,     string calldata label,     address newOwner,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))     returns (bytes32 node) {     bytes32 labelhash = keccak256(bytes(label));     node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);      if (ens.owner(node) != address(this)) {         ens.setSubnodeOwner(parentNode, labelhash, address(this));         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } }  /**  * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain  * @param parentNode parent namehash of the subdomain  * @param label label of the subdomain as a string  * @param newOwner newOwner in the registry  * @param resolver resolver contract in the registry  * @param ttl ttl in the regsitry  * @param fuses initial fuses for the wrapped subdomain  * @param expiry expiry date for the domain  */  function setSubnodeRecord(     bytes32 parentNode,     string memory label,     address newOwner,     address resolver,     uint64 ttl,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label))) {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);     if (ens.owner(node) != address(this)) {         ens.setSubnodeRecord(             parentNode,             labelhash,             address(this),             resolver,             ttl         );         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         ens.setSubnodeRecord(             parentNode,             labelhash,             address(this),             resolver,             ttl         );         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } }  /**  * @notice Sets records for the name in the ENS Registry  * @param node namehash of the name to set a record for  * @param owner newOwner in the registry  * @param resolver the resolver contract  * @param ttl ttl in the registry  */  function setRecord(     bytes32 node,     address owner,     address resolver,     uint64 ttl )     public     override     onlyTokenOwner(node)     operationAllowed(         node,         CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL     ) {     ens.setRecord(node, address(this), resolver, ttl);     (address oldOwner, , ) = getData(uint256(node));     _transfer(oldOwner, owner, uint256(node), 1, ""); }  /**  * @notice Sets resolver contract in the registry  * @param node namehash of the name  * @param resolver the resolver contract  */  function setResolver(bytes32 node, address resolver)     public     override     onlyTokenOwner(node)     operationAllowed(node, CANNOT_SET_RESOLVER) {     ens.setResolver(node, resolver); }  /**  * @notice Sets TTL in the registry  * @param node namehash of the name  * @param ttl TTL in the registry  */  function setTTL(bytes32 node, uint64 ttl)     public     override     onlyTokenOwner(node)     operationAllowed(node, CANNOT_SET_TTL) {     ens.setTTL(node, ttl); }  /**  * @dev Allows an operation only if none of the specified fuses are burned.  * @param node The namehash of the name to check fuses on.  * @param fuseMask A bitmask of fuses that must not be burned.  */  modifier operationAllowed(bytes32 node, uint32 fuseMask) {     (, uint32 fuses, ) = getData(uint256(node));     if (fuses &amp; fuseMask != 0) {         revert OperationProhibited(node);     }     _; }  /**  * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord  * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt  *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for  *      replacing a subdomain. If either conditions are true, then it is possible to call  *      setSubnodeOwner  * @param node namehash of the name to check  * @param labelhash labelhash of the name to check  */  modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {     bytes32 subnode = _makeNode(node, labelhash);     address owner = ens.owner(subnode);      if (owner == address(0)) {         (, uint32 fuses, ) = getData(uint256(node));         if (fuses &amp; CANNOT_CREATE_SUBDOMAIN != 0) {             revert OperationProhibited(node);         }     } else {         (, uint32 subnodeFuses, ) = getData(uint256(subnode));         if (subnodeFuses &amp; PARENT_CANNOT_CONTROL != 0) {             revert OperationProhibited(node);         }     }      _; }  /**  * @notice Checks all Fuses in the mask are burned for the node  * @param node namehash of the name  * @param fuseMask the fuses you want to check  * @return Boolean of whether or not all the selected fuses are burned  */  function allFusesBurned(bytes32 node, uint32 fuseMask)     public     view     override     returns (bool) {     (, uint32 fuses, ) = getData(uint256(node));     return fuses &amp; fuseMask == fuseMask; }  function onERC721Received(     address to,     address,     uint256 tokenId,     bytes calldata data ) public override returns (bytes4) {     //check if it's the eth registrar ERC721     if (msg.sender != address(registrar)) {         revert IncorrectTokenType();     }      (         string memory label,         address owner,         uint32 fuses,         uint64 expiry,         address resolver     ) = abi.decode(data, (string, address, uint32, uint64, address));      bytes32 labelhash = bytes32(tokenId);     bytes32 labelhashFromData = keccak256(bytes(label));      if (labelhashFromData != labelhash) {         revert LabelMismatch(labelhashFromData, labelhash);     }      // transfer the ens record back to the new owner (this contract)     registrar.reclaim(uint256(labelhash), address(this));      _wrapETH2LD(label, owner, fuses, expiry, resolver);      return IERC721Receiver(to).onERC721Received.selector; }  /***** Internal functions */  function _canTransfer(uint32 fuses) internal pure override returns (bool) {     return fuses &amp; CANNOT_TRANSFER == 0; }  function _makeNode(bytes32 node, bytes32 labelhash)     private     pure     returns (bytes32) {     return keccak256(abi.encodePacked(node, labelhash)); }  function _addLabel(string memory label, bytes memory name)     internal     pure     returns (bytes memory ret) {     if (bytes(label).length &lt; 1) {         revert LabelTooShort();     }     if (bytes(label).length &gt; 255) {         revert LabelTooLong(label);     }     return abi.encodePacked(uint8(bytes(label).length), label, name); }  function _mint(     bytes32 node,     address wrappedOwner,     uint32 fuses,     uint64 expiry ) internal override {     address oldWrappedOwner = ownerOf(uint256(node));     _canFusesBeBurned(node, fuses);     if (oldWrappedOwner != address(0)) {         // burn and unwrap old token of old owner         _burn(uint256(node));         emit NameUnwrapped(node, address(0));     }     super._mint(node, wrappedOwner, fuses, expiry); }  function _wrap(     bytes32 node,     bytes memory name,     address wrappedOwner,     uint32 fuses,     uint64 expiry ) internal {     names[node] = name;     _mint(node, wrappedOwner, fuses, expiry);     emit NameWrapped(node, name, wrappedOwner, fuses, expiry); }  function _addLabelAndWrap(     bytes32 parentNode,     bytes32 node,     string memory label,     address newOwner,     uint32 fuses,     uint64 expiry ) internal {     bytes memory name = _addLabel(label, names[parentNode]);     _wrap(node, name, newOwner, fuses, expiry); }  function _prepareUpgrade(bytes32 node)     private     returns (uint32 fuses, uint64 expiry) {     if (address(upgradeContract) == address(0)) {         revert CannotUpgrade();     }      if (!isTokenOwnerOrApproved(node, msg.sender)) {         revert Unauthorised(node, msg.sender);     }      (fuses, expiry) = getFuses(node);      // burn token and fuse data     _burn(uint256(node)); }  function _transferAndBurnFuses(     bytes32 node,     address newOwner,     uint32 fuses,     uint64 expiry ) internal {     (address owner, , ) = getData(uint256(node));     _transfer(owner, newOwner, uint256(node), 1, "");     _setFuses(node, newOwner, fuses, expiry); }  // wrapper function for stack limit function _getDataAndNormaliseExpiry(     bytes32 parentNode,     bytes32 node,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     (, , uint64 maxExpiry) = getData(uint256(parentNode));      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); }  function _getETH2LDDataAndNormaliseExpiry(     bytes32 node,     bytes32 labelhash,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); }  function _normaliseExpiry(     uint64 expiry,     uint64 oldExpiry,     uint64 maxExpiry ) internal pure returns (uint64) {     // Expiry cannot be more than maximum allowed     // .eth names will check registrar, non .eth check parent     if (expiry &gt; maxExpiry) {         expiry = maxExpiry;     }     // Expiry cannot be less than old expiry     if (expiry &lt; oldExpiry) {         expiry = oldExpiry;     }      return expiry; }  function _wrapETH2LD(     string memory label,     address wrappedOwner,     uint32 fuses,     uint64 expiry,     address resolver ) private returns (uint64) {     // Mint a new ERC1155 token with fuses     // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(ETH_NODE, labelhash);      (, , expiry) = _getETH2LDDataAndNormaliseExpiry(         node,         labelhash,         expiry     );      _addLabelAndWrap(         ETH_NODE,         node,         label,         wrappedOwner,         fuses | PARENT_CANNOT_CONTROL,         expiry     );     if (resolver != address(0)) {         ens.setResolver(node, resolver);     }      return expiry; }  function _unwrap(bytes32 node, address newOwner) private {     if (newOwner == address(0x0) || newOwner == address(this)) {         revert IncorrectTargetOwner(newOwner);     }      if (allFusesBurned(node, CANNOT_UNWRAP)) {         revert OperationProhibited(node);     }      // Burn token and fuse data     _burn(uint256(node));     ens.setOwner(node, newOwner);      emit NameUnwrapped(node, newOwner); }  function _setFuses(     bytes32 node,     address owner,     uint32 fuses,     uint64 expiry ) internal {     _setData(node, owner, fuses, expiry);     emit FusesSet(node, fuses, expiry); }  function _setData(     bytes32 node,     address owner,     uint32 fuses,     uint64 expiry ) internal {     _canFusesBeBurned(node, fuses);     super._setData(uint256(node), owner, fuses, expiry); }  function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {     if (         fuses &amp; ~PARENT_CANNOT_CONTROL != 0 &amp;&amp;         fuses &amp; (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=         (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)     ) {         revert OperationProhibited(node);     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 20:35:59 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: //SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "./ERC1155Fuse.sol";
import "./Controllable.sol";
import "./INameWrapper.sol";
import "./INameWrapperUpgrade.sol";
import "./IMetadataService.sol";
import "../registry/ENS.sol";
import "../ethregistrar/IBaseRegistrar.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./BytesUtil.sol";

error Unauthorised(bytes32 node, address addr);
error NameNotFound();
error IncompatibleParent();
error IncompatibleName(bytes name);
error IncorrectTokenType();
error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);
error LabelTooShort();
error LabelTooLong(string label);
error IncorrectTargetOwner(address owner);
error CannotUpgrade();
error InvalidExpiry(bytes32 node, uint64 expiry);

contract NameWrapper is
    Ownable,
    ERC1155Fuse,
    INameWrapper,
    Controllable,
    IERC721Receiver
{
    using BytesUtils for bytes;
    ENS public immutable override ens;
    IBaseRegistrar public immutable override registrar;
    IMetadataService public override metadataService;
    mapping(bytes32 => bytes) public override names;

    bytes32 private constant ETH_NODE =
        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
    bytes32 private constant ROOT_NODE =
        0x0000000000000000000000000000000000000000000000000000000000000000;

    //A contract address to a new upgraded contract if any
    INameWrapperUpgrade public upgradeContract;
    uint64 private constant MAX_EXPIRY = type(uint64).max;

    constructor(
        ENS _ens,
        IBaseRegistrar _registrar,
        IMetadataService _metadataService
    ) {
        ens = _ens;
        registrar = _registrar;
        metadataService = _metadataService;

        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */

        _setData(
            uint256(ETH_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        _setData(
            uint256(ROOT_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        names[ROOT_NODE] = "\x00";
        names[ETH_NODE] = "\x03eth\x00";
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Fuse, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(INameWrapper).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /* ERC1155 */

    function ownerOf(uint256 id)
        public
        view
        override(ERC1155Fuse, INameWrapper)
        returns (address owner)
    {
        return super.ownerOf(id);
    }

    /* Metadata service */

    /**
     * @notice Set the metadata service. Only the owner can do this
     */

    function setMetadataService(IMetadataService _newMetadataService)
        public
        onlyOwner
    {
        metadataService = _newMetadataService;
    }

    /**
     * @notice Get the metadata uri
     * @return String uri of the metadata service
     */

    function uri(uint256 tokenId) public view override returns (string memory) {
        return metadataService.uri(tokenId);
    }

    /**
     * @notice Set the address of the upgradeContract of the contract. only admin can do this
     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time
     * to make the contract not upgradable.
     * @param _upgradeAddress address of an upgraded contract
     */

    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)
        public
        onlyOwner
    {
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), false);
            ens.setApprovalForAll(address(upgradeContract), false);
        }

        upgradeContract = _upgradeAddress;

        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), true);
            ens.setApprovalForAll(address(upgradeContract), true);
        }
    }

    /**
     * @notice Checks if msg.sender is the owner or approved by the owner of a name
     * @param node namehash of the name to check
     */

    modifier onlyTokenOwner(bytes32 node) {
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        _;
    }

    /**
     * @notice Checks if owner or approved by owner
     * @param node namehash of the name to check
     * @param addr which address to check permissions for
     * @return whether or not is owner or approved
     */

    function isTokenOwnerOrApproved(bytes32 node, address addr)
        public
        view
        override
        returns (bool)
    {
        address owner = ownerOf(uint256(node));
        return owner == addr || isApprovedForAll(owner, addr);
    }

    /**
     * @notice Gets fuse permissions for a specific name
     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit
     *      The interface has predefined fuses for all registry permissions, but additional
     *      fuses can be added for other use cases
     *      Also returns expiry, which is when the fuses are set to expire.
     * @param node namehash of the name to check
     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp
     * @return expiry Unix time of when the name expires and fuses are to expire
     */
    function getFuses(bytes32 node)
        public
        view
        override
        returns (uint32 fuses, uint64 expiry)
    {
        (, fuses, expiry) = getData(uint256(node));
        if (fuses == 0 && expiry == 0) {
            bytes memory name = names[node];
            if (name.length == 0) {
                revert NameNotFound();
            }
        }
    }

    /**
     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract
     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar
     * @param label label as a string of the .eth domain to wrap
     * @param wrappedOwner Owner of the name in this contract
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @param resolver resolver contract address
     */

    function wrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) public override returns (uint64) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        address registrant = registrar.ownerOf(tokenId);
        if (
            registrant != msg.sender &&
            !isApprovedForAll(registrant, msg.sender) &&
            !registrar.isApprovedForAll(registrant, msg.sender)
        ) {
            revert Unauthorised(
                _makeNode(ETH_NODE, bytes32(tokenId)),
                msg.sender
            );
        }

        // transfer the token from the user to this contract
        registrar.transferFrom(registrant, address(this), tokenId);

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(tokenId, address(this));

        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Registers a new .eth second-level domain and wraps it.
     *      Only callable by authorised controllers.
     * @param label The label to register (Eg, 'foo' for 'foo.eth').
     * @param wrappedOwner The owner of the wrapped name.
     * @param duration The duration, in seconds, to register the name for.
     * @param resolver The resolver address to set on the ENS registry (optional).
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.
     */

    function registerAndWrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint256 duration,
        address resolver,
        uint32 fuses,
        uint64 expiry
    ) external override onlyController returns (uint256 registrarExpiry) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        registrarExpiry = registrar.register(tokenId, address(this), duration);
        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Renews a .eth second-level domain.
     *      Only callable by authorised controllers.
     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').
     * @param duration The number of seconds to renew the name for.
     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.
     */
    function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));

        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));

        _setData(node, owner, fuses, expiry);
    }

    /**
     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the registry or an authorised caller in the registry
     * @param name The name to wrap, in DNS format
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract address
     */

    function wrap(
        bytes calldata name,
        address wrappedOwner,
        address resolver
    ) public override {
        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
        bytes32 parentNode = name.namehash(offset);
        bytes32 node = _makeNode(parentNode, labelhash);

        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }

        address owner = ens.owner(node);

        if (
            owner != msg.sender &&
            !isApprovedForAll(owner, msg.sender) &&
            !ens.isApprovedForAll(owner, msg.sender)
        ) {
            revert Unauthorised(node, msg.sender);
        }

        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        ens.setOwner(node, address(this));

        _wrap(node, name, wrappedOwner, 0, 0);
    }

    /**
     * @notice Unwraps a .eth domain. e.g. vitalik.eth
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param labelhash labelhash of the .eth domain
     * @param newRegistrant sets the owner in the .eth registrar to this address
     * @param newController sets the owner in the registry to this address
     */

    function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }

    /**
     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param newController sets the owner in the registry to this address
     */

    function unwrap(
        bytes32 parentNode,
        bytes32 labelhash,
        address newController
    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        _unwrap(_makeNode(parentNode, labelhash), newController);
    }

    /**
     * @notice Sets fuses of a name
     * @param node namehash of the name
     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)
     */

    function setFuses(bytes32 node, uint32 fuses)
        public
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_BURN_FUSES)
        returns (uint32)
    {
        if (fuses & PARENT_CANNOT_CONTROL != 0) {
            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.
            revert Unauthorised(node, msg.sender);
        }

        (address owner, uint32 oldFuses, uint64 expiry) = getData(
            uint256(node)
        );

        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
        return fuses;
    }

    /**
     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract
     *     and burning the token of this contract
     * @dev Can be called by the owner of the name in this contract
     * @param label Label as a string of the .eth name to upgrade
     * @param wrappedOwner The owner of the wrapped name
     */

    function upgradeETH2LD(
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);

        upgradeContract.wrapETH2LD(
            label,
            wrappedOwner,
            fuses,
            expiry,
            resolver
        );
    }

    /**
     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner or an authorised caller
     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names
     * @param parentNode namehash of the parent name
     * @param label Label as a string of the name to upgrade
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract for this name
     */

    function upgrade(
        bytes32 parentNode,
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.setSubnodeRecord(
            parentNode,
            label,
            wrappedOwner,
            resolver,
            0,
            fuses,
            expiry
        );
    }

    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param fuses fuses to burn
     * @param expiry when the fuses will expire
     */

    function setChildFuses(
        bytes32 parentNode,
        bytes32 labelhash,
        uint32 fuses,
        uint64 expiry
    ) public {
        bytes32 node = _makeNode(parentNode, labelhash);
        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        uint64 maxExpiry;
        if (parentNode == ETH_NODE) {
            if (!isTokenOwnerOrApproved(node, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            // max expiry is set to the expiry on the registrar
            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        } else {
            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }

            // max expiry is set to the expiry of the parent
            (, , maxExpiry) = getData(uint256(parentNode));
        }

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);

        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed
        if (
            oldFuses & PARENT_CANNOT_CONTROL != 0 &&
            oldFuses | fuses != oldFuses
        ) {
            revert OperationProhibited(node);
        }
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
    }

    /**
     * @notice Sets the subdomain owner in the registry and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry when the fuses will expire
     */

    function setSubnodeOwner(
        bytes32 parentNode,
        string calldata label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
        returns (bytes32 node)
    {
        bytes32 labelhash = keccak256(bytes(label));
        node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);

        if (ens.owner(node) != address(this)) {
            ens.setSubnodeOwner(parentNode, labelhash, address(this));
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param resolver resolver contract in the registry
     * @param ttl ttl in the regsitry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry expiry date for the domain
     */

    function setSubnodeRecord(
        bytes32 parentNode,
        string memory label,
        address newOwner,
        address resolver,
        uint64 ttl,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
    {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets records for the name in the ENS Registry
     * @param node namehash of the name to set a record for
     * @param owner newOwner in the registry
     * @param resolver the resolver contract
     * @param ttl ttl in the registry
     */

    function setRecord(
        bytes32 node,
        address owner,
        address resolver,
        uint64 ttl
    )
        public
        override
        onlyTokenOwner(node)
        operationAllowed(
            node,
            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL
        )
    {
        ens.setRecord(node, address(this), resolver, ttl);
        (address oldOwner, , ) = getData(uint256(node));
        _transfer(oldOwner, owner, uint256(node), 1, "");
    }

    /**
     * @notice Sets resolver contract in the registry
     * @param node namehash of the name
     * @param resolver the resolver contract
     */

    function setResolver(bytes32 node, address resolver)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_RESOLVER)
    {
        ens.setResolver(node, resolver);
    }

    /**
     * @notice Sets TTL in the registry
     * @param node namehash of the name
     * @param ttl TTL in the registry
     */

    function setTTL(bytes32 node, uint64 ttl)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_TTL)
    {
        ens.setTTL(node, ttl);
    }

    /**
     * @dev Allows an operation only if none of the specified fuses are burned.
     * @param node The namehash of the name to check fuses on.
     * @param fuseMask A bitmask of fuses that must not be burned.
     */

    modifier operationAllowed(bytes32 node, uint32 fuseMask) {
        (, uint32 fuses, ) = getData(uint256(node));
        if (fuses & fuseMask != 0) {
            revert OperationProhibited(node);
        }
        _;
    }

    /**
     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord
     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt
     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for
     *      replacing a subdomain. If either conditions are true, then it is possible to call
     *      setSubnodeOwner
     * @param node namehash of the name to check
     * @param labelhash labelhash of the name to check
     */

    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {
        bytes32 subnode = _makeNode(node, labelhash);
        address owner = ens.owner(subnode);

        if (owner == address(0)) {
            (, uint32 fuses, ) = getData(uint256(node));
            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {
                revert OperationProhibited(node);
            }
        } else {
            (, uint32 subnodeFuses, ) = getData(uint256(subnode));
            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {
                revert OperationProhibited(node);
            }
        }

        _;
    }

    /**
     * @notice Checks all Fuses in the mask are burned for the node
     * @param node namehash of the name
     * @param fuseMask the fuses you want to check
     * @return Boolean of whether or not all the selected fuses are burned
     */

    function allFusesBurned(bytes32 node, uint32 fuseMask)
        public
        view
        override
        returns (bool)
    {
        (, uint32 fuses, ) = getData(uint256(node));
        return fuses & fuseMask == fuseMask;
    }

    function onERC721Received(
        address to,
        address,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        //check if it's the eth registrar ERC721
        if (msg.sender != address(registrar)) {
            revert IncorrectTokenType();
        }

        (
            string memory label,
            address owner,
            uint32 fuses,
            uint64 expiry,
            address resolver
        ) = abi.decode(data, (string, address, uint32, uint64, address));

        bytes32 labelhash = bytes32(tokenId);
        bytes32 labelhashFromData = keccak256(bytes(label));

        if (labelhashFromData != labelhash) {
            revert LabelMismatch(labelhashFromData, labelhash);
        }

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(uint256(labelhash), address(this));

        _wrapETH2LD(label, owner, fuses, expiry, resolver);

        return IERC721Receiver(to).onERC721Received.selector;
    }

    /***** Internal functions */

    function _canTransfer(uint32 fuses) internal pure override returns (bool) {
        return fuses & CANNOT_TRANSFER == 0;
    }

    function _makeNode(bytes32 node, bytes32 labelhash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, labelhash));
    }

    function _addLabel(string memory label, bytes memory name)
        internal
        pure
        returns (bytes memory ret)
    {
        if (bytes(label).length < 1) {
            revert LabelTooShort();
        }
        if (bytes(label).length > 255) {
            revert LabelTooLong(label);
        }
        return abi.encodePacked(uint8(bytes(label).length), label, name);
    }

    function _mint(
        bytes32 node,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal override {
        address oldWrappedOwner = ownerOf(uint256(node));
        _canFusesBeBurned(node, fuses);
        if (oldWrappedOwner != address(0)) {
            // burn and unwrap old token of old owner
            _burn(uint256(node));
            emit NameUnwrapped(node, address(0));
        }
        super._mint(node, wrappedOwner, fuses, expiry);
    }

    function _wrap(
        bytes32 node,
        bytes memory name,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        names[node] = name;
        _mint(node, wrappedOwner, fuses, expiry);
        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);
    }

    function _addLabelAndWrap(
        bytes32 parentNode,
        bytes32 node,
        string memory label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        bytes memory name = _addLabel(label, names[parentNode]);
        _wrap(node, name, newOwner, fuses, expiry);
    }

    function _prepareUpgrade(bytes32 node)
        private
        returns (uint32 fuses, uint64 expiry)
    {
        if (address(upgradeContract) == address(0)) {
            revert CannotUpgrade();
        }

        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        (fuses, expiry) = getFuses(node);

        // burn token and fuse data
        _burn(uint256(node));
    }

    function _transferAndBurnFuses(
        bytes32 node,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        (address owner, , ) = getData(uint256(node));
        _transfer(owner, newOwner, uint256(node), 1, "");
        _setFuses(node, newOwner, fuses, expiry);
    }

    // wrapper function for stack limit
    function _getDataAndNormaliseExpiry(
        bytes32 parentNode,
        bytes32 node,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        (, , uint64 maxExpiry) = getData(uint256(parentNode));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _getETH2LDDataAndNormaliseExpiry(
        bytes32 node,
        bytes32 labelhash,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _normaliseExpiry(
        uint64 expiry,
        uint64 oldExpiry,
        uint64 maxExpiry
    ) internal pure returns (uint64) {
        // Expiry cannot be more than maximum allowed
        // .eth names will check registrar, non .eth check parent
        if (expiry > maxExpiry) {
            expiry = maxExpiry;
        }
        // Expiry cannot be less than old expiry
        if (expiry < oldExpiry) {
            expiry = oldExpiry;
        }

        return expiry;
    }

    function _wrapETH2LD(
        string memory label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) private returns (uint64) {
        // Mint a new ERC1155 token with fuses
        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);

        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(
            node,
            labelhash,
            expiry
        );

        _addLabelAndWrap(
            ETH_NODE,
            node,
            label,
            wrappedOwner,
            fuses | PARENT_CANNOT_CONTROL,
            expiry
        );
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        return expiry;
    }

    function _unwrap(bytes32 node, address newOwner) private {
        if (newOwner == address(0x0) || newOwner == address(this)) {
            revert IncorrectTargetOwner(newOwner);
        }

        if (allFusesBurned(node, CANNOT_UNWRAP)) {
            revert OperationProhibited(node);
        }

        // Burn token and fuse data
        _burn(uint256(node));
        ens.setOwner(node, newOwner);

        emit NameUnwrapped(node, newOwner);
    }

    function _setFuses(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _setData(node, owner, fuses, expiry);
        emit FusesSet(node, fuses, expiry);
    }

    function _setData(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _canFusesBeBurned(node, fuses);
        super._setData(uint256(node), owner, fuses, expiry);
    }

    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
        if (
            fuses & ~PARENT_CANNOT_CONTROL != 0 &&
            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
        ) {
            revert OperationProhibited(node);
        }
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "//SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "./ERC1155Fuse.sol";
import "./Controllable.sol";
import "./INameWrapper.sol";
import "./INameWrapperUpgrade.sol";
import "./IMetadataService.sol";
import "../registry/ENS.sol";
import "../ethregistrar/IBaseRegistrar.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./BytesUtil.sol";

error Unauthorised(bytes32 node, address addr);
error NameNotFound();
error IncompatibleParent();
error IncompatibleName(bytes name);
error IncorrectTokenType();
error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);
error LabelTooShort();
error LabelTooLong(string label);
error IncorrectTargetOwner(address owner);
error CannotUpgrade();
error InvalidExpiry(bytes32 node, uint64 expiry);

contract NameWrapper is
    Ownable,
    ERC1155Fuse,
    INameWrapper,
    Controllable,
    IERC721Receiver
{
    using BytesUtils for bytes;
    ENS public immutable override ens;
    IBaseRegistrar public immutable override registrar;
    IMetadataService public override metadataService;
    mapping(bytes32 => bytes) public override names;

    bytes32 private constant ETH_NODE =
        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
    bytes32 private constant ROOT_NODE =
        0x0000000000000000000000000000000000000000000000000000000000000000;

    //A contract address to a new upgraded contract if any
    INameWrapperUpgrade public upgradeContract;
    uint64 private constant MAX_EXPIRY = type(uint64).max;

    constructor(
        ENS _ens,
        IBaseRegistrar _registrar,
        IMetadataService _metadataService
    ) {
        ens = _ens;
        registrar = _registrar;
        metadataService = _metadataService;

        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */

        _setData(
            uint256(ETH_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        _setData(
            uint256(ROOT_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        names[ROOT_NODE] = "\x00";
        names[ETH_NODE] = "\x03eth\x00";
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Fuse, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(INameWrapper).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /* ERC1155 */

    function ownerOf(uint256 id)
        public
        view
        override(ERC1155Fuse, INameWrapper)
        returns (address owner)
    {
        return super.ownerOf(id);
    }

    /* Metadata service */

    /**
     * @notice Set the metadata service. Only the owner can do this
     */

    function setMetadataService(IMetadataService _newMetadataService)
        public
        onlyOwner
    {
        metadataService = _newMetadataService;
    }

    /**
     * @notice Get the metadata uri
     * @return String uri of the metadata service
     */

    function uri(uint256 tokenId) public view override returns (string memory) {
        return metadataService.uri(tokenId);
    }

    /**
     * @notice Set the address of the upgradeContract of the contract. only admin can do this
     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time
     * to make the contract not upgradable.
     * @param _upgradeAddress address of an upgraded contract
     */

    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)
        public
        onlyOwner
    {
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), false);
            ens.setApprovalForAll(address(upgradeContract), false);
        }

        upgradeContract = _upgradeAddress;

        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), true);
            ens.setApprovalForAll(address(upgradeContract), true);
        }
    }

    /**
     * @notice Checks if msg.sender is the owner or approved by the owner of a name
     * @param node namehash of the name to check
     */

    modifier onlyTokenOwner(bytes32 node) {
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        _;
    }

    /**
     * @notice Checks if owner or approved by owner
     * @param node namehash of the name to check
     * @param addr which address to check permissions for
     * @return whether or not is owner or approved
     */

    function isTokenOwnerOrApproved(bytes32 node, address addr)
        public
        view
        override
        returns (bool)
    {
        address owner = ownerOf(uint256(node));
        return owner == addr || isApprovedForAll(owner, addr);
    }

    /**
     * @notice Gets fuse permissions for a specific name
     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit
     *      The interface has predefined fuses for all registry permissions, but additional
     *      fuses can be added for other use cases
     *      Also returns expiry, which is when the fuses are set to expire.
     * @param node namehash of the name to check
     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp
     * @return expiry Unix time of when the name expires and fuses are to expire
     */
    function getFuses(bytes32 node)
        public
        view
        override
        returns (uint32 fuses, uint64 expiry)
    {
        (, fuses, expiry) = getData(uint256(node));
        if (fuses == 0 && expiry == 0) {
            bytes memory name = names[node];
            if (name.length == 0) {
                revert NameNotFound();
            }
        }
    }

    /**
     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract
     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar
     * @param label label as a string of the .eth domain to wrap
     * @param wrappedOwner Owner of the name in this contract
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @param resolver resolver contract address
     */

    function wrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) public override returns (uint64) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        address registrant = registrar.ownerOf(tokenId);
        if (
            registrant != msg.sender &&
            !isApprovedForAll(registrant, msg.sender) &&
            !registrar.isApprovedForAll(registrant, msg.sender)
        ) {
            revert Unauthorised(
                _makeNode(ETH_NODE, bytes32(tokenId)),
                msg.sender
            );
        }

        // transfer the token from the user to this contract
        registrar.transferFrom(registrant, address(this), tokenId);

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(tokenId, address(this));

        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Registers a new .eth second-level domain and wraps it.
     *      Only callable by authorised controllers.
     * @param label The label to register (Eg, 'foo' for 'foo.eth').
     * @param wrappedOwner The owner of the wrapped name.
     * @param duration The duration, in seconds, to register the name for.
     * @param resolver The resolver address to set on the ENS registry (optional).
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.
     */

    function registerAndWrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint256 duration,
        address resolver,
        uint32 fuses,
        uint64 expiry
    ) external override onlyController returns (uint256 registrarExpiry) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        registrarExpiry = registrar.register(tokenId, address(this), duration);
        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Renews a .eth second-level domain.
     *      Only callable by authorised controllers.
     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').
     * @param duration The number of seconds to renew the name for.
     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.
     */
    function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));

        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));

        _setData(node, owner, fuses, expiry);
    }

    /**
     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the registry or an authorised caller in the registry
     * @param name The name to wrap, in DNS format
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract address
     */

    function wrap(
        bytes calldata name,
        address wrappedOwner,
        address resolver
    ) public override {
        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
        bytes32 parentNode = name.namehash(offset);
        bytes32 node = _makeNode(parentNode, labelhash);

        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }

        address owner = ens.owner(node);

        if (
            owner != msg.sender &&
            !isApprovedForAll(owner, msg.sender) &&
            !ens.isApprovedForAll(owner, msg.sender)
        ) {
            revert Unauthorised(node, msg.sender);
        }

        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        ens.setOwner(node, address(this));

        _wrap(node, name, wrappedOwner, 0, 0);
    }

    /**
     * @notice Unwraps a .eth domain. e.g. vitalik.eth
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param labelhash labelhash of the .eth domain
     * @param newRegistrant sets the owner in the .eth registrar to this address
     * @param newController sets the owner in the registry to this address
     */

    function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }

    /**
     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param newController sets the owner in the registry to this address
     */

    function unwrap(
        bytes32 parentNode,
        bytes32 labelhash,
        address newController
    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        _unwrap(_makeNode(parentNode, labelhash), newController);
    }

    /**
     * @notice Sets fuses of a name
     * @param node namehash of the name
     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)
     */

    function setFuses(bytes32 node, uint32 fuses)
        public
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_BURN_FUSES)
        returns (uint32)
    {
        if (fuses & PARENT_CANNOT_CONTROL != 0) {
            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.
            revert Unauthorised(node, msg.sender);
        }

        (address owner, uint32 oldFuses, uint64 expiry) = getData(
            uint256(node)
        );

        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
        return fuses;
    }

    /**
     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract
     *     and burning the token of this contract
     * @dev Can be called by the owner of the name in this contract
     * @param label Label as a string of the .eth name to upgrade
     * @param wrappedOwner The owner of the wrapped name
     */

    function upgradeETH2LD(
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);

        upgradeContract.wrapETH2LD(
            label,
            wrappedOwner,
            fuses,
            expiry,
            resolver
        );
    }

    /**
     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner or an authorised caller
     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names
     * @param parentNode namehash of the parent name
     * @param label Label as a string of the name to upgrade
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract for this name
     */

    function upgrade(
        bytes32 parentNode,
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.setSubnodeRecord(
            parentNode,
            label,
            wrappedOwner,
            resolver,
            0,
            fuses,
            expiry
        );
    }

    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param fuses fuses to burn
     * @param expiry when the fuses will expire
     */

    function setChildFuses(
        bytes32 parentNode,
        bytes32 labelhash,
        uint32 fuses,
        uint64 expiry
    ) public {
        bytes32 node = _makeNode(parentNode, labelhash);
        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        uint64 maxExpiry;
        if (parentNode == ETH_NODE) {
            if (!isTokenOwnerOrApproved(node, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            // max expiry is set to the expiry on the registrar
            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        } else {
            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }

            // max expiry is set to the expiry of the parent
            (, , maxExpiry) = getData(uint256(parentNode));
        }

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);

        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed
        if (
            oldFuses & PARENT_CANNOT_CONTROL != 0 &&
            oldFuses | fuses != oldFuses
        ) {
            revert OperationProhibited(node);
        }
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
    }

    /**
     * @notice Sets the subdomain owner in the registry and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry when the fuses will expire
     */

    function setSubnodeOwner(
        bytes32 parentNode,
        string calldata label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
        returns (bytes32 node)
    {
        bytes32 labelhash = keccak256(bytes(label));
        node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);

        if (ens.owner(node) != address(this)) {
            ens.setSubnodeOwner(parentNode, labelhash, address(this));
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param resolver resolver contract in the registry
     * @param ttl ttl in the regsitry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry expiry date for the domain
     */

    function setSubnodeRecord(
        bytes32 parentNode,
        string memory label,
        address newOwner,
        address resolver,
        uint64 ttl,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
    {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets records for the name in the ENS Registry
     * @param node namehash of the name to set a record for
     * @param owner newOwner in the registry
     * @param resolver the resolver contract
     * @param ttl ttl in the registry
     */

    function setRecord(
        bytes32 node,
        address owner,
        address resolver,
        uint64 ttl
    )
        public
        override
        onlyTokenOwner(node)
        operationAllowed(
            node,
            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL
        )
    {
        ens.setRecord(node, address(this), resolver, ttl);
        (address oldOwner, , ) = getData(uint256(node));
        _transfer(oldOwner, owner, uint256(node), 1, "");
    }

    /**
     * @notice Sets resolver contract in the registry
     * @param node namehash of the name
     * @param resolver the resolver contract
     */

    function setResolver(bytes32 node, address resolver)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_RESOLVER)
    {
        ens.setResolver(node, resolver);
    }

    /**
     * @notice Sets TTL in the registry
     * @param node namehash of the name
     * @param ttl TTL in the registry
     */

    function setTTL(bytes32 node, uint64 ttl)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_TTL)
    {
        ens.setTTL(node, ttl);
    }

    /**
     * @dev Allows an operation only if none of the specified fuses are burned.
     * @param node The namehash of the name to check fuses on.
     * @param fuseMask A bitmask of fuses that must not be burned.
     */

    modifier operationAllowed(bytes32 node, uint32 fuseMask) {
        (, uint32 fuses, ) = getData(uint256(node));
        if (fuses & fuseMask != 0) {
            revert OperationProhibited(node);
        }
        _;
    }

    /**
     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord
     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt
     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for
     *      replacing a subdomain. If either conditions are true, then it is possible to call
     *      setSubnodeOwner
     * @param node namehash of the name to check
     * @param labelhash labelhash of the name to check
     */

    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {
        bytes32 subnode = _makeNode(node, labelhash);
        address owner = ens.owner(subnode);

        if (owner == address(0)) {
            (, uint32 fuses, ) = getData(uint256(node));
            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {
                revert OperationProhibited(node);
            }
        } else {
            (, uint32 subnodeFuses, ) = getData(uint256(subnode));
            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {
                revert OperationProhibited(node);
            }
        }

        _;
    }

    /**
     * @notice Checks all Fuses in the mask are burned for the node
     * @param node namehash of the name
     * @param fuseMask the fuses you want to check
     * @return Boolean of whether or not all the selected fuses are burned
     */

    function allFusesBurned(bytes32 node, uint32 fuseMask)
        public
        view
        override
        returns (bool)
    {
        (, uint32 fuses, ) = getData(uint256(node));
        return fuses & fuseMask == fuseMask;
    }

    function onERC721Received(
        address to,
        address,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        //check if it's the eth registrar ERC721
        if (msg.sender != address(registrar)) {
            revert IncorrectTokenType();
        }

        (
            string memory label,
            address owner,
            uint32 fuses,
            uint64 expiry,
            address resolver
        ) = abi.decode(data, (string, address, uint32, uint64, address));

        bytes32 labelhash = bytes32(tokenId);
        bytes32 labelhashFromData = keccak256(bytes(label));

        if (labelhashFromData != labelhash) {
            revert LabelMismatch(labelhashFromData, labelhash);
        }

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(uint256(labelhash), address(this));

        _wrapETH2LD(label, owner, fuses, expiry, resolver);

        return IERC721Receiver(to).onERC721Received.selector;
    }

    /***** Internal functions */

    function _canTransfer(uint32 fuses) internal pure override returns (bool) {
        return fuses & CANNOT_TRANSFER == 0;
    }

    function _makeNode(bytes32 node, bytes32 labelhash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, labelhash));
    }

    function _addLabel(string memory label, bytes memory name)
        internal
        pure
        returns (bytes memory ret)
    {
        if (bytes(label).length < 1) {
            revert LabelTooShort();
        }
        if (bytes(label).length > 255) {
            revert LabelTooLong(label);
        }
        return abi.encodePacked(uint8(bytes(label).length), label, name);
    }

    function _mint(
        bytes32 node,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal override {
        address oldWrappedOwner = ownerOf(uint256(node));
        _canFusesBeBurned(node, fuses);
        if (oldWrappedOwner != address(0)) {
            // burn and unwrap old token of old owner
            _burn(uint256(node));
            emit NameUnwrapped(node, address(0));
        }
        super._mint(node, wrappedOwner, fuses, expiry);
    }

    function _wrap(
        bytes32 node,
        bytes memory name,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        names[node] = name;
        _mint(node, wrappedOwner, fuses, expiry);
        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);
    }

    function _addLabelAndWrap(
        bytes32 parentNode,
        bytes32 node,
        string memory label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        bytes memory name = _addLabel(label, names[parentNode]);
        _wrap(node, name, newOwner, fuses, expiry);
    }

    function _prepareUpgrade(bytes32 node)
        private
        returns (uint32 fuses, uint64 expiry)
    {
        if (address(upgradeContract) == address(0)) {
            revert CannotUpgrade();
        }

        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        (fuses, expiry) = getFuses(node);

        // burn token and fuse data
        _burn(uint256(node));
    }

    function _transferAndBurnFuses(
        bytes32 node,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        (address owner, , ) = getData(uint256(node));
        _transfer(owner, newOwner, uint256(node), 1, "");
        _setFuses(node, newOwner, fuses, expiry);
    }

    // wrapper function for stack limit
    function _getDataAndNormaliseExpiry(
        bytes32 parentNode,
        bytes32 node,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        (, , uint64 maxExpiry) = getData(uint256(parentNode));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _getETH2LDDataAndNormaliseExpiry(
        bytes32 node,
        bytes32 labelhash,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _normaliseExpiry(
        uint64 expiry,
        uint64 oldExpiry,
        uint64 maxExpiry
    ) internal pure returns (uint64) {
        // Expiry cannot be more than maximum allowed
        // .eth names will check registrar, non .eth check parent
        if (expiry > maxExpiry) {
            expiry = maxExpiry;
        }
        // Expiry cannot be less than old expiry
        if (expiry < oldExpiry) {
            expiry = oldExpiry;
        }

        return expiry;
    }

    function _wrapETH2LD(
        string memory label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) private returns (uint64) {
        // Mint a new ERC1155 token with fuses
        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);

        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(
            node,
            labelhash,
            expiry
        );

        _addLabelAndWrap(
            ETH_NODE,
            node,
            label,
            wrappedOwner,
            fuses | PARENT_CANNOT_CONTROL,
            expiry
        );
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        return expiry;
    }

    function _unwrap(bytes32 node, address newOwner) private {
        if (newOwner == address(0x0) || newOwner == address(this)) {
            revert IncorrectTargetOwner(newOwner);
        }

        if (allFusesBurned(node, CANNOT_UNWRAP)) {
            revert OperationProhibited(node);
        }

        // Burn token and fuse data
        _burn(uint256(node));
        ens.setOwner(node, newOwner);

        emit NameUnwrapped(node, newOwner);
    }

    function _setFuses(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _setData(node, owner, fuses, expiry);
        emit FusesSet(node, fuses, expiry);
    }

    function _setData(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _canFusesBeBurned(node, fuses);
        super._setData(uint256(node), owner, fuses, expiry);
    }

    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
        if (
            fuses & ~PARENT_CANNOT_CONTROL != 0 &&
            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
        ) {
            revert OperationProhibited(node);
        }
    }
}
".
Ideas: " 1".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-01-09 20:36:10 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 20:36:10 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 14282
completion_tokens: 900
total_tokens: 15182
cost: $-1.000000


[2024-01-09 20:36:10 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: //SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "./ERC1155Fuse.sol";
import "./Controllable.sol";
import "./INameWrapper.sol";
import "./INameWrapperUpgrade.sol";
import "./IMetadataService.sol";
import "../registry/ENS.sol";
import "../ethregistrar/IBaseRegistrar.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./BytesUtil.sol";

error Unauthorised(bytes32 node, address addr);
error NameNotFound();
error IncompatibleParent();
error IncompatibleName(bytes name);
error IncorrectTokenType();
error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);
error LabelTooShort();
error LabelTooLong(string label);
error IncorrectTargetOwner(address owner);
error CannotUpgrade();
error InvalidExpiry(bytes32 node, uint64 expiry);

contract NameWrapper is
    Ownable,
    ERC1155Fuse,
    INameWrapper,
    Controllable,
    IERC721Receiver
{
    using BytesUtils for bytes;
    ENS public immutable override ens;
    IBaseRegistrar public immutable override registrar;
    IMetadataService public override metadataService;
    mapping(bytes32 => bytes) public override names;

    bytes32 private constant ETH_NODE =
        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
    bytes32 private constant ROOT_NODE =
        0x0000000000000000000000000000000000000000000000000000000000000000;

    //A contract address to a new upgraded contract if any
    INameWrapperUpgrade public upgradeContract;
    uint64 private constant MAX_EXPIRY = type(uint64).max;

    constructor(
        ENS _ens,
        IBaseRegistrar _registrar,
        IMetadataService _metadataService
    ) {
        ens = _ens;
        registrar = _registrar;
        metadataService = _metadataService;

        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */

        _setData(
            uint256(ETH_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        _setData(
            uint256(ROOT_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        names[ROOT_NODE] = "\x00";
        names[ETH_NODE] = "\x03eth\x00";
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Fuse, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(INameWrapper).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /* ERC1155 */

    function ownerOf(uint256 id)
        public
        view
        override(ERC1155Fuse, INameWrapper)
        returns (address owner)
    {
        return super.ownerOf(id);
    }

    /* Metadata service */

    /**
     * @notice Set the metadata service. Only the owner can do this
     */

    function setMetadataService(IMetadataService _newMetadataService)
        public
        onlyOwner
    {
        metadataService = _newMetadataService;
    }

    /**
     * @notice Get the metadata uri
     * @return String uri of the metadata service
     */

    function uri(uint256 tokenId) public view override returns (string memory) {
        return metadataService.uri(tokenId);
    }

    /**
     * @notice Set the address of the upgradeContract of the contract. only admin can do this
     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time
     * to make the contract not upgradable.
     * @param _upgradeAddress address of an upgraded contract
     */

    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)
        public
        onlyOwner
    {
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), false);
            ens.setApprovalForAll(address(upgradeContract), false);
        }

        upgradeContract = _upgradeAddress;

        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), true);
            ens.setApprovalForAll(address(upgradeContract), true);
        }
    }

    /**
     * @notice Checks if msg.sender is the owner or approved by the owner of a name
     * @param node namehash of the name to check
     */

    modifier onlyTokenOwner(bytes32 node) {
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        _;
    }

    /**
     * @notice Checks if owner or approved by owner
     * @param node namehash of the name to check
     * @param addr which address to check permissions for
     * @return whether or not is owner or approved
     */

    function isTokenOwnerOrApproved(bytes32 node, address addr)
        public
        view
        override
        returns (bool)
    {
        address owner = ownerOf(uint256(node));
        return owner == addr || isApprovedForAll(owner, addr);
    }

    /**
     * @notice Gets fuse permissions for a specific name
     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit
     *      The interface has predefined fuses for all registry permissions, but additional
     *      fuses can be added for other use cases
     *      Also returns expiry, which is when the fuses are set to expire.
     * @param node namehash of the name to check
     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp
     * @return expiry Unix time of when the name expires and fuses are to expire
     */
    function getFuses(bytes32 node)
        public
        view
        override
        returns (uint32 fuses, uint64 expiry)
    {
        (, fuses, expiry) = getData(uint256(node));
        if (fuses == 0 && expiry == 0) {
            bytes memory name = names[node];
            if (name.length == 0) {
                revert NameNotFound();
            }
        }
    }

    /**
     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract
     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar
     * @param label label as a string of the .eth domain to wrap
     * @param wrappedOwner Owner of the name in this contract
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @param resolver resolver contract address
     */

    function wrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) public override returns (uint64) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        address registrant = registrar.ownerOf(tokenId);
        if (
            registrant != msg.sender &&
            !isApprovedForAll(registrant, msg.sender) &&
            !registrar.isApprovedForAll(registrant, msg.sender)
        ) {
            revert Unauthorised(
                _makeNode(ETH_NODE, bytes32(tokenId)),
                msg.sender
            );
        }

        // transfer the token from the user to this contract
        registrar.transferFrom(registrant, address(this), tokenId);

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(tokenId, address(this));

        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Registers a new .eth second-level domain and wraps it.
     *      Only callable by authorised controllers.
     * @param label The label to register (Eg, 'foo' for 'foo.eth').
     * @param wrappedOwner The owner of the wrapped name.
     * @param duration The duration, in seconds, to register the name for.
     * @param resolver The resolver address to set on the ENS registry (optional).
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.
     */

    function registerAndWrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint256 duration,
        address resolver,
        uint32 fuses,
        uint64 expiry
    ) external override onlyController returns (uint256 registrarExpiry) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        registrarExpiry = registrar.register(tokenId, address(this), duration);
        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Renews a .eth second-level domain.
     *      Only callable by authorised controllers.
     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').
     * @param duration The number of seconds to renew the name for.
     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.
     */
    function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));

        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));

        _setData(node, owner, fuses, expiry);
    }

    /**
     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the registry or an authorised caller in the registry
     * @param name The name to wrap, in DNS format
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract address
     */

    function wrap(
        bytes calldata name,
        address wrappedOwner,
        address resolver
    ) public override {
        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
        bytes32 parentNode = name.namehash(offset);
        bytes32 node = _makeNode(parentNode, labelhash);

        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }

        address owner = ens.owner(node);

        if (
            owner != msg.sender &&
            !isApprovedForAll(owner, msg.sender) &&
            !ens.isApprovedForAll(owner, msg.sender)
        ) {
            revert Unauthorised(node, msg.sender);
        }

        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        ens.setOwner(node, address(this));

        _wrap(node, name, wrappedOwner, 0, 0);
    }

    /**
     * @notice Unwraps a .eth domain. e.g. vitalik.eth
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param labelhash labelhash of the .eth domain
     * @param newRegistrant sets the owner in the .eth registrar to this address
     * @param newController sets the owner in the registry to this address
     */

    function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }

    /**
     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param newController sets the owner in the registry to this address
     */

    function unwrap(
        bytes32 parentNode,
        bytes32 labelhash,
        address newController
    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        _unwrap(_makeNode(parentNode, labelhash), newController);
    }

    /**
     * @notice Sets fuses of a name
     * @param node namehash of the name
     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)
     */

    function setFuses(bytes32 node, uint32 fuses)
        public
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_BURN_FUSES)
        returns (uint32)
    {
        if (fuses & PARENT_CANNOT_CONTROL != 0) {
            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.
            revert Unauthorised(node, msg.sender);
        }

        (address owner, uint32 oldFuses, uint64 expiry) = getData(
            uint256(node)
        );

        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
        return fuses;
    }

    /**
     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract
     *     and burning the token of this contract
     * @dev Can be called by the owner of the name in this contract
     * @param label Label as a string of the .eth name to upgrade
     * @param wrappedOwner The owner of the wrapped name
     */

    function upgradeETH2LD(
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);

        upgradeContract.wrapETH2LD(
            label,
            wrappedOwner,
            fuses,
            expiry,
            resolver
        );
    }

    /**
     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner or an authorised caller
     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names
     * @param parentNode namehash of the parent name
     * @param label Label as a string of the name to upgrade
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract for this name
     */

    function upgrade(
        bytes32 parentNode,
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.setSubnodeRecord(
            parentNode,
            label,
            wrappedOwner,
            resolver,
            0,
            fuses,
            expiry
        );
    }

    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param fuses fuses to burn
     * @param expiry when the fuses will expire
     */

    function setChildFuses(
        bytes32 parentNode,
        bytes32 labelhash,
        uint32 fuses,
        uint64 expiry
    ) public {
        bytes32 node = _makeNode(parentNode, labelhash);
        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        uint64 maxExpiry;
        if (parentNode == ETH_NODE) {
            if (!isTokenOwnerOrApproved(node, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            // max expiry is set to the expiry on the registrar
            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        } else {
            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }

            // max expiry is set to the expiry of the parent
            (, , maxExpiry) = getData(uint256(parentNode));
        }

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);

        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed
        if (
            oldFuses & PARENT_CANNOT_CONTROL != 0 &&
            oldFuses | fuses != oldFuses
        ) {
            revert OperationProhibited(node);
        }
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
    }

    /**
     * @notice Sets the subdomain owner in the registry and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry when the fuses will expire
     */

    function setSubnodeOwner(
        bytes32 parentNode,
        string calldata label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
        returns (bytes32 node)
    {
        bytes32 labelhash = keccak256(bytes(label));
        node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);

        if (ens.owner(node) != address(this)) {
            ens.setSubnodeOwner(parentNode, labelhash, address(this));
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param resolver resolver contract in the registry
     * @param ttl ttl in the regsitry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry expiry date for the domain
     */

    function setSubnodeRecord(
        bytes32 parentNode,
        string memory label,
        address newOwner,
        address resolver,
        uint64 ttl,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
    {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets records for the name in the ENS Registry
     * @param node namehash of the name to set a record for
     * @param owner newOwner in the registry
     * @param resolver the resolver contract
     * @param ttl ttl in the registry
     */

    function setRecord(
        bytes32 node,
        address owner,
        address resolver,
        uint64 ttl
    )
        public
        override
        onlyTokenOwner(node)
        operationAllowed(
            node,
            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL
        )
    {
        ens.setRecord(node, address(this), resolver, ttl);
        (address oldOwner, , ) = getData(uint256(node));
        _transfer(oldOwner, owner, uint256(node), 1, "");
    }

    /**
     * @notice Sets resolver contract in the registry
     * @param node namehash of the name
     * @param resolver the resolver contract
     */

    function setResolver(bytes32 node, address resolver)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_RESOLVER)
    {
        ens.setResolver(node, resolver);
    }

    /**
     * @notice Sets TTL in the registry
     * @param node namehash of the name
     * @param ttl TTL in the registry
     */

    function setTTL(bytes32 node, uint64 ttl)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_TTL)
    {
        ens.setTTL(node, ttl);
    }

    /**
     * @dev Allows an operation only if none of the specified fuses are burned.
     * @param node The namehash of the name to check fuses on.
     * @param fuseMask A bitmask of fuses that must not be burned.
     */

    modifier operationAllowed(bytes32 node, uint32 fuseMask) {
        (, uint32 fuses, ) = getData(uint256(node));
        if (fuses & fuseMask != 0) {
            revert OperationProhibited(node);
        }
        _;
    }

    /**
     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord
     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt
     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for
     *      replacing a subdomain. If either conditions are true, then it is possible to call
     *      setSubnodeOwner
     * @param node namehash of the name to check
     * @param labelhash labelhash of the name to check
     */

    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {
        bytes32 subnode = _makeNode(node, labelhash);
        address owner = ens.owner(subnode);

        if (owner == address(0)) {
            (, uint32 fuses, ) = getData(uint256(node));
            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {
                revert OperationProhibited(node);
            }
        } else {
            (, uint32 subnodeFuses, ) = getData(uint256(subnode));
            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {
                revert OperationProhibited(node);
            }
        }

        _;
    }

    /**
     * @notice Checks all Fuses in the mask are burned for the node
     * @param node namehash of the name
     * @param fuseMask the fuses you want to check
     * @return Boolean of whether or not all the selected fuses are burned
     */

    function allFusesBurned(bytes32 node, uint32 fuseMask)
        public
        view
        override
        returns (bool)
    {
        (, uint32 fuses, ) = getData(uint256(node));
        return fuses & fuseMask == fuseMask;
    }

    function onERC721Received(
        address to,
        address,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        //check if it's the eth registrar ERC721
        if (msg.sender != address(registrar)) {
            revert IncorrectTokenType();
        }

        (
            string memory label,
            address owner,
            uint32 fuses,
            uint64 expiry,
            address resolver
        ) = abi.decode(data, (string, address, uint32, uint64, address));

        bytes32 labelhash = bytes32(tokenId);
        bytes32 labelhashFromData = keccak256(bytes(label));

        if (labelhashFromData != labelhash) {
            revert LabelMismatch(labelhashFromData, labelhash);
        }

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(uint256(labelhash), address(this));

        _wrapETH2LD(label, owner, fuses, expiry, resolver);

        return IERC721Receiver(to).onERC721Received.selector;
    }

    /***** Internal functions */

    function _canTransfer(uint32 fuses) internal pure override returns (bool) {
        return fuses & CANNOT_TRANSFER == 0;
    }

    function _makeNode(bytes32 node, bytes32 labelhash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, labelhash));
    }

    function _addLabel(string memory label, bytes memory name)
        internal
        pure
        returns (bytes memory ret)
    {
        if (bytes(label).length < 1) {
            revert LabelTooShort();
        }
        if (bytes(label).length > 255) {
            revert LabelTooLong(label);
        }
        return abi.encodePacked(uint8(bytes(label).length), label, name);
    }

    function _mint(
        bytes32 node,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal override {
        address oldWrappedOwner = ownerOf(uint256(node));
        _canFusesBeBurned(node, fuses);
        if (oldWrappedOwner != address(0)) {
            // burn and unwrap old token of old owner
            _burn(uint256(node));
            emit NameUnwrapped(node, address(0));
        }
        super._mint(node, wrappedOwner, fuses, expiry);
    }

    function _wrap(
        bytes32 node,
        bytes memory name,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        names[node] = name;
        _mint(node, wrappedOwner, fuses, expiry);
        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);
    }

    function _addLabelAndWrap(
        bytes32 parentNode,
        bytes32 node,
        string memory label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        bytes memory name = _addLabel(label, names[parentNode]);
        _wrap(node, name, newOwner, fuses, expiry);
    }

    function _prepareUpgrade(bytes32 node)
        private
        returns (uint32 fuses, uint64 expiry)
    {
        if (address(upgradeContract) == address(0)) {
            revert CannotUpgrade();
        }

        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        (fuses, expiry) = getFuses(node);

        // burn token and fuse data
        _burn(uint256(node));
    }

    function _transferAndBurnFuses(
        bytes32 node,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        (address owner, , ) = getData(uint256(node));
        _transfer(owner, newOwner, uint256(node), 1, "");
        _setFuses(node, newOwner, fuses, expiry);
    }

    // wrapper function for stack limit
    function _getDataAndNormaliseExpiry(
        bytes32 parentNode,
        bytes32 node,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        (, , uint64 maxExpiry) = getData(uint256(parentNode));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _getETH2LDDataAndNormaliseExpiry(
        bytes32 node,
        bytes32 labelhash,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _normaliseExpiry(
        uint64 expiry,
        uint64 oldExpiry,
        uint64 maxExpiry
    ) internal pure returns (uint64) {
        // Expiry cannot be more than maximum allowed
        // .eth names will check registrar, non .eth check parent
        if (expiry > maxExpiry) {
            expiry = maxExpiry;
        }
        // Expiry cannot be less than old expiry
        if (expiry < oldExpiry) {
            expiry = oldExpiry;
        }

        return expiry;
    }

    function _wrapETH2LD(
        string memory label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) private returns (uint64) {
        // Mint a new ERC1155 token with fuses
        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);

        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(
            node,
            labelhash,
            expiry
        );

        _addLabelAndWrap(
            ETH_NODE,
            node,
            label,
            wrappedOwner,
            fuses | PARENT_CANNOT_CONTROL,
            expiry
        );
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        return expiry;
    }

    function _unwrap(bytes32 node, address newOwner) private {
        if (newOwner == address(0x0) || newOwner == address(this)) {
            revert IncorrectTargetOwner(newOwner);
        }

        if (allFusesBurned(node, CANNOT_UNWRAP)) {
            revert OperationProhibited(node);
        }

        // Burn token and fuse data
        _burn(uint256(node));
        ens.setOwner(node, newOwner);

        emit NameUnwrapped(node, newOwner);
    }

    function _setFuses(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _setData(node, owner, fuses, expiry);
        emit FusesSet(node, fuses, expiry);
    }

    function _setData(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _canFusesBeBurned(node, fuses);
        super._setData(uint256(node), owner, fuses, expiry);
    }

    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
        if (
            fuses & ~PARENT_CANNOT_CONTROL != 0 &&
            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
        ) {
            revert OperationProhibited(node);
        }
    }
}
.]

### VULNERABILITY: Reentrancy Attack
```
DETAILED DESCRIPTION: The contract does not implement any reentrancy guards on functions that transfer tokens or call external contracts. For instance, in the `wrapETH2LD` and `unwrapETH2LD` functions, the contract transfers tokens and calls external contracts (like the ENS registry). If an attacker can manipulate the flow of execution by re-entering these functions, they could exploit this to drain funds or manipulate state.

RECOMMENDED MITIGATION: Implement a reentrancy guard using a mutex pattern or the OpenZeppelin `ReentrancyGuard` contract. This will prevent reentrant calls to functions that modify state or transfer funds.
```

### VULNERABILITY: Improper Access Control
```
DETAILED DESCRIPTION: The `setUpgradeContract` function allows the owner to set an upgrade contract, but it does not check if the new upgrade contract is valid or if it has the necessary permissions. This could lead to a situation where an unauthorized contract is set, potentially allowing malicious actions.

RECOMMENDED MITIGATION: Ensure that the new upgrade contract is a valid contract and implement checks to ensure that it conforms to expected interfaces. Additionally, consider adding a mechanism to restrict who can set the upgrade contract.
```

### VULNERABILITY: Lack of Input Validation
```
DETAILED DESCRIPTION: Functions like `wrap`, `wrapETH2LD`, and `setSubnodeOwner` do not validate the input parameters thoroughly. For example, the `label` in `wrapETH2LD` and `wrap` should be checked for length and format to prevent unexpected behavior or state corruption.

RECOMMENDED MITIGATION: Implement input validation checks to ensure that all parameters meet expected criteria (e.g., length checks for strings, valid addresses, etc.) before processing them.
```

### VULNERABILITY: Potential Integer Overflow/Underflow
```
DETAILED DESCRIPTION: Although Solidity 0.8.0 and above has built-in overflow and underflow checks, there are still areas where calculations could lead to unexpected results if not handled properly. For example, in the `_normaliseExpiry` function, if the `expiry` is set incorrectly, it could lead to unintended behavior.

RECOMMENDED MITIGATION: Ensure that all arithmetic operations are checked and handled correctly. Consider using SafeMath for clarity, even though it is not strictly necessary in Solidity 0.8.0 and above.
```

### VULNERABILITY: Unchecked External Calls
```
DETAILED DESCRIPTION: The contract makes several external calls (e.g., to the ENS registry and the registrar) without checking the return values. If these calls fail, the contract may enter an inconsistent state.

RECOMMENDED MITIGATION: Always check the return values of external calls and handle failures appropriately. This could involve reverting the transaction if an external call fails.
```

### VULNERABILITY: Uncontrolled Token Transfers
```
DETAILED DESCRIPTION: The contract allows for token transfers without sufficient checks on the token's ownership and approval status. For instance, in the `unwrapETH2LD` function, the contract transfers tokens based on the assumption that the caller has the right to do so.

RECOMMENDED MITIGATION: Implement checks to ensure that the caller has the necessary permissions to transfer tokens. This includes verifying ownership and approval status before executing transfers.
```

### VULNERABILITY: Missing Events for Critical State Changes
```
DETAILED DESCRIPTION: The contract does not emit events for critical state changes, such as when the upgrade contract is set or when fuses are modified. This can make it difficult to track changes and audit the contract's state.

RECOMMENDED MITIGATION: Emit events for all critical state changes, including setting the upgrade contract, changing fuses, and transferring ownership. This will improve transparency and facilitate easier auditing.
```

### VULNERABILITY: Potential Gas Limit Issues
```
DETAILED DESCRIPTION: Functions that involve loops or multiple external calls (e.g., `setSubnodeRecord`) may run into gas limit issues, especially if the number of operations increases. This can lead to failed transactions.

RECOMMENDED MITIGATION: Optimize functions to minimize gas usage, and consider breaking down complex functions into smaller, more manageable pieces. Additionally, provide users with guidance on gas limits when interacting with the contract.
```

<INFO> Analysis Complete.

[2024-01-09 20:36:10 INFO] **[Seminar Conclusion]**:

 ### VULNERABILITY: Reentrancy Attack
```
DETAILED DESCRIPTION: The contract does not implement any reentrancy guards on functions that transfer tokens or call external contracts. For instance, in the `wrapETH2LD` and `unwrapETH2LD` functions, the contract transfers tokens and calls external contracts (like the ENS registry). If an attacker can manipulate the flow of execution by re-entering these functions, they could exploit this to drain funds or manipulate state.

RECOMMENDED MITIGATION: Implement a reentrancy guard using a mutex pattern or the OpenZeppelin `ReentrancyGuard` contract. This will prevent reentrant calls to functions that modify state or transfer funds.
```

### VULNERABILITY: Improper Access Control
```
DETAILED DESCRIPTION: The `setUpgradeContract` function allows the owner to set an upgrade contract, but it does not check if the new upgrade contract is valid or if it has the necessary permissions. This could lead to a situation where an unauthorized contract is set, potentially allowing malicious actions.

RECOMMENDED MITIGATION: Ensure that the new upgrade contract is a valid contract and implement checks to ensure that it conforms to expected interfaces. Additionally, consider adding a mechanism to restrict who can set the upgrade contract.
```

### VULNERABILITY: Lack of Input Validation
```
DETAILED DESCRIPTION: Functions like `wrap`, `wrapETH2LD`, and `setSubnodeOwner` do not validate the input parameters thoroughly. For example, the `label` in `wrapETH2LD` and `wrap` should be checked for length and format to prevent unexpected behavior or state corruption.

RECOMMENDED MITIGATION: Implement input validation checks to ensure that all parameters meet expected criteria (e.g., length checks for strings, valid addresses, etc.) before processing them.
```

### VULNERABILITY: Potential Integer Overflow/Underflow
```
DETAILED DESCRIPTION: Although Solidity 0.8.0 and above has built-in overflow and underflow checks, there are still areas where calculations could lead to unexpected results if not handled properly. For example, in the `_normaliseExpiry` function, if the `expiry` is set incorrectly, it could lead to unintended behavior.

RECOMMENDED MITIGATION: Ensure that all arithmetic operations are checked and handled correctly. Consider using SafeMath for clarity, even though it is not strictly necessary in Solidity 0.8.0 and above.
```

### VULNERABILITY: Unchecked External Calls
```
DETAILED DESCRIPTION: The contract makes several external calls (e.g., to the ENS registry and the registrar) without checking the return values. If these calls fail, the contract may enter an inconsistent state.

RECOMMENDED MITIGATION: Always check the return values of external calls and handle failures appropriately. This could involve reverting the transaction if an external call fails.
```

### VULNERABILITY: Uncontrolled Token Transfers
```
DETAILED DESCRIPTION: The contract allows for token transfers without sufficient checks on the token's ownership and approval status. For instance, in the `unwrapETH2LD` function, the contract transfers tokens based on the assumption that the caller has the right to do so.

RECOMMENDED MITIGATION: Implement checks to ensure that the caller has the necessary permissions to transfer tokens. This includes verifying ownership and approval status before executing transfers.
```

### VULNERABILITY: Missing Events for Critical State Changes
```
DETAILED DESCRIPTION: The contract does not emit events for critical state changes, such as when the upgrade contract is set or when fuses are modified. This can make it difficult to track changes and audit the contract's state.

RECOMMENDED MITIGATION: Emit events for all critical state changes, including setting the upgrade contract, changing fuses, and transferring ownership. This will improve transparency and facilitate easier auditing.
```

### VULNERABILITY: Potential Gas Limit Issues
```
DETAILED DESCRIPTION: Functions that involve loops or multiple external calls (e.g., `setSubnodeRecord`) may run into gas limit issues, especially if the number of operations increases. This can lead to failed transactions.

RECOMMENDED MITIGATION: Optimize functions to minimize gas usage, and consider breaking down complex functions into smaller, more manageable pieces. Additionally, provide users with guidance on gas limits when interacting with the contract.
```

<INFO> Analysis Complete.

[2024-01-09 20:36:10 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-01-09 20:36:10 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | //SPDX-License-Identifier: MIT pragma solidity ^0.8.4; import "./ERC1155Fuse.sol"; import "./Controllable.sol"; import "./INameWrapper.sol"; import "./INameWrapperUpgrade.sol"; import "./IMetadataService.sol"; import "../registry/ENS.sol"; import "../ethregistrar/IBaseRegistrar.sol"; import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "./BytesUtil.sol"; error Unauthorised(bytes32 node, address addr); error NameNotFound(); error IncompatibleParent(); error IncompatibleName(bytes name); error IncorrectTokenType(); error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash); error LabelTooShort(); error LabelTooLong(string label); error IncorrectTargetOwner(address owner); error CannotUpgrade(); error InvalidExpiry(bytes32 node, uint64 expiry); contract NameWrapper is     Ownable,     ERC1155Fuse,     INameWrapper,     Controllable,     IERC721Receiver {     using BytesUtils for bytes;     ENS public immutable override ens;     IBaseRegistrar public immutable override registrar;     IMetadataService public override metadataService;     mapping(bytes32 =&gt; bytes) public override names; bytes32 private constant ETH_NODE =     0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae; bytes32 private constant ROOT_NODE =     0x0000000000000000000000000000000000000000000000000000000000000000;  //A contract address to a new upgraded contract if any INameWrapperUpgrade public upgradeContract; uint64 private constant MAX_EXPIRY = type(uint64).max;  constructor(     ENS _ens,     IBaseRegistrar _registrar,     IMetadataService _metadataService ) {     ens = _ens;     registrar = _registrar;     metadataService = _metadataService;      /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */      _setData(         uint256(ETH_NODE),         address(0),         uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),         MAX_EXPIRY     );     _setData(         uint256(ROOT_NODE),         address(0),         uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),         MAX_EXPIRY     );     names[ROOT_NODE] = "\x00";     names[ETH_NODE] = "\x03eth\x00"; }  function supportsInterface(bytes4 interfaceId)     public     view     virtual     override(ERC1155Fuse, IERC165)     returns (bool) {     return         interfaceId == type(INameWrapper).interfaceId ||         super.supportsInterface(interfaceId); }  /* ERC1155 */  function ownerOf(uint256 id)     public     view     override(ERC1155Fuse, INameWrapper)     returns (address owner) {     return super.ownerOf(id); }  /* Metadata service */  /**  * @notice Set the metadata service. Only the owner can do this  */  function setMetadataService(IMetadataService _newMetadataService)     public     onlyOwner {     metadataService = _newMetadataService; }  /**  * @notice Get the metadata uri  * @return String uri of the metadata service  */  function uri(uint256 tokenId) public view override returns (string memory) {     return metadataService.uri(tokenId); }  /**  * @notice Set the address of the upgradeContract of the contract. only admin can do this  * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time  * to make the contract not upgradable.  * @param _upgradeAddress address of an upgraded contract  */  function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)     public     onlyOwner {     if (address(upgradeContract) != address(0)) {         registrar.setApprovalForAll(address(upgradeContract), false);         ens.setApprovalForAll(address(upgradeContract), false);     }      upgradeContract = _upgradeAddress;      if (address(upgradeContract) != address(0)) {         registrar.setApprovalForAll(address(upgradeContract), true);         ens.setApprovalForAll(address(upgradeContract), true);     } }  /**  * @notice Checks if msg.sender is the owner or approved by the owner of a name  * @param node namehash of the name to check  */  modifier onlyTokenOwner(bytes32 node) {     if (!isTokenOwnerOrApproved(node, msg.sender)) {         revert Unauthorised(node, msg.sender);     }      _; }  /**  * @notice Checks if owner or approved by owner  * @param node namehash of the name to check  * @param addr which address to check permissions for  * @return whether or not is owner or approved  */  function isTokenOwnerOrApproved(bytes32 node, address addr)     public     view     override     returns (bool) {     address owner = ownerOf(uint256(node));     return owner == addr || isApprovedForAll(owner, addr); }  /**  * @notice Gets fuse permissions for a specific name  * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit  *      The interface has predefined fuses for all registry permissions, but additional  *      fuses can be added for other use cases  *      Also returns expiry, which is when the fuses are set to expire.  * @param node namehash of the name to check  * @return fuses A number that represents the permissions a name has. Returns 0 when expiry &lt; block.timestamp  * @return expiry Unix time of when the name expires and fuses are to expire  */ function getFuses(bytes32 node)     public     view     override     returns (uint32 fuses, uint64 expiry) {     (, fuses, expiry) = getData(uint256(node));     if (fuses == 0 &amp;&amp; expiry == 0) {         bytes memory name = names[node];         if (name.length == 0) {             revert NameNotFound();         }     } }  /**  * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract  * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar  * @param label label as a string of the .eth domain to wrap  * @param wrappedOwner Owner of the name in this contract  * @param fuses initial fuses to set  * @param expiry when the fuses will expire  * @param resolver resolver contract address  */  function wrapETH2LD(     string calldata label,     address wrappedOwner,     uint32 fuses,     uint64 expiry,     address resolver ) public override returns (uint64) {     uint256 tokenId = uint256(keccak256(bytes(label)));     address registrant = registrar.ownerOf(tokenId);     if (         registrant != msg.sender &amp;&amp;         !isApprovedForAll(registrant, msg.sender) &amp;&amp;         !registrar.isApprovedForAll(registrant, msg.sender)     ) {         revert Unauthorised(             _makeNode(ETH_NODE, bytes32(tokenId)),             msg.sender         );     }      // transfer the token from the user to this contract     registrar.transferFrom(registrant, address(this), tokenId);      // transfer the ens record back to the new owner (this contract)     registrar.reclaim(tokenId, address(this));      return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver); }  /**  * @dev Registers a new .eth second-level domain and wraps it.  *      Only callable by authorised controllers.  * @param label The label to register (Eg, 'foo' for 'foo.eth').  * @param wrappedOwner The owner of the wrapped name.  * @param duration The duration, in seconds, to register the name for.  * @param resolver The resolver address to set on the ENS registry (optional).  * @param fuses initial fuses to set  * @param expiry when the fuses will expire  * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.  */  function registerAndWrapETH2LD(     string calldata label,     address wrappedOwner,     uint256 duration,     address resolver,     uint32 fuses,     uint64 expiry ) external override onlyController returns (uint256 registrarExpiry) {     uint256 tokenId = uint256(keccak256(bytes(label)));     registrarExpiry = registrar.register(tokenId, address(this), duration);     _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver); }  /**  * @dev Renews a .eth second-level domain.  *      Only callable by authorised controllers.  * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').  * @param duration The number of seconds to renew the name for.  * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.  */ function renew(     uint256 tokenId,     uint256 duration,     uint64 expiry ) external override onlyController returns (uint256 expires) {     bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));      expires = registrar.renew(tokenId, duration);     (address owner, uint32 fuses, uint64 oldExpiry) = getData(         uint256(node)     );     expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));      _setData(node, owner, fuses, expiry); }  /**  * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner in the registry or an authorised caller in the registry  * @param name The name to wrap, in DNS format  * @param wrappedOwner Owner of the name in this contract  * @param resolver resolver contract address  */  function wrap(     bytes calldata name,     address wrappedOwner,     address resolver ) public override {     (bytes32 labelhash, uint256 offset) = name.readLabel(0);     bytes32 parentNode = name.namehash(offset);     bytes32 node = _makeNode(parentNode, labelhash);      if (parentNode == ETH_NODE) {         revert IncompatibleParent();     }      address owner = ens.owner(node);      if (         owner != msg.sender &amp;&amp;         !isApprovedForAll(owner, msg.sender) &amp;&amp;         !ens.isApprovedForAll(owner, msg.sender)     ) {         revert Unauthorised(node, msg.sender);     }      if (resolver != address(0)) {         ens.setResolver(node, resolver);     }      ens.setOwner(node, address(this));      _wrap(node, name, wrappedOwner, 0, 0); }  /**  * @notice Unwraps a .eth domain. e.g. vitalik.eth  * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper  * @param labelhash labelhash of the .eth domain  * @param newRegistrant sets the owner in the .eth registrar to this address  * @param newController sets the owner in the registry to this address  */  function unwrapETH2LD(     bytes32 labelhash,     address newRegistrant,     address newController ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {     _unwrap(_makeNode(ETH_NODE, labelhash), newController);     registrar.transferFrom(         address(this),         newRegistrant,         uint256(labelhash)     ); }  /**  * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper  * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')  * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')  * @param newController sets the owner in the registry to this address  */  function unwrap(     bytes32 parentNode,     bytes32 labelhash,     address newController ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {     if (parentNode == ETH_NODE) {         revert IncompatibleParent();     }     _unwrap(_makeNode(parentNode, labelhash), newController); }  /**  * @notice Sets fuses of a name  * @param node namehash of the name  * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)  */  function setFuses(bytes32 node, uint32 fuses)     public     onlyTokenOwner(node)     operationAllowed(node, CANNOT_BURN_FUSES)     returns (uint32) {     if (fuses &amp; PARENT_CANNOT_CONTROL != 0) {         // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.         revert Unauthorised(node, msg.sender);     }      (address owner, uint32 oldFuses, uint64 expiry) = getData(         uint256(node)     );      fuses |= oldFuses;     _setFuses(node, owner, fuses, expiry);     return fuses; }  /**  * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract  *     and burning the token of this contract  * @dev Can be called by the owner of the name in this contract  * @param label Label as a string of the .eth name to upgrade  * @param wrappedOwner The owner of the wrapped name  */  function upgradeETH2LD(     string calldata label,     address wrappedOwner,     address resolver ) public {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(ETH_NODE, labelhash);     (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);      upgradeContract.wrapETH2LD(         label,         wrappedOwner,         fuses,         expiry,         resolver     ); }  /**  * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner or an authorised caller  * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names  * @param parentNode namehash of the parent name  * @param label Label as a string of the name to upgrade  * @param wrappedOwner Owner of the name in this contract  * @param resolver resolver contract for this name  */  function upgrade(     bytes32 parentNode,     string calldata label,     address wrappedOwner,     address resolver ) public {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(parentNode, labelhash);     (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);     upgradeContract.setSubnodeRecord(         parentNode,         label,         wrappedOwner,         resolver,         0,         fuses,         expiry     ); }  /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name  * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')  * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')  * @param fuses fuses to burn  * @param expiry when the fuses will expire  */  function setChildFuses(     bytes32 parentNode,     bytes32 labelhash,     uint32 fuses,     uint64 expiry ) public {     bytes32 node = _makeNode(parentNode, labelhash);     (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(         uint256(node)     );     uint64 maxExpiry;     if (parentNode == ETH_NODE) {         if (!isTokenOwnerOrApproved(node, msg.sender)) {             revert Unauthorised(node, msg.sender);         }         // max expiry is set to the expiry on the registrar         maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));     } else {         if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {             revert Unauthorised(node, msg.sender);         }          // max expiry is set to the expiry of the parent         (, , maxExpiry) = getData(uint256(parentNode));     }      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);      // if PARENT_CANNOT_CONTROL has been burned and fuses have changed     if (         oldFuses &amp; PARENT_CANNOT_CONTROL != 0 &amp;&amp;         oldFuses | fuses != oldFuses     ) {         revert OperationProhibited(node);     }     fuses |= oldFuses;     _setFuses(node, owner, fuses, expiry); }  /**  * @notice Sets the subdomain owner in the registry and then wraps the subdomain  * @param parentNode parent namehash of the subdomain  * @param label label of the subdomain as a string  * @param newOwner newOwner in the registry  * @param fuses initial fuses for the wrapped subdomain  * @param expiry when the fuses will expire  */  function setSubnodeOwner(     bytes32 parentNode,     string calldata label,     address newOwner,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))     returns (bytes32 node) {     bytes32 labelhash = keccak256(bytes(label));     node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);      if (ens.owner(node) != address(this)) {         ens.setSubnodeOwner(parentNode, labelhash, address(this));         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } }  /**  * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain  * @param parentNode parent namehash of the subdomain  * @param label label of the subdomain as a string  * @param newOwner newOwner in the registry  * @param resolver resolver contract in the registry  * @param ttl ttl in the regsitry  * @param fuses initial fuses for the wrapped subdomain  * @param expiry expiry date for the domain  */  function setSubnodeRecord(     bytes32 parentNode,     string memory label,     address newOwner,     address resolver,     uint64 ttl,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label))) {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);     if (ens.owner(node) != address(this)) {         ens.setSubnodeRecord(             parentNode,             labelhash,             address(this),             resolver,             ttl         );         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         ens.setSubnodeRecord(             parentNode,             labelhash,             address(this),             resolver,             ttl         );         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } }  /**  * @notice Sets records for the name in the ENS Registry  * @param node namehash of the name to set a record for  * @param owner newOwner in the registry  * @param resolver the resolver contract  * @param ttl ttl in the registry  */  function setRecord(     bytes32 node,     address owner,     address resolver,     uint64 ttl )     public     override     onlyTokenOwner(node)     operationAllowed(         node,         CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL     ) {     ens.setRecord(node, address(this), resolver, ttl);     (address oldOwner, , ) = getData(uint256(node));     _transfer(oldOwner, owner, uint256(node), 1, ""); }  /**  * @notice Sets resolver contract in the registry  * @param node namehash of the name  * @param resolver the resolver contract  */  function setResolver(bytes32 node, address resolver)     public     override     onlyTokenOwner(node)     operationAllowed(node, CANNOT_SET_RESOLVER) {     ens.setResolver(node, resolver); }  /**  * @notice Sets TTL in the registry  * @param node namehash of the name  * @param ttl TTL in the registry  */  function setTTL(bytes32 node, uint64 ttl)     public     override     onlyTokenOwner(node)     operationAllowed(node, CANNOT_SET_TTL) {     ens.setTTL(node, ttl); }  /**  * @dev Allows an operation only if none of the specified fuses are burned.  * @param node The namehash of the name to check fuses on.  * @param fuseMask A bitmask of fuses that must not be burned.  */  modifier operationAllowed(bytes32 node, uint32 fuseMask) {     (, uint32 fuses, ) = getData(uint256(node));     if (fuses &amp; fuseMask != 0) {         revert OperationProhibited(node);     }     _; }  /**  * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord  * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt  *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for  *      replacing a subdomain. If either conditions are true, then it is possible to call  *      setSubnodeOwner  * @param node namehash of the name to check  * @param labelhash labelhash of the name to check  */  modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {     bytes32 subnode = _makeNode(node, labelhash);     address owner = ens.owner(subnode);      if (owner == address(0)) {         (, uint32 fuses, ) = getData(uint256(node));         if (fuses &amp; CANNOT_CREATE_SUBDOMAIN != 0) {             revert OperationProhibited(node);         }     } else {         (, uint32 subnodeFuses, ) = getData(uint256(subnode));         if (subnodeFuses &amp; PARENT_CANNOT_CONTROL != 0) {             revert OperationProhibited(node);         }     }      _; }  /**  * @notice Checks all Fuses in the mask are burned for the node  * @param node namehash of the name  * @param fuseMask the fuses you want to check  * @return Boolean of whether or not all the selected fuses are burned  */  function allFusesBurned(bytes32 node, uint32 fuseMask)     public     view     override     returns (bool) {     (, uint32 fuses, ) = getData(uint256(node));     return fuses &amp; fuseMask == fuseMask; }  function onERC721Received(     address to,     address,     uint256 tokenId,     bytes calldata data ) public override returns (bytes4) {     //check if it's the eth registrar ERC721     if (msg.sender != address(registrar)) {         revert IncorrectTokenType();     }      (         string memory label,         address owner,         uint32 fuses,         uint64 expiry,         address resolver     ) = abi.decode(data, (string, address, uint32, uint64, address));      bytes32 labelhash = bytes32(tokenId);     bytes32 labelhashFromData = keccak256(bytes(label));      if (labelhashFromData != labelhash) {         revert LabelMismatch(labelhashFromData, labelhash);     }      // transfer the ens record back to the new owner (this contract)     registrar.reclaim(uint256(labelhash), address(this));      _wrapETH2LD(label, owner, fuses, expiry, resolver);      return IERC721Receiver(to).onERC721Received.selector; }  /***** Internal functions */  function _canTransfer(uint32 fuses) internal pure override returns (bool) {     return fuses &amp; CANNOT_TRANSFER == 0; }  function _makeNode(bytes32 node, bytes32 labelhash)     private     pure     returns (bytes32) {     return keccak256(abi.encodePacked(node, labelhash)); }  function _addLabel(string memory label, bytes memory name)     internal     pure     returns (bytes memory ret) {     if (bytes(label).length &lt; 1) {         revert LabelTooShort();     }     if (bytes(label).length &gt; 255) {         revert LabelTooLong(label);     }     return abi.encodePacked(uint8(bytes(label).length), label, name); }  function _mint(     bytes32 node,     address wrappedOwner,     uint32 fuses,     uint64 expiry ) internal override {     address oldWrappedOwner = ownerOf(uint256(node));     _canFusesBeBurned(node, fuses);     if (oldWrappedOwner != address(0)) {         // burn and unwrap old token of old owner         _burn(uint256(node));         emit NameUnwrapped(node, address(0));     }     super._mint(node, wrappedOwner, fuses, expiry); }  function _wrap(     bytes32 node,     bytes memory name,     address wrappedOwner,     uint32 fuses,     uint64 expiry ) internal {     names[node] = name;     _mint(node, wrappedOwner, fuses, expiry);     emit NameWrapped(node, name, wrappedOwner, fuses, expiry); }  function _addLabelAndWrap(     bytes32 parentNode,     bytes32 node,     string memory label,     address newOwner,     uint32 fuses,     uint64 expiry ) internal {     bytes memory name = _addLabel(label, names[parentNode]);     _wrap(node, name, newOwner, fuses, expiry); }  function _prepareUpgrade(bytes32 node)     private     returns (uint32 fuses, uint64 expiry) {     if (address(upgradeContract) == address(0)) {         revert CannotUpgrade();     }      if (!isTokenOwnerOrApproved(node, msg.sender)) {         revert Unauthorised(node, msg.sender);     }      (fuses, expiry) = getFuses(node);      // burn token and fuse data     _burn(uint256(node)); }  function _transferAndBurnFuses(     bytes32 node,     address newOwner,     uint32 fuses,     uint64 expiry ) internal {     (address owner, , ) = getData(uint256(node));     _transfer(owner, newOwner, uint256(node), 1, "");     _setFuses(node, newOwner, fuses, expiry); }  // wrapper function for stack limit function _getDataAndNormaliseExpiry(     bytes32 parentNode,     bytes32 node,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     (, , uint64 maxExpiry) = getData(uint256(parentNode));      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); }  function _getETH2LDDataAndNormaliseExpiry(     bytes32 node,     bytes32 labelhash,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); }  function _normaliseExpiry(     uint64 expiry,     uint64 oldExpiry,     uint64 maxExpiry ) internal pure returns (uint64) {     // Expiry cannot be more than maximum allowed     // .eth names will check registrar, non .eth check parent     if (expiry &gt; maxExpiry) {         expiry = maxExpiry;     }     // Expiry cannot be less than old expiry     if (expiry &lt; oldExpiry) {         expiry = oldExpiry;     }      return expiry; }  function _wrapETH2LD(     string memory label,     address wrappedOwner,     uint32 fuses,     uint64 expiry,     address resolver ) private returns (uint64) {     // Mint a new ERC1155 token with fuses     // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(ETH_NODE, labelhash);      (, , expiry) = _getETH2LDDataAndNormaliseExpiry(         node,         labelhash,         expiry     );      _addLabelAndWrap(         ETH_NODE,         node,         label,         wrappedOwner,         fuses | PARENT_CANNOT_CONTROL,         expiry     );     if (resolver != address(0)) {         ens.setResolver(node, resolver);     }      return expiry; }  function _unwrap(bytes32 node, address newOwner) private {     if (newOwner == address(0x0) || newOwner == address(this)) {         revert IncorrectTargetOwner(newOwner);     }      if (allFusesBurned(node, CANNOT_UNWRAP)) {         revert OperationProhibited(node);     }      // Burn token and fuse data     _burn(uint256(node));     ens.setOwner(node, newOwner);      emit NameUnwrapped(node, newOwner); }  function _setFuses(     bytes32 node,     address owner,     uint32 fuses,     uint64 expiry ) internal {     _setData(node, owner, fuses, expiry);     emit FusesSet(node, fuses, expiry); }  function _setData(     bytes32 node,     address owner,     uint32 fuses,     uint64 expiry ) internal {     _canFusesBeBurned(node, fuses);     super._setData(uint256(node), owner, fuses, expiry); }  function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {     if (         fuses &amp; ~PARENT_CANNOT_CONTROL != 0 &amp;&amp;         fuses &amp; (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=         (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)     ) {         revert OperationProhibited(node);     } }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 20:36:10 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | //SPDX-License-Identifier: MIT pragma solidity ^0.8.4; import "./ERC1155Fuse.sol"; import "./Controllable.sol"; import "./INameWrapper.sol"; import "./INameWrapperUpgrade.sol"; import "./IMetadataService.sol"; import "../registry/ENS.sol"; import "../ethregistrar/IBaseRegistrar.sol"; import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "./BytesUtil.sol"; error Unauthorised(bytes32 node, address addr); error NameNotFound(); error IncompatibleParent(); error IncompatibleName(bytes name); error IncorrectTokenType(); error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash); error LabelTooShort(); error LabelTooLong(string label); error IncorrectTargetOwner(address owner); error CannotUpgrade(); error InvalidExpiry(bytes32 node, uint64 expiry); contract NameWrapper is     Ownable,     ERC1155Fuse,     INameWrapper,     Controllable,     IERC721Receiver {     using BytesUtils for bytes;     ENS public immutable override ens;     IBaseRegistrar public immutable override registrar;     IMetadataService public override metadataService;     mapping(bytes32 =&gt; bytes) public override names; bytes32 private constant ETH_NODE =     0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae; bytes32 private constant ROOT_NODE =     0x0000000000000000000000000000000000000000000000000000000000000000;  //A contract address to a new upgraded contract if any INameWrapperUpgrade public upgradeContract; uint64 private constant MAX_EXPIRY = type(uint64).max;  constructor(     ENS _ens,     IBaseRegistrar _registrar,     IMetadataService _metadataService ) {     ens = _ens;     registrar = _registrar;     metadataService = _metadataService;      /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */      _setData(         uint256(ETH_NODE),         address(0),         uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),         MAX_EXPIRY     );     _setData(         uint256(ROOT_NODE),         address(0),         uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),         MAX_EXPIRY     );     names[ROOT_NODE] = "\x00";     names[ETH_NODE] = "\x03eth\x00"; }  function supportsInterface(bytes4 interfaceId)     public     view     virtual     override(ERC1155Fuse, IERC165)     returns (bool) {     return         interfaceId == type(INameWrapper).interfaceId ||         super.supportsInterface(interfaceId); }  /* ERC1155 */  function ownerOf(uint256 id)     public     view     override(ERC1155Fuse, INameWrapper)     returns (address owner) {     return super.ownerOf(id); }  /* Metadata service */  /**  * @notice Set the metadata service. Only the owner can do this  */  function setMetadataService(IMetadataService _newMetadataService)     public     onlyOwner {     metadataService = _newMetadataService; }  /**  * @notice Get the metadata uri  * @return String uri of the metadata service  */  function uri(uint256 tokenId) public view override returns (string memory) {     return metadataService.uri(tokenId); }  /**  * @notice Set the address of the upgradeContract of the contract. only admin can do this  * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time  * to make the contract not upgradable.  * @param _upgradeAddress address of an upgraded contract  */  function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)     public     onlyOwner {     if (address(upgradeContract) != address(0)) {         registrar.setApprovalForAll(address(upgradeContract), false);         ens.setApprovalForAll(address(upgradeContract), false);     }      upgradeContract = _upgradeAddress;      if (address(upgradeContract) != address(0)) {         registrar.setApprovalForAll(address(upgradeContract), true);         ens.setApprovalForAll(address(upgradeContract), true);     } }  /**  * @notice Checks if msg.sender is the owner or approved by the owner of a name  * @param node namehash of the name to check  */  modifier onlyTokenOwner(bytes32 node) {     if (!isTokenOwnerOrApproved(node, msg.sender)) {         revert Unauthorised(node, msg.sender);     }      _; }  /**  * @notice Checks if owner or approved by owner  * @param node namehash of the name to check  * @param addr which address to check permissions for  * @return whether or not is owner or approved  */  function isTokenOwnerOrApproved(bytes32 node, address addr)     public     view     override     returns (bool) {     address owner = ownerOf(uint256(node));     return owner == addr || isApprovedForAll(owner, addr); }  /**  * @notice Gets fuse permissions for a specific name  * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit  *      The interface has predefined fuses for all registry permissions, but additional  *      fuses can be added for other use cases  *      Also returns expiry, which is when the fuses are set to expire.  * @param node namehash of the name to check  * @return fuses A number that represents the permissions a name has. Returns 0 when expiry &lt; block.timestamp  * @return expiry Unix time of when the name expires and fuses are to expire  */ function getFuses(bytes32 node)     public     view     override     returns (uint32 fuses, uint64 expiry) {     (, fuses, expiry) = getData(uint256(node));     if (fuses == 0 &amp;&amp; expiry == 0) {         bytes memory name = names[node];         if (name.length == 0) {             revert NameNotFound();         }     } }  /**  * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract  * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar  * @param label label as a string of the .eth domain to wrap  * @param wrappedOwner Owner of the name in this contract  * @param fuses initial fuses to set  * @param expiry when the fuses will expire  * @param resolver resolver contract address  */  function wrapETH2LD(     string calldata label,     address wrappedOwner,     uint32 fuses,     uint64 expiry,     address resolver ) public override returns (uint64) {     uint256 tokenId = uint256(keccak256(bytes(label)));     address registrant = registrar.ownerOf(tokenId);     if (         registrant != msg.sender &amp;&amp;         !isApprovedForAll(registrant, msg.sender) &amp;&amp;         !registrar.isApprovedForAll(registrant, msg.sender)     ) {         revert Unauthorised(             _makeNode(ETH_NODE, bytes32(tokenId)),             msg.sender         );     }      // transfer the token from the user to this contract     registrar.transferFrom(registrant, address(this), tokenId);      // transfer the ens record back to the new owner (this contract)     registrar.reclaim(tokenId, address(this));      return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver); }  /**  * @dev Registers a new .eth second-level domain and wraps it.  *      Only callable by authorised controllers.  * @param label The label to register (Eg, 'foo' for 'foo.eth').  * @param wrappedOwner The owner of the wrapped name.  * @param duration The duration, in seconds, to register the name for.  * @param resolver The resolver address to set on the ENS registry (optional).  * @param fuses initial fuses to set  * @param expiry when the fuses will expire  * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.  */  function registerAndWrapETH2LD(     string calldata label,     address wrappedOwner,     uint256 duration,     address resolver,     uint32 fuses,     uint64 expiry ) external override onlyController returns (uint256 registrarExpiry) {     uint256 tokenId = uint256(keccak256(bytes(label)));     registrarExpiry = registrar.register(tokenId, address(this), duration);     _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver); }  /**  * @dev Renews a .eth second-level domain.  *      Only callable by authorised controllers.  * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').  * @param duration The number of seconds to renew the name for.  * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.  */ function renew(     uint256 tokenId,     uint256 duration,     uint64 expiry ) external override onlyController returns (uint256 expires) {     bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));      expires = registrar.renew(tokenId, duration);     (address owner, uint32 fuses, uint64 oldExpiry) = getData(         uint256(node)     );     expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));      _setData(node, owner, fuses, expiry); }  /**  * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner in the registry or an authorised caller in the registry  * @param name The name to wrap, in DNS format  * @param wrappedOwner Owner of the name in this contract  * @param resolver resolver contract address  */  function wrap(     bytes calldata name,     address wrappedOwner,     address resolver ) public override {     (bytes32 labelhash, uint256 offset) = name.readLabel(0);     bytes32 parentNode = name.namehash(offset);     bytes32 node = _makeNode(parentNode, labelhash);      if (parentNode == ETH_NODE) {         revert IncompatibleParent();     }      address owner = ens.owner(node);      if (         owner != msg.sender &amp;&amp;         !isApprovedForAll(owner, msg.sender) &amp;&amp;         !ens.isApprovedForAll(owner, msg.sender)     ) {         revert Unauthorised(node, msg.sender);     }      if (resolver != address(0)) {         ens.setResolver(node, resolver);     }      ens.setOwner(node, address(this));      _wrap(node, name, wrappedOwner, 0, 0); }  /**  * @notice Unwraps a .eth domain. e.g. vitalik.eth  * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper  * @param labelhash labelhash of the .eth domain  * @param newRegistrant sets the owner in the .eth registrar to this address  * @param newController sets the owner in the registry to this address  */  function unwrapETH2LD(     bytes32 labelhash,     address newRegistrant,     address newController ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {     _unwrap(_makeNode(ETH_NODE, labelhash), newController);     registrar.transferFrom(         address(this),         newRegistrant,         uint256(labelhash)     ); }  /**  * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper  * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')  * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')  * @param newController sets the owner in the registry to this address  */  function unwrap(     bytes32 parentNode,     bytes32 labelhash,     address newController ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {     if (parentNode == ETH_NODE) {         revert IncompatibleParent();     }     _unwrap(_makeNode(parentNode, labelhash), newController); }  /**  * @notice Sets fuses of a name  * @param node namehash of the name  * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)  */  function setFuses(bytes32 node, uint32 fuses)     public     onlyTokenOwner(node)     operationAllowed(node, CANNOT_BURN_FUSES)     returns (uint32) {     if (fuses &amp; PARENT_CANNOT_CONTROL != 0) {         // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.         revert Unauthorised(node, msg.sender);     }      (address owner, uint32 oldFuses, uint64 expiry) = getData(         uint256(node)     );      fuses |= oldFuses;     _setFuses(node, owner, fuses, expiry);     return fuses; }  /**  * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract  *     and burning the token of this contract  * @dev Can be called by the owner of the name in this contract  * @param label Label as a string of the .eth name to upgrade  * @param wrappedOwner The owner of the wrapped name  */  function upgradeETH2LD(     string calldata label,     address wrappedOwner,     address resolver ) public {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(ETH_NODE, labelhash);     (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);      upgradeContract.wrapETH2LD(         label,         wrappedOwner,         fuses,         expiry,         resolver     ); }  /**  * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner or an authorised caller  * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names  * @param parentNode namehash of the parent name  * @param label Label as a string of the name to upgrade  * @param wrappedOwner Owner of the name in this contract  * @param resolver resolver contract for this name  */  function upgrade(     bytes32 parentNode,     string calldata label,     address wrappedOwner,     address resolver ) public {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(parentNode, labelhash);     (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);     upgradeContract.setSubnodeRecord(         parentNode,         label,         wrappedOwner,         resolver,         0,         fuses,         expiry     ); }  /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name  * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')  * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')  * @param fuses fuses to burn  * @param expiry when the fuses will expire  */  function setChildFuses(     bytes32 parentNode,     bytes32 labelhash,     uint32 fuses,     uint64 expiry ) public {     bytes32 node = _makeNode(parentNode, labelhash);     (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(         uint256(node)     );     uint64 maxExpiry;     if (parentNode == ETH_NODE) {         if (!isTokenOwnerOrApproved(node, msg.sender)) {             revert Unauthorised(node, msg.sender);         }         // max expiry is set to the expiry on the registrar         maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));     } else {         if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {             revert Unauthorised(node, msg.sender);         }          // max expiry is set to the expiry of the parent         (, , maxExpiry) = getData(uint256(parentNode));     }      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);      // if PARENT_CANNOT_CONTROL has been burned and fuses have changed     if (         oldFuses &amp; PARENT_CANNOT_CONTROL != 0 &amp;&amp;         oldFuses | fuses != oldFuses     ) {         revert OperationProhibited(node);     }     fuses |= oldFuses;     _setFuses(node, owner, fuses, expiry); }  /**  * @notice Sets the subdomain owner in the registry and then wraps the subdomain  * @param parentNode parent namehash of the subdomain  * @param label label of the subdomain as a string  * @param newOwner newOwner in the registry  * @param fuses initial fuses for the wrapped subdomain  * @param expiry when the fuses will expire  */  function setSubnodeOwner(     bytes32 parentNode,     string calldata label,     address newOwner,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))     returns (bytes32 node) {     bytes32 labelhash = keccak256(bytes(label));     node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);      if (ens.owner(node) != address(this)) {         ens.setSubnodeOwner(parentNode, labelhash, address(this));         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } }  /**  * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain  * @param parentNode parent namehash of the subdomain  * @param label label of the subdomain as a string  * @param newOwner newOwner in the registry  * @param resolver resolver contract in the registry  * @param ttl ttl in the regsitry  * @param fuses initial fuses for the wrapped subdomain  * @param expiry expiry date for the domain  */  function setSubnodeRecord(     bytes32 parentNode,     string memory label,     address newOwner,     address resolver,     uint64 ttl,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label))) {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);     if (ens.owner(node) != address(this)) {         ens.setSubnodeRecord(             parentNode,             labelhash,             address(this),             resolver,             ttl         );         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         ens.setSubnodeRecord(             parentNode,             labelhash,             address(this),             resolver,             ttl         );         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } }  /**  * @notice Sets records for the name in the ENS Registry  * @param node namehash of the name to set a record for  * @param owner newOwner in the registry  * @param resolver the resolver contract  * @param ttl ttl in the registry  */  function setRecord(     bytes32 node,     address owner,     address resolver,     uint64 ttl )     public     override     onlyTokenOwner(node)     operationAllowed(         node,         CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL     ) {     ens.setRecord(node, address(this), resolver, ttl);     (address oldOwner, , ) = getData(uint256(node));     _transfer(oldOwner, owner, uint256(node), 1, ""); }  /**  * @notice Sets resolver contract in the registry  * @param node namehash of the name  * @param resolver the resolver contract  */  function setResolver(bytes32 node, address resolver)     public     override     onlyTokenOwner(node)     operationAllowed(node, CANNOT_SET_RESOLVER) {     ens.setResolver(node, resolver); }  /**  * @notice Sets TTL in the registry  * @param node namehash of the name  * @param ttl TTL in the registry  */  function setTTL(bytes32 node, uint64 ttl)     public     override     onlyTokenOwner(node)     operationAllowed(node, CANNOT_SET_TTL) {     ens.setTTL(node, ttl); }  /**  * @dev Allows an operation only if none of the specified fuses are burned.  * @param node The namehash of the name to check fuses on.  * @param fuseMask A bitmask of fuses that must not be burned.  */  modifier operationAllowed(bytes32 node, uint32 fuseMask) {     (, uint32 fuses, ) = getData(uint256(node));     if (fuses &amp; fuseMask != 0) {         revert OperationProhibited(node);     }     _; }  /**  * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord  * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt  *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for  *      replacing a subdomain. If either conditions are true, then it is possible to call  *      setSubnodeOwner  * @param node namehash of the name to check  * @param labelhash labelhash of the name to check  */  modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {     bytes32 subnode = _makeNode(node, labelhash);     address owner = ens.owner(subnode);      if (owner == address(0)) {         (, uint32 fuses, ) = getData(uint256(node));         if (fuses &amp; CANNOT_CREATE_SUBDOMAIN != 0) {             revert OperationProhibited(node);         }     } else {         (, uint32 subnodeFuses, ) = getData(uint256(subnode));         if (subnodeFuses &amp; PARENT_CANNOT_CONTROL != 0) {             revert OperationProhibited(node);         }     }      _; }  /**  * @notice Checks all Fuses in the mask are burned for the node  * @param node namehash of the name  * @param fuseMask the fuses you want to check  * @return Boolean of whether or not all the selected fuses are burned  */  function allFusesBurned(bytes32 node, uint32 fuseMask)     public     view     override     returns (bool) {     (, uint32 fuses, ) = getData(uint256(node));     return fuses &amp; fuseMask == fuseMask; }  function onERC721Received(     address to,     address,     uint256 tokenId,     bytes calldata data ) public override returns (bytes4) {     //check if it's the eth registrar ERC721     if (msg.sender != address(registrar)) {         revert IncorrectTokenType();     }      (         string memory label,         address owner,         uint32 fuses,         uint64 expiry,         address resolver     ) = abi.decode(data, (string, address, uint32, uint64, address));      bytes32 labelhash = bytes32(tokenId);     bytes32 labelhashFromData = keccak256(bytes(label));      if (labelhashFromData != labelhash) {         revert LabelMismatch(labelhashFromData, labelhash);     }      // transfer the ens record back to the new owner (this contract)     registrar.reclaim(uint256(labelhash), address(this));      _wrapETH2LD(label, owner, fuses, expiry, resolver);      return IERC721Receiver(to).onERC721Received.selector; }  /***** Internal functions */  function _canTransfer(uint32 fuses) internal pure override returns (bool) {     return fuses &amp; CANNOT_TRANSFER == 0; }  function _makeNode(bytes32 node, bytes32 labelhash)     private     pure     returns (bytes32) {     return keccak256(abi.encodePacked(node, labelhash)); }  function _addLabel(string memory label, bytes memory name)     internal     pure     returns (bytes memory ret) {     if (bytes(label).length &lt; 1) {         revert LabelTooShort();     }     if (bytes(label).length &gt; 255) {         revert LabelTooLong(label);     }     return abi.encodePacked(uint8(bytes(label).length), label, name); }  function _mint(     bytes32 node,     address wrappedOwner,     uint32 fuses,     uint64 expiry ) internal override {     address oldWrappedOwner = ownerOf(uint256(node));     _canFusesBeBurned(node, fuses);     if (oldWrappedOwner != address(0)) {         // burn and unwrap old token of old owner         _burn(uint256(node));         emit NameUnwrapped(node, address(0));     }     super._mint(node, wrappedOwner, fuses, expiry); }  function _wrap(     bytes32 node,     bytes memory name,     address wrappedOwner,     uint32 fuses,     uint64 expiry ) internal {     names[node] = name;     _mint(node, wrappedOwner, fuses, expiry);     emit NameWrapped(node, name, wrappedOwner, fuses, expiry); }  function _addLabelAndWrap(     bytes32 parentNode,     bytes32 node,     string memory label,     address newOwner,     uint32 fuses,     uint64 expiry ) internal {     bytes memory name = _addLabel(label, names[parentNode]);     _wrap(node, name, newOwner, fuses, expiry); }  function _prepareUpgrade(bytes32 node)     private     returns (uint32 fuses, uint64 expiry) {     if (address(upgradeContract) == address(0)) {         revert CannotUpgrade();     }      if (!isTokenOwnerOrApproved(node, msg.sender)) {         revert Unauthorised(node, msg.sender);     }      (fuses, expiry) = getFuses(node);      // burn token and fuse data     _burn(uint256(node)); }  function _transferAndBurnFuses(     bytes32 node,     address newOwner,     uint32 fuses,     uint64 expiry ) internal {     (address owner, , ) = getData(uint256(node));     _transfer(owner, newOwner, uint256(node), 1, "");     _setFuses(node, newOwner, fuses, expiry); }  // wrapper function for stack limit function _getDataAndNormaliseExpiry(     bytes32 parentNode,     bytes32 node,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     (, , uint64 maxExpiry) = getData(uint256(parentNode));      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); }  function _getETH2LDDataAndNormaliseExpiry(     bytes32 node,     bytes32 labelhash,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); }  function _normaliseExpiry(     uint64 expiry,     uint64 oldExpiry,     uint64 maxExpiry ) internal pure returns (uint64) {     // Expiry cannot be more than maximum allowed     // .eth names will check registrar, non .eth check parent     if (expiry &gt; maxExpiry) {         expiry = maxExpiry;     }     // Expiry cannot be less than old expiry     if (expiry &lt; oldExpiry) {         expiry = oldExpiry;     }      return expiry; }  function _wrapETH2LD(     string memory label,     address wrappedOwner,     uint32 fuses,     uint64 expiry,     address resolver ) private returns (uint64) {     // Mint a new ERC1155 token with fuses     // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(ETH_NODE, labelhash);      (, , expiry) = _getETH2LDDataAndNormaliseExpiry(         node,         labelhash,         expiry     );      _addLabelAndWrap(         ETH_NODE,         node,         label,         wrappedOwner,         fuses | PARENT_CANNOT_CONTROL,         expiry     );     if (resolver != address(0)) {         ens.setResolver(node, resolver);     }      return expiry; }  function _unwrap(bytes32 node, address newOwner) private {     if (newOwner == address(0x0) || newOwner == address(this)) {         revert IncorrectTargetOwner(newOwner);     }      if (allFusesBurned(node, CANNOT_UNWRAP)) {         revert OperationProhibited(node);     }      // Burn token and fuse data     _burn(uint256(node));     ens.setOwner(node, newOwner);      emit NameUnwrapped(node, newOwner); }  function _setFuses(     bytes32 node,     address owner,     uint32 fuses,     uint64 expiry ) internal {     _setData(node, owner, fuses, expiry);     emit FusesSet(node, fuses, expiry); }  function _setData(     bytes32 node,     address owner,     uint32 fuses,     uint64 expiry ) internal {     _canFusesBeBurned(node, fuses);     super._setData(uint256(node), owner, fuses, expiry); }  function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {     if (         fuses &amp; ~PARENT_CANNOT_CONTROL != 0 &amp;&amp;         fuses &amp; (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=         (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)     ) {         revert OperationProhibited(node);     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 20:36:10 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: //SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "./ERC1155Fuse.sol";
import "./Controllable.sol";
import "./INameWrapper.sol";
import "./INameWrapperUpgrade.sol";
import "./IMetadataService.sol";
import "../registry/ENS.sol";
import "../ethregistrar/IBaseRegistrar.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./BytesUtil.sol";

error Unauthorised(bytes32 node, address addr);
error NameNotFound();
error IncompatibleParent();
error IncompatibleName(bytes name);
error IncorrectTokenType();
error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);
error LabelTooShort();
error LabelTooLong(string label);
error IncorrectTargetOwner(address owner);
error CannotUpgrade();
error InvalidExpiry(bytes32 node, uint64 expiry);

contract NameWrapper is
    Ownable,
    ERC1155Fuse,
    INameWrapper,
    Controllable,
    IERC721Receiver
{
    using BytesUtils for bytes;
    ENS public immutable override ens;
    IBaseRegistrar public immutable override registrar;
    IMetadataService public override metadataService;
    mapping(bytes32 => bytes) public override names;

    bytes32 private constant ETH_NODE =
        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
    bytes32 private constant ROOT_NODE =
        0x0000000000000000000000000000000000000000000000000000000000000000;

    //A contract address to a new upgraded contract if any
    INameWrapperUpgrade public upgradeContract;
    uint64 private constant MAX_EXPIRY = type(uint64).max;

    constructor(
        ENS _ens,
        IBaseRegistrar _registrar,
        IMetadataService _metadataService
    ) {
        ens = _ens;
        registrar = _registrar;
        metadataService = _metadataService;

        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */

        _setData(
            uint256(ETH_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        _setData(
            uint256(ROOT_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        names[ROOT_NODE] = "\x00";
        names[ETH_NODE] = "\x03eth\x00";
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Fuse, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(INameWrapper).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /* ERC1155 */

    function ownerOf(uint256 id)
        public
        view
        override(ERC1155Fuse, INameWrapper)
        returns (address owner)
    {
        return super.ownerOf(id);
    }

    /* Metadata service */

    /**
     * @notice Set the metadata service. Only the owner can do this
     */

    function setMetadataService(IMetadataService _newMetadataService)
        public
        onlyOwner
    {
        metadataService = _newMetadataService;
    }

    /**
     * @notice Get the metadata uri
     * @return String uri of the metadata service
     */

    function uri(uint256 tokenId) public view override returns (string memory) {
        return metadataService.uri(tokenId);
    }

    /**
     * @notice Set the address of the upgradeContract of the contract. only admin can do this
     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time
     * to make the contract not upgradable.
     * @param _upgradeAddress address of an upgraded contract
     */

    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)
        public
        onlyOwner
    {
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), false);
            ens.setApprovalForAll(address(upgradeContract), false);
        }

        upgradeContract = _upgradeAddress;

        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), true);
            ens.setApprovalForAll(address(upgradeContract), true);
        }
    }

    /**
     * @notice Checks if msg.sender is the owner or approved by the owner of a name
     * @param node namehash of the name to check
     */

    modifier onlyTokenOwner(bytes32 node) {
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        _;
    }

    /**
     * @notice Checks if owner or approved by owner
     * @param node namehash of the name to check
     * @param addr which address to check permissions for
     * @return whether or not is owner or approved
     */

    function isTokenOwnerOrApproved(bytes32 node, address addr)
        public
        view
        override
        returns (bool)
    {
        address owner = ownerOf(uint256(node));
        return owner == addr || isApprovedForAll(owner, addr);
    }

    /**
     * @notice Gets fuse permissions for a specific name
     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit
     *      The interface has predefined fuses for all registry permissions, but additional
     *      fuses can be added for other use cases
     *      Also returns expiry, which is when the fuses are set to expire.
     * @param node namehash of the name to check
     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp
     * @return expiry Unix time of when the name expires and fuses are to expire
     */
    function getFuses(bytes32 node)
        public
        view
        override
        returns (uint32 fuses, uint64 expiry)
    {
        (, fuses, expiry) = getData(uint256(node));
        if (fuses == 0 && expiry == 0) {
            bytes memory name = names[node];
            if (name.length == 0) {
                revert NameNotFound();
            }
        }
    }

    /**
     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract
     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar
     * @param label label as a string of the .eth domain to wrap
     * @param wrappedOwner Owner of the name in this contract
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @param resolver resolver contract address
     */

    function wrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) public override returns (uint64) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        address registrant = registrar.ownerOf(tokenId);
        if (
            registrant != msg.sender &&
            !isApprovedForAll(registrant, msg.sender) &&
            !registrar.isApprovedForAll(registrant, msg.sender)
        ) {
            revert Unauthorised(
                _makeNode(ETH_NODE, bytes32(tokenId)),
                msg.sender
            );
        }

        // transfer the token from the user to this contract
        registrar.transferFrom(registrant, address(this), tokenId);

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(tokenId, address(this));

        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Registers a new .eth second-level domain and wraps it.
     *      Only callable by authorised controllers.
     * @param label The label to register (Eg, 'foo' for 'foo.eth').
     * @param wrappedOwner The owner of the wrapped name.
     * @param duration The duration, in seconds, to register the name for.
     * @param resolver The resolver address to set on the ENS registry (optional).
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.
     */

    function registerAndWrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint256 duration,
        address resolver,
        uint32 fuses,
        uint64 expiry
    ) external override onlyController returns (uint256 registrarExpiry) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        registrarExpiry = registrar.register(tokenId, address(this), duration);
        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Renews a .eth second-level domain.
     *      Only callable by authorised controllers.
     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').
     * @param duration The number of seconds to renew the name for.
     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.
     */
    function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));

        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));

        _setData(node, owner, fuses, expiry);
    }

    /**
     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the registry or an authorised caller in the registry
     * @param name The name to wrap, in DNS format
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract address
     */

    function wrap(
        bytes calldata name,
        address wrappedOwner,
        address resolver
    ) public override {
        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
        bytes32 parentNode = name.namehash(offset);
        bytes32 node = _makeNode(parentNode, labelhash);

        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }

        address owner = ens.owner(node);

        if (
            owner != msg.sender &&
            !isApprovedForAll(owner, msg.sender) &&
            !ens.isApprovedForAll(owner, msg.sender)
        ) {
            revert Unauthorised(node, msg.sender);
        }

        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        ens.setOwner(node, address(this));

        _wrap(node, name, wrappedOwner, 0, 0);
    }

    /**
     * @notice Unwraps a .eth domain. e.g. vitalik.eth
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param labelhash labelhash of the .eth domain
     * @param newRegistrant sets the owner in the .eth registrar to this address
     * @param newController sets the owner in the registry to this address
     */

    function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }

    /**
     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param newController sets the owner in the registry to this address
     */

    function unwrap(
        bytes32 parentNode,
        bytes32 labelhash,
        address newController
    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        _unwrap(_makeNode(parentNode, labelhash), newController);
    }

    /**
     * @notice Sets fuses of a name
     * @param node namehash of the name
     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)
     */

    function setFuses(bytes32 node, uint32 fuses)
        public
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_BURN_FUSES)
        returns (uint32)
    {
        if (fuses & PARENT_CANNOT_CONTROL != 0) {
            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.
            revert Unauthorised(node, msg.sender);
        }

        (address owner, uint32 oldFuses, uint64 expiry) = getData(
            uint256(node)
        );

        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
        return fuses;
    }

    /**
     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract
     *     and burning the token of this contract
     * @dev Can be called by the owner of the name in this contract
     * @param label Label as a string of the .eth name to upgrade
     * @param wrappedOwner The owner of the wrapped name
     */

    function upgradeETH2LD(
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);

        upgradeContract.wrapETH2LD(
            label,
            wrappedOwner,
            fuses,
            expiry,
            resolver
        );
    }

    /**
     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner or an authorised caller
     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names
     * @param parentNode namehash of the parent name
     * @param label Label as a string of the name to upgrade
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract for this name
     */

    function upgrade(
        bytes32 parentNode,
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.setSubnodeRecord(
            parentNode,
            label,
            wrappedOwner,
            resolver,
            0,
            fuses,
            expiry
        );
    }

    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param fuses fuses to burn
     * @param expiry when the fuses will expire
     */

    function setChildFuses(
        bytes32 parentNode,
        bytes32 labelhash,
        uint32 fuses,
        uint64 expiry
    ) public {
        bytes32 node = _makeNode(parentNode, labelhash);
        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        uint64 maxExpiry;
        if (parentNode == ETH_NODE) {
            if (!isTokenOwnerOrApproved(node, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            // max expiry is set to the expiry on the registrar
            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        } else {
            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }

            // max expiry is set to the expiry of the parent
            (, , maxExpiry) = getData(uint256(parentNode));
        }

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);

        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed
        if (
            oldFuses & PARENT_CANNOT_CONTROL != 0 &&
            oldFuses | fuses != oldFuses
        ) {
            revert OperationProhibited(node);
        }
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
    }

    /**
     * @notice Sets the subdomain owner in the registry and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry when the fuses will expire
     */

    function setSubnodeOwner(
        bytes32 parentNode,
        string calldata label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
        returns (bytes32 node)
    {
        bytes32 labelhash = keccak256(bytes(label));
        node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);

        if (ens.owner(node) != address(this)) {
            ens.setSubnodeOwner(parentNode, labelhash, address(this));
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param resolver resolver contract in the registry
     * @param ttl ttl in the regsitry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry expiry date for the domain
     */

    function setSubnodeRecord(
        bytes32 parentNode,
        string memory label,
        address newOwner,
        address resolver,
        uint64 ttl,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
    {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets records for the name in the ENS Registry
     * @param node namehash of the name to set a record for
     * @param owner newOwner in the registry
     * @param resolver the resolver contract
     * @param ttl ttl in the registry
     */

    function setRecord(
        bytes32 node,
        address owner,
        address resolver,
        uint64 ttl
    )
        public
        override
        onlyTokenOwner(node)
        operationAllowed(
            node,
            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL
        )
    {
        ens.setRecord(node, address(this), resolver, ttl);
        (address oldOwner, , ) = getData(uint256(node));
        _transfer(oldOwner, owner, uint256(node), 1, "");
    }

    /**
     * @notice Sets resolver contract in the registry
     * @param node namehash of the name
     * @param resolver the resolver contract
     */

    function setResolver(bytes32 node, address resolver)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_RESOLVER)
    {
        ens.setResolver(node, resolver);
    }

    /**
     * @notice Sets TTL in the registry
     * @param node namehash of the name
     * @param ttl TTL in the registry
     */

    function setTTL(bytes32 node, uint64 ttl)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_TTL)
    {
        ens.setTTL(node, ttl);
    }

    /**
     * @dev Allows an operation only if none of the specified fuses are burned.
     * @param node The namehash of the name to check fuses on.
     * @param fuseMask A bitmask of fuses that must not be burned.
     */

    modifier operationAllowed(bytes32 node, uint32 fuseMask) {
        (, uint32 fuses, ) = getData(uint256(node));
        if (fuses & fuseMask != 0) {
            revert OperationProhibited(node);
        }
        _;
    }

    /**
     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord
     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt
     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for
     *      replacing a subdomain. If either conditions are true, then it is possible to call
     *      setSubnodeOwner
     * @param node namehash of the name to check
     * @param labelhash labelhash of the name to check
     */

    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {
        bytes32 subnode = _makeNode(node, labelhash);
        address owner = ens.owner(subnode);

        if (owner == address(0)) {
            (, uint32 fuses, ) = getData(uint256(node));
            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {
                revert OperationProhibited(node);
            }
        } else {
            (, uint32 subnodeFuses, ) = getData(uint256(subnode));
            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {
                revert OperationProhibited(node);
            }
        }

        _;
    }

    /**
     * @notice Checks all Fuses in the mask are burned for the node
     * @param node namehash of the name
     * @param fuseMask the fuses you want to check
     * @return Boolean of whether or not all the selected fuses are burned
     */

    function allFusesBurned(bytes32 node, uint32 fuseMask)
        public
        view
        override
        returns (bool)
    {
        (, uint32 fuses, ) = getData(uint256(node));
        return fuses & fuseMask == fuseMask;
    }

    function onERC721Received(
        address to,
        address,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        //check if it's the eth registrar ERC721
        if (msg.sender != address(registrar)) {
            revert IncorrectTokenType();
        }

        (
            string memory label,
            address owner,
            uint32 fuses,
            uint64 expiry,
            address resolver
        ) = abi.decode(data, (string, address, uint32, uint64, address));

        bytes32 labelhash = bytes32(tokenId);
        bytes32 labelhashFromData = keccak256(bytes(label));

        if (labelhashFromData != labelhash) {
            revert LabelMismatch(labelhashFromData, labelhash);
        }

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(uint256(labelhash), address(this));

        _wrapETH2LD(label, owner, fuses, expiry, resolver);

        return IERC721Receiver(to).onERC721Received.selector;
    }

    /***** Internal functions */

    function _canTransfer(uint32 fuses) internal pure override returns (bool) {
        return fuses & CANNOT_TRANSFER == 0;
    }

    function _makeNode(bytes32 node, bytes32 labelhash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, labelhash));
    }

    function _addLabel(string memory label, bytes memory name)
        internal
        pure
        returns (bytes memory ret)
    {
        if (bytes(label).length < 1) {
            revert LabelTooShort();
        }
        if (bytes(label).length > 255) {
            revert LabelTooLong(label);
        }
        return abi.encodePacked(uint8(bytes(label).length), label, name);
    }

    function _mint(
        bytes32 node,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal override {
        address oldWrappedOwner = ownerOf(uint256(node));
        _canFusesBeBurned(node, fuses);
        if (oldWrappedOwner != address(0)) {
            // burn and unwrap old token of old owner
            _burn(uint256(node));
            emit NameUnwrapped(node, address(0));
        }
        super._mint(node, wrappedOwner, fuses, expiry);
    }

    function _wrap(
        bytes32 node,
        bytes memory name,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        names[node] = name;
        _mint(node, wrappedOwner, fuses, expiry);
        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);
    }

    function _addLabelAndWrap(
        bytes32 parentNode,
        bytes32 node,
        string memory label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        bytes memory name = _addLabel(label, names[parentNode]);
        _wrap(node, name, newOwner, fuses, expiry);
    }

    function _prepareUpgrade(bytes32 node)
        private
        returns (uint32 fuses, uint64 expiry)
    {
        if (address(upgradeContract) == address(0)) {
            revert CannotUpgrade();
        }

        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        (fuses, expiry) = getFuses(node);

        // burn token and fuse data
        _burn(uint256(node));
    }

    function _transferAndBurnFuses(
        bytes32 node,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        (address owner, , ) = getData(uint256(node));
        _transfer(owner, newOwner, uint256(node), 1, "");
        _setFuses(node, newOwner, fuses, expiry);
    }

    // wrapper function for stack limit
    function _getDataAndNormaliseExpiry(
        bytes32 parentNode,
        bytes32 node,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        (, , uint64 maxExpiry) = getData(uint256(parentNode));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _getETH2LDDataAndNormaliseExpiry(
        bytes32 node,
        bytes32 labelhash,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _normaliseExpiry(
        uint64 expiry,
        uint64 oldExpiry,
        uint64 maxExpiry
    ) internal pure returns (uint64) {
        // Expiry cannot be more than maximum allowed
        // .eth names will check registrar, non .eth check parent
        if (expiry > maxExpiry) {
            expiry = maxExpiry;
        }
        // Expiry cannot be less than old expiry
        if (expiry < oldExpiry) {
            expiry = oldExpiry;
        }

        return expiry;
    }

    function _wrapETH2LD(
        string memory label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) private returns (uint64) {
        // Mint a new ERC1155 token with fuses
        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);

        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(
            node,
            labelhash,
            expiry
        );

        _addLabelAndWrap(
            ETH_NODE,
            node,
            label,
            wrappedOwner,
            fuses | PARENT_CANNOT_CONTROL,
            expiry
        );
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        return expiry;
    }

    function _unwrap(bytes32 node, address newOwner) private {
        if (newOwner == address(0x0) || newOwner == address(this)) {
            revert IncorrectTargetOwner(newOwner);
        }

        if (allFusesBurned(node, CANNOT_UNWRAP)) {
            revert OperationProhibited(node);
        }

        // Burn token and fuse data
        _burn(uint256(node));
        ens.setOwner(node, newOwner);

        emit NameUnwrapped(node, newOwner);
    }

    function _setFuses(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _setData(node, owner, fuses, expiry);
        emit FusesSet(node, fuses, expiry);
    }

    function _setData(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _canFusesBeBurned(node, fuses);
        super._setData(uint256(node), owner, fuses, expiry);
    }

    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
        if (
            fuses & ~PARENT_CANNOT_CONTROL != 0 &&
            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
        ) {
            revert OperationProhibited(node);
        }
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-01-09 20:36:26 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 20:36:26 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 7200
completion_tokens: 799
total_tokens: 7999
cost: $-1.000000


[2024-01-09 20:36:26 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: //SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "./ERC1155Fuse.sol";
import "./Controllable.sol";
import "./INameWrapper.sol";
import "./INameWrapperUpgrade.sol";
import "./IMetadataService.sol";
import "../registry/ENS.sol";
import "../ethregistrar/IBaseRegistrar.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./BytesUtil.sol";

error Unauthorised(bytes32 node, address addr);
error NameNotFound();
error IncompatibleParent();
error IncompatibleName(bytes name);
error IncorrectTokenType();
error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);
error LabelTooShort();
error LabelTooLong(string label);
error IncorrectTargetOwner(address owner);
error CannotUpgrade();
error InvalidExpiry(bytes32 node, uint64 expiry);

contract NameWrapper is
    Ownable,
    ERC1155Fuse,
    INameWrapper,
    Controllable,
    IERC721Receiver
{
    using BytesUtils for bytes;
    ENS public immutable override ens;
    IBaseRegistrar public immutable override registrar;
    IMetadataService public override metadataService;
    mapping(bytes32 => bytes) public override names;

    bytes32 private constant ETH_NODE =
        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
    bytes32 private constant ROOT_NODE =
        0x0000000000000000000000000000000000000000000000000000000000000000;

    //A contract address to a new upgraded contract if any
    INameWrapperUpgrade public upgradeContract;
    uint64 private constant MAX_EXPIRY = type(uint64).max;

    constructor(
        ENS _ens,
        IBaseRegistrar _registrar,
        IMetadataService _metadataService
    ) {
        ens = _ens;
        registrar = _registrar;
        metadataService = _metadataService;

        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */

        _setData(
            uint256(ETH_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        _setData(
            uint256(ROOT_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        names[ROOT_NODE] = "\x00";
        names[ETH_NODE] = "\x03eth\x00";
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Fuse, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(INameWrapper).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /* ERC1155 */

    function ownerOf(uint256 id)
        public
        view
        override(ERC1155Fuse, INameWrapper)
        returns (address owner)
    {
        return super.ownerOf(id);
    }

    /* Metadata service */

    /**
     * @notice Set the metadata service. Only the owner can do this
     */

    function setMetadataService(IMetadataService _newMetadataService)
        public
        onlyOwner
    {
        metadataService = _newMetadataService;
    }

    /**
     * @notice Get the metadata uri
     * @return String uri of the metadata service
     */

    function uri(uint256 tokenId) public view override returns (string memory) {
        return metadataService.uri(tokenId);
    }

    /**
     * @notice Set the address of the upgradeContract of the contract. only admin can do this
     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time
     * to make the contract not upgradable.
     * @param _upgradeAddress address of an upgraded contract
     */

    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)
        public
        onlyOwner
    {
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), false);
            ens.setApprovalForAll(address(upgradeContract), false);
        }

        upgradeContract = _upgradeAddress;

        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), true);
            ens.setApprovalForAll(address(upgradeContract), true);
        }
    }

    /**
     * @notice Checks if msg.sender is the owner or approved by the owner of a name
     * @param node namehash of the name to check
     */

    modifier onlyTokenOwner(bytes32 node) {
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        _;
    }

    /**
     * @notice Checks if owner or approved by owner
     * @param node namehash of the name to check
     * @param addr which address to check permissions for
     * @return whether or not is owner or approved
     */

    function isTokenOwnerOrApproved(bytes32 node, address addr)
        public
        view
        override
        returns (bool)
    {
        address owner = ownerOf(uint256(node));
        return owner == addr || isApprovedForAll(owner, addr);
    }

    /**
     * @notice Gets fuse permissions for a specific name
     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit
     *      The interface has predefined fuses for all registry permissions, but additional
     *      fuses can be added for other use cases
     *      Also returns expiry, which is when the fuses are set to expire.
     * @param node namehash of the name to check
     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp
     * @return expiry Unix time of when the name expires and fuses are to expire
     */
    function getFuses(bytes32 node)
        public
        view
        override
        returns (uint32 fuses, uint64 expiry)
    {
        (, fuses, expiry) = getData(uint256(node));
        if (fuses == 0 && expiry == 0) {
            bytes memory name = names[node];
            if (name.length == 0) {
                revert NameNotFound();
            }
        }
    }

    /**
     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract
     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar
     * @param label label as a string of the .eth domain to wrap
     * @param wrappedOwner Owner of the name in this contract
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @param resolver resolver contract address
     */

    function wrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) public override returns (uint64) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        address registrant = registrar.ownerOf(tokenId);
        if (
            registrant != msg.sender &&
            !isApprovedForAll(registrant, msg.sender) &&
            !registrar.isApprovedForAll(registrant, msg.sender)
        ) {
            revert Unauthorised(
                _makeNode(ETH_NODE, bytes32(tokenId)),
                msg.sender
            );
        }

        // transfer the token from the user to this contract
        registrar.transferFrom(registrant, address(this), tokenId);

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(tokenId, address(this));

        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Registers a new .eth second-level domain and wraps it.
     *      Only callable by authorised controllers.
     * @param label The label to register (Eg, 'foo' for 'foo.eth').
     * @param wrappedOwner The owner of the wrapped name.
     * @param duration The duration, in seconds, to register the name for.
     * @param resolver The resolver address to set on the ENS registry (optional).
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.
     */

    function registerAndWrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint256 duration,
        address resolver,
        uint32 fuses,
        uint64 expiry
    ) external override onlyController returns (uint256 registrarExpiry) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        registrarExpiry = registrar.register(tokenId, address(this), duration);
        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Renews a .eth second-level domain.
     *      Only callable by authorised controllers.
     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').
     * @param duration The number of seconds to renew the name for.
     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.
     */
    function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));

        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));

        _setData(node, owner, fuses, expiry);
    }

    /**
     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the registry or an authorised caller in the registry
     * @param name The name to wrap, in DNS format
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract address
     */

    function wrap(
        bytes calldata name,
        address wrappedOwner,
        address resolver
    ) public override {
        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
        bytes32 parentNode = name.namehash(offset);
        bytes32 node = _makeNode(parentNode, labelhash);

        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }

        address owner = ens.owner(node);

        if (
            owner != msg.sender &&
            !isApprovedForAll(owner, msg.sender) &&
            !ens.isApprovedForAll(owner, msg.sender)
        ) {
            revert Unauthorised(node, msg.sender);
        }

        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        ens.setOwner(node, address(this));

        _wrap(node, name, wrappedOwner, 0, 0);
    }

    /**
     * @notice Unwraps a .eth domain. e.g. vitalik.eth
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param labelhash labelhash of the .eth domain
     * @param newRegistrant sets the owner in the .eth registrar to this address
     * @param newController sets the owner in the registry to this address
     */

    function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }

    /**
     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param newController sets the owner in the registry to this address
     */

    function unwrap(
        bytes32 parentNode,
        bytes32 labelhash,
        address newController
    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        _unwrap(_makeNode(parentNode, labelhash), newController);
    }

    /**
     * @notice Sets fuses of a name
     * @param node namehash of the name
     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)
     */

    function setFuses(bytes32 node, uint32 fuses)
        public
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_BURN_FUSES)
        returns (uint32)
    {
        if (fuses & PARENT_CANNOT_CONTROL != 0) {
            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.
            revert Unauthorised(node, msg.sender);
        }

        (address owner, uint32 oldFuses, uint64 expiry) = getData(
            uint256(node)
        );

        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
        return fuses;
    }

    /**
     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract
     *     and burning the token of this contract
     * @dev Can be called by the owner of the name in this contract
     * @param label Label as a string of the .eth name to upgrade
     * @param wrappedOwner The owner of the wrapped name
     */

    function upgradeETH2LD(
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);

        upgradeContract.wrapETH2LD(
            label,
            wrappedOwner,
            fuses,
            expiry,
            resolver
        );
    }

    /**
     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner or an authorised caller
     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names
     * @param parentNode namehash of the parent name
     * @param label Label as a string of the name to upgrade
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract for this name
     */

    function upgrade(
        bytes32 parentNode,
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.setSubnodeRecord(
            parentNode,
            label,
            wrappedOwner,
            resolver,
            0,
            fuses,
            expiry
        );
    }

    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param fuses fuses to burn
     * @param expiry when the fuses will expire
     */

    function setChildFuses(
        bytes32 parentNode,
        bytes32 labelhash,
        uint32 fuses,
        uint64 expiry
    ) public {
        bytes32 node = _makeNode(parentNode, labelhash);
        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        uint64 maxExpiry;
        if (parentNode == ETH_NODE) {
            if (!isTokenOwnerOrApproved(node, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            // max expiry is set to the expiry on the registrar
            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        } else {
            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }

            // max expiry is set to the expiry of the parent
            (, , maxExpiry) = getData(uint256(parentNode));
        }

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);

        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed
        if (
            oldFuses & PARENT_CANNOT_CONTROL != 0 &&
            oldFuses | fuses != oldFuses
        ) {
            revert OperationProhibited(node);
        }
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
    }

    /**
     * @notice Sets the subdomain owner in the registry and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry when the fuses will expire
     */

    function setSubnodeOwner(
        bytes32 parentNode,
        string calldata label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
        returns (bytes32 node)
    {
        bytes32 labelhash = keccak256(bytes(label));
        node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);

        if (ens.owner(node) != address(this)) {
            ens.setSubnodeOwner(parentNode, labelhash, address(this));
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param resolver resolver contract in the registry
     * @param ttl ttl in the regsitry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry expiry date for the domain
     */

    function setSubnodeRecord(
        bytes32 parentNode,
        string memory label,
        address newOwner,
        address resolver,
        uint64 ttl,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
    {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets records for the name in the ENS Registry
     * @param node namehash of the name to set a record for
     * @param owner newOwner in the registry
     * @param resolver the resolver contract
     * @param ttl ttl in the registry
     */

    function setRecord(
        bytes32 node,
        address owner,
        address resolver,
        uint64 ttl
    )
        public
        override
        onlyTokenOwner(node)
        operationAllowed(
            node,
            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL
        )
    {
        ens.setRecord(node, address(this), resolver, ttl);
        (address oldOwner, , ) = getData(uint256(node));
        _transfer(oldOwner, owner, uint256(node), 1, "");
    }

    /**
     * @notice Sets resolver contract in the registry
     * @param node namehash of the name
     * @param resolver the resolver contract
     */

    function setResolver(bytes32 node, address resolver)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_RESOLVER)
    {
        ens.setResolver(node, resolver);
    }

    /**
     * @notice Sets TTL in the registry
     * @param node namehash of the name
     * @param ttl TTL in the registry
     */

    function setTTL(bytes32 node, uint64 ttl)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_TTL)
    {
        ens.setTTL(node, ttl);
    }

    /**
     * @dev Allows an operation only if none of the specified fuses are burned.
     * @param node The namehash of the name to check fuses on.
     * @param fuseMask A bitmask of fuses that must not be burned.
     */

    modifier operationAllowed(bytes32 node, uint32 fuseMask) {
        (, uint32 fuses, ) = getData(uint256(node));
        if (fuses & fuseMask != 0) {
            revert OperationProhibited(node);
        }
        _;
    }

    /**
     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord
     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt
     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for
     *      replacing a subdomain. If either conditions are true, then it is possible to call
     *      setSubnodeOwner
     * @param node namehash of the name to check
     * @param labelhash labelhash of the name to check
     */

    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {
        bytes32 subnode = _makeNode(node, labelhash);
        address owner = ens.owner(subnode);

        if (owner == address(0)) {
            (, uint32 fuses, ) = getData(uint256(node));
            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {
                revert OperationProhibited(node);
            }
        } else {
            (, uint32 subnodeFuses, ) = getData(uint256(subnode));
            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {
                revert OperationProhibited(node);
            }
        }

        _;
    }

    /**
     * @notice Checks all Fuses in the mask are burned for the node
     * @param node namehash of the name
     * @param fuseMask the fuses you want to check
     * @return Boolean of whether or not all the selected fuses are burned
     */

    function allFusesBurned(bytes32 node, uint32 fuseMask)
        public
        view
        override
        returns (bool)
    {
        (, uint32 fuses, ) = getData(uint256(node));
        return fuses & fuseMask == fuseMask;
    }

    function onERC721Received(
        address to,
        address,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        //check if it's the eth registrar ERC721
        if (msg.sender != address(registrar)) {
            revert IncorrectTokenType();
        }

        (
            string memory label,
            address owner,
            uint32 fuses,
            uint64 expiry,
            address resolver
        ) = abi.decode(data, (string, address, uint32, uint64, address));

        bytes32 labelhash = bytes32(tokenId);
        bytes32 labelhashFromData = keccak256(bytes(label));

        if (labelhashFromData != labelhash) {
            revert LabelMismatch(labelhashFromData, labelhash);
        }

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(uint256(labelhash), address(this));

        _wrapETH2LD(label, owner, fuses, expiry, resolver);

        return IERC721Receiver(to).onERC721Received.selector;
    }

    /***** Internal functions */

    function _canTransfer(uint32 fuses) internal pure override returns (bool) {
        return fuses & CANNOT_TRANSFER == 0;
    }

    function _makeNode(bytes32 node, bytes32 labelhash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, labelhash));
    }

    function _addLabel(string memory label, bytes memory name)
        internal
        pure
        returns (bytes memory ret)
    {
        if (bytes(label).length < 1) {
            revert LabelTooShort();
        }
        if (bytes(label).length > 255) {
            revert LabelTooLong(label);
        }
        return abi.encodePacked(uint8(bytes(label).length), label, name);
    }

    function _mint(
        bytes32 node,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal override {
        address oldWrappedOwner = ownerOf(uint256(node));
        _canFusesBeBurned(node, fuses);
        if (oldWrappedOwner != address(0)) {
            // burn and unwrap old token of old owner
            _burn(uint256(node));
            emit NameUnwrapped(node, address(0));
        }
        super._mint(node, wrappedOwner, fuses, expiry);
    }

    function _wrap(
        bytes32 node,
        bytes memory name,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        names[node] = name;
        _mint(node, wrappedOwner, fuses, expiry);
        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);
    }

    function _addLabelAndWrap(
        bytes32 parentNode,
        bytes32 node,
        string memory label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        bytes memory name = _addLabel(label, names[parentNode]);
        _wrap(node, name, newOwner, fuses, expiry);
    }

    function _prepareUpgrade(bytes32 node)
        private
        returns (uint32 fuses, uint64 expiry)
    {
        if (address(upgradeContract) == address(0)) {
            revert CannotUpgrade();
        }

        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        (fuses, expiry) = getFuses(node);

        // burn token and fuse data
        _burn(uint256(node));
    }

    function _transferAndBurnFuses(
        bytes32 node,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        (address owner, , ) = getData(uint256(node));
        _transfer(owner, newOwner, uint256(node), 1, "");
        _setFuses(node, newOwner, fuses, expiry);
    }

    // wrapper function for stack limit
    function _getDataAndNormaliseExpiry(
        bytes32 parentNode,
        bytes32 node,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        (, , uint64 maxExpiry) = getData(uint256(parentNode));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _getETH2LDDataAndNormaliseExpiry(
        bytes32 node,
        bytes32 labelhash,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _normaliseExpiry(
        uint64 expiry,
        uint64 oldExpiry,
        uint64 maxExpiry
    ) internal pure returns (uint64) {
        // Expiry cannot be more than maximum allowed
        // .eth names will check registrar, non .eth check parent
        if (expiry > maxExpiry) {
            expiry = maxExpiry;
        }
        // Expiry cannot be less than old expiry
        if (expiry < oldExpiry) {
            expiry = oldExpiry;
        }

        return expiry;
    }

    function _wrapETH2LD(
        string memory label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) private returns (uint64) {
        // Mint a new ERC1155 token with fuses
        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);

        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(
            node,
            labelhash,
            expiry
        );

        _addLabelAndWrap(
            ETH_NODE,
            node,
            label,
            wrappedOwner,
            fuses | PARENT_CANNOT_CONTROL,
            expiry
        );
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        return expiry;
    }

    function _unwrap(bytes32 node, address newOwner) private {
        if (newOwner == address(0x0) || newOwner == address(this)) {
            revert IncorrectTargetOwner(newOwner);
        }

        if (allFusesBurned(node, CANNOT_UNWRAP)) {
            revert OperationProhibited(node);
        }

        // Burn token and fuse data
        _burn(uint256(node));
        ens.setOwner(node, newOwner);

        emit NameUnwrapped(node, newOwner);
    }

    function _setFuses(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _setData(node, owner, fuses, expiry);
        emit FusesSet(node, fuses, expiry);
    }

    function _setData(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _canFusesBeBurned(node, fuses);
        super._setData(uint256(node), owner, fuses, expiry);
    }

    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
        if (
            fuses & ~PARENT_CANNOT_CONTROL != 0 &&
            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
        ) {
            revert OperationProhibited(node);
        }
    }
}
.]

Based on the provided smart contract code for the `NameWrapper` contract, here is a summary of potential security vulnerabilities identified within the code:

### Summary of Security Vulnerabilities

1. **Unauthorized Access**:
   - The contract has multiple functions that rely on the `onlyTokenOwner` modifier to restrict access. If the logic for checking ownership or approval is flawed, unauthorized users could gain access to sensitive functions.

2. **Reentrancy Vulnerability**:
   - Functions that transfer tokens or call external contracts (e.g., `transferFrom`, `setResolver`) may be susceptible to reentrancy attacks if not properly guarded. Although the contract uses `IERC721Receiver`, it does not implement a reentrancy guard.

3. **Improper Handling of Token Transfers**:
   - The contract assumes that the transfer of tokens will always succeed. If a transfer fails (e.g., due to insufficient balance), it could lead to inconsistent state or loss of funds.

4. **Lack of Input Validation**:
   - Functions like `wrap`, `unwrap`, and `setSubnodeOwner` do not adequately validate input parameters. For instance, there is no check to ensure that the `wrappedOwner` is not a zero address.

5. **Potential for Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow/underflow protection, any arithmetic operations that manipulate values should still be reviewed to ensure they do not lead to unexpected behavior.

6. **Upgradeability Risks**:
   - The contract allows for an upgradeable pattern through the `upgradeContract` variable. If not managed properly, this could lead to vulnerabilities if the upgrade contract itself has security flaws.

7. **Excessive Gas Consumption**:
   - Some functions may consume excessive gas due to complex logic or loops, which could lead to failed transactions or denial of service.

8. **Inadequate Event Emission**:
   - While the contract emits events for certain actions, it may not emit events for all state-changing functions, making it difficult to track changes and audit actions on-chain.

### Comprehensive Analysis Report

The `NameWrapper` contract is designed to manage the wrapping and unwrapping of ENS names, providing a mechanism for users to control their domain names securely. However, several security vulnerabilities have been identified that could potentially compromise the integrity and security of the contract.

1. **Access Control**: The reliance on ownership checks without sufficient validation could allow unauthorized users to execute sensitive functions. It is crucial to ensure that all access control mechanisms are robust and thoroughly tested.

2. **Reentrancy**: The absence of reentrancy guards in functions that interact with external contracts poses a significant risk. Implementing the Checks-Effects-Interactions pattern or using a reentrancy guard modifier is recommended.

3. **Token Transfer Assumptions**: The contract should handle potential failures in token transfers gracefully. Implementing checks after transfer calls can help maintain the contract's state consistency.

4. **Input Validation**: Functions should validate all inputs rigorously to prevent unexpected behavior or state changes. This includes checks for zero addresses and valid parameters.

5. **Upgradeability Management**: The upgradeable nature of the contract introduces risks if the upgrade contract is not secure. A thorough audit of the upgrade contract is essential before deployment.

6. **Gas Optimization**: Review and optimize functions to reduce gas consumption, ensuring that users can interact with the contract without facing transaction failures due to high gas costs.

7. **Event Emission**: Ensure that all critical state changes are logged with events to facilitate tracking and auditing of contract interactions.

In conclusion, while the `NameWrapper` contract provides valuable functionality for managing ENS names, it is imperative to address the identified vulnerabilities to enhance security and reliability. A comprehensive security audit, including testing and validation of all access controls, input parameters, and external interactions, is recommended before deployment to the mainnet.

[2024-01-09 20:36:26 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for the `NameWrapper` contract, here is a summary of potential security vulnerabilities identified within the code:

### Summary of Security Vulnerabilities

1. **Unauthorized Access**:
   - The contract has multiple functions that rely on the `onlyTokenOwner` modifier to restrict access. If the logic for checking ownership or approval is flawed, unauthorized users could gain access to sensitive functions.

2. **Reentrancy Vulnerability**:
   - Functions that transfer tokens or call external contracts (e.g., `transferFrom`, `setResolver`) may be susceptible to reentrancy attacks if not properly guarded. Although the contract uses `IERC721Receiver`, it does not implement a reentrancy guard.

3. **Improper Handling of Token Transfers**:
   - The contract assumes that the transfer of tokens will always succeed. If a transfer fails (e.g., due to insufficient balance), it could lead to inconsistent state or loss of funds.

4. **Lack of Input Validation**:
   - Functions like `wrap`, `unwrap`, and `setSubnodeOwner` do not adequately validate input parameters. For instance, there is no check to ensure that the `wrappedOwner` is not a zero address.

5. **Potential for Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow/underflow protection, any arithmetic operations that manipulate values should still be reviewed to ensure they do not lead to unexpected behavior.

6. **Upgradeability Risks**:
   - The contract allows for an upgradeable pattern through the `upgradeContract` variable. If not managed properly, this could lead to vulnerabilities if the upgrade contract itself has security flaws.

7. **Excessive Gas Consumption**:
   - Some functions may consume excessive gas due to complex logic or loops, which could lead to failed transactions or denial of service.

8. **Inadequate Event Emission**:
   - While the contract emits events for certain actions, it may not emit events for all state-changing functions, making it difficult to track changes and audit actions on-chain.

### Comprehensive Analysis Report

The `NameWrapper` contract is designed to manage the wrapping and unwrapping of ENS names, providing a mechanism for users to control their domain names securely. However, several security vulnerabilities have been identified that could potentially compromise the integrity and security of the contract.

1. **Access Control**: The reliance on ownership checks without sufficient validation could allow unauthorized users to execute sensitive functions. It is crucial to ensure that all access control mechanisms are robust and thoroughly tested.

2. **Reentrancy**: The absence of reentrancy guards in functions that interact with external contracts poses a significant risk. Implementing the Checks-Effects-Interactions pattern or using a reentrancy guard modifier is recommended.

3. **Token Transfer Assumptions**: The contract should handle potential failures in token transfers gracefully. Implementing checks after transfer calls can help maintain the contract's state consistency.

4. **Input Validation**: Functions should validate all inputs rigorously to prevent unexpected behavior or state changes. This includes checks for zero addresses and valid parameters.

5. **Upgradeability Management**: The upgradeable nature of the contract introduces risks if the upgrade contract is not secure. A thorough audit of the upgrade contract is essential before deployment.

6. **Gas Optimization**: Review and optimize functions to reduce gas consumption, ensuring that users can interact with the contract without facing transaction failures due to high gas costs.

7. **Event Emission**: Ensure that all critical state changes are logged with events to facilitate tracking and auditing of contract interactions.

In conclusion, while the `NameWrapper` contract provides valuable functionality for managing ENS names, it is imperative to address the identified vulnerabilities to enhance security and reliability. A comprehensive security audit, including testing and validation of all access controls, input parameters, and external interactions, is recommended before deployment to the mainnet.

[2024-01-09 20:36:26 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-01-09 20:36:26 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | //SPDX-License-Identifier: MIT pragma solidity ^0.8.4; import "./ERC1155Fuse.sol"; import "./Controllable.sol"; import "./INameWrapper.sol"; import "./INameWrapperUpgrade.sol"; import "./IMetadataService.sol"; import "../registry/ENS.sol"; import "../ethregistrar/IBaseRegistrar.sol"; import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "./BytesUtil.sol"; error Unauthorised(bytes32 node, address addr); error NameNotFound(); error IncompatibleParent(); error IncompatibleName(bytes name); error IncorrectTokenType(); error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash); error LabelTooShort(); error LabelTooLong(string label); error IncorrectTargetOwner(address owner); error CannotUpgrade(); error InvalidExpiry(bytes32 node, uint64 expiry); contract NameWrapper is     Ownable,     ERC1155Fuse,     INameWrapper,     Controllable,     IERC721Receiver {     using BytesUtils for bytes;     ENS public immutable override ens;     IBaseRegistrar public immutable override registrar;     IMetadataService public override metadataService;     mapping(bytes32 =&gt; bytes) public override names; bytes32 private constant ETH_NODE =     0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae; bytes32 private constant ROOT_NODE =     0x0000000000000000000000000000000000000000000000000000000000000000;  //A contract address to a new upgraded contract if any INameWrapperUpgrade public upgradeContract; uint64 private constant MAX_EXPIRY = type(uint64).max;  constructor(     ENS _ens,     IBaseRegistrar _registrar,     IMetadataService _metadataService ) {     ens = _ens;     registrar = _registrar;     metadataService = _metadataService;      /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */      _setData(         uint256(ETH_NODE),         address(0),         uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),         MAX_EXPIRY     );     _setData(         uint256(ROOT_NODE),         address(0),         uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),         MAX_EXPIRY     );     names[ROOT_NODE] = "\x00";     names[ETH_NODE] = "\x03eth\x00"; }  function supportsInterface(bytes4 interfaceId)     public     view     virtual     override(ERC1155Fuse, IERC165)     returns (bool) {     return         interfaceId == type(INameWrapper).interfaceId ||         super.supportsInterface(interfaceId); }  /* ERC1155 */  function ownerOf(uint256 id)     public     view     override(ERC1155Fuse, INameWrapper)     returns (address owner) {     return super.ownerOf(id); }  /* Metadata service */  /**  * @notice Set the metadata service. Only the owner can do this  */  function setMetadataService(IMetadataService _newMetadataService)     public     onlyOwner {     metadataService = _newMetadataService; }  /**  * @notice Get the metadata uri  * @return String uri of the metadata service  */  function uri(uint256 tokenId) public view override returns (string memory) {     return metadataService.uri(tokenId); }  /**  * @notice Set the address of the upgradeContract of the contract. only admin can do this  * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time  * to make the contract not upgradable.  * @param _upgradeAddress address of an upgraded contract  */  function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)     public     onlyOwner {     if (address(upgradeContract) != address(0)) {         registrar.setApprovalForAll(address(upgradeContract), false);         ens.setApprovalForAll(address(upgradeContract), false);     }      upgradeContract = _upgradeAddress;      if (address(upgradeContract) != address(0)) {         registrar.setApprovalForAll(address(upgradeContract), true);         ens.setApprovalForAll(address(upgradeContract), true);     } }  /**  * @notice Checks if msg.sender is the owner or approved by the owner of a name  * @param node namehash of the name to check  */  modifier onlyTokenOwner(bytes32 node) {     if (!isTokenOwnerOrApproved(node, msg.sender)) {         revert Unauthorised(node, msg.sender);     }      _; }  /**  * @notice Checks if owner or approved by owner  * @param node namehash of the name to check  * @param addr which address to check permissions for  * @return whether or not is owner or approved  */  function isTokenOwnerOrApproved(bytes32 node, address addr)     public     view     override     returns (bool) {     address owner = ownerOf(uint256(node));     return owner == addr || isApprovedForAll(owner, addr); }  /**  * @notice Gets fuse permissions for a specific name  * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit  *      The interface has predefined fuses for all registry permissions, but additional  *      fuses can be added for other use cases  *      Also returns expiry, which is when the fuses are set to expire.  * @param node namehash of the name to check  * @return fuses A number that represents the permissions a name has. Returns 0 when expiry &lt; block.timestamp  * @return expiry Unix time of when the name expires and fuses are to expire  */ function getFuses(bytes32 node)     public     view     override     returns (uint32 fuses, uint64 expiry) {     (, fuses, expiry) = getData(uint256(node));     if (fuses == 0 &amp;&amp; expiry == 0) {         bytes memory name = names[node];         if (name.length == 0) {             revert NameNotFound();         }     } }  /**  * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract  * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar  * @param label label as a string of the .eth domain to wrap  * @param wrappedOwner Owner of the name in this contract  * @param fuses initial fuses to set  * @param expiry when the fuses will expire  * @param resolver resolver contract address  */  function wrapETH2LD(     string calldata label,     address wrappedOwner,     uint32 fuses,     uint64 expiry,     address resolver ) public override returns (uint64) {     uint256 tokenId = uint256(keccak256(bytes(label)));     address registrant = registrar.ownerOf(tokenId);     if (         registrant != msg.sender &amp;&amp;         !isApprovedForAll(registrant, msg.sender) &amp;&amp;         !registrar.isApprovedForAll(registrant, msg.sender)     ) {         revert Unauthorised(             _makeNode(ETH_NODE, bytes32(tokenId)),             msg.sender         );     }      // transfer the token from the user to this contract     registrar.transferFrom(registrant, address(this), tokenId);      // transfer the ens record back to the new owner (this contract)     registrar.reclaim(tokenId, address(this));      return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver); }  /**  * @dev Registers a new .eth second-level domain and wraps it.  *      Only callable by authorised controllers.  * @param label The label to register (Eg, 'foo' for 'foo.eth').  * @param wrappedOwner The owner of the wrapped name.  * @param duration The duration, in seconds, to register the name for.  * @param resolver The resolver address to set on the ENS registry (optional).  * @param fuses initial fuses to set  * @param expiry when the fuses will expire  * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.  */  function registerAndWrapETH2LD(     string calldata label,     address wrappedOwner,     uint256 duration,     address resolver,     uint32 fuses,     uint64 expiry ) external override onlyController returns (uint256 registrarExpiry) {     uint256 tokenId = uint256(keccak256(bytes(label)));     registrarExpiry = registrar.register(tokenId, address(this), duration);     _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver); }  /**  * @dev Renews a .eth second-level domain.  *      Only callable by authorised controllers.  * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').  * @param duration The number of seconds to renew the name for.  * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.  */ function renew(     uint256 tokenId,     uint256 duration,     uint64 expiry ) external override onlyController returns (uint256 expires) {     bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));      expires = registrar.renew(tokenId, duration);     (address owner, uint32 fuses, uint64 oldExpiry) = getData(         uint256(node)     );     expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));      _setData(node, owner, fuses, expiry); }  /**  * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner in the registry or an authorised caller in the registry  * @param name The name to wrap, in DNS format  * @param wrappedOwner Owner of the name in this contract  * @param resolver resolver contract address  */  function wrap(     bytes calldata name,     address wrappedOwner,     address resolver ) public override {     (bytes32 labelhash, uint256 offset) = name.readLabel(0);     bytes32 parentNode = name.namehash(offset);     bytes32 node = _makeNode(parentNode, labelhash);      if (parentNode == ETH_NODE) {         revert IncompatibleParent();     }      address owner = ens.owner(node);      if (         owner != msg.sender &amp;&amp;         !isApprovedForAll(owner, msg.sender) &amp;&amp;         !ens.isApprovedForAll(owner, msg.sender)     ) {         revert Unauthorised(node, msg.sender);     }      if (resolver != address(0)) {         ens.setResolver(node, resolver);     }      ens.setOwner(node, address(this));      _wrap(node, name, wrappedOwner, 0, 0); }  /**  * @notice Unwraps a .eth domain. e.g. vitalik.eth  * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper  * @param labelhash labelhash of the .eth domain  * @param newRegistrant sets the owner in the .eth registrar to this address  * @param newController sets the owner in the registry to this address  */  function unwrapETH2LD(     bytes32 labelhash,     address newRegistrant,     address newController ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {     _unwrap(_makeNode(ETH_NODE, labelhash), newController);     registrar.transferFrom(         address(this),         newRegistrant,         uint256(labelhash)     ); }  /**  * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper  * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')  * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')  * @param newController sets the owner in the registry to this address  */  function unwrap(     bytes32 parentNode,     bytes32 labelhash,     address newController ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {     if (parentNode == ETH_NODE) {         revert IncompatibleParent();     }     _unwrap(_makeNode(parentNode, labelhash), newController); }  /**  * @notice Sets fuses of a name  * @param node namehash of the name  * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)  */  function setFuses(bytes32 node, uint32 fuses)     public     onlyTokenOwner(node)     operationAllowed(node, CANNOT_BURN_FUSES)     returns (uint32) {     if (fuses &amp; PARENT_CANNOT_CONTROL != 0) {         // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.         revert Unauthorised(node, msg.sender);     }      (address owner, uint32 oldFuses, uint64 expiry) = getData(         uint256(node)     );      fuses |= oldFuses;     _setFuses(node, owner, fuses, expiry);     return fuses; }  /**  * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract  *     and burning the token of this contract  * @dev Can be called by the owner of the name in this contract  * @param label Label as a string of the .eth name to upgrade  * @param wrappedOwner The owner of the wrapped name  */  function upgradeETH2LD(     string calldata label,     address wrappedOwner,     address resolver ) public {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(ETH_NODE, labelhash);     (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);      upgradeContract.wrapETH2LD(         label,         wrappedOwner,         fuses,         expiry,         resolver     ); }  /**  * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner or an authorised caller  * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names  * @param parentNode namehash of the parent name  * @param label Label as a string of the name to upgrade  * @param wrappedOwner Owner of the name in this contract  * @param resolver resolver contract for this name  */  function upgrade(     bytes32 parentNode,     string calldata label,     address wrappedOwner,     address resolver ) public {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(parentNode, labelhash);     (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);     upgradeContract.setSubnodeRecord(         parentNode,         label,         wrappedOwner,         resolver,         0,         fuses,         expiry     ); }  /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name  * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')  * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')  * @param fuses fuses to burn  * @param expiry when the fuses will expire  */  function setChildFuses(     bytes32 parentNode,     bytes32 labelhash,     uint32 fuses,     uint64 expiry ) public {     bytes32 node = _makeNode(parentNode, labelhash);     (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(         uint256(node)     );     uint64 maxExpiry;     if (parentNode == ETH_NODE) {         if (!isTokenOwnerOrApproved(node, msg.sender)) {             revert Unauthorised(node, msg.sender);         }         // max expiry is set to the expiry on the registrar         maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));     } else {         if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {             revert Unauthorised(node, msg.sender);         }          // max expiry is set to the expiry of the parent         (, , maxExpiry) = getData(uint256(parentNode));     }      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);      // if PARENT_CANNOT_CONTROL has been burned and fuses have changed     if (         oldFuses &amp; PARENT_CANNOT_CONTROL != 0 &amp;&amp;         oldFuses | fuses != oldFuses     ) {         revert OperationProhibited(node);     }     fuses |= oldFuses;     _setFuses(node, owner, fuses, expiry); }  /**  * @notice Sets the subdomain owner in the registry and then wraps the subdomain  * @param parentNode parent namehash of the subdomain  * @param label label of the subdomain as a string  * @param newOwner newOwner in the registry  * @param fuses initial fuses for the wrapped subdomain  * @param expiry when the fuses will expire  */  function setSubnodeOwner(     bytes32 parentNode,     string calldata label,     address newOwner,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))     returns (bytes32 node) {     bytes32 labelhash = keccak256(bytes(label));     node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);      if (ens.owner(node) != address(this)) {         ens.setSubnodeOwner(parentNode, labelhash, address(this));         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } }  /**  * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain  * @param parentNode parent namehash of the subdomain  * @param label label of the subdomain as a string  * @param newOwner newOwner in the registry  * @param resolver resolver contract in the registry  * @param ttl ttl in the regsitry  * @param fuses initial fuses for the wrapped subdomain  * @param expiry expiry date for the domain  */  function setSubnodeRecord(     bytes32 parentNode,     string memory label,     address newOwner,     address resolver,     uint64 ttl,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label))) {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);     if (ens.owner(node) != address(this)) {         ens.setSubnodeRecord(             parentNode,             labelhash,             address(this),             resolver,             ttl         );         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         ens.setSubnodeRecord(             parentNode,             labelhash,             address(this),             resolver,             ttl         );         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } }  /**  * @notice Sets records for the name in the ENS Registry  * @param node namehash of the name to set a record for  * @param owner newOwner in the registry  * @param resolver the resolver contract  * @param ttl ttl in the registry  */  function setRecord(     bytes32 node,     address owner,     address resolver,     uint64 ttl )     public     override     onlyTokenOwner(node)     operationAllowed(         node,         CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL     ) {     ens.setRecord(node, address(this), resolver, ttl);     (address oldOwner, , ) = getData(uint256(node));     _transfer(oldOwner, owner, uint256(node), 1, ""); }  /**  * @notice Sets resolver contract in the registry  * @param node namehash of the name  * @param resolver the resolver contract  */  function setResolver(bytes32 node, address resolver)     public     override     onlyTokenOwner(node)     operationAllowed(node, CANNOT_SET_RESOLVER) {     ens.setResolver(node, resolver); }  /**  * @notice Sets TTL in the registry  * @param node namehash of the name  * @param ttl TTL in the registry  */  function setTTL(bytes32 node, uint64 ttl)     public     override     onlyTokenOwner(node)     operationAllowed(node, CANNOT_SET_TTL) {     ens.setTTL(node, ttl); }  /**  * @dev Allows an operation only if none of the specified fuses are burned.  * @param node The namehash of the name to check fuses on.  * @param fuseMask A bitmask of fuses that must not be burned.  */  modifier operationAllowed(bytes32 node, uint32 fuseMask) {     (, uint32 fuses, ) = getData(uint256(node));     if (fuses &amp; fuseMask != 0) {         revert OperationProhibited(node);     }     _; }  /**  * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord  * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt  *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for  *      replacing a subdomain. If either conditions are true, then it is possible to call  *      setSubnodeOwner  * @param node namehash of the name to check  * @param labelhash labelhash of the name to check  */  modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {     bytes32 subnode = _makeNode(node, labelhash);     address owner = ens.owner(subnode);      if (owner == address(0)) {         (, uint32 fuses, ) = getData(uint256(node));         if (fuses &amp; CANNOT_CREATE_SUBDOMAIN != 0) {             revert OperationProhibited(node);         }     } else {         (, uint32 subnodeFuses, ) = getData(uint256(subnode));         if (subnodeFuses &amp; PARENT_CANNOT_CONTROL != 0) {             revert OperationProhibited(node);         }     }      _; }  /**  * @notice Checks all Fuses in the mask are burned for the node  * @param node namehash of the name  * @param fuseMask the fuses you want to check  * @return Boolean of whether or not all the selected fuses are burned  */  function allFusesBurned(bytes32 node, uint32 fuseMask)     public     view     override     returns (bool) {     (, uint32 fuses, ) = getData(uint256(node));     return fuses &amp; fuseMask == fuseMask; }  function onERC721Received(     address to,     address,     uint256 tokenId,     bytes calldata data ) public override returns (bytes4) {     //check if it's the eth registrar ERC721     if (msg.sender != address(registrar)) {         revert IncorrectTokenType();     }      (         string memory label,         address owner,         uint32 fuses,         uint64 expiry,         address resolver     ) = abi.decode(data, (string, address, uint32, uint64, address));      bytes32 labelhash = bytes32(tokenId);     bytes32 labelhashFromData = keccak256(bytes(label));      if (labelhashFromData != labelhash) {         revert LabelMismatch(labelhashFromData, labelhash);     }      // transfer the ens record back to the new owner (this contract)     registrar.reclaim(uint256(labelhash), address(this));      _wrapETH2LD(label, owner, fuses, expiry, resolver);      return IERC721Receiver(to).onERC721Received.selector; }  /***** Internal functions */  function _canTransfer(uint32 fuses) internal pure override returns (bool) {     return fuses &amp; CANNOT_TRANSFER == 0; }  function _makeNode(bytes32 node, bytes32 labelhash)     private     pure     returns (bytes32) {     return keccak256(abi.encodePacked(node, labelhash)); }  function _addLabel(string memory label, bytes memory name)     internal     pure     returns (bytes memory ret) {     if (bytes(label).length &lt; 1) {         revert LabelTooShort();     }     if (bytes(label).length &gt; 255) {         revert LabelTooLong(label);     }     return abi.encodePacked(uint8(bytes(label).length), label, name); }  function _mint(     bytes32 node,     address wrappedOwner,     uint32 fuses,     uint64 expiry ) internal override {     address oldWrappedOwner = ownerOf(uint256(node));     _canFusesBeBurned(node, fuses);     if (oldWrappedOwner != address(0)) {         // burn and unwrap old token of old owner         _burn(uint256(node));         emit NameUnwrapped(node, address(0));     }     super._mint(node, wrappedOwner, fuses, expiry); }  function _wrap(     bytes32 node,     bytes memory name,     address wrappedOwner,     uint32 fuses,     uint64 expiry ) internal {     names[node] = name;     _mint(node, wrappedOwner, fuses, expiry);     emit NameWrapped(node, name, wrappedOwner, fuses, expiry); }  function _addLabelAndWrap(     bytes32 parentNode,     bytes32 node,     string memory label,     address newOwner,     uint32 fuses,     uint64 expiry ) internal {     bytes memory name = _addLabel(label, names[parentNode]);     _wrap(node, name, newOwner, fuses, expiry); }  function _prepareUpgrade(bytes32 node)     private     returns (uint32 fuses, uint64 expiry) {     if (address(upgradeContract) == address(0)) {         revert CannotUpgrade();     }      if (!isTokenOwnerOrApproved(node, msg.sender)) {         revert Unauthorised(node, msg.sender);     }      (fuses, expiry) = getFuses(node);      // burn token and fuse data     _burn(uint256(node)); }  function _transferAndBurnFuses(     bytes32 node,     address newOwner,     uint32 fuses,     uint64 expiry ) internal {     (address owner, , ) = getData(uint256(node));     _transfer(owner, newOwner, uint256(node), 1, "");     _setFuses(node, newOwner, fuses, expiry); }  // wrapper function for stack limit function _getDataAndNormaliseExpiry(     bytes32 parentNode,     bytes32 node,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     (, , uint64 maxExpiry) = getData(uint256(parentNode));      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); }  function _getETH2LDDataAndNormaliseExpiry(     bytes32 node,     bytes32 labelhash,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); }  function _normaliseExpiry(     uint64 expiry,     uint64 oldExpiry,     uint64 maxExpiry ) internal pure returns (uint64) {     // Expiry cannot be more than maximum allowed     // .eth names will check registrar, non .eth check parent     if (expiry &gt; maxExpiry) {         expiry = maxExpiry;     }     // Expiry cannot be less than old expiry     if (expiry &lt; oldExpiry) {         expiry = oldExpiry;     }      return expiry; }  function _wrapETH2LD(     string memory label,     address wrappedOwner,     uint32 fuses,     uint64 expiry,     address resolver ) private returns (uint64) {     // Mint a new ERC1155 token with fuses     // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(ETH_NODE, labelhash);      (, , expiry) = _getETH2LDDataAndNormaliseExpiry(         node,         labelhash,         expiry     );      _addLabelAndWrap(         ETH_NODE,         node,         label,         wrappedOwner,         fuses | PARENT_CANNOT_CONTROL,         expiry     );     if (resolver != address(0)) {         ens.setResolver(node, resolver);     }      return expiry; }  function _unwrap(bytes32 node, address newOwner) private {     if (newOwner == address(0x0) || newOwner == address(this)) {         revert IncorrectTargetOwner(newOwner);     }      if (allFusesBurned(node, CANNOT_UNWRAP)) {         revert OperationProhibited(node);     }      // Burn token and fuse data     _burn(uint256(node));     ens.setOwner(node, newOwner);      emit NameUnwrapped(node, newOwner); }  function _setFuses(     bytes32 node,     address owner,     uint32 fuses,     uint64 expiry ) internal {     _setData(node, owner, fuses, expiry);     emit FusesSet(node, fuses, expiry); }  function _setData(     bytes32 node,     address owner,     uint32 fuses,     uint64 expiry ) internal {     _canFusesBeBurned(node, fuses);     super._setData(uint256(node), owner, fuses, expiry); }  function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {     if (         fuses &amp; ~PARENT_CANNOT_CONTROL != 0 &amp;&amp;         fuses &amp; (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=         (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)     ) {         revert OperationProhibited(node);     } }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport "./ERC1155Fuse.sol";\nimport "./Controllable.sol";\nimport "./INameWrapper.sol";\nimport "./INameWrapperUpgrade.sol";\nimport "./IMetadataService.sol";\nimport "../registry/ENS.sol";\nimport "../ethregistrar/IBaseRegistrar.sol";\nimport "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";\nimport "@openzeppelin/contracts/access/Ownable.sol";\nimport "./BytesUtil.sol";\n\nerror Unauthorised(bytes32 node, address addr);\nerror NameNotFound();\nerror IncompatibleParent();\nerror IncompatibleName(bytes name);\nerror IncorrectTokenType();\nerror LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);\nerror LabelTooShort();\nerror LabelTooLong(string label);\nerror IncorrectTargetOwner(address owner);\nerror CannotUpgrade();\nerror InvalidExpiry(bytes32 node, uint64 expiry);\n\ncontract NameWrapper is\n    Ownable,\n    ERC1155Fuse,\n    INameWrapper,\n    Controllable,\n    IERC721Receiver\n{\n    using BytesUtils for bytes;\n    ENS public immutable override ens;\n    IBaseRegistrar public immutable override registrar;\n    IMetadataService public override metadataService;\n    mapping(bytes32 =&gt; bytes) public override names;\n\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n    bytes32 private constant ROOT_NODE =\n        0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    //A contract address to a new upgraded contract if any\n    INameWrapperUpgrade public upgradeContract;\n    uint64 private constant MAX_EXPIRY = type(uint64).max;\n\n    constructor(\n        ENS _ens,\n        IBaseRegistrar _registrar,\n        IMetadataService _metadataService\n    ) {\n        ens = _ens;\n        registrar = _registrar;\n        metadataService = _metadataService;\n\n        / Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE /\n\n        _setData(\n            uint256(ETH_NODE),\n            address(0),\n            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),\n            MAX_EXPIRY\n        );\n        _setData(\n            uint256(ROOT_NODE),\n            address(0),\n            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),\n            MAX_EXPIRY\n        );\n        names[ROOT_NODE] = "\x00";\n        names[ETH_NODE] = "\x03eth\x00";\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC1155Fuse, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(INameWrapper).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    / ERC1155 /\n\n    function ownerOf(uint256 id)\n        public\n        view\n        override(ERC1155Fuse, INameWrapper)\n        returns (address owner)\n    {\n        return super.ownerOf(id);\n    }\n\n    / Metadata service /\n\n    /\n     * @notice Set the metadata service. Only the owner can do this\n     /\n\n    function setMetadataService(IMetadataService _newMetadataService)\n        public\n        onlyOwner\n    {\n        metadataService = _newMetadataService;\n    }\n\n    /\n     * @notice Get the metadata uri\n     * @return String uri of the metadata service\n     */\n\n    function uri(uint256 tokenId) public view override returns (string memory) {\n        return metadataService.uri(tokenId);\n    }\n\n    /\n     * @notice Set the address of the upgradeContract of the contract. only admin can do this\n     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time\n     * to make the contract not upgradable.\n     * @param _upgradeAddress address of an upgraded contract\n     /\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)\n        public\n        onlyOwner\n    {\n        if (address(upgradeContract) != address(0)) {\n            registrar.setApprovalForAll(address(upgradeContract), false);\n            ens.setApprovalForAll(address(upgradeContract), false);\n        }\n\n        upgradeContract = _upgradeAddress;\n\n        if (address(upgradeContract) != address(0)) {\n            registrar.setApprovalForAll(address(upgradeContract), true);\n            ens.setApprovalForAll(address(upgradeContract), true);\n        }\n    }\n\n    /\n     * @notice Checks if msg.sender is the owner or approved by the owner of a name\n     * @param node namehash of the name to check\n     /\n\n    modifier onlyTokenOwner(bytes32 node) {\n        if (!isTokenOwnerOrApproved(node, msg.sender)) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        _;\n    }\n\n    /\n     * @notice Checks if owner or approved by owner\n     * @param node namehash of the name to check\n     * @param addr which address to check permissions for\n     * @return whether or not is owner or approved\n     */\n\n    function isTokenOwnerOrApproved(bytes32 node, address addr)\n        public\n        view\n        override\n        returns (bool)\n    {\n        address owner = ownerOf(uint256(node));\n        return owner == addr || isApprovedForAll(owner, addr);\n    }\n\n    /\n     * @notice Gets fuse permissions for a specific name\n     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit\n     *      The interface has predefined fuses for all registry permissions, but additional\n     *      fuses can be added for other use cases\n     *      Also returns expiry, which is when the fuses are set to expire.\n     * @param node namehash of the name to check\n     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry &lt; block.timestamp\n     * @return expiry Unix time of when the name expires and fuses are to expire\n     /\n    function getFuses(bytes32 node)\n        public\n        view\n        override\n        returns (uint32 fuses, uint64 expiry)\n    {\n        (, fuses, expiry) = getData(uint256(node));\n        if (fuses == 0 &amp;&amp; expiry == 0) {\n            bytes memory name = names[node];\n            if (name.length == 0) {\n                revert NameNotFound();\n            }\n        }\n    }\n\n    /\n     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract\n     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar\n     * @param label label as a string of the .eth domain to wrap\n     * @param wrappedOwner Owner of the name in this contract\n     * @param fuses initial fuses to set\n     * @param expiry when the fuses will expire\n     * @param resolver resolver contract address\n     /\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address resolver\n    ) public override returns (uint64) {\n        uint256 tokenId = uint256(keccak256(bytes(label)));\n        address registrant = registrar.ownerOf(tokenId);\n        if (\n            registrant != msg.sender &amp;&amp;\n            !isApprovedForAll(registrant, msg.sender) &amp;&amp;\n            !registrar.isApprovedForAll(registrant, msg.sender)\n        ) {\n            revert Unauthorised(\n                _makeNode(ETH_NODE, bytes32(tokenId)),\n                msg.sender\n            );\n        }\n\n        // transfer the token from the user to this contract\n        registrar.transferFrom(registrant, address(this), tokenId);\n\n        // transfer the ens record back to the new owner (this contract)\n        registrar.reclaim(tokenId, address(this));\n\n        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);\n    }\n\n    /\n     * @dev Registers a new .eth second-level domain and wraps it.\n     *      Only callable by authorised controllers.\n     * @param label The label to register (Eg, \'foo\' for \'foo.eth\').\n     * @param wrappedOwner The owner of the wrapped name.\n     * @param duration The duration, in seconds, to register the name for.\n     * @param resolver The resolver address to set on the ENS registry (optional).\n     * @param fuses initial fuses to set\n     * @param expiry when the fuses will expire\n     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.\n     */\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint32 fuses,\n        uint64 expiry\n    ) external override onlyController returns (uint256 registrarExpiry) {\n        uint256 tokenId = uint256(keccak256(bytes(label)));\n        registrarExpiry = registrar.register(tokenId, address(this), duration);\n        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);\n    }\n\n    /\n     * @dev Renews a .eth second-level domain.\n     *      Only callable by authorised controllers.\n     * @param tokenId The hash of the label to register (eg, keccak256(\'foo\'), for \'foo.eth\').\n     * @param duration The number of seconds to renew the name for.\n     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.\n     /\n    function renew(\n        uint256 tokenId,\n        uint256 duration,\n        uint64 expiry\n    ) external override onlyController returns (uint256 expires) {\n        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));\n\n        expires = registrar.renew(tokenId, duration);\n        (address owner, uint32 fuses, uint64 oldExpiry) = getData(\n            uint256(node)\n        );\n        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));\n\n        _setData(node, owner, fuses, expiry);\n    }\n\n    /\n     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner in the registry or an authorised caller in the registry\n     * @param name The name to wrap, in DNS format\n     * @param wrappedOwner Owner of the name in this contract\n     * @param resolver resolver contract address\n     /\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) public override {\n        (bytes32 labelhash, uint256 offset) = name.readLabel(0);\n        bytes32 parentNode = name.namehash(offset);\n        bytes32 node = _makeNode(parentNode, labelhash);\n\n        if (parentNode == ETH_NODE) {\n            revert IncompatibleParent();\n        }\n\n        address owner = ens.owner(node);\n\n        if (\n            owner != msg.sender &amp;&amp;\n            !isApprovedForAll(owner, msg.sender) &amp;&amp;\n            !ens.isApprovedForAll(owner, msg.sender)\n        ) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        if (resolver != address(0)) {\n            ens.setResolver(node, resolver);\n        }\n\n        ens.setOwner(node, address(this));\n\n        _wrap(node, name, wrappedOwner, 0, 0);\n    }\n\n    /\n     * @notice Unwraps a .eth domain. e.g. vitalik.eth\n     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper\n     * @param labelhash labelhash of the .eth domain\n     * @param newRegistrant sets the owner in the .eth registrar to this address\n     * @param newController sets the owner in the registry to this address\n     */\n\n    function unwrapETH2LD(\n        bytes32 labelhash,\n        address newRegistrant,\n        address newController\n    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {\n        _unwrap(_makeNode(ETH_NODE, labelhash), newController);\n        registrar.transferFrom(\n            address(this),\n            newRegistrant,\n            uint256(labelhash)\n        );\n    }\n\n    /\n     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper\n     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash(\'xyz\')\n     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256(\'vitalik\')\n     * @param newController sets the owner in the registry to this address\n     /\n\n    function unwrap(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        address newController\n    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {\n        if (parentNode == ETH_NODE) {\n            revert IncompatibleParent();\n        }\n        _unwrap(_makeNode(parentNode, labelhash), newController);\n    }\n\n    /\n     * @notice Sets fuses of a name\n     * @param node namehash of the name\n     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)\n     /\n\n    function setFuses(bytes32 node, uint32 fuses)\n        public\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_BURN_FUSES)\n        returns (uint32)\n    {\n        if (fuses &amp; PARENT_CANNOT_CONTROL != 0) {\n            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.\n            revert Unauthorised(node, msg.sender);\n        }\n\n        (address owner, uint32 oldFuses, uint64 expiry) = getData(\n            uint256(node)\n        );\n\n        fuses |= oldFuses;\n        _setFuses(node, owner, fuses, expiry);\n        return fuses;\n    }\n\n    /\n     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract\n     *     and burning the token of this contract\n     * @dev Can be called by the owner of the name in this contract\n     * @param label Label as a string of the .eth name to upgrade\n     * @param wrappedOwner The owner of the wrapped name\n     */\n\n    function upgradeETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        address resolver\n    ) public {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(ETH_NODE, labelhash);\n        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n\n        upgradeContract.wrapETH2LD(\n            label,\n            wrappedOwner,\n            fuses,\n            expiry,\n            resolver\n        );\n    }\n\n    /\n     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner or an authorised caller\n     * Requires upgraded Namewrapper to permit old Namewrapper to call setSubnodeRecord for all names\n     * @param parentNode namehash of the parent name\n     * @param label Label as a string of the name to upgrade\n     * @param wrappedOwner Owner of the name in this contract\n     * @param resolver resolver contract for this name\n     /\n\n    function upgrade(\n        bytes32 parentNode,\n        string calldata label,\n        address wrappedOwner,\n        address resolver\n    ) public {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n        upgradeContract.setSubnodeRecord(\n            parentNode,\n            label,\n            wrappedOwner,\n            resolver,\n            0,\n            fuses,\n            expiry\n        );\n    }\n\n    / @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name\n     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash(\'xyz\')\n     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256(\'vitalik\')\n     * @param fuses fuses to burn\n     * @param expiry when the fuses will expire\n     /\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) public {\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(\n            uint256(node)\n        );\n        uint64 maxExpiry;\n        if (parentNode == ETH_NODE) {\n            if (!isTokenOwnerOrApproved(node, msg.sender)) {\n                revert Unauthorised(node, msg.sender);\n            }\n            // max expiry is set to the expiry on the registrar\n            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));\n        } else {\n            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {\n                revert Unauthorised(node, msg.sender);\n            }\n\n            // max expiry is set to the expiry of the parent\n            (, , maxExpiry) = getData(uint256(parentNode));\n        }\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n\n        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed\n        if (\n            oldFuses &amp; PARENT_CANNOT_CONTROL != 0 &amp;&amp;\n            oldFuses | fuses != oldFuses\n        ) {\n            revert OperationProhibited(node);\n        }\n        fuses |= oldFuses;\n        _setFuses(node, owner, fuses, expiry);\n    }\n\n    /\n     * @notice Sets the subdomain owner in the registry and then wraps the subdomain\n     * @param parentNode parent namehash of the subdomain\n     * @param label label of the subdomain as a string\n     * @param newOwner newOwner in the registry\n     * @param fuses initial fuses for the wrapped subdomain\n     * @param expiry when the fuses will expire\n     /\n\n    function setSubnodeOwner(\n        bytes32 parentNode,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    )\n        public\n        onlyTokenOwner(parentNode)\n        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))\n        returns (bytes32 node)\n    {\n        bytes32 labelhash = keccak256(bytes(label));\n        node = _makeNode(parentNode, labelhash);\n        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);\n\n        if (ens.owner(node) != address(this)) {\n            ens.setSubnodeOwner(parentNode, labelhash, address(this));\n            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);\n        } else {\n            _transferAndBurnFuses(node, newOwner, fuses, expiry);\n        }\n    }\n\n    /\n     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain\n     * @param parentNode parent namehash of the subdomain\n     * @param label label of the subdomain as a string\n     * @param newOwner newOwner in the registry\n     * @param resolver resolver contract in the registry\n     * @param ttl ttl in the regsitry\n     * @param fuses initial fuses for the wrapped subdomain\n     * @param expiry expiry date for the domain\n     */\n\n    function setSubnodeRecord(\n        bytes32 parentNode,\n        string memory label,\n        address newOwner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    )\n        public\n        onlyTokenOwner(parentNode)\n        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))\n    {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);\n        if (ens.owner(node) != address(this)) {\n            ens.setSubnodeRecord(\n                parentNode,\n                labelhash,\n                address(this),\n                resolver,\n                ttl\n            );\n            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);\n        } else {\n            ens.setSubnodeRecord(\n                parentNode,\n                labelhash,\n                address(this),\n                resolver,\n                ttl\n            );\n            _transferAndBurnFuses(node, newOwner, fuses, expiry);\n        }\n    }\n\n    /\n     * @notice Sets records for the name in the ENS Registry\n     * @param node namehash of the name to set a record for\n     * @param owner newOwner in the registry\n     * @param resolver the resolver contract\n     * @param ttl ttl in the registry\n     /\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    )\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(\n            node,\n            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL\n        )\n    {\n        ens.setRecord(node, address(this), resolver, ttl);\n        (address oldOwner, , ) = getData(uint256(node));\n        _transfer(oldOwner, owner, uint256(node), 1, "");\n    }\n\n    /\n     * @notice Sets resolver contract in the registry\n     * @param node namehash of the name\n     * @param resolver the resolver contract\n     /\n\n    function setResolver(bytes32 node, address resolver)\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_SET_RESOLVER)\n    {\n        ens.setResolver(node, resolver);\n    }\n\n    /\n     * @notice Sets TTL in the registry\n     * @param node namehash of the name\n     * @param ttl TTL in the registry\n     */\n\n    function setTTL(bytes32 node, uint64 ttl)\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_SET_TTL)\n    {\n        ens.setTTL(node, ttl);\n    }\n\n    /\n     * @dev Allows an operation only if none of the specified fuses are burned.\n     * @param node The namehash of the name to check fuses on.\n     * @param fuseMask A bitmask of fuses that must not be burned.\n     /\n\n    modifier operationAllowed(bytes32 node, uint32 fuseMask) {\n        (, uint32 fuses, ) = getData(uint256(node));\n        if (fuses &amp; fuseMask != 0) {\n            revert OperationProhibited(node);\n        }\n        _;\n    }\n\n    /\n     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord\n     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt\n     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for\n     *      replacing a subdomain. If either conditions are true, then it is possible to call\n     *      setSubnodeOwner\n     * @param node namehash of the name to check\n     * @param labelhash labelhash of the name to check\n     /\n\n    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {\n        bytes32 subnode = makeNode(node, labelhash);\n        address owner = ens.owner(subnode);\n\n        if (owner == address(0)) {\n            (, uint32 fuses, ) = getData(uint256(node));\n            if (fuses &amp; CANNOT_CREATE_SUBDOMAIN != 0) {\n                revert OperationProhibited(node);\n            }\n        } else {\n            (, uint32 subnodeFuses, ) = getData(uint256(subnode));\n            if (subnodeFuses &amp; PARENT_CANNOT_CONTROL != 0) {\n                revert OperationProhibited(node);\n            }\n        }\n\n        ;\n    }\n\n    /*\n     * @notice Checks all Fuses in the mask are burned for the node\n     * @param node namehash of the name\n     * @param fuseMask the fuses you want to check\n     * @return Boolean of whether or not all the selected fuses are burned\n     /\n\n    function allFusesBurned(bytes32 node, uint32 fuseMask)\n        public\n        view\n        override\n        returns (bool)\n    {\n        (, uint32 fuses, ) = getData(uint256(node));\n        return fuses &amp; fuseMask == fuseMask;\n    }\n\n    function onERC721Received(\n        address to,\n        address,\n        uint256 tokenId,\n        bytes calldata data\n    ) public override returns (bytes4) {\n        //check if it\'s the eth registrar ERC721\n        if (msg.sender != address(registrar)) {\n            revert IncorrectTokenType();\n        }\n\n        (\n            string memory label,\n            address owner,\n            uint32 fuses,\n            uint64 expiry,\n            address resolver\n        ) = abi.decode(data, (string, address, uint32, uint64, address));\n\n        bytes32 labelhash = bytes32(tokenId);\n        bytes32 labelhashFromData = keccak256(bytes(label));\n\n        if (labelhashFromData != labelhash) {\n            revert LabelMismatch(labelhashFromData, labelhash);\n        }\n\n        // transfer the ens record back to the new owner (this contract)\n        registrar.reclaim(uint256(labelhash), address(this));\n\n        _wrapETH2LD(label, owner, fuses, expiry, resolver);\n\n        return IERC721Receiver(to).onERC721Received.selector;\n    }\n\n    /* Internal functions /\n\n    function _canTransfer(uint32 fuses) internal pure override returns (bool) {\n        return fuses &amp; CANNOT_TRANSFER == 0;\n    }\n\n    function _makeNode(bytes32 node, bytes32 labelhash)\n        private\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(node, labelhash));\n    }\n\n    function _addLabel(string memory label, bytes memory name)\n        internal\n        pure\n        returns (bytes memory ret)\n    {\n        if (bytes(label).length &lt; 1) {\n            revert LabelTooShort();\n        }\n        if (bytes(label).length &gt; 255) {\n            revert LabelTooLong(label);\n        }\n        return abi.encodePacked(uint8(bytes(label).length), label, name);\n    }\n\n    function _mint(\n        bytes32 node,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal override {\n        address oldWrappedOwner = ownerOf(uint256(node));\n        _canFusesBeBurned(node, fuses);\n        if (oldWrappedOwner != address(0)) {\n            // burn and unwrap old token of old owner\n            _burn(uint256(node));\n            emit NameUnwrapped(node, address(0));\n        }\n        super._mint(node, wrappedOwner, fuses, expiry);\n    }\n\n    function _wrap(\n        bytes32 node,\n        bytes memory name,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        names[node] = name;\n        _mint(node, wrappedOwner, fuses, expiry);\n        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);\n    }\n\n    function _addLabelAndWrap(\n        bytes32 parentNode,\n        bytes32 node,\n        string memory label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        bytes memory name = _addLabel(label, names[parentNode]);\n        _wrap(node, name, newOwner, fuses, expiry);\n    }\n\n    function _prepareUpgrade(bytes32 node)\n        private\n        returns (uint32 fuses, uint64 expiry)\n    {\n        if (address(upgradeContract) == address(0)) {\n            revert CannotUpgrade();\n        }\n\n        if (!isTokenOwnerOrApproved(node, msg.sender)) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        (fuses, expiry) = getFuses(node);\n\n        // burn token and fuse data\n        _burn(uint256(node));\n    }\n\n    function _transferAndBurnFuses(\n        bytes32 node,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        (address owner, , ) = getData(uint256(node));\n        _transfer(owner, newOwner, uint256(node), 1, "");\n        _setFuses(node, newOwner, fuses, expiry);\n    }\n\n    // wrapper function for stack limit\n    function _getDataAndNormaliseExpiry(\n        bytes32 parentNode,\n        bytes32 node,\n        uint64 expiry\n    )\n        internal\n        view\n        returns (\n            address owner,\n            uint32 fuses,\n            uint64\n        )\n    {\n        uint64 oldExpiry;\n        (owner, fuses, oldExpiry) = getData(uint256(node));\n        (, , uint64 maxExpiry) = getData(uint256(parentNode));\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n        return (owner, fuses, expiry);\n    }\n\n    function _getETH2LDDataAndNormaliseExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    )\n        internal\n        view\n        returns (\n            address owner,\n            uint32 fuses,\n            uint64\n        )\n    {\n        uint64 oldExpiry;\n        (owner, fuses, oldExpiry) = getData(uint256(node));\n        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n        return (owner, fuses, expiry);\n    }\n\n    function _normaliseExpiry(\n        uint64 expiry,\n        uint64 oldExpiry,\n        uint64 maxExpiry\n    ) internal pure returns (uint64) {\n        // Expiry cannot be more than maximum allowed\n        // .eth names will check registrar, non .eth check parent\n        if (expiry &gt; maxExpiry) {\n            expiry = maxExpiry;\n        }\n        // Expiry cannot be less than old expiry\n        if (expiry &lt; oldExpiry) {\n            expiry = oldExpiry;\n        }\n\n        return expiry;\n    }\n\n    function _wrapETH2LD(\n        string memory label,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address resolver\n    ) private returns (uint64) {\n        // Mint a new ERC1155 token with fuses\n        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(ETH_NODE, labelhash);\n\n        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(\n            node,\n            labelhash,\n            expiry\n        );\n\n        _addLabelAndWrap(\n            ETH_NODE,\n            node,\n            label,\n            wrappedOwner,\n            fuses | PARENT_CANNOT_CONTROL,\n            expiry\n        );\n        if (resolver != address(0)) {\n            ens.setResolver(node, resolver);\n        }\n\n        return expiry;\n    }\n\n    function _unwrap(bytes32 node, address newOwner) private {\n        if (newOwner == address(0x0) || newOwner == address(this)) {\n            revert IncorrectTargetOwner(newOwner);\n        }\n\n        if (allFusesBurned(node, CANNOT_UNWRAP)) {\n            revert OperationProhibited(node);\n        }\n\n        // Burn token and fuse data\n        _burn(uint256(node));\n        ens.setOwner(node, newOwner);\n\n        emit NameUnwrapped(node, newOwner);\n    }\n\n    function _setFuses(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        _setData(node, owner, fuses, expiry);\n        emit FusesSet(node, fuses, expiry);\n    }\n\n    function _setData(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        _canFusesBeBurned(node, fuses);\n        super._setData(uint256(node), owner, fuses, expiry);\n    }\n\n    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {\n        if (\n            fuses &amp; ~PARENT_CANNOT_CONTROL != 0 &amp;&amp;\n            fuses &amp; (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=\n            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)\n        ) {\n            revert OperationProhibited(node);\n        }\n    }\n}\n', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 20:36:26 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | //SPDX-License-Identifier: MIT pragma solidity ^0.8.4; import "./ERC1155Fuse.sol"; import "./Controllable.sol"; import "./INameWrapper.sol"; import "./INameWrapperUpgrade.sol"; import "./IMetadataService.sol"; import "../registry/ENS.sol"; import "../ethregistrar/IBaseRegistrar.sol"; import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "./BytesUtil.sol"; error Unauthorised(bytes32 node, address addr); error NameNotFound(); error IncompatibleParent(); error IncompatibleName(bytes name); error IncorrectTokenType(); error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash); error LabelTooShort(); error LabelTooLong(string label); error IncorrectTargetOwner(address owner); error CannotUpgrade(); error InvalidExpiry(bytes32 node, uint64 expiry); contract NameWrapper is     Ownable,     ERC1155Fuse,     INameWrapper,     Controllable,     IERC721Receiver {     using BytesUtils for bytes;     ENS public immutable override ens;     IBaseRegistrar public immutable override registrar;     IMetadataService public override metadataService;     mapping(bytes32 =&gt; bytes) public override names; bytes32 private constant ETH_NODE =     0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae; bytes32 private constant ROOT_NODE =     0x0000000000000000000000000000000000000000000000000000000000000000;  //A contract address to a new upgraded contract if any INameWrapperUpgrade public upgradeContract; uint64 private constant MAX_EXPIRY = type(uint64).max;  constructor(     ENS _ens,     IBaseRegistrar _registrar,     IMetadataService _metadataService ) {     ens = _ens;     registrar = _registrar;     metadataService = _metadataService;      /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */      _setData(         uint256(ETH_NODE),         address(0),         uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),         MAX_EXPIRY     );     _setData(         uint256(ROOT_NODE),         address(0),         uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),         MAX_EXPIRY     );     names[ROOT_NODE] = "\x00";     names[ETH_NODE] = "\x03eth\x00"; }  function supportsInterface(bytes4 interfaceId)     public     view     virtual     override(ERC1155Fuse, IERC165)     returns (bool) {     return         interfaceId == type(INameWrapper).interfaceId ||         super.supportsInterface(interfaceId); }  /* ERC1155 */  function ownerOf(uint256 id)     public     view     override(ERC1155Fuse, INameWrapper)     returns (address owner) {     return super.ownerOf(id); }  /* Metadata service */  /**  * @notice Set the metadata service. Only the owner can do this  */  function setMetadataService(IMetadataService _newMetadataService)     public     onlyOwner {     metadataService = _newMetadataService; }  /**  * @notice Get the metadata uri  * @return String uri of the metadata service  */  function uri(uint256 tokenId) public view override returns (string memory) {     return metadataService.uri(tokenId); }  /**  * @notice Set the address of the upgradeContract of the contract. only admin can do this  * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time  * to make the contract not upgradable.  * @param _upgradeAddress address of an upgraded contract  */  function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)     public     onlyOwner {     if (address(upgradeContract) != address(0)) {         registrar.setApprovalForAll(address(upgradeContract), false);         ens.setApprovalForAll(address(upgradeContract), false);     }      upgradeContract = _upgradeAddress;      if (address(upgradeContract) != address(0)) {         registrar.setApprovalForAll(address(upgradeContract), true);         ens.setApprovalForAll(address(upgradeContract), true);     } }  /**  * @notice Checks if msg.sender is the owner or approved by the owner of a name  * @param node namehash of the name to check  */  modifier onlyTokenOwner(bytes32 node) {     if (!isTokenOwnerOrApproved(node, msg.sender)) {         revert Unauthorised(node, msg.sender);     }      _; }  /**  * @notice Checks if owner or approved by owner  * @param node namehash of the name to check  * @param addr which address to check permissions for  * @return whether or not is owner or approved  */  function isTokenOwnerOrApproved(bytes32 node, address addr)     public     view     override     returns (bool) {     address owner = ownerOf(uint256(node));     return owner == addr || isApprovedForAll(owner, addr); }  /**  * @notice Gets fuse permissions for a specific name  * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit  *      The interface has predefined fuses for all registry permissions, but additional  *      fuses can be added for other use cases  *      Also returns expiry, which is when the fuses are set to expire.  * @param node namehash of the name to check  * @return fuses A number that represents the permissions a name has. Returns 0 when expiry &lt; block.timestamp  * @return expiry Unix time of when the name expires and fuses are to expire  */ function getFuses(bytes32 node)     public     view     override     returns (uint32 fuses, uint64 expiry) {     (, fuses, expiry) = getData(uint256(node));     if (fuses == 0 &amp;&amp; expiry == 0) {         bytes memory name = names[node];         if (name.length == 0) {             revert NameNotFound();         }     } }  /**  * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract  * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar  * @param label label as a string of the .eth domain to wrap  * @param wrappedOwner Owner of the name in this contract  * @param fuses initial fuses to set  * @param expiry when the fuses will expire  * @param resolver resolver contract address  */  function wrapETH2LD(     string calldata label,     address wrappedOwner,     uint32 fuses,     uint64 expiry,     address resolver ) public override returns (uint64) {     uint256 tokenId = uint256(keccak256(bytes(label)));     address registrant = registrar.ownerOf(tokenId);     if (         registrant != msg.sender &amp;&amp;         !isApprovedForAll(registrant, msg.sender) &amp;&amp;         !registrar.isApprovedForAll(registrant, msg.sender)     ) {         revert Unauthorised(             _makeNode(ETH_NODE, bytes32(tokenId)),             msg.sender         );     }      // transfer the token from the user to this contract     registrar.transferFrom(registrant, address(this), tokenId);      // transfer the ens record back to the new owner (this contract)     registrar.reclaim(tokenId, address(this));      return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver); }  /**  * @dev Registers a new .eth second-level domain and wraps it.  *      Only callable by authorised controllers.  * @param label The label to register (Eg, 'foo' for 'foo.eth').  * @param wrappedOwner The owner of the wrapped name.  * @param duration The duration, in seconds, to register the name for.  * @param resolver The resolver address to set on the ENS registry (optional).  * @param fuses initial fuses to set  * @param expiry when the fuses will expire  * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.  */  function registerAndWrapETH2LD(     string calldata label,     address wrappedOwner,     uint256 duration,     address resolver,     uint32 fuses,     uint64 expiry ) external override onlyController returns (uint256 registrarExpiry) {     uint256 tokenId = uint256(keccak256(bytes(label)));     registrarExpiry = registrar.register(tokenId, address(this), duration);     _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver); }  /**  * @dev Renews a .eth second-level domain.  *      Only callable by authorised controllers.  * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').  * @param duration The number of seconds to renew the name for.  * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.  */ function renew(     uint256 tokenId,     uint256 duration,     uint64 expiry ) external override onlyController returns (uint256 expires) {     bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));      expires = registrar.renew(tokenId, duration);     (address owner, uint32 fuses, uint64 oldExpiry) = getData(         uint256(node)     );     expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));      _setData(node, owner, fuses, expiry); }  /**  * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner in the registry or an authorised caller in the registry  * @param name The name to wrap, in DNS format  * @param wrappedOwner Owner of the name in this contract  * @param resolver resolver contract address  */  function wrap(     bytes calldata name,     address wrappedOwner,     address resolver ) public override {     (bytes32 labelhash, uint256 offset) = name.readLabel(0);     bytes32 parentNode = name.namehash(offset);     bytes32 node = _makeNode(parentNode, labelhash);      if (parentNode == ETH_NODE) {         revert IncompatibleParent();     }      address owner = ens.owner(node);      if (         owner != msg.sender &amp;&amp;         !isApprovedForAll(owner, msg.sender) &amp;&amp;         !ens.isApprovedForAll(owner, msg.sender)     ) {         revert Unauthorised(node, msg.sender);     }      if (resolver != address(0)) {         ens.setResolver(node, resolver);     }      ens.setOwner(node, address(this));      _wrap(node, name, wrappedOwner, 0, 0); }  /**  * @notice Unwraps a .eth domain. e.g. vitalik.eth  * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper  * @param labelhash labelhash of the .eth domain  * @param newRegistrant sets the owner in the .eth registrar to this address  * @param newController sets the owner in the registry to this address  */  function unwrapETH2LD(     bytes32 labelhash,     address newRegistrant,     address newController ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {     _unwrap(_makeNode(ETH_NODE, labelhash), newController);     registrar.transferFrom(         address(this),         newRegistrant,         uint256(labelhash)     ); }  /**  * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper  * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')  * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')  * @param newController sets the owner in the registry to this address  */  function unwrap(     bytes32 parentNode,     bytes32 labelhash,     address newController ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {     if (parentNode == ETH_NODE) {         revert IncompatibleParent();     }     _unwrap(_makeNode(parentNode, labelhash), newController); }  /**  * @notice Sets fuses of a name  * @param node namehash of the name  * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)  */  function setFuses(bytes32 node, uint32 fuses)     public     onlyTokenOwner(node)     operationAllowed(node, CANNOT_BURN_FUSES)     returns (uint32) {     if (fuses &amp; PARENT_CANNOT_CONTROL != 0) {         // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.         revert Unauthorised(node, msg.sender);     }      (address owner, uint32 oldFuses, uint64 expiry) = getData(         uint256(node)     );      fuses |= oldFuses;     _setFuses(node, owner, fuses, expiry);     return fuses; }  /**  * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract  *     and burning the token of this contract  * @dev Can be called by the owner of the name in this contract  * @param label Label as a string of the .eth name to upgrade  * @param wrappedOwner The owner of the wrapped name  */  function upgradeETH2LD(     string calldata label,     address wrappedOwner,     address resolver ) public {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(ETH_NODE, labelhash);     (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);      upgradeContract.wrapETH2LD(         label,         wrappedOwner,         fuses,         expiry,         resolver     ); }  /**  * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner or an authorised caller  * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names  * @param parentNode namehash of the parent name  * @param label Label as a string of the name to upgrade  * @param wrappedOwner Owner of the name in this contract  * @param resolver resolver contract for this name  */  function upgrade(     bytes32 parentNode,     string calldata label,     address wrappedOwner,     address resolver ) public {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(parentNode, labelhash);     (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);     upgradeContract.setSubnodeRecord(         parentNode,         label,         wrappedOwner,         resolver,         0,         fuses,         expiry     ); }  /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name  * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')  * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')  * @param fuses fuses to burn  * @param expiry when the fuses will expire  */  function setChildFuses(     bytes32 parentNode,     bytes32 labelhash,     uint32 fuses,     uint64 expiry ) public {     bytes32 node = _makeNode(parentNode, labelhash);     (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(         uint256(node)     );     uint64 maxExpiry;     if (parentNode == ETH_NODE) {         if (!isTokenOwnerOrApproved(node, msg.sender)) {             revert Unauthorised(node, msg.sender);         }         // max expiry is set to the expiry on the registrar         maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));     } else {         if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {             revert Unauthorised(node, msg.sender);         }          // max expiry is set to the expiry of the parent         (, , maxExpiry) = getData(uint256(parentNode));     }      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);      // if PARENT_CANNOT_CONTROL has been burned and fuses have changed     if (         oldFuses &amp; PARENT_CANNOT_CONTROL != 0 &amp;&amp;         oldFuses | fuses != oldFuses     ) {         revert OperationProhibited(node);     }     fuses |= oldFuses;     _setFuses(node, owner, fuses, expiry); }  /**  * @notice Sets the subdomain owner in the registry and then wraps the subdomain  * @param parentNode parent namehash of the subdomain  * @param label label of the subdomain as a string  * @param newOwner newOwner in the registry  * @param fuses initial fuses for the wrapped subdomain  * @param expiry when the fuses will expire  */  function setSubnodeOwner(     bytes32 parentNode,     string calldata label,     address newOwner,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))     returns (bytes32 node) {     bytes32 labelhash = keccak256(bytes(label));     node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);      if (ens.owner(node) != address(this)) {         ens.setSubnodeOwner(parentNode, labelhash, address(this));         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } }  /**  * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain  * @param parentNode parent namehash of the subdomain  * @param label label of the subdomain as a string  * @param newOwner newOwner in the registry  * @param resolver resolver contract in the registry  * @param ttl ttl in the regsitry  * @param fuses initial fuses for the wrapped subdomain  * @param expiry expiry date for the domain  */  function setSubnodeRecord(     bytes32 parentNode,     string memory label,     address newOwner,     address resolver,     uint64 ttl,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label))) {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);     if (ens.owner(node) != address(this)) {         ens.setSubnodeRecord(             parentNode,             labelhash,             address(this),             resolver,             ttl         );         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         ens.setSubnodeRecord(             parentNode,             labelhash,             address(this),             resolver,             ttl         );         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } }  /**  * @notice Sets records for the name in the ENS Registry  * @param node namehash of the name to set a record for  * @param owner newOwner in the registry  * @param resolver the resolver contract  * @param ttl ttl in the registry  */  function setRecord(     bytes32 node,     address owner,     address resolver,     uint64 ttl )     public     override     onlyTokenOwner(node)     operationAllowed(         node,         CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL     ) {     ens.setRecord(node, address(this), resolver, ttl);     (address oldOwner, , ) = getData(uint256(node));     _transfer(oldOwner, owner, uint256(node), 1, ""); }  /**  * @notice Sets resolver contract in the registry  * @param node namehash of the name  * @param resolver the resolver contract  */  function setResolver(bytes32 node, address resolver)     public     override     onlyTokenOwner(node)     operationAllowed(node, CANNOT_SET_RESOLVER) {     ens.setResolver(node, resolver); }  /**  * @notice Sets TTL in the registry  * @param node namehash of the name  * @param ttl TTL in the registry  */  function setTTL(bytes32 node, uint64 ttl)     public     override     onlyTokenOwner(node)     operationAllowed(node, CANNOT_SET_TTL) {     ens.setTTL(node, ttl); }  /**  * @dev Allows an operation only if none of the specified fuses are burned.  * @param node The namehash of the name to check fuses on.  * @param fuseMask A bitmask of fuses that must not be burned.  */  modifier operationAllowed(bytes32 node, uint32 fuseMask) {     (, uint32 fuses, ) = getData(uint256(node));     if (fuses &amp; fuseMask != 0) {         revert OperationProhibited(node);     }     _; }  /**  * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord  * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt  *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for  *      replacing a subdomain. If either conditions are true, then it is possible to call  *      setSubnodeOwner  * @param node namehash of the name to check  * @param labelhash labelhash of the name to check  */  modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {     bytes32 subnode = _makeNode(node, labelhash);     address owner = ens.owner(subnode);      if (owner == address(0)) {         (, uint32 fuses, ) = getData(uint256(node));         if (fuses &amp; CANNOT_CREATE_SUBDOMAIN != 0) {             revert OperationProhibited(node);         }     } else {         (, uint32 subnodeFuses, ) = getData(uint256(subnode));         if (subnodeFuses &amp; PARENT_CANNOT_CONTROL != 0) {             revert OperationProhibited(node);         }     }      _; }  /**  * @notice Checks all Fuses in the mask are burned for the node  * @param node namehash of the name  * @param fuseMask the fuses you want to check  * @return Boolean of whether or not all the selected fuses are burned  */  function allFusesBurned(bytes32 node, uint32 fuseMask)     public     view     override     returns (bool) {     (, uint32 fuses, ) = getData(uint256(node));     return fuses &amp; fuseMask == fuseMask; }  function onERC721Received(     address to,     address,     uint256 tokenId,     bytes calldata data ) public override returns (bytes4) {     //check if it's the eth registrar ERC721     if (msg.sender != address(registrar)) {         revert IncorrectTokenType();     }      (         string memory label,         address owner,         uint32 fuses,         uint64 expiry,         address resolver     ) = abi.decode(data, (string, address, uint32, uint64, address));      bytes32 labelhash = bytes32(tokenId);     bytes32 labelhashFromData = keccak256(bytes(label));      if (labelhashFromData != labelhash) {         revert LabelMismatch(labelhashFromData, labelhash);     }      // transfer the ens record back to the new owner (this contract)     registrar.reclaim(uint256(labelhash), address(this));      _wrapETH2LD(label, owner, fuses, expiry, resolver);      return IERC721Receiver(to).onERC721Received.selector; }  /***** Internal functions */  function _canTransfer(uint32 fuses) internal pure override returns (bool) {     return fuses &amp; CANNOT_TRANSFER == 0; }  function _makeNode(bytes32 node, bytes32 labelhash)     private     pure     returns (bytes32) {     return keccak256(abi.encodePacked(node, labelhash)); }  function _addLabel(string memory label, bytes memory name)     internal     pure     returns (bytes memory ret) {     if (bytes(label).length &lt; 1) {         revert LabelTooShort();     }     if (bytes(label).length &gt; 255) {         revert LabelTooLong(label);     }     return abi.encodePacked(uint8(bytes(label).length), label, name); }  function _mint(     bytes32 node,     address wrappedOwner,     uint32 fuses,     uint64 expiry ) internal override {     address oldWrappedOwner = ownerOf(uint256(node));     _canFusesBeBurned(node, fuses);     if (oldWrappedOwner != address(0)) {         // burn and unwrap old token of old owner         _burn(uint256(node));         emit NameUnwrapped(node, address(0));     }     super._mint(node, wrappedOwner, fuses, expiry); }  function _wrap(     bytes32 node,     bytes memory name,     address wrappedOwner,     uint32 fuses,     uint64 expiry ) internal {     names[node] = name;     _mint(node, wrappedOwner, fuses, expiry);     emit NameWrapped(node, name, wrappedOwner, fuses, expiry); }  function _addLabelAndWrap(     bytes32 parentNode,     bytes32 node,     string memory label,     address newOwner,     uint32 fuses,     uint64 expiry ) internal {     bytes memory name = _addLabel(label, names[parentNode]);     _wrap(node, name, newOwner, fuses, expiry); }  function _prepareUpgrade(bytes32 node)     private     returns (uint32 fuses, uint64 expiry) {     if (address(upgradeContract) == address(0)) {         revert CannotUpgrade();     }      if (!isTokenOwnerOrApproved(node, msg.sender)) {         revert Unauthorised(node, msg.sender);     }      (fuses, expiry) = getFuses(node);      // burn token and fuse data     _burn(uint256(node)); }  function _transferAndBurnFuses(     bytes32 node,     address newOwner,     uint32 fuses,     uint64 expiry ) internal {     (address owner, , ) = getData(uint256(node));     _transfer(owner, newOwner, uint256(node), 1, "");     _setFuses(node, newOwner, fuses, expiry); }  // wrapper function for stack limit function _getDataAndNormaliseExpiry(     bytes32 parentNode,     bytes32 node,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     (, , uint64 maxExpiry) = getData(uint256(parentNode));      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); }  function _getETH2LDDataAndNormaliseExpiry(     bytes32 node,     bytes32 labelhash,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); }  function _normaliseExpiry(     uint64 expiry,     uint64 oldExpiry,     uint64 maxExpiry ) internal pure returns (uint64) {     // Expiry cannot be more than maximum allowed     // .eth names will check registrar, non .eth check parent     if (expiry &gt; maxExpiry) {         expiry = maxExpiry;     }     // Expiry cannot be less than old expiry     if (expiry &lt; oldExpiry) {         expiry = oldExpiry;     }      return expiry; }  function _wrapETH2LD(     string memory label,     address wrappedOwner,     uint32 fuses,     uint64 expiry,     address resolver ) private returns (uint64) {     // Mint a new ERC1155 token with fuses     // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(ETH_NODE, labelhash);      (, , expiry) = _getETH2LDDataAndNormaliseExpiry(         node,         labelhash,         expiry     );      _addLabelAndWrap(         ETH_NODE,         node,         label,         wrappedOwner,         fuses | PARENT_CANNOT_CONTROL,         expiry     );     if (resolver != address(0)) {         ens.setResolver(node, resolver);     }      return expiry; }  function _unwrap(bytes32 node, address newOwner) private {     if (newOwner == address(0x0) || newOwner == address(this)) {         revert IncorrectTargetOwner(newOwner);     }      if (allFusesBurned(node, CANNOT_UNWRAP)) {         revert OperationProhibited(node);     }      // Burn token and fuse data     _burn(uint256(node));     ens.setOwner(node, newOwner);      emit NameUnwrapped(node, newOwner); }  function _setFuses(     bytes32 node,     address owner,     uint32 fuses,     uint64 expiry ) internal {     _setData(node, owner, fuses, expiry);     emit FusesSet(node, fuses, expiry); }  function _setData(     bytes32 node,     address owner,     uint32 fuses,     uint64 expiry ) internal {     _canFusesBeBurned(node, fuses);     super._setData(uint256(node), owner, fuses, expiry); }  function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {     if (         fuses &amp; ~PARENT_CANNOT_CONTROL != 0 &amp;&amp;         fuses &amp; (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=         (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)     ) {         revert OperationProhibited(node);     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 20:36:26 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: //SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "./ERC1155Fuse.sol";
import "./Controllable.sol";
import "./INameWrapper.sol";
import "./INameWrapperUpgrade.sol";
import "./IMetadataService.sol";
import "../registry/ENS.sol";
import "../ethregistrar/IBaseRegistrar.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./BytesUtil.sol";

error Unauthorised(bytes32 node, address addr);
error NameNotFound();
error IncompatibleParent();
error IncompatibleName(bytes name);
error IncorrectTokenType();
error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);
error LabelTooShort();
error LabelTooLong(string label);
error IncorrectTargetOwner(address owner);
error CannotUpgrade();
error InvalidExpiry(bytes32 node, uint64 expiry);

contract NameWrapper is
    Ownable,
    ERC1155Fuse,
    INameWrapper,
    Controllable,
    IERC721Receiver
{
    using BytesUtils for bytes;
    ENS public immutable override ens;
    IBaseRegistrar public immutable override registrar;
    IMetadataService public override metadataService;
    mapping(bytes32 => bytes) public override names;

    bytes32 private constant ETH_NODE =
        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
    bytes32 private constant ROOT_NODE =
        0x0000000000000000000000000000000000000000000000000000000000000000;

    //A contract address to a new upgraded contract if any
    INameWrapperUpgrade public upgradeContract;
    uint64 private constant MAX_EXPIRY = type(uint64).max;

    constructor(
        ENS _ens,
        IBaseRegistrar _registrar,
        IMetadataService _metadataService
    ) {
        ens = _ens;
        registrar = _registrar;
        metadataService = _metadataService;

        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */

        _setData(
            uint256(ETH_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        _setData(
            uint256(ROOT_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        names[ROOT_NODE] = "\x00";
        names[ETH_NODE] = "\x03eth\x00";
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Fuse, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(INameWrapper).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /* ERC1155 */

    function ownerOf(uint256 id)
        public
        view
        override(ERC1155Fuse, INameWrapper)
        returns (address owner)
    {
        return super.ownerOf(id);
    }

    /* Metadata service */

    /**
     * @notice Set the metadata service. Only the owner can do this
     */

    function setMetadataService(IMetadataService _newMetadataService)
        public
        onlyOwner
    {
        metadataService = _newMetadataService;
    }

    /**
     * @notice Get the metadata uri
     * @return String uri of the metadata service
     */

    function uri(uint256 tokenId) public view override returns (string memory) {
        return metadataService.uri(tokenId);
    }

    /**
     * @notice Set the address of the upgradeContract of the contract. only admin can do this
     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time
     * to make the contract not upgradable.
     * @param _upgradeAddress address of an upgraded contract
     */

    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)
        public
        onlyOwner
    {
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), false);
            ens.setApprovalForAll(address(upgradeContract), false);
        }

        upgradeContract = _upgradeAddress;

        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), true);
            ens.setApprovalForAll(address(upgradeContract), true);
        }
    }

    /**
     * @notice Checks if msg.sender is the owner or approved by the owner of a name
     * @param node namehash of the name to check
     */

    modifier onlyTokenOwner(bytes32 node) {
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        _;
    }

    /**
     * @notice Checks if owner or approved by owner
     * @param node namehash of the name to check
     * @param addr which address to check permissions for
     * @return whether or not is owner or approved
     */

    function isTokenOwnerOrApproved(bytes32 node, address addr)
        public
        view
        override
        returns (bool)
    {
        address owner = ownerOf(uint256(node));
        return owner == addr || isApprovedForAll(owner, addr);
    }

    /**
     * @notice Gets fuse permissions for a specific name
     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit
     *      The interface has predefined fuses for all registry permissions, but additional
     *      fuses can be added for other use cases
     *      Also returns expiry, which is when the fuses are set to expire.
     * @param node namehash of the name to check
     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp
     * @return expiry Unix time of when the name expires and fuses are to expire
     */
    function getFuses(bytes32 node)
        public
        view
        override
        returns (uint32 fuses, uint64 expiry)
    {
        (, fuses, expiry) = getData(uint256(node));
        if (fuses == 0 && expiry == 0) {
            bytes memory name = names[node];
            if (name.length == 0) {
                revert NameNotFound();
            }
        }
    }

    /**
     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract
     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar
     * @param label label as a string of the .eth domain to wrap
     * @param wrappedOwner Owner of the name in this contract
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @param resolver resolver contract address
     */

    function wrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) public override returns (uint64) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        address registrant = registrar.ownerOf(tokenId);
        if (
            registrant != msg.sender &&
            !isApprovedForAll(registrant, msg.sender) &&
            !registrar.isApprovedForAll(registrant, msg.sender)
        ) {
            revert Unauthorised(
                _makeNode(ETH_NODE, bytes32(tokenId)),
                msg.sender
            );
        }

        // transfer the token from the user to this contract
        registrar.transferFrom(registrant, address(this), tokenId);

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(tokenId, address(this));

        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Registers a new .eth second-level domain and wraps it.
     *      Only callable by authorised controllers.
     * @param label The label to register (Eg, 'foo' for 'foo.eth').
     * @param wrappedOwner The owner of the wrapped name.
     * @param duration The duration, in seconds, to register the name for.
     * @param resolver The resolver address to set on the ENS registry (optional).
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.
     */

    function registerAndWrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint256 duration,
        address resolver,
        uint32 fuses,
        uint64 expiry
    ) external override onlyController returns (uint256 registrarExpiry) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        registrarExpiry = registrar.register(tokenId, address(this), duration);
        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Renews a .eth second-level domain.
     *      Only callable by authorised controllers.
     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').
     * @param duration The number of seconds to renew the name for.
     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.
     */
    function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));

        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));

        _setData(node, owner, fuses, expiry);
    }

    /**
     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the registry or an authorised caller in the registry
     * @param name The name to wrap, in DNS format
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract address
     */

    function wrap(
        bytes calldata name,
        address wrappedOwner,
        address resolver
    ) public override {
        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
        bytes32 parentNode = name.namehash(offset);
        bytes32 node = _makeNode(parentNode, labelhash);

        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }

        address owner = ens.owner(node);

        if (
            owner != msg.sender &&
            !isApprovedForAll(owner, msg.sender) &&
            !ens.isApprovedForAll(owner, msg.sender)
        ) {
            revert Unauthorised(node, msg.sender);
        }

        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        ens.setOwner(node, address(this));

        _wrap(node, name, wrappedOwner, 0, 0);
    }

    /**
     * @notice Unwraps a .eth domain. e.g. vitalik.eth
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param labelhash labelhash of the .eth domain
     * @param newRegistrant sets the owner in the .eth registrar to this address
     * @param newController sets the owner in the registry to this address
     */

    function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }

    /**
     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param newController sets the owner in the registry to this address
     */

    function unwrap(
        bytes32 parentNode,
        bytes32 labelhash,
        address newController
    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        _unwrap(_makeNode(parentNode, labelhash), newController);
    }

    /**
     * @notice Sets fuses of a name
     * @param node namehash of the name
     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)
     */

    function setFuses(bytes32 node, uint32 fuses)
        public
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_BURN_FUSES)
        returns (uint32)
    {
        if (fuses & PARENT_CANNOT_CONTROL != 0) {
            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.
            revert Unauthorised(node, msg.sender);
        }

        (address owner, uint32 oldFuses, uint64 expiry) = getData(
            uint256(node)
        );

        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
        return fuses;
    }

    /**
     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract
     *     and burning the token of this contract
     * @dev Can be called by the owner of the name in this contract
     * @param label Label as a string of the .eth name to upgrade
     * @param wrappedOwner The owner of the wrapped name
     */

    function upgradeETH2LD(
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);

        upgradeContract.wrapETH2LD(
            label,
            wrappedOwner,
            fuses,
            expiry,
            resolver
        );
    }

    /**
     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner or an authorised caller
     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names
     * @param parentNode namehash of the parent name
     * @param label Label as a string of the name to upgrade
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract for this name
     */

    function upgrade(
        bytes32 parentNode,
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.setSubnodeRecord(
            parentNode,
            label,
            wrappedOwner,
            resolver,
            0,
            fuses,
            expiry
        );
    }

    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param fuses fuses to burn
     * @param expiry when the fuses will expire
     */

    function setChildFuses(
        bytes32 parentNode,
        bytes32 labelhash,
        uint32 fuses,
        uint64 expiry
    ) public {
        bytes32 node = _makeNode(parentNode, labelhash);
        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        uint64 maxExpiry;
        if (parentNode == ETH_NODE) {
            if (!isTokenOwnerOrApproved(node, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            // max expiry is set to the expiry on the registrar
            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        } else {
            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }

            // max expiry is set to the expiry of the parent
            (, , maxExpiry) = getData(uint256(parentNode));
        }

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);

        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed
        if (
            oldFuses & PARENT_CANNOT_CONTROL != 0 &&
            oldFuses | fuses != oldFuses
        ) {
            revert OperationProhibited(node);
        }
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
    }

    /**
     * @notice Sets the subdomain owner in the registry and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry when the fuses will expire
     */

    function setSubnodeOwner(
        bytes32 parentNode,
        string calldata label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
        returns (bytes32 node)
    {
        bytes32 labelhash = keccak256(bytes(label));
        node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);

        if (ens.owner(node) != address(this)) {
            ens.setSubnodeOwner(parentNode, labelhash, address(this));
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param resolver resolver contract in the registry
     * @param ttl ttl in the regsitry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry expiry date for the domain
     */

    function setSubnodeRecord(
        bytes32 parentNode,
        string memory label,
        address newOwner,
        address resolver,
        uint64 ttl,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
    {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets records for the name in the ENS Registry
     * @param node namehash of the name to set a record for
     * @param owner newOwner in the registry
     * @param resolver the resolver contract
     * @param ttl ttl in the registry
     */

    function setRecord(
        bytes32 node,
        address owner,
        address resolver,
        uint64 ttl
    )
        public
        override
        onlyTokenOwner(node)
        operationAllowed(
            node,
            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL
        )
    {
        ens.setRecord(node, address(this), resolver, ttl);
        (address oldOwner, , ) = getData(uint256(node));
        _transfer(oldOwner, owner, uint256(node), 1, "");
    }

    /**
     * @notice Sets resolver contract in the registry
     * @param node namehash of the name
     * @param resolver the resolver contract
     */

    function setResolver(bytes32 node, address resolver)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_RESOLVER)
    {
        ens.setResolver(node, resolver);
    }

    /**
     * @notice Sets TTL in the registry
     * @param node namehash of the name
     * @param ttl TTL in the registry
     */

    function setTTL(bytes32 node, uint64 ttl)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_TTL)
    {
        ens.setTTL(node, ttl);
    }

    /**
     * @dev Allows an operation only if none of the specified fuses are burned.
     * @param node The namehash of the name to check fuses on.
     * @param fuseMask A bitmask of fuses that must not be burned.
     */

    modifier operationAllowed(bytes32 node, uint32 fuseMask) {
        (, uint32 fuses, ) = getData(uint256(node));
        if (fuses & fuseMask != 0) {
            revert OperationProhibited(node);
        }
        _;
    }

    /**
     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord
     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt
     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for
     *      replacing a subdomain. If either conditions are true, then it is possible to call
     *      setSubnodeOwner
     * @param node namehash of the name to check
     * @param labelhash labelhash of the name to check
     */

    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {
        bytes32 subnode = _makeNode(node, labelhash);
        address owner = ens.owner(subnode);

        if (owner == address(0)) {
            (, uint32 fuses, ) = getData(uint256(node));
            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {
                revert OperationProhibited(node);
            }
        } else {
            (, uint32 subnodeFuses, ) = getData(uint256(subnode));
            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {
                revert OperationProhibited(node);
            }
        }

        _;
    }

    /**
     * @notice Checks all Fuses in the mask are burned for the node
     * @param node namehash of the name
     * @param fuseMask the fuses you want to check
     * @return Boolean of whether or not all the selected fuses are burned
     */

    function allFusesBurned(bytes32 node, uint32 fuseMask)
        public
        view
        override
        returns (bool)
    {
        (, uint32 fuses, ) = getData(uint256(node));
        return fuses & fuseMask == fuseMask;
    }

    function onERC721Received(
        address to,
        address,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        //check if it's the eth registrar ERC721
        if (msg.sender != address(registrar)) {
            revert IncorrectTokenType();
        }

        (
            string memory label,
            address owner,
            uint32 fuses,
            uint64 expiry,
            address resolver
        ) = abi.decode(data, (string, address, uint32, uint64, address));

        bytes32 labelhash = bytes32(tokenId);
        bytes32 labelhashFromData = keccak256(bytes(label));

        if (labelhashFromData != labelhash) {
            revert LabelMismatch(labelhashFromData, labelhash);
        }

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(uint256(labelhash), address(this));

        _wrapETH2LD(label, owner, fuses, expiry, resolver);

        return IERC721Receiver(to).onERC721Received.selector;
    }

    /***** Internal functions */

    function _canTransfer(uint32 fuses) internal pure override returns (bool) {
        return fuses & CANNOT_TRANSFER == 0;
    }

    function _makeNode(bytes32 node, bytes32 labelhash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, labelhash));
    }

    function _addLabel(string memory label, bytes memory name)
        internal
        pure
        returns (bytes memory ret)
    {
        if (bytes(label).length < 1) {
            revert LabelTooShort();
        }
        if (bytes(label).length > 255) {
            revert LabelTooLong(label);
        }
        return abi.encodePacked(uint8(bytes(label).length), label, name);
    }

    function _mint(
        bytes32 node,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal override {
        address oldWrappedOwner = ownerOf(uint256(node));
        _canFusesBeBurned(node, fuses);
        if (oldWrappedOwner != address(0)) {
            // burn and unwrap old token of old owner
            _burn(uint256(node));
            emit NameUnwrapped(node, address(0));
        }
        super._mint(node, wrappedOwner, fuses, expiry);
    }

    function _wrap(
        bytes32 node,
        bytes memory name,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        names[node] = name;
        _mint(node, wrappedOwner, fuses, expiry);
        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);
    }

    function _addLabelAndWrap(
        bytes32 parentNode,
        bytes32 node,
        string memory label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        bytes memory name = _addLabel(label, names[parentNode]);
        _wrap(node, name, newOwner, fuses, expiry);
    }

    function _prepareUpgrade(bytes32 node)
        private
        returns (uint32 fuses, uint64 expiry)
    {
        if (address(upgradeContract) == address(0)) {
            revert CannotUpgrade();
        }

        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        (fuses, expiry) = getFuses(node);

        // burn token and fuse data
        _burn(uint256(node));
    }

    function _transferAndBurnFuses(
        bytes32 node,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        (address owner, , ) = getData(uint256(node));
        _transfer(owner, newOwner, uint256(node), 1, "");
        _setFuses(node, newOwner, fuses, expiry);
    }

    // wrapper function for stack limit
    function _getDataAndNormaliseExpiry(
        bytes32 parentNode,
        bytes32 node,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        (, , uint64 maxExpiry) = getData(uint256(parentNode));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _getETH2LDDataAndNormaliseExpiry(
        bytes32 node,
        bytes32 labelhash,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _normaliseExpiry(
        uint64 expiry,
        uint64 oldExpiry,
        uint64 maxExpiry
    ) internal pure returns (uint64) {
        // Expiry cannot be more than maximum allowed
        // .eth names will check registrar, non .eth check parent
        if (expiry > maxExpiry) {
            expiry = maxExpiry;
        }
        // Expiry cannot be less than old expiry
        if (expiry < oldExpiry) {
            expiry = oldExpiry;
        }

        return expiry;
    }

    function _wrapETH2LD(
        string memory label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) private returns (uint64) {
        // Mint a new ERC1155 token with fuses
        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);

        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(
            node,
            labelhash,
            expiry
        );

        _addLabelAndWrap(
            ETH_NODE,
            node,
            label,
            wrappedOwner,
            fuses | PARENT_CANNOT_CONTROL,
            expiry
        );
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        return expiry;
    }

    function _unwrap(bytes32 node, address newOwner) private {
        if (newOwner == address(0x0) || newOwner == address(this)) {
            revert IncorrectTargetOwner(newOwner);
        }

        if (allFusesBurned(node, CANNOT_UNWRAP)) {
            revert OperationProhibited(node);
        }

        // Burn token and fuse data
        _burn(uint256(node));
        ens.setOwner(node, newOwner);

        emit NameUnwrapped(node, newOwner);
    }

    function _setFuses(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _setData(node, owner, fuses, expiry);
        emit FusesSet(node, fuses, expiry);
    }

    function _setData(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _canFusesBeBurned(node, fuses);
        super._setData(uint256(node), owner, fuses, expiry);
    }

    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
        if (
            fuses & ~PARENT_CANNOT_CONTROL != 0 &&
            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
        ) {
            revert OperationProhibited(node);
        }
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "//SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "./ERC1155Fuse.sol";
import "./Controllable.sol";
import "./INameWrapper.sol";
import "./INameWrapperUpgrade.sol";
import "./IMetadataService.sol";
import "../registry/ENS.sol";
import "../ethregistrar/IBaseRegistrar.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./BytesUtil.sol";

error Unauthorised(bytes32 node, address addr);
error NameNotFound();
error IncompatibleParent();
error IncompatibleName(bytes name);
error IncorrectTokenType();
error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);
error LabelTooShort();
error LabelTooLong(string label);
error IncorrectTargetOwner(address owner);
error CannotUpgrade();
error InvalidExpiry(bytes32 node, uint64 expiry);

contract NameWrapper is
    Ownable,
    ERC1155Fuse,
    INameWrapper,
    Controllable,
    IERC721Receiver
{
    using BytesUtils for bytes;
    ENS public immutable override ens;
    IBaseRegistrar public immutable override registrar;
    IMetadataService public override metadataService;
    mapping(bytes32 => bytes) public override names;

    bytes32 private constant ETH_NODE =
        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
    bytes32 private constant ROOT_NODE =
        0x0000000000000000000000000000000000000000000000000000000000000000;

    //A contract address to a new upgraded contract if any
    INameWrapperUpgrade public upgradeContract;
    uint64 private constant MAX_EXPIRY = type(uint64).max;

    constructor(
        ENS _ens,
        IBaseRegistrar _registrar,
        IMetadataService _metadataService
    ) {
        ens = _ens;
        registrar = _registrar;
        metadataService = _metadataService;

        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */

        _setData(
            uint256(ETH_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        _setData(
            uint256(ROOT_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        names[ROOT_NODE] = "\x00";
        names[ETH_NODE] = "\x03eth\x00";
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Fuse, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(INameWrapper).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /* ERC1155 */

    function ownerOf(uint256 id)
        public
        view
        override(ERC1155Fuse, INameWrapper)
        returns (address owner)
    {
        return super.ownerOf(id);
    }

    /* Metadata service */

    /**
     * @notice Set the metadata service. Only the owner can do this
     */

    function setMetadataService(IMetadataService _newMetadataService)
        public
        onlyOwner
    {
        metadataService = _newMetadataService;
    }

    /**
     * @notice Get the metadata uri
     * @return String uri of the metadata service
     */

    function uri(uint256 tokenId) public view override returns (string memory) {
        return metadataService.uri(tokenId);
    }

    /**
     * @notice Set the address of the upgradeContract of the contract. only admin can do this
     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time
     * to make the contract not upgradable.
     * @param _upgradeAddress address of an upgraded contract
     */

    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)
        public
        onlyOwner
    {
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), false);
            ens.setApprovalForAll(address(upgradeContract), false);
        }

        upgradeContract = _upgradeAddress;

        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), true);
            ens.setApprovalForAll(address(upgradeContract), true);
        }
    }

    /**
     * @notice Checks if msg.sender is the owner or approved by the owner of a name
     * @param node namehash of the name to check
     */

    modifier onlyTokenOwner(bytes32 node) {
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        _;
    }

    /**
     * @notice Checks if owner or approved by owner
     * @param node namehash of the name to check
     * @param addr which address to check permissions for
     * @return whether or not is owner or approved
     */

    function isTokenOwnerOrApproved(bytes32 node, address addr)
        public
        view
        override
        returns (bool)
    {
        address owner = ownerOf(uint256(node));
        return owner == addr || isApprovedForAll(owner, addr);
    }

    /**
     * @notice Gets fuse permissions for a specific name
     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit
     *      The interface has predefined fuses for all registry permissions, but additional
     *      fuses can be added for other use cases
     *      Also returns expiry, which is when the fuses are set to expire.
     * @param node namehash of the name to check
     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp
     * @return expiry Unix time of when the name expires and fuses are to expire
     */
    function getFuses(bytes32 node)
        public
        view
        override
        returns (uint32 fuses, uint64 expiry)
    {
        (, fuses, expiry) = getData(uint256(node));
        if (fuses == 0 && expiry == 0) {
            bytes memory name = names[node];
            if (name.length == 0) {
                revert NameNotFound();
            }
        }
    }

    /**
     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract
     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar
     * @param label label as a string of the .eth domain to wrap
     * @param wrappedOwner Owner of the name in this contract
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @param resolver resolver contract address
     */

    function wrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) public override returns (uint64) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        address registrant = registrar.ownerOf(tokenId);
        if (
            registrant != msg.sender &&
            !isApprovedForAll(registrant, msg.sender) &&
            !registrar.isApprovedForAll(registrant, msg.sender)
        ) {
            revert Unauthorised(
                _makeNode(ETH_NODE, bytes32(tokenId)),
                msg.sender
            );
        }

        // transfer the token from the user to this contract
        registrar.transferFrom(registrant, address(this), tokenId);

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(tokenId, address(this));

        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Registers a new .eth second-level domain and wraps it.
     *      Only callable by authorised controllers.
     * @param label The label to register (Eg, 'foo' for 'foo.eth').
     * @param wrappedOwner The owner of the wrapped name.
     * @param duration The duration, in seconds, to register the name for.
     * @param resolver The resolver address to set on the ENS registry (optional).
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.
     */

    function registerAndWrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint256 duration,
        address resolver,
        uint32 fuses,
        uint64 expiry
    ) external override onlyController returns (uint256 registrarExpiry) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        registrarExpiry = registrar.register(tokenId, address(this), duration);
        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Renews a .eth second-level domain.
     *      Only callable by authorised controllers.
     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').
     * @param duration The number of seconds to renew the name for.
     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.
     */
    function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));

        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));

        _setData(node, owner, fuses, expiry);
    }

    /**
     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the registry or an authorised caller in the registry
     * @param name The name to wrap, in DNS format
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract address
     */

    function wrap(
        bytes calldata name,
        address wrappedOwner,
        address resolver
    ) public override {
        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
        bytes32 parentNode = name.namehash(offset);
        bytes32 node = _makeNode(parentNode, labelhash);

        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }

        address owner = ens.owner(node);

        if (
            owner != msg.sender &&
            !isApprovedForAll(owner, msg.sender) &&
            !ens.isApprovedForAll(owner, msg.sender)
        ) {
            revert Unauthorised(node, msg.sender);
        }

        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        ens.setOwner(node, address(this));

        _wrap(node, name, wrappedOwner, 0, 0);
    }

    /**
     * @notice Unwraps a .eth domain. e.g. vitalik.eth
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param labelhash labelhash of the .eth domain
     * @param newRegistrant sets the owner in the .eth registrar to this address
     * @param newController sets the owner in the registry to this address
     */

    function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }

    /**
     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param newController sets the owner in the registry to this address
     */

    function unwrap(
        bytes32 parentNode,
        bytes32 labelhash,
        address newController
    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        _unwrap(_makeNode(parentNode, labelhash), newController);
    }

    /**
     * @notice Sets fuses of a name
     * @param node namehash of the name
     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)
     */

    function setFuses(bytes32 node, uint32 fuses)
        public
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_BURN_FUSES)
        returns (uint32)
    {
        if (fuses & PARENT_CANNOT_CONTROL != 0) {
            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.
            revert Unauthorised(node, msg.sender);
        }

        (address owner, uint32 oldFuses, uint64 expiry) = getData(
            uint256(node)
        );

        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
        return fuses;
    }

    /**
     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract
     *     and burning the token of this contract
     * @dev Can be called by the owner of the name in this contract
     * @param label Label as a string of the .eth name to upgrade
     * @param wrappedOwner The owner of the wrapped name
     */

    function upgradeETH2LD(
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);

        upgradeContract.wrapETH2LD(
            label,
            wrappedOwner,
            fuses,
            expiry,
            resolver
        );
    }

    /**
     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner or an authorised caller
     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names
     * @param parentNode namehash of the parent name
     * @param label Label as a string of the name to upgrade
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract for this name
     */

    function upgrade(
        bytes32 parentNode,
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.setSubnodeRecord(
            parentNode,
            label,
            wrappedOwner,
            resolver,
            0,
            fuses,
            expiry
        );
    }

    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param fuses fuses to burn
     * @param expiry when the fuses will expire
     */

    function setChildFuses(
        bytes32 parentNode,
        bytes32 labelhash,
        uint32 fuses,
        uint64 expiry
    ) public {
        bytes32 node = _makeNode(parentNode, labelhash);
        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        uint64 maxExpiry;
        if (parentNode == ETH_NODE) {
            if (!isTokenOwnerOrApproved(node, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            // max expiry is set to the expiry on the registrar
            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        } else {
            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }

            // max expiry is set to the expiry of the parent
            (, , maxExpiry) = getData(uint256(parentNode));
        }

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);

        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed
        if (
            oldFuses & PARENT_CANNOT_CONTROL != 0 &&
            oldFuses | fuses != oldFuses
        ) {
            revert OperationProhibited(node);
        }
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
    }

    /**
     * @notice Sets the subdomain owner in the registry and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry when the fuses will expire
     */

    function setSubnodeOwner(
        bytes32 parentNode,
        string calldata label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
        returns (bytes32 node)
    {
        bytes32 labelhash = keccak256(bytes(label));
        node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);

        if (ens.owner(node) != address(this)) {
            ens.setSubnodeOwner(parentNode, labelhash, address(this));
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param resolver resolver contract in the registry
     * @param ttl ttl in the regsitry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry expiry date for the domain
     */

    function setSubnodeRecord(
        bytes32 parentNode,
        string memory label,
        address newOwner,
        address resolver,
        uint64 ttl,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
    {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets records for the name in the ENS Registry
     * @param node namehash of the name to set a record for
     * @param owner newOwner in the registry
     * @param resolver the resolver contract
     * @param ttl ttl in the registry
     */

    function setRecord(
        bytes32 node,
        address owner,
        address resolver,
        uint64 ttl
    )
        public
        override
        onlyTokenOwner(node)
        operationAllowed(
            node,
            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL
        )
    {
        ens.setRecord(node, address(this), resolver, ttl);
        (address oldOwner, , ) = getData(uint256(node));
        _transfer(oldOwner, owner, uint256(node), 1, "");
    }

    /**
     * @notice Sets resolver contract in the registry
     * @param node namehash of the name
     * @param resolver the resolver contract
     */

    function setResolver(bytes32 node, address resolver)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_RESOLVER)
    {
        ens.setResolver(node, resolver);
    }

    /**
     * @notice Sets TTL in the registry
     * @param node namehash of the name
     * @param ttl TTL in the registry
     */

    function setTTL(bytes32 node, uint64 ttl)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_TTL)
    {
        ens.setTTL(node, ttl);
    }

    /**
     * @dev Allows an operation only if none of the specified fuses are burned.
     * @param node The namehash of the name to check fuses on.
     * @param fuseMask A bitmask of fuses that must not be burned.
     */

    modifier operationAllowed(bytes32 node, uint32 fuseMask) {
        (, uint32 fuses, ) = getData(uint256(node));
        if (fuses & fuseMask != 0) {
            revert OperationProhibited(node);
        }
        _;
    }

    /**
     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord
     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt
     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for
     *      replacing a subdomain. If either conditions are true, then it is possible to call
     *      setSubnodeOwner
     * @param node namehash of the name to check
     * @param labelhash labelhash of the name to check
     */

    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {
        bytes32 subnode = _makeNode(node, labelhash);
        address owner = ens.owner(subnode);

        if (owner == address(0)) {
            (, uint32 fuses, ) = getData(uint256(node));
            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {
                revert OperationProhibited(node);
            }
        } else {
            (, uint32 subnodeFuses, ) = getData(uint256(subnode));
            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {
                revert OperationProhibited(node);
            }
        }

        _;
    }

    /**
     * @notice Checks all Fuses in the mask are burned for the node
     * @param node namehash of the name
     * @param fuseMask the fuses you want to check
     * @return Boolean of whether or not all the selected fuses are burned
     */

    function allFusesBurned(bytes32 node, uint32 fuseMask)
        public
        view
        override
        returns (bool)
    {
        (, uint32 fuses, ) = getData(uint256(node));
        return fuses & fuseMask == fuseMask;
    }

    function onERC721Received(
        address to,
        address,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        //check if it's the eth registrar ERC721
        if (msg.sender != address(registrar)) {
            revert IncorrectTokenType();
        }

        (
            string memory label,
            address owner,
            uint32 fuses,
            uint64 expiry,
            address resolver
        ) = abi.decode(data, (string, address, uint32, uint64, address));

        bytes32 labelhash = bytes32(tokenId);
        bytes32 labelhashFromData = keccak256(bytes(label));

        if (labelhashFromData != labelhash) {
            revert LabelMismatch(labelhashFromData, labelhash);
        }

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(uint256(labelhash), address(this));

        _wrapETH2LD(label, owner, fuses, expiry, resolver);

        return IERC721Receiver(to).onERC721Received.selector;
    }

    /***** Internal functions */

    function _canTransfer(uint32 fuses) internal pure override returns (bool) {
        return fuses & CANNOT_TRANSFER == 0;
    }

    function _makeNode(bytes32 node, bytes32 labelhash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, labelhash));
    }

    function _addLabel(string memory label, bytes memory name)
        internal
        pure
        returns (bytes memory ret)
    {
        if (bytes(label).length < 1) {
            revert LabelTooShort();
        }
        if (bytes(label).length > 255) {
            revert LabelTooLong(label);
        }
        return abi.encodePacked(uint8(bytes(label).length), label, name);
    }

    function _mint(
        bytes32 node,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal override {
        address oldWrappedOwner = ownerOf(uint256(node));
        _canFusesBeBurned(node, fuses);
        if (oldWrappedOwner != address(0)) {
            // burn and unwrap old token of old owner
            _burn(uint256(node));
            emit NameUnwrapped(node, address(0));
        }
        super._mint(node, wrappedOwner, fuses, expiry);
    }

    function _wrap(
        bytes32 node,
        bytes memory name,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        names[node] = name;
        _mint(node, wrappedOwner, fuses, expiry);
        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);
    }

    function _addLabelAndWrap(
        bytes32 parentNode,
        bytes32 node,
        string memory label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        bytes memory name = _addLabel(label, names[parentNode]);
        _wrap(node, name, newOwner, fuses, expiry);
    }

    function _prepareUpgrade(bytes32 node)
        private
        returns (uint32 fuses, uint64 expiry)
    {
        if (address(upgradeContract) == address(0)) {
            revert CannotUpgrade();
        }

        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        (fuses, expiry) = getFuses(node);

        // burn token and fuse data
        _burn(uint256(node));
    }

    function _transferAndBurnFuses(
        bytes32 node,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        (address owner, , ) = getData(uint256(node));
        _transfer(owner, newOwner, uint256(node), 1, "");
        _setFuses(node, newOwner, fuses, expiry);
    }

    // wrapper function for stack limit
    function _getDataAndNormaliseExpiry(
        bytes32 parentNode,
        bytes32 node,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        (, , uint64 maxExpiry) = getData(uint256(parentNode));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _getETH2LDDataAndNormaliseExpiry(
        bytes32 node,
        bytes32 labelhash,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _normaliseExpiry(
        uint64 expiry,
        uint64 oldExpiry,
        uint64 maxExpiry
    ) internal pure returns (uint64) {
        // Expiry cannot be more than maximum allowed
        // .eth names will check registrar, non .eth check parent
        if (expiry > maxExpiry) {
            expiry = maxExpiry;
        }
        // Expiry cannot be less than old expiry
        if (expiry < oldExpiry) {
            expiry = oldExpiry;
        }

        return expiry;
    }

    function _wrapETH2LD(
        string memory label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) private returns (uint64) {
        // Mint a new ERC1155 token with fuses
        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);

        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(
            node,
            labelhash,
            expiry
        );

        _addLabelAndWrap(
            ETH_NODE,
            node,
            label,
            wrappedOwner,
            fuses | PARENT_CANNOT_CONTROL,
            expiry
        );
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        return expiry;
    }

    function _unwrap(bytes32 node, address newOwner) private {
        if (newOwner == address(0x0) || newOwner == address(this)) {
            revert IncorrectTargetOwner(newOwner);
        }

        if (allFusesBurned(node, CANNOT_UNWRAP)) {
            revert OperationProhibited(node);
        }

        // Burn token and fuse data
        _burn(uint256(node));
        ens.setOwner(node, newOwner);

        emit NameUnwrapped(node, newOwner);
    }

    function _setFuses(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _setData(node, owner, fuses, expiry);
        emit FusesSet(node, fuses, expiry);
    }

    function _setData(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _canFusesBeBurned(node, fuses);
        super._setData(uint256(node), owner, fuses, expiry);
    }

    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
        if (
            fuses & ~PARENT_CANNOT_CONTROL != 0 &&
            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
        ) {
            revert OperationProhibited(node);
        }
    }
}
".
Ideas: " 1".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-01-09 20:36:38 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 20:36:38 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 14282
completion_tokens: 914
total_tokens: 15196
cost: $-1.000000


[2024-01-09 20:36:38 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: //SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "./ERC1155Fuse.sol";
import "./Controllable.sol";
import "./INameWrapper.sol";
import "./INameWrapperUpgrade.sol";
import "./IMetadataService.sol";
import "../registry/ENS.sol";
import "../ethregistrar/IBaseRegistrar.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./BytesUtil.sol";

error Unauthorised(bytes32 node, address addr);
error NameNotFound();
error IncompatibleParent();
error IncompatibleName(bytes name);
error IncorrectTokenType();
error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);
error LabelTooShort();
error LabelTooLong(string label);
error IncorrectTargetOwner(address owner);
error CannotUpgrade();
error InvalidExpiry(bytes32 node, uint64 expiry);

contract NameWrapper is
    Ownable,
    ERC1155Fuse,
    INameWrapper,
    Controllable,
    IERC721Receiver
{
    using BytesUtils for bytes;
    ENS public immutable override ens;
    IBaseRegistrar public immutable override registrar;
    IMetadataService public override metadataService;
    mapping(bytes32 => bytes) public override names;

    bytes32 private constant ETH_NODE =
        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
    bytes32 private constant ROOT_NODE =
        0x0000000000000000000000000000000000000000000000000000000000000000;

    //A contract address to a new upgraded contract if any
    INameWrapperUpgrade public upgradeContract;
    uint64 private constant MAX_EXPIRY = type(uint64).max;

    constructor(
        ENS _ens,
        IBaseRegistrar _registrar,
        IMetadataService _metadataService
    ) {
        ens = _ens;
        registrar = _registrar;
        metadataService = _metadataService;

        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */

        _setData(
            uint256(ETH_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        _setData(
            uint256(ROOT_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        names[ROOT_NODE] = "\x00";
        names[ETH_NODE] = "\x03eth\x00";
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Fuse, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(INameWrapper).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /* ERC1155 */

    function ownerOf(uint256 id)
        public
        view
        override(ERC1155Fuse, INameWrapper)
        returns (address owner)
    {
        return super.ownerOf(id);
    }

    /* Metadata service */

    /**
     * @notice Set the metadata service. Only the owner can do this
     */

    function setMetadataService(IMetadataService _newMetadataService)
        public
        onlyOwner
    {
        metadataService = _newMetadataService;
    }

    /**
     * @notice Get the metadata uri
     * @return String uri of the metadata service
     */

    function uri(uint256 tokenId) public view override returns (string memory) {
        return metadataService.uri(tokenId);
    }

    /**
     * @notice Set the address of the upgradeContract of the contract. only admin can do this
     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time
     * to make the contract not upgradable.
     * @param _upgradeAddress address of an upgraded contract
     */

    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)
        public
        onlyOwner
    {
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), false);
            ens.setApprovalForAll(address(upgradeContract), false);
        }

        upgradeContract = _upgradeAddress;

        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), true);
            ens.setApprovalForAll(address(upgradeContract), true);
        }
    }

    /**
     * @notice Checks if msg.sender is the owner or approved by the owner of a name
     * @param node namehash of the name to check
     */

    modifier onlyTokenOwner(bytes32 node) {
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        _;
    }

    /**
     * @notice Checks if owner or approved by owner
     * @param node namehash of the name to check
     * @param addr which address to check permissions for
     * @return whether or not is owner or approved
     */

    function isTokenOwnerOrApproved(bytes32 node, address addr)
        public
        view
        override
        returns (bool)
    {
        address owner = ownerOf(uint256(node));
        return owner == addr || isApprovedForAll(owner, addr);
    }

    /**
     * @notice Gets fuse permissions for a specific name
     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit
     *      The interface has predefined fuses for all registry permissions, but additional
     *      fuses can be added for other use cases
     *      Also returns expiry, which is when the fuses are set to expire.
     * @param node namehash of the name to check
     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp
     * @return expiry Unix time of when the name expires and fuses are to expire
     */
    function getFuses(bytes32 node)
        public
        view
        override
        returns (uint32 fuses, uint64 expiry)
    {
        (, fuses, expiry) = getData(uint256(node));
        if (fuses == 0 && expiry == 0) {
            bytes memory name = names[node];
            if (name.length == 0) {
                revert NameNotFound();
            }
        }
    }

    /**
     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract
     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar
     * @param label label as a string of the .eth domain to wrap
     * @param wrappedOwner Owner of the name in this contract
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @param resolver resolver contract address
     */

    function wrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) public override returns (uint64) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        address registrant = registrar.ownerOf(tokenId);
        if (
            registrant != msg.sender &&
            !isApprovedForAll(registrant, msg.sender) &&
            !registrar.isApprovedForAll(registrant, msg.sender)
        ) {
            revert Unauthorised(
                _makeNode(ETH_NODE, bytes32(tokenId)),
                msg.sender
            );
        }

        // transfer the token from the user to this contract
        registrar.transferFrom(registrant, address(this), tokenId);

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(tokenId, address(this));

        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Registers a new .eth second-level domain and wraps it.
     *      Only callable by authorised controllers.
     * @param label The label to register (Eg, 'foo' for 'foo.eth').
     * @param wrappedOwner The owner of the wrapped name.
     * @param duration The duration, in seconds, to register the name for.
     * @param resolver The resolver address to set on the ENS registry (optional).
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.
     */

    function registerAndWrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint256 duration,
        address resolver,
        uint32 fuses,
        uint64 expiry
    ) external override onlyController returns (uint256 registrarExpiry) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        registrarExpiry = registrar.register(tokenId, address(this), duration);
        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Renews a .eth second-level domain.
     *      Only callable by authorised controllers.
     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').
     * @param duration The number of seconds to renew the name for.
     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.
     */
    function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));

        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));

        _setData(node, owner, fuses, expiry);
    }

    /**
     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the registry or an authorised caller in the registry
     * @param name The name to wrap, in DNS format
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract address
     */

    function wrap(
        bytes calldata name,
        address wrappedOwner,
        address resolver
    ) public override {
        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
        bytes32 parentNode = name.namehash(offset);
        bytes32 node = _makeNode(parentNode, labelhash);

        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }

        address owner = ens.owner(node);

        if (
            owner != msg.sender &&
            !isApprovedForAll(owner, msg.sender) &&
            !ens.isApprovedForAll(owner, msg.sender)
        ) {
            revert Unauthorised(node, msg.sender);
        }

        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        ens.setOwner(node, address(this));

        _wrap(node, name, wrappedOwner, 0, 0);
    }

    /**
     * @notice Unwraps a .eth domain. e.g. vitalik.eth
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param labelhash labelhash of the .eth domain
     * @param newRegistrant sets the owner in the .eth registrar to this address
     * @param newController sets the owner in the registry to this address
     */

    function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }

    /**
     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param newController sets the owner in the registry to this address
     */

    function unwrap(
        bytes32 parentNode,
        bytes32 labelhash,
        address newController
    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        _unwrap(_makeNode(parentNode, labelhash), newController);
    }

    /**
     * @notice Sets fuses of a name
     * @param node namehash of the name
     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)
     */

    function setFuses(bytes32 node, uint32 fuses)
        public
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_BURN_FUSES)
        returns (uint32)
    {
        if (fuses & PARENT_CANNOT_CONTROL != 0) {
            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.
            revert Unauthorised(node, msg.sender);
        }

        (address owner, uint32 oldFuses, uint64 expiry) = getData(
            uint256(node)
        );

        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
        return fuses;
    }

    /**
     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract
     *     and burning the token of this contract
     * @dev Can be called by the owner of the name in this contract
     * @param label Label as a string of the .eth name to upgrade
     * @param wrappedOwner The owner of the wrapped name
     */

    function upgradeETH2LD(
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);

        upgradeContract.wrapETH2LD(
            label,
            wrappedOwner,
            fuses,
            expiry,
            resolver
        );
    }

    /**
     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner or an authorised caller
     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names
     * @param parentNode namehash of the parent name
     * @param label Label as a string of the name to upgrade
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract for this name
     */

    function upgrade(
        bytes32 parentNode,
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.setSubnodeRecord(
            parentNode,
            label,
            wrappedOwner,
            resolver,
            0,
            fuses,
            expiry
        );
    }

    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param fuses fuses to burn
     * @param expiry when the fuses will expire
     */

    function setChildFuses(
        bytes32 parentNode,
        bytes32 labelhash,
        uint32 fuses,
        uint64 expiry
    ) public {
        bytes32 node = _makeNode(parentNode, labelhash);
        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        uint64 maxExpiry;
        if (parentNode == ETH_NODE) {
            if (!isTokenOwnerOrApproved(node, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            // max expiry is set to the expiry on the registrar
            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        } else {
            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }

            // max expiry is set to the expiry of the parent
            (, , maxExpiry) = getData(uint256(parentNode));
        }

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);

        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed
        if (
            oldFuses & PARENT_CANNOT_CONTROL != 0 &&
            oldFuses | fuses != oldFuses
        ) {
            revert OperationProhibited(node);
        }
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
    }

    /**
     * @notice Sets the subdomain owner in the registry and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry when the fuses will expire
     */

    function setSubnodeOwner(
        bytes32 parentNode,
        string calldata label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
        returns (bytes32 node)
    {
        bytes32 labelhash = keccak256(bytes(label));
        node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);

        if (ens.owner(node) != address(this)) {
            ens.setSubnodeOwner(parentNode, labelhash, address(this));
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param resolver resolver contract in the registry
     * @param ttl ttl in the regsitry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry expiry date for the domain
     */

    function setSubnodeRecord(
        bytes32 parentNode,
        string memory label,
        address newOwner,
        address resolver,
        uint64 ttl,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
    {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets records for the name in the ENS Registry
     * @param node namehash of the name to set a record for
     * @param owner newOwner in the registry
     * @param resolver the resolver contract
     * @param ttl ttl in the registry
     */

    function setRecord(
        bytes32 node,
        address owner,
        address resolver,
        uint64 ttl
    )
        public
        override
        onlyTokenOwner(node)
        operationAllowed(
            node,
            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL
        )
    {
        ens.setRecord(node, address(this), resolver, ttl);
        (address oldOwner, , ) = getData(uint256(node));
        _transfer(oldOwner, owner, uint256(node), 1, "");
    }

    /**
     * @notice Sets resolver contract in the registry
     * @param node namehash of the name
     * @param resolver the resolver contract
     */

    function setResolver(bytes32 node, address resolver)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_RESOLVER)
    {
        ens.setResolver(node, resolver);
    }

    /**
     * @notice Sets TTL in the registry
     * @param node namehash of the name
     * @param ttl TTL in the registry
     */

    function setTTL(bytes32 node, uint64 ttl)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_TTL)
    {
        ens.setTTL(node, ttl);
    }

    /**
     * @dev Allows an operation only if none of the specified fuses are burned.
     * @param node The namehash of the name to check fuses on.
     * @param fuseMask A bitmask of fuses that must not be burned.
     */

    modifier operationAllowed(bytes32 node, uint32 fuseMask) {
        (, uint32 fuses, ) = getData(uint256(node));
        if (fuses & fuseMask != 0) {
            revert OperationProhibited(node);
        }
        _;
    }

    /**
     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord
     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt
     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for
     *      replacing a subdomain. If either conditions are true, then it is possible to call
     *      setSubnodeOwner
     * @param node namehash of the name to check
     * @param labelhash labelhash of the name to check
     */

    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {
        bytes32 subnode = _makeNode(node, labelhash);
        address owner = ens.owner(subnode);

        if (owner == address(0)) {
            (, uint32 fuses, ) = getData(uint256(node));
            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {
                revert OperationProhibited(node);
            }
        } else {
            (, uint32 subnodeFuses, ) = getData(uint256(subnode));
            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {
                revert OperationProhibited(node);
            }
        }

        _;
    }

    /**
     * @notice Checks all Fuses in the mask are burned for the node
     * @param node namehash of the name
     * @param fuseMask the fuses you want to check
     * @return Boolean of whether or not all the selected fuses are burned
     */

    function allFusesBurned(bytes32 node, uint32 fuseMask)
        public
        view
        override
        returns (bool)
    {
        (, uint32 fuses, ) = getData(uint256(node));
        return fuses & fuseMask == fuseMask;
    }

    function onERC721Received(
        address to,
        address,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        //check if it's the eth registrar ERC721
        if (msg.sender != address(registrar)) {
            revert IncorrectTokenType();
        }

        (
            string memory label,
            address owner,
            uint32 fuses,
            uint64 expiry,
            address resolver
        ) = abi.decode(data, (string, address, uint32, uint64, address));

        bytes32 labelhash = bytes32(tokenId);
        bytes32 labelhashFromData = keccak256(bytes(label));

        if (labelhashFromData != labelhash) {
            revert LabelMismatch(labelhashFromData, labelhash);
        }

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(uint256(labelhash), address(this));

        _wrapETH2LD(label, owner, fuses, expiry, resolver);

        return IERC721Receiver(to).onERC721Received.selector;
    }

    /***** Internal functions */

    function _canTransfer(uint32 fuses) internal pure override returns (bool) {
        return fuses & CANNOT_TRANSFER == 0;
    }

    function _makeNode(bytes32 node, bytes32 labelhash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, labelhash));
    }

    function _addLabel(string memory label, bytes memory name)
        internal
        pure
        returns (bytes memory ret)
    {
        if (bytes(label).length < 1) {
            revert LabelTooShort();
        }
        if (bytes(label).length > 255) {
            revert LabelTooLong(label);
        }
        return abi.encodePacked(uint8(bytes(label).length), label, name);
    }

    function _mint(
        bytes32 node,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal override {
        address oldWrappedOwner = ownerOf(uint256(node));
        _canFusesBeBurned(node, fuses);
        if (oldWrappedOwner != address(0)) {
            // burn and unwrap old token of old owner
            _burn(uint256(node));
            emit NameUnwrapped(node, address(0));
        }
        super._mint(node, wrappedOwner, fuses, expiry);
    }

    function _wrap(
        bytes32 node,
        bytes memory name,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        names[node] = name;
        _mint(node, wrappedOwner, fuses, expiry);
        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);
    }

    function _addLabelAndWrap(
        bytes32 parentNode,
        bytes32 node,
        string memory label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        bytes memory name = _addLabel(label, names[parentNode]);
        _wrap(node, name, newOwner, fuses, expiry);
    }

    function _prepareUpgrade(bytes32 node)
        private
        returns (uint32 fuses, uint64 expiry)
    {
        if (address(upgradeContract) == address(0)) {
            revert CannotUpgrade();
        }

        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        (fuses, expiry) = getFuses(node);

        // burn token and fuse data
        _burn(uint256(node));
    }

    function _transferAndBurnFuses(
        bytes32 node,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        (address owner, , ) = getData(uint256(node));
        _transfer(owner, newOwner, uint256(node), 1, "");
        _setFuses(node, newOwner, fuses, expiry);
    }

    // wrapper function for stack limit
    function _getDataAndNormaliseExpiry(
        bytes32 parentNode,
        bytes32 node,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        (, , uint64 maxExpiry) = getData(uint256(parentNode));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _getETH2LDDataAndNormaliseExpiry(
        bytes32 node,
        bytes32 labelhash,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _normaliseExpiry(
        uint64 expiry,
        uint64 oldExpiry,
        uint64 maxExpiry
    ) internal pure returns (uint64) {
        // Expiry cannot be more than maximum allowed
        // .eth names will check registrar, non .eth check parent
        if (expiry > maxExpiry) {
            expiry = maxExpiry;
        }
        // Expiry cannot be less than old expiry
        if (expiry < oldExpiry) {
            expiry = oldExpiry;
        }

        return expiry;
    }

    function _wrapETH2LD(
        string memory label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) private returns (uint64) {
        // Mint a new ERC1155 token with fuses
        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);

        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(
            node,
            labelhash,
            expiry
        );

        _addLabelAndWrap(
            ETH_NODE,
            node,
            label,
            wrappedOwner,
            fuses | PARENT_CANNOT_CONTROL,
            expiry
        );
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        return expiry;
    }

    function _unwrap(bytes32 node, address newOwner) private {
        if (newOwner == address(0x0) || newOwner == address(this)) {
            revert IncorrectTargetOwner(newOwner);
        }

        if (allFusesBurned(node, CANNOT_UNWRAP)) {
            revert OperationProhibited(node);
        }

        // Burn token and fuse data
        _burn(uint256(node));
        ens.setOwner(node, newOwner);

        emit NameUnwrapped(node, newOwner);
    }

    function _setFuses(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _setData(node, owner, fuses, expiry);
        emit FusesSet(node, fuses, expiry);
    }

    function _setData(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _canFusesBeBurned(node, fuses);
        super._setData(uint256(node), owner, fuses, expiry);
    }

    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
        if (
            fuses & ~PARENT_CANNOT_CONTROL != 0 &&
            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
        ) {
            revert OperationProhibited(node);
        }
    }
}
.]

### VULNERABILITY: Reentrancy Attack
```
The contract does not implement any reentrancy guards, particularly in functions that involve transferring tokens or calling external contracts (e.g., `wrapETH2LD`, `unwrapETH2LD`, `setSubnodeRecord`). An attacker could exploit this by recursively calling these functions before the state is updated, potentially draining funds or manipulating the contract's state.

**Mitigation:** Implement a reentrancy guard using a mutex pattern or OpenZeppelin's `ReentrancyGuard` to prevent reentrant calls to critical functions.
```

### VULNERABILITY: Improper Access Control
```
Several functions, such as `setUpgradeContract`, `wrapETH2LD`, and `registerAndWrapETH2LD`, rely on the `onlyOwner` or `onlyController` modifiers for access control. However, if the owner or controller's address is compromised, an attacker could gain unauthorized access to these functions.

**Mitigation:** Consider implementing a multi-signature wallet for ownership and control functions to enhance security. Additionally, review the logic to ensure that only authorized addresses can call sensitive functions.
```

### VULNERABILITY: Lack of Input Validation
```
Functions such as `setFuses`, `wrap`, and `setSubnodeOwner` do not validate inputs thoroughly. For example, there is no check to ensure that the `wrappedOwner` address is not zero, which could lead to loss of ownership or funds.

**Mitigation:** Add input validation checks to ensure that addresses are not zero and that other parameters meet expected criteria (e.g., valid fuse values).
```

### VULNERABILITY: Overflow/Underflow Issues
```
Although Solidity 0.8.x has built-in overflow and underflow protection, the contract still uses arithmetic operations that could lead to unexpected results if not handled properly. For example, the `_normaliseExpiry` function could potentially lead to incorrect expiry values if not validated correctly.

**Mitigation:** Ensure that all arithmetic operations are validated and consider using SafeMath for clarity, even though it's not strictly necessary in Solidity 0.8.x.
```

### VULNERABILITY: Inadequate Event Emission
```
Certain critical state changes, such as setting the metadata service or changing the upgrade contract, do not emit events. This lack of transparency can make it difficult to track changes and can hinder debugging efforts.

**Mitigation:** Emit events for all state-changing operations to provide a clear audit trail and improve transparency.
```

### VULNERABILITY: Potential for Denial of Service (DoS)
```
The contract relies on external calls to the `registrar` and `ens` contracts. If these contracts are malicious or malfunctioning, they could cause a denial of service, preventing users from executing critical functions like wrapping or unwrapping domains.

**Mitigation:** Implement checks to ensure that external calls succeed and consider using a fallback mechanism or circuit breaker pattern to handle failures gracefully.
```

### VULNERABILITY: Upgradeability Risks
```
The contract allows for an upgradeable pattern via `INameWrapperUpgrade`. If the upgrade contract is compromised or malicious, it could lead to significant vulnerabilities in the main contract.

**Mitigation:** Ensure that the upgrade contract is thoroughly audited and consider implementing a time-lock mechanism for upgrades to allow users to react to potential issues.
```

### VULNERABILITY: Unchecked External Calls
```
In functions like `onERC721Received`, the contract makes external calls to the `registrar` and `ens` contracts without checking their return values. If these calls fail, the contract may enter an inconsistent state.

**Mitigation:** Always check the return values of external calls and handle failures appropriately to maintain the integrity of the contract's state.
```

### VULNERABILITY: Gas Limit Issues
```
Functions that involve complex operations or loops may run into gas limit issues, especially if they are called in a single transaction. This could lead to failed transactions and a poor user experience.

**Mitigation:** Optimize functions to minimize gas usage and consider breaking complex operations into smaller, more manageable transactions.
```

### VULNERABILITY: Lack of Fallback Function
```
The contract does not implement a fallback function to handle unexpected Ether transfers. This could lead to lost funds if someone sends Ether directly to the contract.

**Mitigation:** Implement a fallback function to reject incoming Ether or handle it appropriately.
```

<INFO> Analysis Complete.

[2024-01-09 20:36:38 INFO] **[Seminar Conclusion]**:

 ### VULNERABILITY: Reentrancy Attack
```
The contract does not implement any reentrancy guards, particularly in functions that involve transferring tokens or calling external contracts (e.g., `wrapETH2LD`, `unwrapETH2LD`, `setSubnodeRecord`). An attacker could exploit this by recursively calling these functions before the state is updated, potentially draining funds or manipulating the contract's state.

**Mitigation:** Implement a reentrancy guard using a mutex pattern or OpenZeppelin's `ReentrancyGuard` to prevent reentrant calls to critical functions.
```

### VULNERABILITY: Improper Access Control
```
Several functions, such as `setUpgradeContract`, `wrapETH2LD`, and `registerAndWrapETH2LD`, rely on the `onlyOwner` or `onlyController` modifiers for access control. However, if the owner or controller's address is compromised, an attacker could gain unauthorized access to these functions.

**Mitigation:** Consider implementing a multi-signature wallet for ownership and control functions to enhance security. Additionally, review the logic to ensure that only authorized addresses can call sensitive functions.
```

### VULNERABILITY: Lack of Input Validation
```
Functions such as `setFuses`, `wrap`, and `setSubnodeOwner` do not validate inputs thoroughly. For example, there is no check to ensure that the `wrappedOwner` address is not zero, which could lead to loss of ownership or funds.

**Mitigation:** Add input validation checks to ensure that addresses are not zero and that other parameters meet expected criteria (e.g., valid fuse values).
```

### VULNERABILITY: Overflow/Underflow Issues
```
Although Solidity 0.8.x has built-in overflow and underflow protection, the contract still uses arithmetic operations that could lead to unexpected results if not handled properly. For example, the `_normaliseExpiry` function could potentially lead to incorrect expiry values if not validated correctly.

**Mitigation:** Ensure that all arithmetic operations are validated and consider using SafeMath for clarity, even though it's not strictly necessary in Solidity 0.8.x.
```

### VULNERABILITY: Inadequate Event Emission
```
Certain critical state changes, such as setting the metadata service or changing the upgrade contract, do not emit events. This lack of transparency can make it difficult to track changes and can hinder debugging efforts.

**Mitigation:** Emit events for all state-changing operations to provide a clear audit trail and improve transparency.
```

### VULNERABILITY: Potential for Denial of Service (DoS)
```
The contract relies on external calls to the `registrar` and `ens` contracts. If these contracts are malicious or malfunctioning, they could cause a denial of service, preventing users from executing critical functions like wrapping or unwrapping domains.

**Mitigation:** Implement checks to ensure that external calls succeed and consider using a fallback mechanism or circuit breaker pattern to handle failures gracefully.
```

### VULNERABILITY: Upgradeability Risks
```
The contract allows for an upgradeable pattern via `INameWrapperUpgrade`. If the upgrade contract is compromised or malicious, it could lead to significant vulnerabilities in the main contract.

**Mitigation:** Ensure that the upgrade contract is thoroughly audited and consider implementing a time-lock mechanism for upgrades to allow users to react to potential issues.
```

### VULNERABILITY: Unchecked External Calls
```
In functions like `onERC721Received`, the contract makes external calls to the `registrar` and `ens` contracts without checking their return values. If these calls fail, the contract may enter an inconsistent state.

**Mitigation:** Always check the return values of external calls and handle failures appropriately to maintain the integrity of the contract's state.
```

### VULNERABILITY: Gas Limit Issues
```
Functions that involve complex operations or loops may run into gas limit issues, especially if they are called in a single transaction. This could lead to failed transactions and a poor user experience.

**Mitigation:** Optimize functions to minimize gas usage and consider breaking complex operations into smaller, more manageable transactions.
```

### VULNERABILITY: Lack of Fallback Function
```
The contract does not implement a fallback function to handle unexpected Ether transfers. This could lead to lost funds if someone sends Ether directly to the contract.

**Mitigation:** Implement a fallback function to reject incoming Ether or handle it appropriately.
```

<INFO> Analysis Complete.

[2024-01-09 20:36:38 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-01-09 20:36:38 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | //SPDX-License-Identifier: MIT pragma solidity ^0.8.4; import "./ERC1155Fuse.sol"; import "./Controllable.sol"; import "./INameWrapper.sol"; import "./INameWrapperUpgrade.sol"; import "./IMetadataService.sol"; import "../registry/ENS.sol"; import "../ethregistrar/IBaseRegistrar.sol"; import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "./BytesUtil.sol"; error Unauthorised(bytes32 node, address addr); error NameNotFound(); error IncompatibleParent(); error IncompatibleName(bytes name); error IncorrectTokenType(); error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash); error LabelTooShort(); error LabelTooLong(string label); error IncorrectTargetOwner(address owner); error CannotUpgrade(); error InvalidExpiry(bytes32 node, uint64 expiry); contract NameWrapper is     Ownable,     ERC1155Fuse,     INameWrapper,     Controllable,     IERC721Receiver {     using BytesUtils for bytes;     ENS public immutable override ens;     IBaseRegistrar public immutable override registrar;     IMetadataService public override metadataService;     mapping(bytes32 =&gt; bytes) public override names; bytes32 private constant ETH_NODE =     0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae; bytes32 private constant ROOT_NODE =     0x0000000000000000000000000000000000000000000000000000000000000000;  //A contract address to a new upgraded contract if any INameWrapperUpgrade public upgradeContract; uint64 private constant MAX_EXPIRY = type(uint64).max;  constructor(     ENS _ens,     IBaseRegistrar _registrar,     IMetadataService _metadataService ) {     ens = _ens;     registrar = _registrar;     metadataService = _metadataService;      /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */      _setData(         uint256(ETH_NODE),         address(0),         uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),         MAX_EXPIRY     );     _setData(         uint256(ROOT_NODE),         address(0),         uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),         MAX_EXPIRY     );     names[ROOT_NODE] = "\x00";     names[ETH_NODE] = "\x03eth\x00"; }  function supportsInterface(bytes4 interfaceId)     public     view     virtual     override(ERC1155Fuse, IERC165)     returns (bool) {     return         interfaceId == type(INameWrapper).interfaceId ||         super.supportsInterface(interfaceId); }  /* ERC1155 */  function ownerOf(uint256 id)     public     view     override(ERC1155Fuse, INameWrapper)     returns (address owner) {     return super.ownerOf(id); }  /* Metadata service */  /**  * @notice Set the metadata service. Only the owner can do this  */  function setMetadataService(IMetadataService _newMetadataService)     public     onlyOwner {     metadataService = _newMetadataService; }  /**  * @notice Get the metadata uri  * @return String uri of the metadata service  */  function uri(uint256 tokenId) public view override returns (string memory) {     return metadataService.uri(tokenId); }  /**  * @notice Set the address of the upgradeContract of the contract. only admin can do this  * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time  * to make the contract not upgradable.  * @param _upgradeAddress address of an upgraded contract  */  function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)     public     onlyOwner {     if (address(upgradeContract) != address(0)) {         registrar.setApprovalForAll(address(upgradeContract), false);         ens.setApprovalForAll(address(upgradeContract), false);     }      upgradeContract = _upgradeAddress;      if (address(upgradeContract) != address(0)) {         registrar.setApprovalForAll(address(upgradeContract), true);         ens.setApprovalForAll(address(upgradeContract), true);     } }  /**  * @notice Checks if msg.sender is the owner or approved by the owner of a name  * @param node namehash of the name to check  */  modifier onlyTokenOwner(bytes32 node) {     if (!isTokenOwnerOrApproved(node, msg.sender)) {         revert Unauthorised(node, msg.sender);     }      _; }  /**  * @notice Checks if owner or approved by owner  * @param node namehash of the name to check  * @param addr which address to check permissions for  * @return whether or not is owner or approved  */  function isTokenOwnerOrApproved(bytes32 node, address addr)     public     view     override     returns (bool) {     address owner = ownerOf(uint256(node));     return owner == addr || isApprovedForAll(owner, addr); }  /**  * @notice Gets fuse permissions for a specific name  * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit  *      The interface has predefined fuses for all registry permissions, but additional  *      fuses can be added for other use cases  *      Also returns expiry, which is when the fuses are set to expire.  * @param node namehash of the name to check  * @return fuses A number that represents the permissions a name has. Returns 0 when expiry &lt; block.timestamp  * @return expiry Unix time of when the name expires and fuses are to expire  */ function getFuses(bytes32 node)     public     view     override     returns (uint32 fuses, uint64 expiry) {     (, fuses, expiry) = getData(uint256(node));     if (fuses == 0 &amp;&amp; expiry == 0) {         bytes memory name = names[node];         if (name.length == 0) {             revert NameNotFound();         }     } }  /**  * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract  * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar  * @param label label as a string of the .eth domain to wrap  * @param wrappedOwner Owner of the name in this contract  * @param fuses initial fuses to set  * @param expiry when the fuses will expire  * @param resolver resolver contract address  */  function wrapETH2LD(     string calldata label,     address wrappedOwner,     uint32 fuses,     uint64 expiry,     address resolver ) public override returns (uint64) {     uint256 tokenId = uint256(keccak256(bytes(label)));     address registrant = registrar.ownerOf(tokenId);     if (         registrant != msg.sender &amp;&amp;         !isApprovedForAll(registrant, msg.sender) &amp;&amp;         !registrar.isApprovedForAll(registrant, msg.sender)     ) {         revert Unauthorised(             _makeNode(ETH_NODE, bytes32(tokenId)),             msg.sender         );     }      // transfer the token from the user to this contract     registrar.transferFrom(registrant, address(this), tokenId);      // transfer the ens record back to the new owner (this contract)     registrar.reclaim(tokenId, address(this));      return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver); }  /**  * @dev Registers a new .eth second-level domain and wraps it.  *      Only callable by authorised controllers.  * @param label The label to register (Eg, 'foo' for 'foo.eth').  * @param wrappedOwner The owner of the wrapped name.  * @param duration The duration, in seconds, to register the name for.  * @param resolver The resolver address to set on the ENS registry (optional).  * @param fuses initial fuses to set  * @param expiry when the fuses will expire  * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.  */  function registerAndWrapETH2LD(     string calldata label,     address wrappedOwner,     uint256 duration,     address resolver,     uint32 fuses,     uint64 expiry ) external override onlyController returns (uint256 registrarExpiry) {     uint256 tokenId = uint256(keccak256(bytes(label)));     registrarExpiry = registrar.register(tokenId, address(this), duration);     _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver); }  /**  * @dev Renews a .eth second-level domain.  *      Only callable by authorised controllers.  * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').  * @param duration The number of seconds to renew the name for.  * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.  */ function renew(     uint256 tokenId,     uint256 duration,     uint64 expiry ) external override onlyController returns (uint256 expires) {     bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));      expires = registrar.renew(tokenId, duration);     (address owner, uint32 fuses, uint64 oldExpiry) = getData(         uint256(node)     );     expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));      _setData(node, owner, fuses, expiry); }  /**  * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner in the registry or an authorised caller in the registry  * @param name The name to wrap, in DNS format  * @param wrappedOwner Owner of the name in this contract  * @param resolver resolver contract address  */  function wrap(     bytes calldata name,     address wrappedOwner,     address resolver ) public override {     (bytes32 labelhash, uint256 offset) = name.readLabel(0);     bytes32 parentNode = name.namehash(offset);     bytes32 node = _makeNode(parentNode, labelhash);      if (parentNode == ETH_NODE) {         revert IncompatibleParent();     }      address owner = ens.owner(node);      if (         owner != msg.sender &amp;&amp;         !isApprovedForAll(owner, msg.sender) &amp;&amp;         !ens.isApprovedForAll(owner, msg.sender)     ) {         revert Unauthorised(node, msg.sender);     }      if (resolver != address(0)) {         ens.setResolver(node, resolver);     }      ens.setOwner(node, address(this));      _wrap(node, name, wrappedOwner, 0, 0); }  /**  * @notice Unwraps a .eth domain. e.g. vitalik.eth  * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper  * @param labelhash labelhash of the .eth domain  * @param newRegistrant sets the owner in the .eth registrar to this address  * @param newController sets the owner in the registry to this address  */  function unwrapETH2LD(     bytes32 labelhash,     address newRegistrant,     address newController ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {     _unwrap(_makeNode(ETH_NODE, labelhash), newController);     registrar.transferFrom(         address(this),         newRegistrant,         uint256(labelhash)     ); }  /**  * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper  * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')  * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')  * @param newController sets the owner in the registry to this address  */  function unwrap(     bytes32 parentNode,     bytes32 labelhash,     address newController ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {     if (parentNode == ETH_NODE) {         revert IncompatibleParent();     }     _unwrap(_makeNode(parentNode, labelhash), newController); }  /**  * @notice Sets fuses of a name  * @param node namehash of the name  * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)  */  function setFuses(bytes32 node, uint32 fuses)     public     onlyTokenOwner(node)     operationAllowed(node, CANNOT_BURN_FUSES)     returns (uint32) {     if (fuses &amp; PARENT_CANNOT_CONTROL != 0) {         // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.         revert Unauthorised(node, msg.sender);     }      (address owner, uint32 oldFuses, uint64 expiry) = getData(         uint256(node)     );      fuses |= oldFuses;     _setFuses(node, owner, fuses, expiry);     return fuses; }  /**  * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract  *     and burning the token of this contract  * @dev Can be called by the owner of the name in this contract  * @param label Label as a string of the .eth name to upgrade  * @param wrappedOwner The owner of the wrapped name  */  function upgradeETH2LD(     string calldata label,     address wrappedOwner,     address resolver ) public {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(ETH_NODE, labelhash);     (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);      upgradeContract.wrapETH2LD(         label,         wrappedOwner,         fuses,         expiry,         resolver     ); }  /**  * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner or an authorised caller  * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names  * @param parentNode namehash of the parent name  * @param label Label as a string of the name to upgrade  * @param wrappedOwner Owner of the name in this contract  * @param resolver resolver contract for this name  */  function upgrade(     bytes32 parentNode,     string calldata label,     address wrappedOwner,     address resolver ) public {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(parentNode, labelhash);     (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);     upgradeContract.setSubnodeRecord(         parentNode,         label,         wrappedOwner,         resolver,         0,         fuses,         expiry     ); }  /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name  * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')  * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')  * @param fuses fuses to burn  * @param expiry when the fuses will expire  */  function setChildFuses(     bytes32 parentNode,     bytes32 labelhash,     uint32 fuses,     uint64 expiry ) public {     bytes32 node = _makeNode(parentNode, labelhash);     (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(         uint256(node)     );     uint64 maxExpiry;     if (parentNode == ETH_NODE) {         if (!isTokenOwnerOrApproved(node, msg.sender)) {             revert Unauthorised(node, msg.sender);         }         // max expiry is set to the expiry on the registrar         maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));     } else {         if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {             revert Unauthorised(node, msg.sender);         }          // max expiry is set to the expiry of the parent         (, , maxExpiry) = getData(uint256(parentNode));     }      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);      // if PARENT_CANNOT_CONTROL has been burned and fuses have changed     if (         oldFuses &amp; PARENT_CANNOT_CONTROL != 0 &amp;&amp;         oldFuses | fuses != oldFuses     ) {         revert OperationProhibited(node);     }     fuses |= oldFuses;     _setFuses(node, owner, fuses, expiry); }  /**  * @notice Sets the subdomain owner in the registry and then wraps the subdomain  * @param parentNode parent namehash of the subdomain  * @param label label of the subdomain as a string  * @param newOwner newOwner in the registry  * @param fuses initial fuses for the wrapped subdomain  * @param expiry when the fuses will expire  */  function setSubnodeOwner(     bytes32 parentNode,     string calldata label,     address newOwner,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))     returns (bytes32 node) {     bytes32 labelhash = keccak256(bytes(label));     node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);      if (ens.owner(node) != address(this)) {         ens.setSubnodeOwner(parentNode, labelhash, address(this));         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } }  /**  * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain  * @param parentNode parent namehash of the subdomain  * @param label label of the subdomain as a string  * @param newOwner newOwner in the registry  * @param resolver resolver contract in the registry  * @param ttl ttl in the regsitry  * @param fuses initial fuses for the wrapped subdomain  * @param expiry expiry date for the domain  */  function setSubnodeRecord(     bytes32 parentNode,     string memory label,     address newOwner,     address resolver,     uint64 ttl,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label))) {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);     if (ens.owner(node) != address(this)) {         ens.setSubnodeRecord(             parentNode,             labelhash,             address(this),             resolver,             ttl         );         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         ens.setSubnodeRecord(             parentNode,             labelhash,             address(this),             resolver,             ttl         );         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } }  /**  * @notice Sets records for the name in the ENS Registry  * @param node namehash of the name to set a record for  * @param owner newOwner in the registry  * @param resolver the resolver contract  * @param ttl ttl in the registry  */  function setRecord(     bytes32 node,     address owner,     address resolver,     uint64 ttl )     public     override     onlyTokenOwner(node)     operationAllowed(         node,         CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL     ) {     ens.setRecord(node, address(this), resolver, ttl);     (address oldOwner, , ) = getData(uint256(node));     _transfer(oldOwner, owner, uint256(node), 1, ""); }  /**  * @notice Sets resolver contract in the registry  * @param node namehash of the name  * @param resolver the resolver contract  */  function setResolver(bytes32 node, address resolver)     public     override     onlyTokenOwner(node)     operationAllowed(node, CANNOT_SET_RESOLVER) {     ens.setResolver(node, resolver); }  /**  * @notice Sets TTL in the registry  * @param node namehash of the name  * @param ttl TTL in the registry  */  function setTTL(bytes32 node, uint64 ttl)     public     override     onlyTokenOwner(node)     operationAllowed(node, CANNOT_SET_TTL) {     ens.setTTL(node, ttl); }  /**  * @dev Allows an operation only if none of the specified fuses are burned.  * @param node The namehash of the name to check fuses on.  * @param fuseMask A bitmask of fuses that must not be burned.  */  modifier operationAllowed(bytes32 node, uint32 fuseMask) {     (, uint32 fuses, ) = getData(uint256(node));     if (fuses &amp; fuseMask != 0) {         revert OperationProhibited(node);     }     _; }  /**  * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord  * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt  *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for  *      replacing a subdomain. If either conditions are true, then it is possible to call  *      setSubnodeOwner  * @param node namehash of the name to check  * @param labelhash labelhash of the name to check  */  modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {     bytes32 subnode = _makeNode(node, labelhash);     address owner = ens.owner(subnode);      if (owner == address(0)) {         (, uint32 fuses, ) = getData(uint256(node));         if (fuses &amp; CANNOT_CREATE_SUBDOMAIN != 0) {             revert OperationProhibited(node);         }     } else {         (, uint32 subnodeFuses, ) = getData(uint256(subnode));         if (subnodeFuses &amp; PARENT_CANNOT_CONTROL != 0) {             revert OperationProhibited(node);         }     }      _; }  /**  * @notice Checks all Fuses in the mask are burned for the node  * @param node namehash of the name  * @param fuseMask the fuses you want to check  * @return Boolean of whether or not all the selected fuses are burned  */  function allFusesBurned(bytes32 node, uint32 fuseMask)     public     view     override     returns (bool) {     (, uint32 fuses, ) = getData(uint256(node));     return fuses &amp; fuseMask == fuseMask; }  function onERC721Received(     address to,     address,     uint256 tokenId,     bytes calldata data ) public override returns (bytes4) {     //check if it's the eth registrar ERC721     if (msg.sender != address(registrar)) {         revert IncorrectTokenType();     }      (         string memory label,         address owner,         uint32 fuses,         uint64 expiry,         address resolver     ) = abi.decode(data, (string, address, uint32, uint64, address));      bytes32 labelhash = bytes32(tokenId);     bytes32 labelhashFromData = keccak256(bytes(label));      if (labelhashFromData != labelhash) {         revert LabelMismatch(labelhashFromData, labelhash);     }      // transfer the ens record back to the new owner (this contract)     registrar.reclaim(uint256(labelhash), address(this));      _wrapETH2LD(label, owner, fuses, expiry, resolver);      return IERC721Receiver(to).onERC721Received.selector; }  /***** Internal functions */  function _canTransfer(uint32 fuses) internal pure override returns (bool) {     return fuses &amp; CANNOT_TRANSFER == 0; }  function _makeNode(bytes32 node, bytes32 labelhash)     private     pure     returns (bytes32) {     return keccak256(abi.encodePacked(node, labelhash)); }  function _addLabel(string memory label, bytes memory name)     internal     pure     returns (bytes memory ret) {     if (bytes(label).length &lt; 1) {         revert LabelTooShort();     }     if (bytes(label).length &gt; 255) {         revert LabelTooLong(label);     }     return abi.encodePacked(uint8(bytes(label).length), label, name); }  function _mint(     bytes32 node,     address wrappedOwner,     uint32 fuses,     uint64 expiry ) internal override {     address oldWrappedOwner = ownerOf(uint256(node));     _canFusesBeBurned(node, fuses);     if (oldWrappedOwner != address(0)) {         // burn and unwrap old token of old owner         _burn(uint256(node));         emit NameUnwrapped(node, address(0));     }     super._mint(node, wrappedOwner, fuses, expiry); }  function _wrap(     bytes32 node,     bytes memory name,     address wrappedOwner,     uint32 fuses,     uint64 expiry ) internal {     names[node] = name;     _mint(node, wrappedOwner, fuses, expiry);     emit NameWrapped(node, name, wrappedOwner, fuses, expiry); }  function _addLabelAndWrap(     bytes32 parentNode,     bytes32 node,     string memory label,     address newOwner,     uint32 fuses,     uint64 expiry ) internal {     bytes memory name = _addLabel(label, names[parentNode]);     _wrap(node, name, newOwner, fuses, expiry); }  function _prepareUpgrade(bytes32 node)     private     returns (uint32 fuses, uint64 expiry) {     if (address(upgradeContract) == address(0)) {         revert CannotUpgrade();     }      if (!isTokenOwnerOrApproved(node, msg.sender)) {         revert Unauthorised(node, msg.sender);     }      (fuses, expiry) = getFuses(node);      // burn token and fuse data     _burn(uint256(node)); }  function _transferAndBurnFuses(     bytes32 node,     address newOwner,     uint32 fuses,     uint64 expiry ) internal {     (address owner, , ) = getData(uint256(node));     _transfer(owner, newOwner, uint256(node), 1, "");     _setFuses(node, newOwner, fuses, expiry); }  // wrapper function for stack limit function _getDataAndNormaliseExpiry(     bytes32 parentNode,     bytes32 node,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     (, , uint64 maxExpiry) = getData(uint256(parentNode));      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); }  function _getETH2LDDataAndNormaliseExpiry(     bytes32 node,     bytes32 labelhash,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); }  function _normaliseExpiry(     uint64 expiry,     uint64 oldExpiry,     uint64 maxExpiry ) internal pure returns (uint64) {     // Expiry cannot be more than maximum allowed     // .eth names will check registrar, non .eth check parent     if (expiry &gt; maxExpiry) {         expiry = maxExpiry;     }     // Expiry cannot be less than old expiry     if (expiry &lt; oldExpiry) {         expiry = oldExpiry;     }      return expiry; }  function _wrapETH2LD(     string memory label,     address wrappedOwner,     uint32 fuses,     uint64 expiry,     address resolver ) private returns (uint64) {     // Mint a new ERC1155 token with fuses     // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(ETH_NODE, labelhash);      (, , expiry) = _getETH2LDDataAndNormaliseExpiry(         node,         labelhash,         expiry     );      _addLabelAndWrap(         ETH_NODE,         node,         label,         wrappedOwner,         fuses | PARENT_CANNOT_CONTROL,         expiry     );     if (resolver != address(0)) {         ens.setResolver(node, resolver);     }      return expiry; }  function _unwrap(bytes32 node, address newOwner) private {     if (newOwner == address(0x0) || newOwner == address(this)) {         revert IncorrectTargetOwner(newOwner);     }      if (allFusesBurned(node, CANNOT_UNWRAP)) {         revert OperationProhibited(node);     }      // Burn token and fuse data     _burn(uint256(node));     ens.setOwner(node, newOwner);      emit NameUnwrapped(node, newOwner); }  function _setFuses(     bytes32 node,     address owner,     uint32 fuses,     uint64 expiry ) internal {     _setData(node, owner, fuses, expiry);     emit FusesSet(node, fuses, expiry); }  function _setData(     bytes32 node,     address owner,     uint32 fuses,     uint64 expiry ) internal {     _canFusesBeBurned(node, fuses);     super._setData(uint256(node), owner, fuses, expiry); }  function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {     if (         fuses &amp; ~PARENT_CANNOT_CONTROL != 0 &amp;&amp;         fuses &amp; (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=         (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)     ) {         revert OperationProhibited(node);     } }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 20:36:38 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | //SPDX-License-Identifier: MIT pragma solidity ^0.8.4; import "./ERC1155Fuse.sol"; import "./Controllable.sol"; import "./INameWrapper.sol"; import "./INameWrapperUpgrade.sol"; import "./IMetadataService.sol"; import "../registry/ENS.sol"; import "../ethregistrar/IBaseRegistrar.sol"; import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "./BytesUtil.sol"; error Unauthorised(bytes32 node, address addr); error NameNotFound(); error IncompatibleParent(); error IncompatibleName(bytes name); error IncorrectTokenType(); error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash); error LabelTooShort(); error LabelTooLong(string label); error IncorrectTargetOwner(address owner); error CannotUpgrade(); error InvalidExpiry(bytes32 node, uint64 expiry); contract NameWrapper is     Ownable,     ERC1155Fuse,     INameWrapper,     Controllable,     IERC721Receiver {     using BytesUtils for bytes;     ENS public immutable override ens;     IBaseRegistrar public immutable override registrar;     IMetadataService public override metadataService;     mapping(bytes32 =&gt; bytes) public override names; bytes32 private constant ETH_NODE =     0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae; bytes32 private constant ROOT_NODE =     0x0000000000000000000000000000000000000000000000000000000000000000;  //A contract address to a new upgraded contract if any INameWrapperUpgrade public upgradeContract; uint64 private constant MAX_EXPIRY = type(uint64).max;  constructor(     ENS _ens,     IBaseRegistrar _registrar,     IMetadataService _metadataService ) {     ens = _ens;     registrar = _registrar;     metadataService = _metadataService;      /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */      _setData(         uint256(ETH_NODE),         address(0),         uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),         MAX_EXPIRY     );     _setData(         uint256(ROOT_NODE),         address(0),         uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),         MAX_EXPIRY     );     names[ROOT_NODE] = "\x00";     names[ETH_NODE] = "\x03eth\x00"; }  function supportsInterface(bytes4 interfaceId)     public     view     virtual     override(ERC1155Fuse, IERC165)     returns (bool) {     return         interfaceId == type(INameWrapper).interfaceId ||         super.supportsInterface(interfaceId); }  /* ERC1155 */  function ownerOf(uint256 id)     public     view     override(ERC1155Fuse, INameWrapper)     returns (address owner) {     return super.ownerOf(id); }  /* Metadata service */  /**  * @notice Set the metadata service. Only the owner can do this  */  function setMetadataService(IMetadataService _newMetadataService)     public     onlyOwner {     metadataService = _newMetadataService; }  /**  * @notice Get the metadata uri  * @return String uri of the metadata service  */  function uri(uint256 tokenId) public view override returns (string memory) {     return metadataService.uri(tokenId); }  /**  * @notice Set the address of the upgradeContract of the contract. only admin can do this  * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time  * to make the contract not upgradable.  * @param _upgradeAddress address of an upgraded contract  */  function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)     public     onlyOwner {     if (address(upgradeContract) != address(0)) {         registrar.setApprovalForAll(address(upgradeContract), false);         ens.setApprovalForAll(address(upgradeContract), false);     }      upgradeContract = _upgradeAddress;      if (address(upgradeContract) != address(0)) {         registrar.setApprovalForAll(address(upgradeContract), true);         ens.setApprovalForAll(address(upgradeContract), true);     } }  /**  * @notice Checks if msg.sender is the owner or approved by the owner of a name  * @param node namehash of the name to check  */  modifier onlyTokenOwner(bytes32 node) {     if (!isTokenOwnerOrApproved(node, msg.sender)) {         revert Unauthorised(node, msg.sender);     }      _; }  /**  * @notice Checks if owner or approved by owner  * @param node namehash of the name to check  * @param addr which address to check permissions for  * @return whether or not is owner or approved  */  function isTokenOwnerOrApproved(bytes32 node, address addr)     public     view     override     returns (bool) {     address owner = ownerOf(uint256(node));     return owner == addr || isApprovedForAll(owner, addr); }  /**  * @notice Gets fuse permissions for a specific name  * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit  *      The interface has predefined fuses for all registry permissions, but additional  *      fuses can be added for other use cases  *      Also returns expiry, which is when the fuses are set to expire.  * @param node namehash of the name to check  * @return fuses A number that represents the permissions a name has. Returns 0 when expiry &lt; block.timestamp  * @return expiry Unix time of when the name expires and fuses are to expire  */ function getFuses(bytes32 node)     public     view     override     returns (uint32 fuses, uint64 expiry) {     (, fuses, expiry) = getData(uint256(node));     if (fuses == 0 &amp;&amp; expiry == 0) {         bytes memory name = names[node];         if (name.length == 0) {             revert NameNotFound();         }     } }  /**  * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract  * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar  * @param label label as a string of the .eth domain to wrap  * @param wrappedOwner Owner of the name in this contract  * @param fuses initial fuses to set  * @param expiry when the fuses will expire  * @param resolver resolver contract address  */  function wrapETH2LD(     string calldata label,     address wrappedOwner,     uint32 fuses,     uint64 expiry,     address resolver ) public override returns (uint64) {     uint256 tokenId = uint256(keccak256(bytes(label)));     address registrant = registrar.ownerOf(tokenId);     if (         registrant != msg.sender &amp;&amp;         !isApprovedForAll(registrant, msg.sender) &amp;&amp;         !registrar.isApprovedForAll(registrant, msg.sender)     ) {         revert Unauthorised(             _makeNode(ETH_NODE, bytes32(tokenId)),             msg.sender         );     }      // transfer the token from the user to this contract     registrar.transferFrom(registrant, address(this), tokenId);      // transfer the ens record back to the new owner (this contract)     registrar.reclaim(tokenId, address(this));      return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver); }  /**  * @dev Registers a new .eth second-level domain and wraps it.  *      Only callable by authorised controllers.  * @param label The label to register (Eg, 'foo' for 'foo.eth').  * @param wrappedOwner The owner of the wrapped name.  * @param duration The duration, in seconds, to register the name for.  * @param resolver The resolver address to set on the ENS registry (optional).  * @param fuses initial fuses to set  * @param expiry when the fuses will expire  * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.  */  function registerAndWrapETH2LD(     string calldata label,     address wrappedOwner,     uint256 duration,     address resolver,     uint32 fuses,     uint64 expiry ) external override onlyController returns (uint256 registrarExpiry) {     uint256 tokenId = uint256(keccak256(bytes(label)));     registrarExpiry = registrar.register(tokenId, address(this), duration);     _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver); }  /**  * @dev Renews a .eth second-level domain.  *      Only callable by authorised controllers.  * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').  * @param duration The number of seconds to renew the name for.  * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.  */ function renew(     uint256 tokenId,     uint256 duration,     uint64 expiry ) external override onlyController returns (uint256 expires) {     bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));      expires = registrar.renew(tokenId, duration);     (address owner, uint32 fuses, uint64 oldExpiry) = getData(         uint256(node)     );     expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));      _setData(node, owner, fuses, expiry); }  /**  * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner in the registry or an authorised caller in the registry  * @param name The name to wrap, in DNS format  * @param wrappedOwner Owner of the name in this contract  * @param resolver resolver contract address  */  function wrap(     bytes calldata name,     address wrappedOwner,     address resolver ) public override {     (bytes32 labelhash, uint256 offset) = name.readLabel(0);     bytes32 parentNode = name.namehash(offset);     bytes32 node = _makeNode(parentNode, labelhash);      if (parentNode == ETH_NODE) {         revert IncompatibleParent();     }      address owner = ens.owner(node);      if (         owner != msg.sender &amp;&amp;         !isApprovedForAll(owner, msg.sender) &amp;&amp;         !ens.isApprovedForAll(owner, msg.sender)     ) {         revert Unauthorised(node, msg.sender);     }      if (resolver != address(0)) {         ens.setResolver(node, resolver);     }      ens.setOwner(node, address(this));      _wrap(node, name, wrappedOwner, 0, 0); }  /**  * @notice Unwraps a .eth domain. e.g. vitalik.eth  * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper  * @param labelhash labelhash of the .eth domain  * @param newRegistrant sets the owner in the .eth registrar to this address  * @param newController sets the owner in the registry to this address  */  function unwrapETH2LD(     bytes32 labelhash,     address newRegistrant,     address newController ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {     _unwrap(_makeNode(ETH_NODE, labelhash), newController);     registrar.transferFrom(         address(this),         newRegistrant,         uint256(labelhash)     ); }  /**  * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper  * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')  * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')  * @param newController sets the owner in the registry to this address  */  function unwrap(     bytes32 parentNode,     bytes32 labelhash,     address newController ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {     if (parentNode == ETH_NODE) {         revert IncompatibleParent();     }     _unwrap(_makeNode(parentNode, labelhash), newController); }  /**  * @notice Sets fuses of a name  * @param node namehash of the name  * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)  */  function setFuses(bytes32 node, uint32 fuses)     public     onlyTokenOwner(node)     operationAllowed(node, CANNOT_BURN_FUSES)     returns (uint32) {     if (fuses &amp; PARENT_CANNOT_CONTROL != 0) {         // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.         revert Unauthorised(node, msg.sender);     }      (address owner, uint32 oldFuses, uint64 expiry) = getData(         uint256(node)     );      fuses |= oldFuses;     _setFuses(node, owner, fuses, expiry);     return fuses; }  /**  * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract  *     and burning the token of this contract  * @dev Can be called by the owner of the name in this contract  * @param label Label as a string of the .eth name to upgrade  * @param wrappedOwner The owner of the wrapped name  */  function upgradeETH2LD(     string calldata label,     address wrappedOwner,     address resolver ) public {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(ETH_NODE, labelhash);     (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);      upgradeContract.wrapETH2LD(         label,         wrappedOwner,         fuses,         expiry,         resolver     ); }  /**  * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner or an authorised caller  * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names  * @param parentNode namehash of the parent name  * @param label Label as a string of the name to upgrade  * @param wrappedOwner Owner of the name in this contract  * @param resolver resolver contract for this name  */  function upgrade(     bytes32 parentNode,     string calldata label,     address wrappedOwner,     address resolver ) public {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(parentNode, labelhash);     (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);     upgradeContract.setSubnodeRecord(         parentNode,         label,         wrappedOwner,         resolver,         0,         fuses,         expiry     ); }  /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name  * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')  * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')  * @param fuses fuses to burn  * @param expiry when the fuses will expire  */  function setChildFuses(     bytes32 parentNode,     bytes32 labelhash,     uint32 fuses,     uint64 expiry ) public {     bytes32 node = _makeNode(parentNode, labelhash);     (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(         uint256(node)     );     uint64 maxExpiry;     if (parentNode == ETH_NODE) {         if (!isTokenOwnerOrApproved(node, msg.sender)) {             revert Unauthorised(node, msg.sender);         }         // max expiry is set to the expiry on the registrar         maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));     } else {         if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {             revert Unauthorised(node, msg.sender);         }          // max expiry is set to the expiry of the parent         (, , maxExpiry) = getData(uint256(parentNode));     }      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);      // if PARENT_CANNOT_CONTROL has been burned and fuses have changed     if (         oldFuses &amp; PARENT_CANNOT_CONTROL != 0 &amp;&amp;         oldFuses | fuses != oldFuses     ) {         revert OperationProhibited(node);     }     fuses |= oldFuses;     _setFuses(node, owner, fuses, expiry); }  /**  * @notice Sets the subdomain owner in the registry and then wraps the subdomain  * @param parentNode parent namehash of the subdomain  * @param label label of the subdomain as a string  * @param newOwner newOwner in the registry  * @param fuses initial fuses for the wrapped subdomain  * @param expiry when the fuses will expire  */  function setSubnodeOwner(     bytes32 parentNode,     string calldata label,     address newOwner,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))     returns (bytes32 node) {     bytes32 labelhash = keccak256(bytes(label));     node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);      if (ens.owner(node) != address(this)) {         ens.setSubnodeOwner(parentNode, labelhash, address(this));         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } }  /**  * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain  * @param parentNode parent namehash of the subdomain  * @param label label of the subdomain as a string  * @param newOwner newOwner in the registry  * @param resolver resolver contract in the registry  * @param ttl ttl in the regsitry  * @param fuses initial fuses for the wrapped subdomain  * @param expiry expiry date for the domain  */  function setSubnodeRecord(     bytes32 parentNode,     string memory label,     address newOwner,     address resolver,     uint64 ttl,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label))) {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);     if (ens.owner(node) != address(this)) {         ens.setSubnodeRecord(             parentNode,             labelhash,             address(this),             resolver,             ttl         );         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         ens.setSubnodeRecord(             parentNode,             labelhash,             address(this),             resolver,             ttl         );         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } }  /**  * @notice Sets records for the name in the ENS Registry  * @param node namehash of the name to set a record for  * @param owner newOwner in the registry  * @param resolver the resolver contract  * @param ttl ttl in the registry  */  function setRecord(     bytes32 node,     address owner,     address resolver,     uint64 ttl )     public     override     onlyTokenOwner(node)     operationAllowed(         node,         CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL     ) {     ens.setRecord(node, address(this), resolver, ttl);     (address oldOwner, , ) = getData(uint256(node));     _transfer(oldOwner, owner, uint256(node), 1, ""); }  /**  * @notice Sets resolver contract in the registry  * @param node namehash of the name  * @param resolver the resolver contract  */  function setResolver(bytes32 node, address resolver)     public     override     onlyTokenOwner(node)     operationAllowed(node, CANNOT_SET_RESOLVER) {     ens.setResolver(node, resolver); }  /**  * @notice Sets TTL in the registry  * @param node namehash of the name  * @param ttl TTL in the registry  */  function setTTL(bytes32 node, uint64 ttl)     public     override     onlyTokenOwner(node)     operationAllowed(node, CANNOT_SET_TTL) {     ens.setTTL(node, ttl); }  /**  * @dev Allows an operation only if none of the specified fuses are burned.  * @param node The namehash of the name to check fuses on.  * @param fuseMask A bitmask of fuses that must not be burned.  */  modifier operationAllowed(bytes32 node, uint32 fuseMask) {     (, uint32 fuses, ) = getData(uint256(node));     if (fuses &amp; fuseMask != 0) {         revert OperationProhibited(node);     }     _; }  /**  * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord  * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt  *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for  *      replacing a subdomain. If either conditions are true, then it is possible to call  *      setSubnodeOwner  * @param node namehash of the name to check  * @param labelhash labelhash of the name to check  */  modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {     bytes32 subnode = _makeNode(node, labelhash);     address owner = ens.owner(subnode);      if (owner == address(0)) {         (, uint32 fuses, ) = getData(uint256(node));         if (fuses &amp; CANNOT_CREATE_SUBDOMAIN != 0) {             revert OperationProhibited(node);         }     } else {         (, uint32 subnodeFuses, ) = getData(uint256(subnode));         if (subnodeFuses &amp; PARENT_CANNOT_CONTROL != 0) {             revert OperationProhibited(node);         }     }      _; }  /**  * @notice Checks all Fuses in the mask are burned for the node  * @param node namehash of the name  * @param fuseMask the fuses you want to check  * @return Boolean of whether or not all the selected fuses are burned  */  function allFusesBurned(bytes32 node, uint32 fuseMask)     public     view     override     returns (bool) {     (, uint32 fuses, ) = getData(uint256(node));     return fuses &amp; fuseMask == fuseMask; }  function onERC721Received(     address to,     address,     uint256 tokenId,     bytes calldata data ) public override returns (bytes4) {     //check if it's the eth registrar ERC721     if (msg.sender != address(registrar)) {         revert IncorrectTokenType();     }      (         string memory label,         address owner,         uint32 fuses,         uint64 expiry,         address resolver     ) = abi.decode(data, (string, address, uint32, uint64, address));      bytes32 labelhash = bytes32(tokenId);     bytes32 labelhashFromData = keccak256(bytes(label));      if (labelhashFromData != labelhash) {         revert LabelMismatch(labelhashFromData, labelhash);     }      // transfer the ens record back to the new owner (this contract)     registrar.reclaim(uint256(labelhash), address(this));      _wrapETH2LD(label, owner, fuses, expiry, resolver);      return IERC721Receiver(to).onERC721Received.selector; }  /***** Internal functions */  function _canTransfer(uint32 fuses) internal pure override returns (bool) {     return fuses &amp; CANNOT_TRANSFER == 0; }  function _makeNode(bytes32 node, bytes32 labelhash)     private     pure     returns (bytes32) {     return keccak256(abi.encodePacked(node, labelhash)); }  function _addLabel(string memory label, bytes memory name)     internal     pure     returns (bytes memory ret) {     if (bytes(label).length &lt; 1) {         revert LabelTooShort();     }     if (bytes(label).length &gt; 255) {         revert LabelTooLong(label);     }     return abi.encodePacked(uint8(bytes(label).length), label, name); }  function _mint(     bytes32 node,     address wrappedOwner,     uint32 fuses,     uint64 expiry ) internal override {     address oldWrappedOwner = ownerOf(uint256(node));     _canFusesBeBurned(node, fuses);     if (oldWrappedOwner != address(0)) {         // burn and unwrap old token of old owner         _burn(uint256(node));         emit NameUnwrapped(node, address(0));     }     super._mint(node, wrappedOwner, fuses, expiry); }  function _wrap(     bytes32 node,     bytes memory name,     address wrappedOwner,     uint32 fuses,     uint64 expiry ) internal {     names[node] = name;     _mint(node, wrappedOwner, fuses, expiry);     emit NameWrapped(node, name, wrappedOwner, fuses, expiry); }  function _addLabelAndWrap(     bytes32 parentNode,     bytes32 node,     string memory label,     address newOwner,     uint32 fuses,     uint64 expiry ) internal {     bytes memory name = _addLabel(label, names[parentNode]);     _wrap(node, name, newOwner, fuses, expiry); }  function _prepareUpgrade(bytes32 node)     private     returns (uint32 fuses, uint64 expiry) {     if (address(upgradeContract) == address(0)) {         revert CannotUpgrade();     }      if (!isTokenOwnerOrApproved(node, msg.sender)) {         revert Unauthorised(node, msg.sender);     }      (fuses, expiry) = getFuses(node);      // burn token and fuse data     _burn(uint256(node)); }  function _transferAndBurnFuses(     bytes32 node,     address newOwner,     uint32 fuses,     uint64 expiry ) internal {     (address owner, , ) = getData(uint256(node));     _transfer(owner, newOwner, uint256(node), 1, "");     _setFuses(node, newOwner, fuses, expiry); }  // wrapper function for stack limit function _getDataAndNormaliseExpiry(     bytes32 parentNode,     bytes32 node,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     (, , uint64 maxExpiry) = getData(uint256(parentNode));      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); }  function _getETH2LDDataAndNormaliseExpiry(     bytes32 node,     bytes32 labelhash,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); }  function _normaliseExpiry(     uint64 expiry,     uint64 oldExpiry,     uint64 maxExpiry ) internal pure returns (uint64) {     // Expiry cannot be more than maximum allowed     // .eth names will check registrar, non .eth check parent     if (expiry &gt; maxExpiry) {         expiry = maxExpiry;     }     // Expiry cannot be less than old expiry     if (expiry &lt; oldExpiry) {         expiry = oldExpiry;     }      return expiry; }  function _wrapETH2LD(     string memory label,     address wrappedOwner,     uint32 fuses,     uint64 expiry,     address resolver ) private returns (uint64) {     // Mint a new ERC1155 token with fuses     // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(ETH_NODE, labelhash);      (, , expiry) = _getETH2LDDataAndNormaliseExpiry(         node,         labelhash,         expiry     );      _addLabelAndWrap(         ETH_NODE,         node,         label,         wrappedOwner,         fuses | PARENT_CANNOT_CONTROL,         expiry     );     if (resolver != address(0)) {         ens.setResolver(node, resolver);     }      return expiry; }  function _unwrap(bytes32 node, address newOwner) private {     if (newOwner == address(0x0) || newOwner == address(this)) {         revert IncorrectTargetOwner(newOwner);     }      if (allFusesBurned(node, CANNOT_UNWRAP)) {         revert OperationProhibited(node);     }      // Burn token and fuse data     _burn(uint256(node));     ens.setOwner(node, newOwner);      emit NameUnwrapped(node, newOwner); }  function _setFuses(     bytes32 node,     address owner,     uint32 fuses,     uint64 expiry ) internal {     _setData(node, owner, fuses, expiry);     emit FusesSet(node, fuses, expiry); }  function _setData(     bytes32 node,     address owner,     uint32 fuses,     uint64 expiry ) internal {     _canFusesBeBurned(node, fuses);     super._setData(uint256(node), owner, fuses, expiry); }  function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {     if (         fuses &amp; ~PARENT_CANNOT_CONTROL != 0 &amp;&amp;         fuses &amp; (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=         (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)     ) {         revert OperationProhibited(node);     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 20:36:38 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: //SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "./ERC1155Fuse.sol";
import "./Controllable.sol";
import "./INameWrapper.sol";
import "./INameWrapperUpgrade.sol";
import "./IMetadataService.sol";
import "../registry/ENS.sol";
import "../ethregistrar/IBaseRegistrar.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./BytesUtil.sol";

error Unauthorised(bytes32 node, address addr);
error NameNotFound();
error IncompatibleParent();
error IncompatibleName(bytes name);
error IncorrectTokenType();
error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);
error LabelTooShort();
error LabelTooLong(string label);
error IncorrectTargetOwner(address owner);
error CannotUpgrade();
error InvalidExpiry(bytes32 node, uint64 expiry);

contract NameWrapper is
    Ownable,
    ERC1155Fuse,
    INameWrapper,
    Controllable,
    IERC721Receiver
{
    using BytesUtils for bytes;
    ENS public immutable override ens;
    IBaseRegistrar public immutable override registrar;
    IMetadataService public override metadataService;
    mapping(bytes32 => bytes) public override names;

    bytes32 private constant ETH_NODE =
        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
    bytes32 private constant ROOT_NODE =
        0x0000000000000000000000000000000000000000000000000000000000000000;

    //A contract address to a new upgraded contract if any
    INameWrapperUpgrade public upgradeContract;
    uint64 private constant MAX_EXPIRY = type(uint64).max;

    constructor(
        ENS _ens,
        IBaseRegistrar _registrar,
        IMetadataService _metadataService
    ) {
        ens = _ens;
        registrar = _registrar;
        metadataService = _metadataService;

        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */

        _setData(
            uint256(ETH_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        _setData(
            uint256(ROOT_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        names[ROOT_NODE] = "\x00";
        names[ETH_NODE] = "\x03eth\x00";
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Fuse, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(INameWrapper).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /* ERC1155 */

    function ownerOf(uint256 id)
        public
        view
        override(ERC1155Fuse, INameWrapper)
        returns (address owner)
    {
        return super.ownerOf(id);
    }

    /* Metadata service */

    /**
     * @notice Set the metadata service. Only the owner can do this
     */

    function setMetadataService(IMetadataService _newMetadataService)
        public
        onlyOwner
    {
        metadataService = _newMetadataService;
    }

    /**
     * @notice Get the metadata uri
     * @return String uri of the metadata service
     */

    function uri(uint256 tokenId) public view override returns (string memory) {
        return metadataService.uri(tokenId);
    }

    /**
     * @notice Set the address of the upgradeContract of the contract. only admin can do this
     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time
     * to make the contract not upgradable.
     * @param _upgradeAddress address of an upgraded contract
     */

    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)
        public
        onlyOwner
    {
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), false);
            ens.setApprovalForAll(address(upgradeContract), false);
        }

        upgradeContract = _upgradeAddress;

        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), true);
            ens.setApprovalForAll(address(upgradeContract), true);
        }
    }

    /**
     * @notice Checks if msg.sender is the owner or approved by the owner of a name
     * @param node namehash of the name to check
     */

    modifier onlyTokenOwner(bytes32 node) {
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        _;
    }

    /**
     * @notice Checks if owner or approved by owner
     * @param node namehash of the name to check
     * @param addr which address to check permissions for
     * @return whether or not is owner or approved
     */

    function isTokenOwnerOrApproved(bytes32 node, address addr)
        public
        view
        override
        returns (bool)
    {
        address owner = ownerOf(uint256(node));
        return owner == addr || isApprovedForAll(owner, addr);
    }

    /**
     * @notice Gets fuse permissions for a specific name
     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit
     *      The interface has predefined fuses for all registry permissions, but additional
     *      fuses can be added for other use cases
     *      Also returns expiry, which is when the fuses are set to expire.
     * @param node namehash of the name to check
     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp
     * @return expiry Unix time of when the name expires and fuses are to expire
     */
    function getFuses(bytes32 node)
        public
        view
        override
        returns (uint32 fuses, uint64 expiry)
    {
        (, fuses, expiry) = getData(uint256(node));
        if (fuses == 0 && expiry == 0) {
            bytes memory name = names[node];
            if (name.length == 0) {
                revert NameNotFound();
            }
        }
    }

    /**
     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract
     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar
     * @param label label as a string of the .eth domain to wrap
     * @param wrappedOwner Owner of the name in this contract
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @param resolver resolver contract address
     */

    function wrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) public override returns (uint64) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        address registrant = registrar.ownerOf(tokenId);
        if (
            registrant != msg.sender &&
            !isApprovedForAll(registrant, msg.sender) &&
            !registrar.isApprovedForAll(registrant, msg.sender)
        ) {
            revert Unauthorised(
                _makeNode(ETH_NODE, bytes32(tokenId)),
                msg.sender
            );
        }

        // transfer the token from the user to this contract
        registrar.transferFrom(registrant, address(this), tokenId);

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(tokenId, address(this));

        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Registers a new .eth second-level domain and wraps it.
     *      Only callable by authorised controllers.
     * @param label The label to register (Eg, 'foo' for 'foo.eth').
     * @param wrappedOwner The owner of the wrapped name.
     * @param duration The duration, in seconds, to register the name for.
     * @param resolver The resolver address to set on the ENS registry (optional).
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.
     */

    function registerAndWrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint256 duration,
        address resolver,
        uint32 fuses,
        uint64 expiry
    ) external override onlyController returns (uint256 registrarExpiry) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        registrarExpiry = registrar.register(tokenId, address(this), duration);
        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Renews a .eth second-level domain.
     *      Only callable by authorised controllers.
     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').
     * @param duration The number of seconds to renew the name for.
     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.
     */
    function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));

        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));

        _setData(node, owner, fuses, expiry);
    }

    /**
     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the registry or an authorised caller in the registry
     * @param name The name to wrap, in DNS format
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract address
     */

    function wrap(
        bytes calldata name,
        address wrappedOwner,
        address resolver
    ) public override {
        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
        bytes32 parentNode = name.namehash(offset);
        bytes32 node = _makeNode(parentNode, labelhash);

        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }

        address owner = ens.owner(node);

        if (
            owner != msg.sender &&
            !isApprovedForAll(owner, msg.sender) &&
            !ens.isApprovedForAll(owner, msg.sender)
        ) {
            revert Unauthorised(node, msg.sender);
        }

        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        ens.setOwner(node, address(this));

        _wrap(node, name, wrappedOwner, 0, 0);
    }

    /**
     * @notice Unwraps a .eth domain. e.g. vitalik.eth
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param labelhash labelhash of the .eth domain
     * @param newRegistrant sets the owner in the .eth registrar to this address
     * @param newController sets the owner in the registry to this address
     */

    function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }

    /**
     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param newController sets the owner in the registry to this address
     */

    function unwrap(
        bytes32 parentNode,
        bytes32 labelhash,
        address newController
    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        _unwrap(_makeNode(parentNode, labelhash), newController);
    }

    /**
     * @notice Sets fuses of a name
     * @param node namehash of the name
     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)
     */

    function setFuses(bytes32 node, uint32 fuses)
        public
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_BURN_FUSES)
        returns (uint32)
    {
        if (fuses & PARENT_CANNOT_CONTROL != 0) {
            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.
            revert Unauthorised(node, msg.sender);
        }

        (address owner, uint32 oldFuses, uint64 expiry) = getData(
            uint256(node)
        );

        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
        return fuses;
    }

    /**
     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract
     *     and burning the token of this contract
     * @dev Can be called by the owner of the name in this contract
     * @param label Label as a string of the .eth name to upgrade
     * @param wrappedOwner The owner of the wrapped name
     */

    function upgradeETH2LD(
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);

        upgradeContract.wrapETH2LD(
            label,
            wrappedOwner,
            fuses,
            expiry,
            resolver
        );
    }

    /**
     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner or an authorised caller
     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names
     * @param parentNode namehash of the parent name
     * @param label Label as a string of the name to upgrade
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract for this name
     */

    function upgrade(
        bytes32 parentNode,
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.setSubnodeRecord(
            parentNode,
            label,
            wrappedOwner,
            resolver,
            0,
            fuses,
            expiry
        );
    }

    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param fuses fuses to burn
     * @param expiry when the fuses will expire
     */

    function setChildFuses(
        bytes32 parentNode,
        bytes32 labelhash,
        uint32 fuses,
        uint64 expiry
    ) public {
        bytes32 node = _makeNode(parentNode, labelhash);
        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        uint64 maxExpiry;
        if (parentNode == ETH_NODE) {
            if (!isTokenOwnerOrApproved(node, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            // max expiry is set to the expiry on the registrar
            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        } else {
            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }

            // max expiry is set to the expiry of the parent
            (, , maxExpiry) = getData(uint256(parentNode));
        }

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);

        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed
        if (
            oldFuses & PARENT_CANNOT_CONTROL != 0 &&
            oldFuses | fuses != oldFuses
        ) {
            revert OperationProhibited(node);
        }
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
    }

    /**
     * @notice Sets the subdomain owner in the registry and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry when the fuses will expire
     */

    function setSubnodeOwner(
        bytes32 parentNode,
        string calldata label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
        returns (bytes32 node)
    {
        bytes32 labelhash = keccak256(bytes(label));
        node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);

        if (ens.owner(node) != address(this)) {
            ens.setSubnodeOwner(parentNode, labelhash, address(this));
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param resolver resolver contract in the registry
     * @param ttl ttl in the regsitry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry expiry date for the domain
     */

    function setSubnodeRecord(
        bytes32 parentNode,
        string memory label,
        address newOwner,
        address resolver,
        uint64 ttl,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
    {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets records for the name in the ENS Registry
     * @param node namehash of the name to set a record for
     * @param owner newOwner in the registry
     * @param resolver the resolver contract
     * @param ttl ttl in the registry
     */

    function setRecord(
        bytes32 node,
        address owner,
        address resolver,
        uint64 ttl
    )
        public
        override
        onlyTokenOwner(node)
        operationAllowed(
            node,
            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL
        )
    {
        ens.setRecord(node, address(this), resolver, ttl);
        (address oldOwner, , ) = getData(uint256(node));
        _transfer(oldOwner, owner, uint256(node), 1, "");
    }

    /**
     * @notice Sets resolver contract in the registry
     * @param node namehash of the name
     * @param resolver the resolver contract
     */

    function setResolver(bytes32 node, address resolver)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_RESOLVER)
    {
        ens.setResolver(node, resolver);
    }

    /**
     * @notice Sets TTL in the registry
     * @param node namehash of the name
     * @param ttl TTL in the registry
     */

    function setTTL(bytes32 node, uint64 ttl)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_TTL)
    {
        ens.setTTL(node, ttl);
    }

    /**
     * @dev Allows an operation only if none of the specified fuses are burned.
     * @param node The namehash of the name to check fuses on.
     * @param fuseMask A bitmask of fuses that must not be burned.
     */

    modifier operationAllowed(bytes32 node, uint32 fuseMask) {
        (, uint32 fuses, ) = getData(uint256(node));
        if (fuses & fuseMask != 0) {
            revert OperationProhibited(node);
        }
        _;
    }

    /**
     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord
     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt
     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for
     *      replacing a subdomain. If either conditions are true, then it is possible to call
     *      setSubnodeOwner
     * @param node namehash of the name to check
     * @param labelhash labelhash of the name to check
     */

    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {
        bytes32 subnode = _makeNode(node, labelhash);
        address owner = ens.owner(subnode);

        if (owner == address(0)) {
            (, uint32 fuses, ) = getData(uint256(node));
            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {
                revert OperationProhibited(node);
            }
        } else {
            (, uint32 subnodeFuses, ) = getData(uint256(subnode));
            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {
                revert OperationProhibited(node);
            }
        }

        _;
    }

    /**
     * @notice Checks all Fuses in the mask are burned for the node
     * @param node namehash of the name
     * @param fuseMask the fuses you want to check
     * @return Boolean of whether or not all the selected fuses are burned
     */

    function allFusesBurned(bytes32 node, uint32 fuseMask)
        public
        view
        override
        returns (bool)
    {
        (, uint32 fuses, ) = getData(uint256(node));
        return fuses & fuseMask == fuseMask;
    }

    function onERC721Received(
        address to,
        address,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        //check if it's the eth registrar ERC721
        if (msg.sender != address(registrar)) {
            revert IncorrectTokenType();
        }

        (
            string memory label,
            address owner,
            uint32 fuses,
            uint64 expiry,
            address resolver
        ) = abi.decode(data, (string, address, uint32, uint64, address));

        bytes32 labelhash = bytes32(tokenId);
        bytes32 labelhashFromData = keccak256(bytes(label));

        if (labelhashFromData != labelhash) {
            revert LabelMismatch(labelhashFromData, labelhash);
        }

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(uint256(labelhash), address(this));

        _wrapETH2LD(label, owner, fuses, expiry, resolver);

        return IERC721Receiver(to).onERC721Received.selector;
    }

    /***** Internal functions */

    function _canTransfer(uint32 fuses) internal pure override returns (bool) {
        return fuses & CANNOT_TRANSFER == 0;
    }

    function _makeNode(bytes32 node, bytes32 labelhash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, labelhash));
    }

    function _addLabel(string memory label, bytes memory name)
        internal
        pure
        returns (bytes memory ret)
    {
        if (bytes(label).length < 1) {
            revert LabelTooShort();
        }
        if (bytes(label).length > 255) {
            revert LabelTooLong(label);
        }
        return abi.encodePacked(uint8(bytes(label).length), label, name);
    }

    function _mint(
        bytes32 node,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal override {
        address oldWrappedOwner = ownerOf(uint256(node));
        _canFusesBeBurned(node, fuses);
        if (oldWrappedOwner != address(0)) {
            // burn and unwrap old token of old owner
            _burn(uint256(node));
            emit NameUnwrapped(node, address(0));
        }
        super._mint(node, wrappedOwner, fuses, expiry);
    }

    function _wrap(
        bytes32 node,
        bytes memory name,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        names[node] = name;
        _mint(node, wrappedOwner, fuses, expiry);
        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);
    }

    function _addLabelAndWrap(
        bytes32 parentNode,
        bytes32 node,
        string memory label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        bytes memory name = _addLabel(label, names[parentNode]);
        _wrap(node, name, newOwner, fuses, expiry);
    }

    function _prepareUpgrade(bytes32 node)
        private
        returns (uint32 fuses, uint64 expiry)
    {
        if (address(upgradeContract) == address(0)) {
            revert CannotUpgrade();
        }

        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        (fuses, expiry) = getFuses(node);

        // burn token and fuse data
        _burn(uint256(node));
    }

    function _transferAndBurnFuses(
        bytes32 node,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        (address owner, , ) = getData(uint256(node));
        _transfer(owner, newOwner, uint256(node), 1, "");
        _setFuses(node, newOwner, fuses, expiry);
    }

    // wrapper function for stack limit
    function _getDataAndNormaliseExpiry(
        bytes32 parentNode,
        bytes32 node,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        (, , uint64 maxExpiry) = getData(uint256(parentNode));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _getETH2LDDataAndNormaliseExpiry(
        bytes32 node,
        bytes32 labelhash,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _normaliseExpiry(
        uint64 expiry,
        uint64 oldExpiry,
        uint64 maxExpiry
    ) internal pure returns (uint64) {
        // Expiry cannot be more than maximum allowed
        // .eth names will check registrar, non .eth check parent
        if (expiry > maxExpiry) {
            expiry = maxExpiry;
        }
        // Expiry cannot be less than old expiry
        if (expiry < oldExpiry) {
            expiry = oldExpiry;
        }

        return expiry;
    }

    function _wrapETH2LD(
        string memory label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) private returns (uint64) {
        // Mint a new ERC1155 token with fuses
        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);

        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(
            node,
            labelhash,
            expiry
        );

        _addLabelAndWrap(
            ETH_NODE,
            node,
            label,
            wrappedOwner,
            fuses | PARENT_CANNOT_CONTROL,
            expiry
        );
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        return expiry;
    }

    function _unwrap(bytes32 node, address newOwner) private {
        if (newOwner == address(0x0) || newOwner == address(this)) {
            revert IncorrectTargetOwner(newOwner);
        }

        if (allFusesBurned(node, CANNOT_UNWRAP)) {
            revert OperationProhibited(node);
        }

        // Burn token and fuse data
        _burn(uint256(node));
        ens.setOwner(node, newOwner);

        emit NameUnwrapped(node, newOwner);
    }

    function _setFuses(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _setData(node, owner, fuses, expiry);
        emit FusesSet(node, fuses, expiry);
    }

    function _setData(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _canFusesBeBurned(node, fuses);
        super._setData(uint256(node), owner, fuses, expiry);
    }

    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
        if (
            fuses & ~PARENT_CANNOT_CONTROL != 0 &&
            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
        ) {
            revert OperationProhibited(node);
        }
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-01-09 20:36:48 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 20:36:48 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 7200
completion_tokens: 839
total_tokens: 8039
cost: $-1.000000


[2024-01-09 20:36:48 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: //SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "./ERC1155Fuse.sol";
import "./Controllable.sol";
import "./INameWrapper.sol";
import "./INameWrapperUpgrade.sol";
import "./IMetadataService.sol";
import "../registry/ENS.sol";
import "../ethregistrar/IBaseRegistrar.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./BytesUtil.sol";

error Unauthorised(bytes32 node, address addr);
error NameNotFound();
error IncompatibleParent();
error IncompatibleName(bytes name);
error IncorrectTokenType();
error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);
error LabelTooShort();
error LabelTooLong(string label);
error IncorrectTargetOwner(address owner);
error CannotUpgrade();
error InvalidExpiry(bytes32 node, uint64 expiry);

contract NameWrapper is
    Ownable,
    ERC1155Fuse,
    INameWrapper,
    Controllable,
    IERC721Receiver
{
    using BytesUtils for bytes;
    ENS public immutable override ens;
    IBaseRegistrar public immutable override registrar;
    IMetadataService public override metadataService;
    mapping(bytes32 => bytes) public override names;

    bytes32 private constant ETH_NODE =
        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
    bytes32 private constant ROOT_NODE =
        0x0000000000000000000000000000000000000000000000000000000000000000;

    //A contract address to a new upgraded contract if any
    INameWrapperUpgrade public upgradeContract;
    uint64 private constant MAX_EXPIRY = type(uint64).max;

    constructor(
        ENS _ens,
        IBaseRegistrar _registrar,
        IMetadataService _metadataService
    ) {
        ens = _ens;
        registrar = _registrar;
        metadataService = _metadataService;

        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */

        _setData(
            uint256(ETH_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        _setData(
            uint256(ROOT_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        names[ROOT_NODE] = "\x00";
        names[ETH_NODE] = "\x03eth\x00";
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Fuse, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(INameWrapper).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /* ERC1155 */

    function ownerOf(uint256 id)
        public
        view
        override(ERC1155Fuse, INameWrapper)
        returns (address owner)
    {
        return super.ownerOf(id);
    }

    /* Metadata service */

    /**
     * @notice Set the metadata service. Only the owner can do this
     */

    function setMetadataService(IMetadataService _newMetadataService)
        public
        onlyOwner
    {
        metadataService = _newMetadataService;
    }

    /**
     * @notice Get the metadata uri
     * @return String uri of the metadata service
     */

    function uri(uint256 tokenId) public view override returns (string memory) {
        return metadataService.uri(tokenId);
    }

    /**
     * @notice Set the address of the upgradeContract of the contract. only admin can do this
     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time
     * to make the contract not upgradable.
     * @param _upgradeAddress address of an upgraded contract
     */

    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)
        public
        onlyOwner
    {
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), false);
            ens.setApprovalForAll(address(upgradeContract), false);
        }

        upgradeContract = _upgradeAddress;

        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), true);
            ens.setApprovalForAll(address(upgradeContract), true);
        }
    }

    /**
     * @notice Checks if msg.sender is the owner or approved by the owner of a name
     * @param node namehash of the name to check
     */

    modifier onlyTokenOwner(bytes32 node) {
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        _;
    }

    /**
     * @notice Checks if owner or approved by owner
     * @param node namehash of the name to check
     * @param addr which address to check permissions for
     * @return whether or not is owner or approved
     */

    function isTokenOwnerOrApproved(bytes32 node, address addr)
        public
        view
        override
        returns (bool)
    {
        address owner = ownerOf(uint256(node));
        return owner == addr || isApprovedForAll(owner, addr);
    }

    /**
     * @notice Gets fuse permissions for a specific name
     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit
     *      The interface has predefined fuses for all registry permissions, but additional
     *      fuses can be added for other use cases
     *      Also returns expiry, which is when the fuses are set to expire.
     * @param node namehash of the name to check
     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp
     * @return expiry Unix time of when the name expires and fuses are to expire
     */
    function getFuses(bytes32 node)
        public
        view
        override
        returns (uint32 fuses, uint64 expiry)
    {
        (, fuses, expiry) = getData(uint256(node));
        if (fuses == 0 && expiry == 0) {
            bytes memory name = names[node];
            if (name.length == 0) {
                revert NameNotFound();
            }
        }
    }

    /**
     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract
     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar
     * @param label label as a string of the .eth domain to wrap
     * @param wrappedOwner Owner of the name in this contract
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @param resolver resolver contract address
     */

    function wrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) public override returns (uint64) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        address registrant = registrar.ownerOf(tokenId);
        if (
            registrant != msg.sender &&
            !isApprovedForAll(registrant, msg.sender) &&
            !registrar.isApprovedForAll(registrant, msg.sender)
        ) {
            revert Unauthorised(
                _makeNode(ETH_NODE, bytes32(tokenId)),
                msg.sender
            );
        }

        // transfer the token from the user to this contract
        registrar.transferFrom(registrant, address(this), tokenId);

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(tokenId, address(this));

        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Registers a new .eth second-level domain and wraps it.
     *      Only callable by authorised controllers.
     * @param label The label to register (Eg, 'foo' for 'foo.eth').
     * @param wrappedOwner The owner of the wrapped name.
     * @param duration The duration, in seconds, to register the name for.
     * @param resolver The resolver address to set on the ENS registry (optional).
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.
     */

    function registerAndWrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint256 duration,
        address resolver,
        uint32 fuses,
        uint64 expiry
    ) external override onlyController returns (uint256 registrarExpiry) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        registrarExpiry = registrar.register(tokenId, address(this), duration);
        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Renews a .eth second-level domain.
     *      Only callable by authorised controllers.
     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').
     * @param duration The number of seconds to renew the name for.
     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.
     */
    function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));

        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));

        _setData(node, owner, fuses, expiry);
    }

    /**
     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the registry or an authorised caller in the registry
     * @param name The name to wrap, in DNS format
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract address
     */

    function wrap(
        bytes calldata name,
        address wrappedOwner,
        address resolver
    ) public override {
        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
        bytes32 parentNode = name.namehash(offset);
        bytes32 node = _makeNode(parentNode, labelhash);

        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }

        address owner = ens.owner(node);

        if (
            owner != msg.sender &&
            !isApprovedForAll(owner, msg.sender) &&
            !ens.isApprovedForAll(owner, msg.sender)
        ) {
            revert Unauthorised(node, msg.sender);
        }

        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        ens.setOwner(node, address(this));

        _wrap(node, name, wrappedOwner, 0, 0);
    }

    /**
     * @notice Unwraps a .eth domain. e.g. vitalik.eth
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param labelhash labelhash of the .eth domain
     * @param newRegistrant sets the owner in the .eth registrar to this address
     * @param newController sets the owner in the registry to this address
     */

    function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }

    /**
     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param newController sets the owner in the registry to this address
     */

    function unwrap(
        bytes32 parentNode,
        bytes32 labelhash,
        address newController
    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        _unwrap(_makeNode(parentNode, labelhash), newController);
    }

    /**
     * @notice Sets fuses of a name
     * @param node namehash of the name
     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)
     */

    function setFuses(bytes32 node, uint32 fuses)
        public
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_BURN_FUSES)
        returns (uint32)
    {
        if (fuses & PARENT_CANNOT_CONTROL != 0) {
            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.
            revert Unauthorised(node, msg.sender);
        }

        (address owner, uint32 oldFuses, uint64 expiry) = getData(
            uint256(node)
        );

        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
        return fuses;
    }

    /**
     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract
     *     and burning the token of this contract
     * @dev Can be called by the owner of the name in this contract
     * @param label Label as a string of the .eth name to upgrade
     * @param wrappedOwner The owner of the wrapped name
     */

    function upgradeETH2LD(
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);

        upgradeContract.wrapETH2LD(
            label,
            wrappedOwner,
            fuses,
            expiry,
            resolver
        );
    }

    /**
     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner or an authorised caller
     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names
     * @param parentNode namehash of the parent name
     * @param label Label as a string of the name to upgrade
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract for this name
     */

    function upgrade(
        bytes32 parentNode,
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.setSubnodeRecord(
            parentNode,
            label,
            wrappedOwner,
            resolver,
            0,
            fuses,
            expiry
        );
    }

    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param fuses fuses to burn
     * @param expiry when the fuses will expire
     */

    function setChildFuses(
        bytes32 parentNode,
        bytes32 labelhash,
        uint32 fuses,
        uint64 expiry
    ) public {
        bytes32 node = _makeNode(parentNode, labelhash);
        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        uint64 maxExpiry;
        if (parentNode == ETH_NODE) {
            if (!isTokenOwnerOrApproved(node, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            // max expiry is set to the expiry on the registrar
            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        } else {
            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }

            // max expiry is set to the expiry of the parent
            (, , maxExpiry) = getData(uint256(parentNode));
        }

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);

        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed
        if (
            oldFuses & PARENT_CANNOT_CONTROL != 0 &&
            oldFuses | fuses != oldFuses
        ) {
            revert OperationProhibited(node);
        }
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
    }

    /**
     * @notice Sets the subdomain owner in the registry and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry when the fuses will expire
     */

    function setSubnodeOwner(
        bytes32 parentNode,
        string calldata label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
        returns (bytes32 node)
    {
        bytes32 labelhash = keccak256(bytes(label));
        node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);

        if (ens.owner(node) != address(this)) {
            ens.setSubnodeOwner(parentNode, labelhash, address(this));
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param resolver resolver contract in the registry
     * @param ttl ttl in the regsitry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry expiry date for the domain
     */

    function setSubnodeRecord(
        bytes32 parentNode,
        string memory label,
        address newOwner,
        address resolver,
        uint64 ttl,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
    {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets records for the name in the ENS Registry
     * @param node namehash of the name to set a record for
     * @param owner newOwner in the registry
     * @param resolver the resolver contract
     * @param ttl ttl in the registry
     */

    function setRecord(
        bytes32 node,
        address owner,
        address resolver,
        uint64 ttl
    )
        public
        override
        onlyTokenOwner(node)
        operationAllowed(
            node,
            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL
        )
    {
        ens.setRecord(node, address(this), resolver, ttl);
        (address oldOwner, , ) = getData(uint256(node));
        _transfer(oldOwner, owner, uint256(node), 1, "");
    }

    /**
     * @notice Sets resolver contract in the registry
     * @param node namehash of the name
     * @param resolver the resolver contract
     */

    function setResolver(bytes32 node, address resolver)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_RESOLVER)
    {
        ens.setResolver(node, resolver);
    }

    /**
     * @notice Sets TTL in the registry
     * @param node namehash of the name
     * @param ttl TTL in the registry
     */

    function setTTL(bytes32 node, uint64 ttl)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_TTL)
    {
        ens.setTTL(node, ttl);
    }

    /**
     * @dev Allows an operation only if none of the specified fuses are burned.
     * @param node The namehash of the name to check fuses on.
     * @param fuseMask A bitmask of fuses that must not be burned.
     */

    modifier operationAllowed(bytes32 node, uint32 fuseMask) {
        (, uint32 fuses, ) = getData(uint256(node));
        if (fuses & fuseMask != 0) {
            revert OperationProhibited(node);
        }
        _;
    }

    /**
     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord
     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt
     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for
     *      replacing a subdomain. If either conditions are true, then it is possible to call
     *      setSubnodeOwner
     * @param node namehash of the name to check
     * @param labelhash labelhash of the name to check
     */

    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {
        bytes32 subnode = _makeNode(node, labelhash);
        address owner = ens.owner(subnode);

        if (owner == address(0)) {
            (, uint32 fuses, ) = getData(uint256(node));
            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {
                revert OperationProhibited(node);
            }
        } else {
            (, uint32 subnodeFuses, ) = getData(uint256(subnode));
            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {
                revert OperationProhibited(node);
            }
        }

        _;
    }

    /**
     * @notice Checks all Fuses in the mask are burned for the node
     * @param node namehash of the name
     * @param fuseMask the fuses you want to check
     * @return Boolean of whether or not all the selected fuses are burned
     */

    function allFusesBurned(bytes32 node, uint32 fuseMask)
        public
        view
        override
        returns (bool)
    {
        (, uint32 fuses, ) = getData(uint256(node));
        return fuses & fuseMask == fuseMask;
    }

    function onERC721Received(
        address to,
        address,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        //check if it's the eth registrar ERC721
        if (msg.sender != address(registrar)) {
            revert IncorrectTokenType();
        }

        (
            string memory label,
            address owner,
            uint32 fuses,
            uint64 expiry,
            address resolver
        ) = abi.decode(data, (string, address, uint32, uint64, address));

        bytes32 labelhash = bytes32(tokenId);
        bytes32 labelhashFromData = keccak256(bytes(label));

        if (labelhashFromData != labelhash) {
            revert LabelMismatch(labelhashFromData, labelhash);
        }

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(uint256(labelhash), address(this));

        _wrapETH2LD(label, owner, fuses, expiry, resolver);

        return IERC721Receiver(to).onERC721Received.selector;
    }

    /***** Internal functions */

    function _canTransfer(uint32 fuses) internal pure override returns (bool) {
        return fuses & CANNOT_TRANSFER == 0;
    }

    function _makeNode(bytes32 node, bytes32 labelhash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, labelhash));
    }

    function _addLabel(string memory label, bytes memory name)
        internal
        pure
        returns (bytes memory ret)
    {
        if (bytes(label).length < 1) {
            revert LabelTooShort();
        }
        if (bytes(label).length > 255) {
            revert LabelTooLong(label);
        }
        return abi.encodePacked(uint8(bytes(label).length), label, name);
    }

    function _mint(
        bytes32 node,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal override {
        address oldWrappedOwner = ownerOf(uint256(node));
        _canFusesBeBurned(node, fuses);
        if (oldWrappedOwner != address(0)) {
            // burn and unwrap old token of old owner
            _burn(uint256(node));
            emit NameUnwrapped(node, address(0));
        }
        super._mint(node, wrappedOwner, fuses, expiry);
    }

    function _wrap(
        bytes32 node,
        bytes memory name,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        names[node] = name;
        _mint(node, wrappedOwner, fuses, expiry);
        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);
    }

    function _addLabelAndWrap(
        bytes32 parentNode,
        bytes32 node,
        string memory label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        bytes memory name = _addLabel(label, names[parentNode]);
        _wrap(node, name, newOwner, fuses, expiry);
    }

    function _prepareUpgrade(bytes32 node)
        private
        returns (uint32 fuses, uint64 expiry)
    {
        if (address(upgradeContract) == address(0)) {
            revert CannotUpgrade();
        }

        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        (fuses, expiry) = getFuses(node);

        // burn token and fuse data
        _burn(uint256(node));
    }

    function _transferAndBurnFuses(
        bytes32 node,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        (address owner, , ) = getData(uint256(node));
        _transfer(owner, newOwner, uint256(node), 1, "");
        _setFuses(node, newOwner, fuses, expiry);
    }

    // wrapper function for stack limit
    function _getDataAndNormaliseExpiry(
        bytes32 parentNode,
        bytes32 node,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        (, , uint64 maxExpiry) = getData(uint256(parentNode));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _getETH2LDDataAndNormaliseExpiry(
        bytes32 node,
        bytes32 labelhash,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _normaliseExpiry(
        uint64 expiry,
        uint64 oldExpiry,
        uint64 maxExpiry
    ) internal pure returns (uint64) {
        // Expiry cannot be more than maximum allowed
        // .eth names will check registrar, non .eth check parent
        if (expiry > maxExpiry) {
            expiry = maxExpiry;
        }
        // Expiry cannot be less than old expiry
        if (expiry < oldExpiry) {
            expiry = oldExpiry;
        }

        return expiry;
    }

    function _wrapETH2LD(
        string memory label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) private returns (uint64) {
        // Mint a new ERC1155 token with fuses
        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);

        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(
            node,
            labelhash,
            expiry
        );

        _addLabelAndWrap(
            ETH_NODE,
            node,
            label,
            wrappedOwner,
            fuses | PARENT_CANNOT_CONTROL,
            expiry
        );
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        return expiry;
    }

    function _unwrap(bytes32 node, address newOwner) private {
        if (newOwner == address(0x0) || newOwner == address(this)) {
            revert IncorrectTargetOwner(newOwner);
        }

        if (allFusesBurned(node, CANNOT_UNWRAP)) {
            revert OperationProhibited(node);
        }

        // Burn token and fuse data
        _burn(uint256(node));
        ens.setOwner(node, newOwner);

        emit NameUnwrapped(node, newOwner);
    }

    function _setFuses(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _setData(node, owner, fuses, expiry);
        emit FusesSet(node, fuses, expiry);
    }

    function _setData(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _canFusesBeBurned(node, fuses);
        super._setData(uint256(node), owner, fuses, expiry);
    }

    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
        if (
            fuses & ~PARENT_CANNOT_CONTROL != 0 &&
            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
        ) {
            revert OperationProhibited(node);
        }
    }
}
.]

Based on the provided smart contract code for the `NameWrapper` contract, here is a summary of the potential security vulnerabilities identified:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**: 
   - The contract does not implement any reentrancy guards. Functions that involve external calls (like transferring tokens) could be susceptible to reentrancy attacks.

2. **Access Control Issues**:
   - The `onlyController` modifier is used in several functions, but it is unclear how controllers are defined and managed. If not properly controlled, unauthorized users could potentially call sensitive functions.
   - The `setUpgradeContract` function allows the owner to set an upgrade contract without any checks on the validity of the contract address, which could lead to malicious contract interactions.

3. **Gas Limit Issues**:
   - Functions that involve loops or multiple external calls (like `setSubnodeRecord`) could run into gas limit issues, especially if the number of operations exceeds the block gas limit.

4. **Improper Error Handling**:
   - The contract relies on revert statements for error handling, which is generally acceptable, but there are scenarios where more informative error messages could be provided to help users understand the failure reasons better.

5. **Lack of Input Validation**:
   - Functions like `wrapETH2LD` and `registerAndWrapETH2LD` do not sufficiently validate input parameters (e.g., checking if `wrappedOwner` is a valid address).

6. **Potential for Denial of Service (DoS)**:
   - If the ENS or registrar contracts become unavailable or malfunction, functions that depend on them could fail, leading to a denial of service for users trying to wrap or unwrap names.

7. **Token Ownership and Approval Logic**:
   - The logic for checking token ownership and approvals could be simplified or made more robust to prevent unauthorized access to sensitive functions.

8. **Upgradeability Risks**:
   - The contract allows for an upgrade mechanism, but without proper checks and balances, this could lead to vulnerabilities if the upgrade contract itself is compromised.

### Comprehensive Analysis Report:

The `NameWrapper` contract is a complex implementation that interacts with multiple external contracts, including ENS and ERC721. While it provides essential functionalities for wrapping and managing domain names, several security vulnerabilities could pose risks to users and the integrity of the contract.

1. **Reentrancy Attacks**: The absence of reentrancy guards in functions that perform external calls could allow attackers to exploit the contract's state during execution.

2. **Access Control**: The reliance on the `onlyController` modifier without clear management of controller roles could lead to unauthorized access. Additionally, the ability to set an upgrade contract without validation poses a significant risk.

3. **Gas Limit Concerns**: Functions that could potentially exceed gas limits need to be optimized to prevent failures during execution.

4. **Error Handling**: While revert statements are used, more descriptive error messages could enhance user experience and debugging.

5. **Input Validation**: Insufficient checks on input parameters could lead to unexpected behaviors or vulnerabilities.

6. **Denial of Service**: The contract's reliance on external contracts means that any downtime or issues with those contracts could render the `NameWrapper` unusable.

7. **Token Management Logic**: The ownership and approval checks need to be more robust to prevent unauthorized access to critical functions.

8. **Upgradeability Risks**: The upgrade mechanism must be carefully managed to avoid introducing vulnerabilities through malicious contracts.

### Recommendations:

- Implement reentrancy guards on functions that involve external calls.
- Strengthen access control mechanisms and ensure proper management of controller roles.
- Optimize functions to avoid gas limit issues.
- Enhance error handling with more informative messages.
- Add thorough input validation for all public functions.
- Consider implementing circuit breakers or alternative mechanisms to handle potential DoS scenarios.
- Review and refine token ownership and approval logic for robustness.
- Establish a clear protocol for managing upgrade contracts to mitigate risks associated with upgradeability.

By addressing these vulnerabilities, the `NameWrapper` contract can be made more secure and resilient against potential attacks and operational failures.

[2024-01-09 20:36:48 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for the `NameWrapper` contract, here is a summary of the potential security vulnerabilities identified:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**: 
   - The contract does not implement any reentrancy guards. Functions that involve external calls (like transferring tokens) could be susceptible to reentrancy attacks.

2. **Access Control Issues**:
   - The `onlyController` modifier is used in several functions, but it is unclear how controllers are defined and managed. If not properly controlled, unauthorized users could potentially call sensitive functions.
   - The `setUpgradeContract` function allows the owner to set an upgrade contract without any checks on the validity of the contract address, which could lead to malicious contract interactions.

3. **Gas Limit Issues**:
   - Functions that involve loops or multiple external calls (like `setSubnodeRecord`) could run into gas limit issues, especially if the number of operations exceeds the block gas limit.

4. **Improper Error Handling**:
   - The contract relies on revert statements for error handling, which is generally acceptable, but there are scenarios where more informative error messages could be provided to help users understand the failure reasons better.

5. **Lack of Input Validation**:
   - Functions like `wrapETH2LD` and `registerAndWrapETH2LD` do not sufficiently validate input parameters (e.g., checking if `wrappedOwner` is a valid address).

6. **Potential for Denial of Service (DoS)**:
   - If the ENS or registrar contracts become unavailable or malfunction, functions that depend on them could fail, leading to a denial of service for users trying to wrap or unwrap names.

7. **Token Ownership and Approval Logic**:
   - The logic for checking token ownership and approvals could be simplified or made more robust to prevent unauthorized access to sensitive functions.

8. **Upgradeability Risks**:
   - The contract allows for an upgrade mechanism, but without proper checks and balances, this could lead to vulnerabilities if the upgrade contract itself is compromised.

### Comprehensive Analysis Report:

The `NameWrapper` contract is a complex implementation that interacts with multiple external contracts, including ENS and ERC721. While it provides essential functionalities for wrapping and managing domain names, several security vulnerabilities could pose risks to users and the integrity of the contract.

1. **Reentrancy Attacks**: The absence of reentrancy guards in functions that perform external calls could allow attackers to exploit the contract's state during execution.

2. **Access Control**: The reliance on the `onlyController` modifier without clear management of controller roles could lead to unauthorized access. Additionally, the ability to set an upgrade contract without validation poses a significant risk.

3. **Gas Limit Concerns**: Functions that could potentially exceed gas limits need to be optimized to prevent failures during execution.

4. **Error Handling**: While revert statements are used, more descriptive error messages could enhance user experience and debugging.

5. **Input Validation**: Insufficient checks on input parameters could lead to unexpected behaviors or vulnerabilities.

6. **Denial of Service**: The contract's reliance on external contracts means that any downtime or issues with those contracts could render the `NameWrapper` unusable.

7. **Token Management Logic**: The ownership and approval checks need to be more robust to prevent unauthorized access to critical functions.

8. **Upgradeability Risks**: The upgrade mechanism must be carefully managed to avoid introducing vulnerabilities through malicious contracts.

### Recommendations:

- Implement reentrancy guards on functions that involve external calls.
- Strengthen access control mechanisms and ensure proper management of controller roles.
- Optimize functions to avoid gas limit issues.
- Enhance error handling with more informative messages.
- Add thorough input validation for all public functions.
- Consider implementing circuit breakers or alternative mechanisms to handle potential DoS scenarios.
- Review and refine token ownership and approval logic for robustness.
- Establish a clear protocol for managing upgrade contracts to mitigate risks associated with upgradeability.

By addressing these vulnerabilities, the `NameWrapper` contract can be made more secure and resilient against potential attacks and operational failures.

[2024-01-09 20:36:51 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | //SPDX-License-Identifier: MIT pragma solidity ^0.8.4; import "./ERC1155Fuse.sol"; import "./Controllable.sol"; import "./INameWrapper.sol"; import "./INameWrapperUpgrade.sol"; import "./IMetadataService.sol"; import "../registry/ENS.sol"; import "../ethregistrar/IBaseRegistrar.sol"; import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "./BytesUtil.sol"; error Unauthorised(bytes32 node, address addr); error NameNotFound(); error IncompatibleParent(); error IncompatibleName(bytes name); error IncorrectTokenType(); error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash); error LabelTooShort(); error LabelTooLong(string label); error IncorrectTargetOwner(address owner); error CannotUpgrade(); error InvalidExpiry(bytes32 node, uint64 expiry); contract NameWrapper is     Ownable,     ERC1155Fuse,     INameWrapper,     Controllable,     IERC721Receiver {     using BytesUtils for bytes;     ENS public immutable override ens;     IBaseRegistrar public immutable override registrar;     IMetadataService public override metadataService;     mapping(bytes32 =&gt; bytes) public override names; bytes32 private constant ETH_NODE =     0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae; bytes32 private constant ROOT_NODE =     0x0000000000000000000000000000000000000000000000000000000000000000;  //A contract address to a new upgraded contract if any INameWrapperUpgrade public upgradeContract; uint64 private constant MAX_EXPIRY = type(uint64).max;  constructor(     ENS _ens,     IBaseRegistrar _registrar,     IMetadataService _metadataService ) {     ens = _ens;     registrar = _registrar;     metadataService = _metadataService;      /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */      _setData(         uint256(ETH_NODE),         address(0),         uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),         MAX_EXPIRY     );     _setData(         uint256(ROOT_NODE),         address(0),         uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),         MAX_EXPIRY     );     names[ROOT_NODE] = "\x00";     names[ETH_NODE] = "\x03eth\x00"; }  function supportsInterface(bytes4 interfaceId)     public     view     virtual     override(ERC1155Fuse, IERC165)     returns (bool) {     return         interfaceId == type(INameWrapper).interfaceId ||         super.supportsInterface(interfaceId); }  /* ERC1155 */  function ownerOf(uint256 id)     public     view     override(ERC1155Fuse, INameWrapper)     returns (address owner) {     return super.ownerOf(id); }  /* Metadata service */  /**  * @notice Set the metadata service. Only the owner can do this  */  function setMetadataService(IMetadataService _newMetadataService)     public     onlyOwner {     metadataService = _newMetadataService; }  /**  * @notice Get the metadata uri  * @return String uri of the metadata service  */  function uri(uint256 tokenId) public view override returns (string memory) {     return metadataService.uri(tokenId); }  /**  * @notice Set the address of the upgradeContract of the contract. only admin can do this  * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time  * to make the contract not upgradable.  * @param _upgradeAddress address of an upgraded contract  */  function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)     public     onlyOwner {     if (address(upgradeContract) != address(0)) {         registrar.setApprovalForAll(address(upgradeContract), false);         ens.setApprovalForAll(address(upgradeContract), false);     }      upgradeContract = _upgradeAddress;      if (address(upgradeContract) != address(0)) {         registrar.setApprovalForAll(address(upgradeContract), true);         ens.setApprovalForAll(address(upgradeContract), true);     } }  /**  * @notice Checks if msg.sender is the owner or approved by the owner of a name  * @param node namehash of the name to check  */  modifier onlyTokenOwner(bytes32 node) {     if (!isTokenOwnerOrApproved(node, msg.sender)) {         revert Unauthorised(node, msg.sender);     }      _; }  /**  * @notice Checks if owner or approved by owner  * @param node namehash of the name to check  * @param addr which address to check permissions for  * @return whether or not is owner or approved  */  function isTokenOwnerOrApproved(bytes32 node, address addr)     public     view     override     returns (bool) {     address owner = ownerOf(uint256(node));     return owner == addr || isApprovedForAll(owner, addr); }  /**  * @notice Gets fuse permissions for a specific name  * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit  *      The interface has predefined fuses for all registry permissions, but additional  *      fuses can be added for other use cases  *      Also returns expiry, which is when the fuses are set to expire.  * @param node namehash of the name to check  * @return fuses A number that represents the permissions a name has. Returns 0 when expiry &lt; block.timestamp  * @return expiry Unix time of when the name expires and fuses are to expire  */ function getFuses(bytes32 node)     public     view     override     returns (uint32 fuses, uint64 expiry) {     (, fuses, expiry) = getData(uint256(node));     if (fuses == 0 &amp;&amp; expiry == 0) {         bytes memory name = names[node];         if (name.length == 0) {             revert NameNotFound();         }     } }  /**  * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract  * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar  * @param label label as a string of the .eth domain to wrap  * @param wrappedOwner Owner of the name in this contract  * @param fuses initial fuses to set  * @param expiry when the fuses will expire  * @param resolver resolver contract address  */  function wrapETH2LD(     string calldata label,     address wrappedOwner,     uint32 fuses,     uint64 expiry,     address resolver ) public override returns (uint64) {     uint256 tokenId = uint256(keccak256(bytes(label)));     address registrant = registrar.ownerOf(tokenId);     if (         registrant != msg.sender &amp;&amp;         !isApprovedForAll(registrant, msg.sender) &amp;&amp;         !registrar.isApprovedForAll(registrant, msg.sender)     ) {         revert Unauthorised(             _makeNode(ETH_NODE, bytes32(tokenId)),             msg.sender         );     }      // transfer the token from the user to this contract     registrar.transferFrom(registrant, address(this), tokenId);      // transfer the ens record back to the new owner (this contract)     registrar.reclaim(tokenId, address(this));      return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver); }  /**  * @dev Registers a new .eth second-level domain and wraps it.  *      Only callable by authorised controllers.  * @param label The label to register (Eg, 'foo' for 'foo.eth').  * @param wrappedOwner The owner of the wrapped name.  * @param duration The duration, in seconds, to register the name for.  * @param resolver The resolver address to set on the ENS registry (optional).  * @param fuses initial fuses to set  * @param expiry when the fuses will expire  * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.  */  function registerAndWrapETH2LD(     string calldata label,     address wrappedOwner,     uint256 duration,     address resolver,     uint32 fuses,     uint64 expiry ) external override onlyController returns (uint256 registrarExpiry) {     uint256 tokenId = uint256(keccak256(bytes(label)));     registrarExpiry = registrar.register(tokenId, address(this), duration);     _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver); }  /**  * @dev Renews a .eth second-level domain.  *      Only callable by authorised controllers.  * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').  * @param duration The number of seconds to renew the name for.  * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.  */ function renew(     uint256 tokenId,     uint256 duration,     uint64 expiry ) external override onlyController returns (uint256 expires) {     bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));      expires = registrar.renew(tokenId, duration);     (address owner, uint32 fuses, uint64 oldExpiry) = getData(         uint256(node)     );     expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));      _setData(node, owner, fuses, expiry); }  /**  * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner in the registry or an authorised caller in the registry  * @param name The name to wrap, in DNS format  * @param wrappedOwner Owner of the name in this contract  * @param resolver resolver contract address  */  function wrap(     bytes calldata name,     address wrappedOwner,     address resolver ) public override {     (bytes32 labelhash, uint256 offset) = name.readLabel(0);     bytes32 parentNode = name.namehash(offset);     bytes32 node = _makeNode(parentNode, labelhash);      if (parentNode == ETH_NODE) {         revert IncompatibleParent();     }      address owner = ens.owner(node);      if (         owner != msg.sender &amp;&amp;         !isApprovedForAll(owner, msg.sender) &amp;&amp;         !ens.isApprovedForAll(owner, msg.sender)     ) {         revert Unauthorised(node, msg.sender);     }      if (resolver != address(0)) {         ens.setResolver(node, resolver);     }      ens.setOwner(node, address(this));      _wrap(node, name, wrappedOwner, 0, 0); }  /**  * @notice Unwraps a .eth domain. e.g. vitalik.eth  * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper  * @param labelhash labelhash of the .eth domain  * @param newRegistrant sets the owner in the .eth registrar to this address  * @param newController sets the owner in the registry to this address  */  function unwrapETH2LD(     bytes32 labelhash,     address newRegistrant,     address newController ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {     _unwrap(_makeNode(ETH_NODE, labelhash), newController);     registrar.transferFrom(         address(this),         newRegistrant,         uint256(labelhash)     ); }  /**  * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper  * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')  * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')  * @param newController sets the owner in the registry to this address  */  function unwrap(     bytes32 parentNode,     bytes32 labelhash,     address newController ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {     if (parentNode == ETH_NODE) {         revert IncompatibleParent();     }     _unwrap(_makeNode(parentNode, labelhash), newController); }  /**  * @notice Sets fuses of a name  * @param node namehash of the name  * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)  */  function setFuses(bytes32 node, uint32 fuses)     public     onlyTokenOwner(node)     operationAllowed(node, CANNOT_BURN_FUSES)     returns (uint32) {     if (fuses &amp; PARENT_CANNOT_CONTROL != 0) {         // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.         revert Unauthorised(node, msg.sender);     }      (address owner, uint32 oldFuses, uint64 expiry) = getData(         uint256(node)     );      fuses |= oldFuses;     _setFuses(node, owner, fuses, expiry);     return fuses; }  /**  * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract  *     and burning the token of this contract  * @dev Can be called by the owner of the name in this contract  * @param label Label as a string of the .eth name to upgrade  * @param wrappedOwner The owner of the wrapped name  */  function upgradeETH2LD(     string calldata label,     address wrappedOwner,     address resolver ) public {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(ETH_NODE, labelhash);     (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);      upgradeContract.wrapETH2LD(         label,         wrappedOwner,         fuses,         expiry,         resolver     ); }  /**  * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner or an authorised caller  * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names  * @param parentNode namehash of the parent name  * @param label Label as a string of the name to upgrade  * @param wrappedOwner Owner of the name in this contract  * @param resolver resolver contract for this name  */  function upgrade(     bytes32 parentNode,     string calldata label,     address wrappedOwner,     address resolver ) public {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(parentNode, labelhash);     (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);     upgradeContract.setSubnodeRecord(         parentNode,         label,         wrappedOwner,         resolver,         0,         fuses,         expiry     ); }  /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name  * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')  * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')  * @param fuses fuses to burn  * @param expiry when the fuses will expire  */  function setChildFuses(     bytes32 parentNode,     bytes32 labelhash,     uint32 fuses,     uint64 expiry ) public {     bytes32 node = _makeNode(parentNode, labelhash);     (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(         uint256(node)     );     uint64 maxExpiry;     if (parentNode == ETH_NODE) {         if (!isTokenOwnerOrApproved(node, msg.sender)) {             revert Unauthorised(node, msg.sender);         }         // max expiry is set to the expiry on the registrar         maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));     } else {         if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {             revert Unauthorised(node, msg.sender);         }          // max expiry is set to the expiry of the parent         (, , maxExpiry) = getData(uint256(parentNode));     }      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);      // if PARENT_CANNOT_CONTROL has been burned and fuses have changed     if (         oldFuses &amp; PARENT_CANNOT_CONTROL != 0 &amp;&amp;         oldFuses | fuses != oldFuses     ) {         revert OperationProhibited(node);     }     fuses |= oldFuses;     _setFuses(node, owner, fuses, expiry); }  /**  * @notice Sets the subdomain owner in the registry and then wraps the subdomain  * @param parentNode parent namehash of the subdomain  * @param label label of the subdomain as a string  * @param newOwner newOwner in the registry  * @param fuses initial fuses for the wrapped subdomain  * @param expiry when the fuses will expire  */  function setSubnodeOwner(     bytes32 parentNode,     string calldata label,     address newOwner,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))     returns (bytes32 node) {     bytes32 labelhash = keccak256(bytes(label));     node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);      if (ens.owner(node) != address(this)) {         ens.setSubnodeOwner(parentNode, labelhash, address(this));         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } }  /**  * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain  * @param parentNode parent namehash of the subdomain  * @param label label of the subdomain as a string  * @param newOwner newOwner in the registry  * @param resolver resolver contract in the registry  * @param ttl ttl in the regsitry  * @param fuses initial fuses for the wrapped subdomain  * @param expiry expiry date for the domain  */  function setSubnodeRecord(     bytes32 parentNode,     string memory label,     address newOwner,     address resolver,     uint64 ttl,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label))) {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);     if (ens.owner(node) != address(this)) {         ens.setSubnodeRecord(             parentNode,             labelhash,             address(this),             resolver,             ttl         );         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         ens.setSubnodeRecord(             parentNode,             labelhash,             address(this),             resolver,             ttl         );         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } }  /**  * @notice Sets records for the name in the ENS Registry  * @param node namehash of the name to set a record for  * @param owner newOwner in the registry  * @param resolver the resolver contract  * @param ttl ttl in the registry  */  function setRecord(     bytes32 node,     address owner,     address resolver,     uint64 ttl )     public     override     onlyTokenOwner(node)     operationAllowed(         node,         CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL     ) {     ens.setRecord(node, address(this), resolver, ttl);     (address oldOwner, , ) = getData(uint256(node));     _transfer(oldOwner, owner, uint256(node), 1, ""); }  /**  * @notice Sets resolver contract in the registry  * @param node namehash of the name  * @param resolver the resolver contract  */  function setResolver(bytes32 node, address resolver)     public     override     onlyTokenOwner(node)     operationAllowed(node, CANNOT_SET_RESOLVER) {     ens.setResolver(node, resolver); }  /**  * @notice Sets TTL in the registry  * @param node namehash of the name  * @param ttl TTL in the registry  */  function setTTL(bytes32 node, uint64 ttl)     public     override     onlyTokenOwner(node)     operationAllowed(node, CANNOT_SET_TTL) {     ens.setTTL(node, ttl); }  /**  * @dev Allows an operation only if none of the specified fuses are burned.  * @param node The namehash of the name to check fuses on.  * @param fuseMask A bitmask of fuses that must not be burned.  */  modifier operationAllowed(bytes32 node, uint32 fuseMask) {     (, uint32 fuses, ) = getData(uint256(node));     if (fuses &amp; fuseMask != 0) {         revert OperationProhibited(node);     }     _; }  /**  * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord  * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt  *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for  *      replacing a subdomain. If either conditions are true, then it is possible to call  *      setSubnodeOwner  * @param node namehash of the name to check  * @param labelhash labelhash of the name to check  */  modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {     bytes32 subnode = _makeNode(node, labelhash);     address owner = ens.owner(subnode);      if (owner == address(0)) {         (, uint32 fuses, ) = getData(uint256(node));         if (fuses &amp; CANNOT_CREATE_SUBDOMAIN != 0) {             revert OperationProhibited(node);         }     } else {         (, uint32 subnodeFuses, ) = getData(uint256(subnode));         if (subnodeFuses &amp; PARENT_CANNOT_CONTROL != 0) {             revert OperationProhibited(node);         }     }      _; }  /**  * @notice Checks all Fuses in the mask are burned for the node  * @param node namehash of the name  * @param fuseMask the fuses you want to check  * @return Boolean of whether or not all the selected fuses are burned  */  function allFusesBurned(bytes32 node, uint32 fuseMask)     public     view     override     returns (bool) {     (, uint32 fuses, ) = getData(uint256(node));     return fuses &amp; fuseMask == fuseMask; }  function onERC721Received(     address to,     address,     uint256 tokenId,     bytes calldata data ) public override returns (bytes4) {     //check if it's the eth registrar ERC721     if (msg.sender != address(registrar)) {         revert IncorrectTokenType();     }      (         string memory label,         address owner,         uint32 fuses,         uint64 expiry,         address resolver     ) = abi.decode(data, (string, address, uint32, uint64, address));      bytes32 labelhash = bytes32(tokenId);     bytes32 labelhashFromData = keccak256(bytes(label));      if (labelhashFromData != labelhash) {         revert LabelMismatch(labelhashFromData, labelhash);     }      // transfer the ens record back to the new owner (this contract)     registrar.reclaim(uint256(labelhash), address(this));      _wrapETH2LD(label, owner, fuses, expiry, resolver);      return IERC721Receiver(to).onERC721Received.selector; }  /***** Internal functions */  function _canTransfer(uint32 fuses) internal pure override returns (bool) {     return fuses &amp; CANNOT_TRANSFER == 0; }  function _makeNode(bytes32 node, bytes32 labelhash)     private     pure     returns (bytes32) {     return keccak256(abi.encodePacked(node, labelhash)); }  function _addLabel(string memory label, bytes memory name)     internal     pure     returns (bytes memory ret) {     if (bytes(label).length &lt; 1) {         revert LabelTooShort();     }     if (bytes(label).length &gt; 255) {         revert LabelTooLong(label);     }     return abi.encodePacked(uint8(bytes(label).length), label, name); }  function _mint(     bytes32 node,     address wrappedOwner,     uint32 fuses,     uint64 expiry ) internal override {     address oldWrappedOwner = ownerOf(uint256(node));     _canFusesBeBurned(node, fuses);     if (oldWrappedOwner != address(0)) {         // burn and unwrap old token of old owner         _burn(uint256(node));         emit NameUnwrapped(node, address(0));     }     super._mint(node, wrappedOwner, fuses, expiry); }  function _wrap(     bytes32 node,     bytes memory name,     address wrappedOwner,     uint32 fuses,     uint64 expiry ) internal {     names[node] = name;     _mint(node, wrappedOwner, fuses, expiry);     emit NameWrapped(node, name, wrappedOwner, fuses, expiry); }  function _addLabelAndWrap(     bytes32 parentNode,     bytes32 node,     string memory label,     address newOwner,     uint32 fuses,     uint64 expiry ) internal {     bytes memory name = _addLabel(label, names[parentNode]);     _wrap(node, name, newOwner, fuses, expiry); }  function _prepareUpgrade(bytes32 node)     private     returns (uint32 fuses, uint64 expiry) {     if (address(upgradeContract) == address(0)) {         revert CannotUpgrade();     }      if (!isTokenOwnerOrApproved(node, msg.sender)) {         revert Unauthorised(node, msg.sender);     }      (fuses, expiry) = getFuses(node);      // burn token and fuse data     _burn(uint256(node)); }  function _transferAndBurnFuses(     bytes32 node,     address newOwner,     uint32 fuses,     uint64 expiry ) internal {     (address owner, , ) = getData(uint256(node));     _transfer(owner, newOwner, uint256(node), 1, "");     _setFuses(node, newOwner, fuses, expiry); }  // wrapper function for stack limit function _getDataAndNormaliseExpiry(     bytes32 parentNode,     bytes32 node,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     (, , uint64 maxExpiry) = getData(uint256(parentNode));      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); }  function _getETH2LDDataAndNormaliseExpiry(     bytes32 node,     bytes32 labelhash,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); }  function _normaliseExpiry(     uint64 expiry,     uint64 oldExpiry,     uint64 maxExpiry ) internal pure returns (uint64) {     // Expiry cannot be more than maximum allowed     // .eth names will check registrar, non .eth check parent     if (expiry &gt; maxExpiry) {         expiry = maxExpiry;     }     // Expiry cannot be less than old expiry     if (expiry &lt; oldExpiry) {         expiry = oldExpiry;     }      return expiry; }  function _wrapETH2LD(     string memory label,     address wrappedOwner,     uint32 fuses,     uint64 expiry,     address resolver ) private returns (uint64) {     // Mint a new ERC1155 token with fuses     // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(ETH_NODE, labelhash);      (, , expiry) = _getETH2LDDataAndNormaliseExpiry(         node,         labelhash,         expiry     );      _addLabelAndWrap(         ETH_NODE,         node,         label,         wrappedOwner,         fuses | PARENT_CANNOT_CONTROL,         expiry     );     if (resolver != address(0)) {         ens.setResolver(node, resolver);     }      return expiry; }  function _unwrap(bytes32 node, address newOwner) private {     if (newOwner == address(0x0) || newOwner == address(this)) {         revert IncorrectTargetOwner(newOwner);     }      if (allFusesBurned(node, CANNOT_UNWRAP)) {         revert OperationProhibited(node);     }      // Burn token and fuse data     _burn(uint256(node));     ens.setOwner(node, newOwner);      emit NameUnwrapped(node, newOwner); }  function _setFuses(     bytes32 node,     address owner,     uint32 fuses,     uint64 expiry ) internal {     _setData(node, owner, fuses, expiry);     emit FusesSet(node, fuses, expiry); }  function _setData(     bytes32 node,     address owner,     uint32 fuses,     uint64 expiry ) internal {     _canFusesBeBurned(node, fuses);     super._setData(uint256(node), owner, fuses, expiry); }  function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {     if (         fuses &amp; ~PARENT_CANNOT_CONTROL != 0 &amp;&amp;         fuses &amp; (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=         (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)     ) {         revert OperationProhibited(node);     } }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport "./ERC1155Fuse.sol";\nimport "./Controllable.sol";\nimport "./INameWrapper.sol";\nimport "./INameWrapperUpgrade.sol";\nimport "./IMetadataService.sol";\nimport "../registry/ENS.sol";\nimport "../ethregistrar/IBaseRegistrar.sol";\nimport "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";\nimport "@openzeppelin/contracts/access/Ownable.sol";\nimport "./BytesUtil.sol";\n\nerror Unauthorised(bytes32 node, address addr);\nerror NameNotFound();\nerror IncompatibleParent();\nerror IncompatibleName(bytes name);\nerror IncorrectTokenType();\nerror LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);\nerror LabelTooShort();\nerror LabelTooLong(string label);\nerror IncorrectTargetOwner(address owner);\nerror CannotUpgrade();\nerror InvalidExpiry(bytes32 node, uint64 expiry);\n\ncontract NameWrapper is\n    Ownable,\n    ERC1155Fuse,\n    INameWrapper,\n    Controllable,\n    IERC721Receiver\n{\n    using BytesUtils for bytes;\n    ENS public immutable override ens;\n    IBaseRegistrar public immutable override registrar;\n    IMetadataService public override metadataService;\n    mapping(bytes32 =&gt; bytes) public override names;\n\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n    bytes32 private constant ROOT_NODE =\n        0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    //A contract address to a new upgraded contract if any\n    INameWrapperUpgrade public upgradeContract;\n    uint64 private constant MAX_EXPIRY = type(uint64).max;\n\n    constructor(\n        ENS _ens,\n        IBaseRegistrar _registrar,\n        IMetadataService _metadataService\n    ) {\n        ens = _ens;\n        registrar = _registrar;\n        metadataService = _metadataService;\n\n        / Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE /\n\n        _setData(\n            uint256(ETH_NODE),\n            address(0),\n            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),\n            MAX_EXPIRY\n        );\n        _setData(\n            uint256(ROOT_NODE),\n            address(0),\n            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),\n            MAX_EXPIRY\n        );\n        names[ROOT_NODE] = "\x00";\n        names[ETH_NODE] = "\x03eth\x00";\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC1155Fuse, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(INameWrapper).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    / ERC1155 /\n\n    function ownerOf(uint256 id)\n        public\n        view\n        override(ERC1155Fuse, INameWrapper)\n        returns (address owner)\n    {\n        return super.ownerOf(id);\n    }\n\n    / Metadata service /\n\n    /\n     * @notice Set the metadata service. Only the owner can do this\n     /\n\n    function setMetadataService(IMetadataService _newMetadataService)\n        public\n        onlyOwner\n    {\n        metadataService = _newMetadataService;\n    }\n\n    /\n     * @notice Get the metadata uri\n     * @return String uri of the metadata service\n     */\n\n    function uri(uint256 tokenId) public view override returns (string memory) {\n        return metadataService.uri(tokenId);\n    }\n\n    /\n     * @notice Set the address of the upgradeContract of the contract. only admin can do this\n     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time\n     * to make the contract not upgradable.\n     * @param _upgradeAddress address of an upgraded contract\n     /\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)\n        public\n        onlyOwner\n    {\n        if (address(upgradeContract) != address(0)) {\n            registrar.setApprovalForAll(address(upgradeContract), false);\n            ens.setApprovalForAll(address(upgradeContract), false);\n        }\n\n        upgradeContract = _upgradeAddress;\n\n        if (address(upgradeContract) != address(0)) {\n            registrar.setApprovalForAll(address(upgradeContract), true);\n            ens.setApprovalForAll(address(upgradeContract), true);\n        }\n    }\n\n    /\n     * @notice Checks if msg.sender is the owner or approved by the owner of a name\n     * @param node namehash of the name to check\n     /\n\n    modifier onlyTokenOwner(bytes32 node) {\n        if (!isTokenOwnerOrApproved(node, msg.sender)) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        _;\n    }\n\n    /\n     * @notice Checks if owner or approved by owner\n     * @param node namehash of the name to check\n     * @param addr which address to check permissions for\n     * @return whether or not is owner or approved\n     */\n\n    function isTokenOwnerOrApproved(bytes32 node, address addr)\n        public\n        view\n        override\n        returns (bool)\n    {\n        address owner = ownerOf(uint256(node));\n        return owner == addr || isApprovedForAll(owner, addr);\n    }\n\n    /\n     * @notice Gets fuse permissions for a specific name\n     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit\n     *      The interface has predefined fuses for all registry permissions, but additional\n     *      fuses can be added for other use cases\n     *      Also returns expiry, which is when the fuses are set to expire.\n     * @param node namehash of the name to check\n     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry &lt; block.timestamp\n     * @return expiry Unix time of when the name expires and fuses are to expire\n     /\n    function getFuses(bytes32 node)\n        public\n        view\n        override\n        returns (uint32 fuses, uint64 expiry)\n    {\n        (, fuses, expiry) = getData(uint256(node));\n        if (fuses == 0 &amp;&amp; expiry == 0) {\n            bytes memory name = names[node];\n            if (name.length == 0) {\n                revert NameNotFound();\n            }\n        }\n    }\n\n    /\n     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract\n     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar\n     * @param label label as a string of the .eth domain to wrap\n     * @param wrappedOwner Owner of the name in this contract\n     * @param fuses initial fuses to set\n     * @param expiry when the fuses will expire\n     * @param resolver resolver contract address\n     /\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address resolver\n    ) public override returns (uint64) {\n        uint256 tokenId = uint256(keccak256(bytes(label)));\n        address registrant = registrar.ownerOf(tokenId);\n        if (\n            registrant != msg.sender &amp;&amp;\n            !isApprovedForAll(registrant, msg.sender) &amp;&amp;\n            !registrar.isApprovedForAll(registrant, msg.sender)\n        ) {\n            revert Unauthorised(\n                _makeNode(ETH_NODE, bytes32(tokenId)),\n                msg.sender\n            );\n        }\n\n        // transfer the token from the user to this contract\n        registrar.transferFrom(registrant, address(this), tokenId);\n\n        // transfer the ens record back to the new owner (this contract)\n        registrar.reclaim(tokenId, address(this));\n\n        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);\n    }\n\n    /\n     * @dev Registers a new .eth second-level domain and wraps it.\n     *      Only callable by authorised controllers.\n     * @param label The label to register (Eg, \'foo\' for \'foo.eth\').\n     * @param wrappedOwner The owner of the wrapped name.\n     * @param duration The duration, in seconds, to register the name for.\n     * @param resolver The resolver address to set on the ENS registry (optional).\n     * @param fuses initial fuses to set\n     * @param expiry when the fuses will expire\n     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.\n     */\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint32 fuses,\n        uint64 expiry\n    ) external override onlyController returns (uint256 registrarExpiry) {\n        uint256 tokenId = uint256(keccak256(bytes(label)));\n        registrarExpiry = registrar.register(tokenId, address(this), duration);\n        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);\n    }\n\n    /\n     * @dev Renews a .eth second-level domain.\n     *      Only callable by authorised controllers.\n     * @param tokenId The hash of the label to register (eg, keccak256(\'foo\'), for \'foo.eth\').\n     * @param duration The number of seconds to renew the name for.\n     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.\n     /\n    function renew(\n        uint256 tokenId,\n        uint256 duration,\n        uint64 expiry\n    ) external override onlyController returns (uint256 expires) {\n        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));\n\n        expires = registrar.renew(tokenId, duration);\n        (address owner, uint32 fuses, uint64 oldExpiry) = getData(\n            uint256(node)\n        );\n        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));\n\n        _setData(node, owner, fuses, expiry);\n    }\n\n    /\n     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner in the registry or an authorised caller in the registry\n     * @param name The name to wrap, in DNS format\n     * @param wrappedOwner Owner of the name in this contract\n     * @param resolver resolver contract address\n     /\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) public override {\n        (bytes32 labelhash, uint256 offset) = name.readLabel(0);\n        bytes32 parentNode = name.namehash(offset);\n        bytes32 node = _makeNode(parentNode, labelhash);\n\n        if (parentNode == ETH_NODE) {\n            revert IncompatibleParent();\n        }\n\n        address owner = ens.owner(node);\n\n        if (\n            owner != msg.sender &amp;&amp;\n            !isApprovedForAll(owner, msg.sender) &amp;&amp;\n            !ens.isApprovedForAll(owner, msg.sender)\n        ) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        if (resolver != address(0)) {\n            ens.setResolver(node, resolver);\n        }\n\n        ens.setOwner(node, address(this));\n\n        _wrap(node, name, wrappedOwner, 0, 0);\n    }\n\n    /\n     * @notice Unwraps a .eth domain. e.g. vitalik.eth\n     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper\n     * @param labelhash labelhash of the .eth domain\n     * @param newRegistrant sets the owner in the .eth registrar to this address\n     * @param newController sets the owner in the registry to this address\n     */\n\n    function unwrapETH2LD(\n        bytes32 labelhash,\n        address newRegistrant,\n        address newController\n    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {\n        _unwrap(_makeNode(ETH_NODE, labelhash), newController);\n        registrar.transferFrom(\n            address(this),\n            newRegistrant,\n            uint256(labelhash)\n        );\n    }\n\n    /\n     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper\n     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash(\'xyz\')\n     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256(\'vitalik\')\n     * @param newController sets the owner in the registry to this address\n     /\n\n    function unwrap(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        address newController\n    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {\n        if (parentNode == ETH_NODE) {\n            revert IncompatibleParent();\n        }\n        _unwrap(_makeNode(parentNode, labelhash), newController);\n    }\n\n    /\n     * @notice Sets fuses of a name\n     * @param node namehash of the name\n     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)\n     /\n\n    function setFuses(bytes32 node, uint32 fuses)\n        public\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_BURN_FUSES)\n        returns (uint32)\n    {\n        if (fuses &amp; PARENT_CANNOT_CONTROL != 0) {\n            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.\n            revert Unauthorised(node, msg.sender);\n        }\n\n        (address owner, uint32 oldFuses, uint64 expiry) = getData(\n            uint256(node)\n        );\n\n        fuses |= oldFuses;\n        _setFuses(node, owner, fuses, expiry);\n        return fuses;\n    }\n\n    /\n     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract\n     *     and burning the token of this contract\n     * @dev Can be called by the owner of the name in this contract\n     * @param label Label as a string of the .eth name to upgrade\n     * @param wrappedOwner The owner of the wrapped name\n     */\n\n    function upgradeETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        address resolver\n    ) public {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(ETH_NODE, labelhash);\n        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n\n        upgradeContract.wrapETH2LD(\n            label,\n            wrappedOwner,\n            fuses,\n            expiry,\n            resolver\n        );\n    }\n\n    /\n     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner or an authorised caller\n     * Requires upgraded Namewrapper to permit old Namewrapper to call setSubnodeRecord for all names\n     * @param parentNode namehash of the parent name\n     * @param label Label as a string of the name to upgrade\n     * @param wrappedOwner Owner of the name in this contract\n     * @param resolver resolver contract for this name\n     /\n\n    function upgrade(\n        bytes32 parentNode,\n        string calldata label,\n        address wrappedOwner,\n        address resolver\n    ) public {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n        upgradeContract.setSubnodeRecord(\n            parentNode,\n            label,\n            wrappedOwner,\n            resolver,\n            0,\n            fuses,\n            expiry\n        );\n    }\n\n    / @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name\n     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash(\'xyz\')\n     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256(\'vitalik\')\n     * @param fuses fuses to burn\n     * @param expiry when the fuses will expire\n     /\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) public {\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(\n            uint256(node)\n        );\n        uint64 maxExpiry;\n        if (parentNode == ETH_NODE) {\n            if (!isTokenOwnerOrApproved(node, msg.sender)) {\n                revert Unauthorised(node, msg.sender);\n            }\n            // max expiry is set to the expiry on the registrar\n            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));\n        } else {\n            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {\n                revert Unauthorised(node, msg.sender);\n            }\n\n            // max expiry is set to the expiry of the parent\n            (, , maxExpiry) = getData(uint256(parentNode));\n        }\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n\n        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed\n        if (\n            oldFuses &amp; PARENT_CANNOT_CONTROL != 0 &amp;&amp;\n            oldFuses | fuses != oldFuses\n        ) {\n            revert OperationProhibited(node);\n        }\n        fuses |= oldFuses;\n        _setFuses(node, owner, fuses, expiry);\n    }\n\n    /\n     * @notice Sets the subdomain owner in the registry and then wraps the subdomain\n     * @param parentNode parent namehash of the subdomain\n     * @param label label of the subdomain as a string\n     * @param newOwner newOwner in the registry\n     * @param fuses initial fuses for the wrapped subdomain\n     * @param expiry when the fuses will expire\n     /\n\n    function setSubnodeOwner(\n        bytes32 parentNode,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    )\n        public\n        onlyTokenOwner(parentNode)\n        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))\n        returns (bytes32 node)\n    {\n        bytes32 labelhash = keccak256(bytes(label));\n        node = _makeNode(parentNode, labelhash);\n        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);\n\n        if (ens.owner(node) != address(this)) {\n            ens.setSubnodeOwner(parentNode, labelhash, address(this));\n            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);\n        } else {\n            _transferAndBurnFuses(node, newOwner, fuses, expiry);\n        }\n    }\n\n    /\n     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain\n     * @param parentNode parent namehash of the subdomain\n     * @param label label of the subdomain as a string\n     * @param newOwner newOwner in the registry\n     * @param resolver resolver contract in the registry\n     * @param ttl ttl in the regsitry\n     * @param fuses initial fuses for the wrapped subdomain\n     * @param expiry expiry date for the domain\n     */\n\n    function setSubnodeRecord(\n        bytes32 parentNode,\n        string memory label,\n        address newOwner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    )\n        public\n        onlyTokenOwner(parentNode)\n        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))\n    {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);\n        if (ens.owner(node) != address(this)) {\n            ens.setSubnodeRecord(\n                parentNode,\n                labelhash,\n                address(this),\n                resolver,\n                ttl\n            );\n            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);\n        } else {\n            ens.setSubnodeRecord(\n                parentNode,\n                labelhash,\n                address(this),\n                resolver,\n                ttl\n            );\n            _transferAndBurnFuses(node, newOwner, fuses, expiry);\n        }\n    }\n\n    /\n     * @notice Sets records for the name in the ENS Registry\n     * @param node namehash of the name to set a record for\n     * @param owner newOwner in the registry\n     * @param resolver the resolver contract\n     * @param ttl ttl in the registry\n     /\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    )\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(\n            node,\n            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL\n        )\n    {\n        ens.setRecord(node, address(this), resolver, ttl);\n        (address oldOwner, , ) = getData(uint256(node));\n        _transfer(oldOwner, owner, uint256(node), 1, "");\n    }\n\n    /\n     * @notice Sets resolver contract in the registry\n     * @param node namehash of the name\n     * @param resolver the resolver contract\n     /\n\n    function setResolver(bytes32 node, address resolver)\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_SET_RESOLVER)\n    {\n        ens.setResolver(node, resolver);\n    }\n\n    /\n     * @notice Sets TTL in the registry\n     * @param node namehash of the name\n     * @param ttl TTL in the registry\n     */\n\n    function setTTL(bytes32 node, uint64 ttl)\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_SET_TTL)\n    {\n        ens.setTTL(node, ttl);\n    }\n\n    /\n     * @dev Allows an operation only if none of the specified fuses are burned.\n     * @param node The namehash of the name to check fuses on.\n     * @param fuseMask A bitmask of fuses that must not be burned.\n     /\n\n    modifier operationAllowed(bytes32 node, uint32 fuseMask) {\n        (, uint32 fuses, ) = getData(uint256(node));\n        if (fuses &amp; fuseMask != 0) {\n            revert OperationProhibited(node);\n        }\n        _;\n    }\n\n    /\n     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord\n     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt\n     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for\n     *      replacing a subdomain. If either conditions are true, then it is possible to call\n     *      setSubnodeOwner\n     * @param node namehash of the name to check\n     * @param labelhash labelhash of the name to check\n     /\n\n    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {\n        bytes32 subnode = makeNode(node, labelhash);\n        address owner = ens.owner(subnode);\n\n        if (owner == address(0)) {\n            (, uint32 fuses, ) = getData(uint256(node));\n            if (fuses &amp; CANNOT_CREATE_SUBDOMAIN != 0) {\n                revert OperationProhibited(node);\n            }\n        } else {\n            (, uint32 subnodeFuses, ) = getData(uint256(subnode));\n            if (subnodeFuses &amp; PARENT_CANNOT_CONTROL != 0) {\n                revert OperationProhibited(node);\n            }\n        }\n\n        ;\n    }\n\n    /*\n     * @notice Checks all Fuses in the mask are burned for the node\n     * @param node namehash of the name\n     * @param fuseMask the fuses you want to check\n     * @return Boolean of whether or not all the selected fuses are burned\n     /\n\n    function allFusesBurned(bytes32 node, uint32 fuseMask)\n        public\n        view\n        override\n        returns (bool)\n    {\n        (, uint32 fuses, ) = getData(uint256(node));\n        return fuses &amp; fuseMask == fuseMask;\n    }\n\n    function onERC721Received(\n        address to,\n        address,\n        uint256 tokenId,\n        bytes calldata data\n    ) public override returns (bytes4) {\n        //check if it\'s the eth registrar ERC721\n        if (msg.sender != address(registrar)) {\n            revert IncorrectTokenType();\n        }\n\n        (\n            string memory label,\n            address owner,\n            uint32 fuses,\n            uint64 expiry,\n            address resolver\n        ) = abi.decode(data, (string, address, uint32, uint64, address));\n\n        bytes32 labelhash = bytes32(tokenId);\n        bytes32 labelhashFromData = keccak256(bytes(label));\n\n        if (labelhashFromData != labelhash) {\n            revert LabelMismatch(labelhashFromData, labelhash);\n        }\n\n        // transfer the ens record back to the new owner (this contract)\n        registrar.reclaim(uint256(labelhash), address(this));\n\n        _wrapETH2LD(label, owner, fuses, expiry, resolver);\n\n        return IERC721Receiver(to).onERC721Received.selector;\n    }\n\n    /* Internal functions /\n\n    function _canTransfer(uint32 fuses) internal pure override returns (bool) {\n        return fuses &amp; CANNOT_TRANSFER == 0;\n    }\n\n    function _makeNode(bytes32 node, bytes32 labelhash)\n        private\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(node, labelhash));\n    }\n\n    function _addLabel(string memory label, bytes memory name)\n        internal\n        pure\n        returns (bytes memory ret)\n    {\n        if (bytes(label).length &lt; 1) {\n            revert LabelTooShort();\n        }\n        if (bytes(label).length &gt; 255) {\n            revert LabelTooLong(label);\n        }\n        return abi.encodePacked(uint8(bytes(label).length), label, name);\n    }\n\n    function _mint(\n        bytes32 node,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal override {\n        address oldWrappedOwner = ownerOf(uint256(node));\n        _canFusesBeBurned(node, fuses);\n        if (oldWrappedOwner != address(0)) {\n            // burn and unwrap old token of old owner\n            _burn(uint256(node));\n            emit NameUnwrapped(node, address(0));\n        }\n        super._mint(node, wrappedOwner, fuses, expiry);\n    }\n\n    function _wrap(\n        bytes32 node,\n        bytes memory name,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        names[node] = name;\n        _mint(node, wrappedOwner, fuses, expiry);\n        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);\n    }\n\n    function _addLabelAndWrap(\n        bytes32 parentNode,\n        bytes32 node,\n        string memory label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        bytes memory name = _addLabel(label, names[parentNode]);\n        _wrap(node, name, newOwner, fuses, expiry);\n    }\n\n    function _prepareUpgrade(bytes32 node)\n        private\n        returns (uint32 fuses, uint64 expiry)\n    {\n        if (address(upgradeContract) == address(0)) {\n            revert CannotUpgrade();\n        }\n\n        if (!isTokenOwnerOrApproved(node, msg.sender)) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        (fuses, expiry) = getFuses(node);\n\n        // burn token and fuse data\n        _burn(uint256(node));\n    }\n\n    function _transferAndBurnFuses(\n        bytes32 node,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        (address owner, , ) = getData(uint256(node));\n        _transfer(owner, newOwner, uint256(node), 1, "");\n        _setFuses(node, newOwner, fuses, expiry);\n    }\n\n    // wrapper function for stack limit\n    function _getDataAndNormaliseExpiry(\n        bytes32 parentNode,\n        bytes32 node,\n        uint64 expiry\n    )\n        internal\n        view\n        returns (\n            address owner,\n            uint32 fuses,\n            uint64\n        )\n    {\n        uint64 oldExpiry;\n        (owner, fuses, oldExpiry) = getData(uint256(node));\n        (, , uint64 maxExpiry) = getData(uint256(parentNode));\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n        return (owner, fuses, expiry);\n    }\n\n    function _getETH2LDDataAndNormaliseExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    )\n        internal\n        view\n        returns (\n            address owner,\n            uint32 fuses,\n            uint64\n        )\n    {\n        uint64 oldExpiry;\n        (owner, fuses, oldExpiry) = getData(uint256(node));\n        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n        return (owner, fuses, expiry);\n    }\n\n    function _normaliseExpiry(\n        uint64 expiry,\n        uint64 oldExpiry,\n        uint64 maxExpiry\n    ) internal pure returns (uint64) {\n        // Expiry cannot be more than maximum allowed\n        // .eth names will check registrar, non .eth check parent\n        if (expiry &gt; maxExpiry) {\n            expiry = maxExpiry;\n        }\n        // Expiry cannot be less than old expiry\n        if (expiry &lt; oldExpiry) {\n            expiry = oldExpiry;\n        }\n\n        return expiry;\n    }\n\n    function _wrapETH2LD(\n        string memory label,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address resolver\n    ) private returns (uint64) {\n        // Mint a new ERC1155 token with fuses\n        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(ETH_NODE, labelhash);\n\n        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(\n            node,\n            labelhash,\n            expiry\n        );\n\n        _addLabelAndWrap(\n            ETH_NODE,\n            node,\n            label,\n            wrappedOwner,\n            fuses | PARENT_CANNOT_CONTROL,\n            expiry\n        );\n        if (resolver != address(0)) {\n            ens.setResolver(node, resolver);\n        }\n\n        return expiry;\n    }\n\n    function _unwrap(bytes32 node, address newOwner) private {\n        if (newOwner == address(0x0) || newOwner == address(this)) {\n            revert IncorrectTargetOwner(newOwner);\n        }\n\n        if (allFusesBurned(node, CANNOT_UNWRAP)) {\n            revert OperationProhibited(node);\n        }\n\n        // Burn token and fuse data\n        _burn(uint256(node));\n        ens.setOwner(node, newOwner);\n\n        emit NameUnwrapped(node, newOwner);\n    }\n\n    function _setFuses(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        _setData(node, owner, fuses, expiry);\n        emit FusesSet(node, fuses, expiry);\n    }\n\n    function _setData(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        _canFusesBeBurned(node, fuses);\n        super._setData(uint256(node), owner, fuses, expiry);\n    }\n\n    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {\n        if (\n            fuses &amp; ~PARENT_CANNOT_CONTROL != 0 &amp;&amp;\n            fuses &amp; (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=\n            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)\n        ) {\n            revert OperationProhibited(node);\n        }\n    }\n}\n', 'ideas': ' 1', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-01-09 20:36:51 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | //SPDX-License-Identifier: MIT pragma solidity ^0.8.4; import "./ERC1155Fuse.sol"; import "./Controllable.sol"; import "./INameWrapper.sol"; import "./INameWrapperUpgrade.sol"; import "./IMetadataService.sol"; import "../registry/ENS.sol"; import "../ethregistrar/IBaseRegistrar.sol"; import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "./BytesUtil.sol"; error Unauthorised(bytes32 node, address addr); error NameNotFound(); error IncompatibleParent(); error IncompatibleName(bytes name); error IncorrectTokenType(); error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash); error LabelTooShort(); error LabelTooLong(string label); error IncorrectTargetOwner(address owner); error CannotUpgrade(); error InvalidExpiry(bytes32 node, uint64 expiry); contract NameWrapper is     Ownable,     ERC1155Fuse,     INameWrapper,     Controllable,     IERC721Receiver {     using BytesUtils for bytes;     ENS public immutable override ens;     IBaseRegistrar public immutable override registrar;     IMetadataService public override metadataService;     mapping(bytes32 =&gt; bytes) public override names; bytes32 private constant ETH_NODE =     0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae; bytes32 private constant ROOT_NODE =     0x0000000000000000000000000000000000000000000000000000000000000000;  //A contract address to a new upgraded contract if any INameWrapperUpgrade public upgradeContract; uint64 private constant MAX_EXPIRY = type(uint64).max;  constructor(     ENS _ens,     IBaseRegistrar _registrar,     IMetadataService _metadataService ) {     ens = _ens;     registrar = _registrar;     metadataService = _metadataService;      /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */      _setData(         uint256(ETH_NODE),         address(0),         uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),         MAX_EXPIRY     );     _setData(         uint256(ROOT_NODE),         address(0),         uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),         MAX_EXPIRY     );     names[ROOT_NODE] = "\x00";     names[ETH_NODE] = "\x03eth\x00"; }  function supportsInterface(bytes4 interfaceId)     public     view     virtual     override(ERC1155Fuse, IERC165)     returns (bool) {     return         interfaceId == type(INameWrapper).interfaceId ||         super.supportsInterface(interfaceId); }  /* ERC1155 */  function ownerOf(uint256 id)     public     view     override(ERC1155Fuse, INameWrapper)     returns (address owner) {     return super.ownerOf(id); }  /* Metadata service */  /**  * @notice Set the metadata service. Only the owner can do this  */  function setMetadataService(IMetadataService _newMetadataService)     public     onlyOwner {     metadataService = _newMetadataService; }  /**  * @notice Get the metadata uri  * @return String uri of the metadata service  */  function uri(uint256 tokenId) public view override returns (string memory) {     return metadataService.uri(tokenId); }  /**  * @notice Set the address of the upgradeContract of the contract. only admin can do this  * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time  * to make the contract not upgradable.  * @param _upgradeAddress address of an upgraded contract  */  function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)     public     onlyOwner {     if (address(upgradeContract) != address(0)) {         registrar.setApprovalForAll(address(upgradeContract), false);         ens.setApprovalForAll(address(upgradeContract), false);     }      upgradeContract = _upgradeAddress;      if (address(upgradeContract) != address(0)) {         registrar.setApprovalForAll(address(upgradeContract), true);         ens.setApprovalForAll(address(upgradeContract), true);     } }  /**  * @notice Checks if msg.sender is the owner or approved by the owner of a name  * @param node namehash of the name to check  */  modifier onlyTokenOwner(bytes32 node) {     if (!isTokenOwnerOrApproved(node, msg.sender)) {         revert Unauthorised(node, msg.sender);     }      _; }  /**  * @notice Checks if owner or approved by owner  * @param node namehash of the name to check  * @param addr which address to check permissions for  * @return whether or not is owner or approved  */  function isTokenOwnerOrApproved(bytes32 node, address addr)     public     view     override     returns (bool) {     address owner = ownerOf(uint256(node));     return owner == addr || isApprovedForAll(owner, addr); }  /**  * @notice Gets fuse permissions for a specific name  * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit  *      The interface has predefined fuses for all registry permissions, but additional  *      fuses can be added for other use cases  *      Also returns expiry, which is when the fuses are set to expire.  * @param node namehash of the name to check  * @return fuses A number that represents the permissions a name has. Returns 0 when expiry &lt; block.timestamp  * @return expiry Unix time of when the name expires and fuses are to expire  */ function getFuses(bytes32 node)     public     view     override     returns (uint32 fuses, uint64 expiry) {     (, fuses, expiry) = getData(uint256(node));     if (fuses == 0 &amp;&amp; expiry == 0) {         bytes memory name = names[node];         if (name.length == 0) {             revert NameNotFound();         }     } }  /**  * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract  * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar  * @param label label as a string of the .eth domain to wrap  * @param wrappedOwner Owner of the name in this contract  * @param fuses initial fuses to set  * @param expiry when the fuses will expire  * @param resolver resolver contract address  */  function wrapETH2LD(     string calldata label,     address wrappedOwner,     uint32 fuses,     uint64 expiry,     address resolver ) public override returns (uint64) {     uint256 tokenId = uint256(keccak256(bytes(label)));     address registrant = registrar.ownerOf(tokenId);     if (         registrant != msg.sender &amp;&amp;         !isApprovedForAll(registrant, msg.sender) &amp;&amp;         !registrar.isApprovedForAll(registrant, msg.sender)     ) {         revert Unauthorised(             _makeNode(ETH_NODE, bytes32(tokenId)),             msg.sender         );     }      // transfer the token from the user to this contract     registrar.transferFrom(registrant, address(this), tokenId);      // transfer the ens record back to the new owner (this contract)     registrar.reclaim(tokenId, address(this));      return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver); }  /**  * @dev Registers a new .eth second-level domain and wraps it.  *      Only callable by authorised controllers.  * @param label The label to register (Eg, 'foo' for 'foo.eth').  * @param wrappedOwner The owner of the wrapped name.  * @param duration The duration, in seconds, to register the name for.  * @param resolver The resolver address to set on the ENS registry (optional).  * @param fuses initial fuses to set  * @param expiry when the fuses will expire  * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.  */  function registerAndWrapETH2LD(     string calldata label,     address wrappedOwner,     uint256 duration,     address resolver,     uint32 fuses,     uint64 expiry ) external override onlyController returns (uint256 registrarExpiry) {     uint256 tokenId = uint256(keccak256(bytes(label)));     registrarExpiry = registrar.register(tokenId, address(this), duration);     _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver); }  /**  * @dev Renews a .eth second-level domain.  *      Only callable by authorised controllers.  * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').  * @param duration The number of seconds to renew the name for.  * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.  */ function renew(     uint256 tokenId,     uint256 duration,     uint64 expiry ) external override onlyController returns (uint256 expires) {     bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));      expires = registrar.renew(tokenId, duration);     (address owner, uint32 fuses, uint64 oldExpiry) = getData(         uint256(node)     );     expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));      _setData(node, owner, fuses, expiry); }  /**  * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner in the registry or an authorised caller in the registry  * @param name The name to wrap, in DNS format  * @param wrappedOwner Owner of the name in this contract  * @param resolver resolver contract address  */  function wrap(     bytes calldata name,     address wrappedOwner,     address resolver ) public override {     (bytes32 labelhash, uint256 offset) = name.readLabel(0);     bytes32 parentNode = name.namehash(offset);     bytes32 node = _makeNode(parentNode, labelhash);      if (parentNode == ETH_NODE) {         revert IncompatibleParent();     }      address owner = ens.owner(node);      if (         owner != msg.sender &amp;&amp;         !isApprovedForAll(owner, msg.sender) &amp;&amp;         !ens.isApprovedForAll(owner, msg.sender)     ) {         revert Unauthorised(node, msg.sender);     }      if (resolver != address(0)) {         ens.setResolver(node, resolver);     }      ens.setOwner(node, address(this));      _wrap(node, name, wrappedOwner, 0, 0); }  /**  * @notice Unwraps a .eth domain. e.g. vitalik.eth  * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper  * @param labelhash labelhash of the .eth domain  * @param newRegistrant sets the owner in the .eth registrar to this address  * @param newController sets the owner in the registry to this address  */  function unwrapETH2LD(     bytes32 labelhash,     address newRegistrant,     address newController ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {     _unwrap(_makeNode(ETH_NODE, labelhash), newController);     registrar.transferFrom(         address(this),         newRegistrant,         uint256(labelhash)     ); }  /**  * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper  * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')  * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')  * @param newController sets the owner in the registry to this address  */  function unwrap(     bytes32 parentNode,     bytes32 labelhash,     address newController ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {     if (parentNode == ETH_NODE) {         revert IncompatibleParent();     }     _unwrap(_makeNode(parentNode, labelhash), newController); }  /**  * @notice Sets fuses of a name  * @param node namehash of the name  * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)  */  function setFuses(bytes32 node, uint32 fuses)     public     onlyTokenOwner(node)     operationAllowed(node, CANNOT_BURN_FUSES)     returns (uint32) {     if (fuses &amp; PARENT_CANNOT_CONTROL != 0) {         // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.         revert Unauthorised(node, msg.sender);     }      (address owner, uint32 oldFuses, uint64 expiry) = getData(         uint256(node)     );      fuses |= oldFuses;     _setFuses(node, owner, fuses, expiry);     return fuses; }  /**  * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract  *     and burning the token of this contract  * @dev Can be called by the owner of the name in this contract  * @param label Label as a string of the .eth name to upgrade  * @param wrappedOwner The owner of the wrapped name  */  function upgradeETH2LD(     string calldata label,     address wrappedOwner,     address resolver ) public {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(ETH_NODE, labelhash);     (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);      upgradeContract.wrapETH2LD(         label,         wrappedOwner,         fuses,         expiry,         resolver     ); }  /**  * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain  * @dev Can be called by the owner or an authorised caller  * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names  * @param parentNode namehash of the parent name  * @param label Label as a string of the name to upgrade  * @param wrappedOwner Owner of the name in this contract  * @param resolver resolver contract for this name  */  function upgrade(     bytes32 parentNode,     string calldata label,     address wrappedOwner,     address resolver ) public {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(parentNode, labelhash);     (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);     upgradeContract.setSubnodeRecord(         parentNode,         label,         wrappedOwner,         resolver,         0,         fuses,         expiry     ); }  /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name  * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')  * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')  * @param fuses fuses to burn  * @param expiry when the fuses will expire  */  function setChildFuses(     bytes32 parentNode,     bytes32 labelhash,     uint32 fuses,     uint64 expiry ) public {     bytes32 node = _makeNode(parentNode, labelhash);     (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(         uint256(node)     );     uint64 maxExpiry;     if (parentNode == ETH_NODE) {         if (!isTokenOwnerOrApproved(node, msg.sender)) {             revert Unauthorised(node, msg.sender);         }         // max expiry is set to the expiry on the registrar         maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));     } else {         if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {             revert Unauthorised(node, msg.sender);         }          // max expiry is set to the expiry of the parent         (, , maxExpiry) = getData(uint256(parentNode));     }      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);      // if PARENT_CANNOT_CONTROL has been burned and fuses have changed     if (         oldFuses &amp; PARENT_CANNOT_CONTROL != 0 &amp;&amp;         oldFuses | fuses != oldFuses     ) {         revert OperationProhibited(node);     }     fuses |= oldFuses;     _setFuses(node, owner, fuses, expiry); }  /**  * @notice Sets the subdomain owner in the registry and then wraps the subdomain  * @param parentNode parent namehash of the subdomain  * @param label label of the subdomain as a string  * @param newOwner newOwner in the registry  * @param fuses initial fuses for the wrapped subdomain  * @param expiry when the fuses will expire  */  function setSubnodeOwner(     bytes32 parentNode,     string calldata label,     address newOwner,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))     returns (bytes32 node) {     bytes32 labelhash = keccak256(bytes(label));     node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);      if (ens.owner(node) != address(this)) {         ens.setSubnodeOwner(parentNode, labelhash, address(this));         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } }  /**  * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain  * @param parentNode parent namehash of the subdomain  * @param label label of the subdomain as a string  * @param newOwner newOwner in the registry  * @param resolver resolver contract in the registry  * @param ttl ttl in the regsitry  * @param fuses initial fuses for the wrapped subdomain  * @param expiry expiry date for the domain  */  function setSubnodeRecord(     bytes32 parentNode,     string memory label,     address newOwner,     address resolver,     uint64 ttl,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label))) {     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);     if (ens.owner(node) != address(this)) {         ens.setSubnodeRecord(             parentNode,             labelhash,             address(this),             resolver,             ttl         );         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         ens.setSubnodeRecord(             parentNode,             labelhash,             address(this),             resolver,             ttl         );         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } }  /**  * @notice Sets records for the name in the ENS Registry  * @param node namehash of the name to set a record for  * @param owner newOwner in the registry  * @param resolver the resolver contract  * @param ttl ttl in the registry  */  function setRecord(     bytes32 node,     address owner,     address resolver,     uint64 ttl )     public     override     onlyTokenOwner(node)     operationAllowed(         node,         CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL     ) {     ens.setRecord(node, address(this), resolver, ttl);     (address oldOwner, , ) = getData(uint256(node));     _transfer(oldOwner, owner, uint256(node), 1, ""); }  /**  * @notice Sets resolver contract in the registry  * @param node namehash of the name  * @param resolver the resolver contract  */  function setResolver(bytes32 node, address resolver)     public     override     onlyTokenOwner(node)     operationAllowed(node, CANNOT_SET_RESOLVER) {     ens.setResolver(node, resolver); }  /**  * @notice Sets TTL in the registry  * @param node namehash of the name  * @param ttl TTL in the registry  */  function setTTL(bytes32 node, uint64 ttl)     public     override     onlyTokenOwner(node)     operationAllowed(node, CANNOT_SET_TTL) {     ens.setTTL(node, ttl); }  /**  * @dev Allows an operation only if none of the specified fuses are burned.  * @param node The namehash of the name to check fuses on.  * @param fuseMask A bitmask of fuses that must not be burned.  */  modifier operationAllowed(bytes32 node, uint32 fuseMask) {     (, uint32 fuses, ) = getData(uint256(node));     if (fuses &amp; fuseMask != 0) {         revert OperationProhibited(node);     }     _; }  /**  * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord  * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt  *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for  *      replacing a subdomain. If either conditions are true, then it is possible to call  *      setSubnodeOwner  * @param node namehash of the name to check  * @param labelhash labelhash of the name to check  */  modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {     bytes32 subnode = _makeNode(node, labelhash);     address owner = ens.owner(subnode);      if (owner == address(0)) {         (, uint32 fuses, ) = getData(uint256(node));         if (fuses &amp; CANNOT_CREATE_SUBDOMAIN != 0) {             revert OperationProhibited(node);         }     } else {         (, uint32 subnodeFuses, ) = getData(uint256(subnode));         if (subnodeFuses &amp; PARENT_CANNOT_CONTROL != 0) {             revert OperationProhibited(node);         }     }      _; }  /**  * @notice Checks all Fuses in the mask are burned for the node  * @param node namehash of the name  * @param fuseMask the fuses you want to check  * @return Boolean of whether or not all the selected fuses are burned  */  function allFusesBurned(bytes32 node, uint32 fuseMask)     public     view     override     returns (bool) {     (, uint32 fuses, ) = getData(uint256(node));     return fuses &amp; fuseMask == fuseMask; }  function onERC721Received(     address to,     address,     uint256 tokenId,     bytes calldata data ) public override returns (bytes4) {     //check if it's the eth registrar ERC721     if (msg.sender != address(registrar)) {         revert IncorrectTokenType();     }      (         string memory label,         address owner,         uint32 fuses,         uint64 expiry,         address resolver     ) = abi.decode(data, (string, address, uint32, uint64, address));      bytes32 labelhash = bytes32(tokenId);     bytes32 labelhashFromData = keccak256(bytes(label));      if (labelhashFromData != labelhash) {         revert LabelMismatch(labelhashFromData, labelhash);     }      // transfer the ens record back to the new owner (this contract)     registrar.reclaim(uint256(labelhash), address(this));      _wrapETH2LD(label, owner, fuses, expiry, resolver);      return IERC721Receiver(to).onERC721Received.selector; }  /***** Internal functions */  function _canTransfer(uint32 fuses) internal pure override returns (bool) {     return fuses &amp; CANNOT_TRANSFER == 0; }  function _makeNode(bytes32 node, bytes32 labelhash)     private     pure     returns (bytes32) {     return keccak256(abi.encodePacked(node, labelhash)); }  function _addLabel(string memory label, bytes memory name)     internal     pure     returns (bytes memory ret) {     if (bytes(label).length &lt; 1) {         revert LabelTooShort();     }     if (bytes(label).length &gt; 255) {         revert LabelTooLong(label);     }     return abi.encodePacked(uint8(bytes(label).length), label, name); }  function _mint(     bytes32 node,     address wrappedOwner,     uint32 fuses,     uint64 expiry ) internal override {     address oldWrappedOwner = ownerOf(uint256(node));     _canFusesBeBurned(node, fuses);     if (oldWrappedOwner != address(0)) {         // burn and unwrap old token of old owner         _burn(uint256(node));         emit NameUnwrapped(node, address(0));     }     super._mint(node, wrappedOwner, fuses, expiry); }  function _wrap(     bytes32 node,     bytes memory name,     address wrappedOwner,     uint32 fuses,     uint64 expiry ) internal {     names[node] = name;     _mint(node, wrappedOwner, fuses, expiry);     emit NameWrapped(node, name, wrappedOwner, fuses, expiry); }  function _addLabelAndWrap(     bytes32 parentNode,     bytes32 node,     string memory label,     address newOwner,     uint32 fuses,     uint64 expiry ) internal {     bytes memory name = _addLabel(label, names[parentNode]);     _wrap(node, name, newOwner, fuses, expiry); }  function _prepareUpgrade(bytes32 node)     private     returns (uint32 fuses, uint64 expiry) {     if (address(upgradeContract) == address(0)) {         revert CannotUpgrade();     }      if (!isTokenOwnerOrApproved(node, msg.sender)) {         revert Unauthorised(node, msg.sender);     }      (fuses, expiry) = getFuses(node);      // burn token and fuse data     _burn(uint256(node)); }  function _transferAndBurnFuses(     bytes32 node,     address newOwner,     uint32 fuses,     uint64 expiry ) internal {     (address owner, , ) = getData(uint256(node));     _transfer(owner, newOwner, uint256(node), 1, "");     _setFuses(node, newOwner, fuses, expiry); }  // wrapper function for stack limit function _getDataAndNormaliseExpiry(     bytes32 parentNode,     bytes32 node,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     (, , uint64 maxExpiry) = getData(uint256(parentNode));      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); }  function _getETH2LDDataAndNormaliseExpiry(     bytes32 node,     bytes32 labelhash,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));      expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); }  function _normaliseExpiry(     uint64 expiry,     uint64 oldExpiry,     uint64 maxExpiry ) internal pure returns (uint64) {     // Expiry cannot be more than maximum allowed     // .eth names will check registrar, non .eth check parent     if (expiry &gt; maxExpiry) {         expiry = maxExpiry;     }     // Expiry cannot be less than old expiry     if (expiry &lt; oldExpiry) {         expiry = oldExpiry;     }      return expiry; }  function _wrapETH2LD(     string memory label,     address wrappedOwner,     uint32 fuses,     uint64 expiry,     address resolver ) private returns (uint64) {     // Mint a new ERC1155 token with fuses     // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD     bytes32 labelhash = keccak256(bytes(label));     bytes32 node = _makeNode(ETH_NODE, labelhash);      (, , expiry) = _getETH2LDDataAndNormaliseExpiry(         node,         labelhash,         expiry     );      _addLabelAndWrap(         ETH_NODE,         node,         label,         wrappedOwner,         fuses | PARENT_CANNOT_CONTROL,         expiry     );     if (resolver != address(0)) {         ens.setResolver(node, resolver);     }      return expiry; }  function _unwrap(bytes32 node, address newOwner) private {     if (newOwner == address(0x0) || newOwner == address(this)) {         revert IncorrectTargetOwner(newOwner);     }      if (allFusesBurned(node, CANNOT_UNWRAP)) {         revert OperationProhibited(node);     }      // Burn token and fuse data     _burn(uint256(node));     ens.setOwner(node, newOwner);      emit NameUnwrapped(node, newOwner); }  function _setFuses(     bytes32 node,     address owner,     uint32 fuses,     uint64 expiry ) internal {     _setData(node, owner, fuses, expiry);     emit FusesSet(node, fuses, expiry); }  function _setData(     bytes32 node,     address owner,     uint32 fuses,     uint64 expiry ) internal {     _canFusesBeBurned(node, fuses);     super._setData(uint256(node), owner, fuses, expiry); }  function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {     if (         fuses &amp; ~PARENT_CANNOT_CONTROL != 0 &amp;&amp;         fuses &amp; (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=         (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)     ) {         revert OperationProhibited(node);     } }  } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 20:36:51 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: //SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "./ERC1155Fuse.sol";
import "./Controllable.sol";
import "./INameWrapper.sol";
import "./INameWrapperUpgrade.sol";
import "./IMetadataService.sol";
import "../registry/ENS.sol";
import "../ethregistrar/IBaseRegistrar.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./BytesUtil.sol";

error Unauthorised(bytes32 node, address addr);
error NameNotFound();
error IncompatibleParent();
error IncompatibleName(bytes name);
error IncorrectTokenType();
error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);
error LabelTooShort();
error LabelTooLong(string label);
error IncorrectTargetOwner(address owner);
error CannotUpgrade();
error InvalidExpiry(bytes32 node, uint64 expiry);

contract NameWrapper is
    Ownable,
    ERC1155Fuse,
    INameWrapper,
    Controllable,
    IERC721Receiver
{
    using BytesUtils for bytes;
    ENS public immutable override ens;
    IBaseRegistrar public immutable override registrar;
    IMetadataService public override metadataService;
    mapping(bytes32 => bytes) public override names;

    bytes32 private constant ETH_NODE =
        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
    bytes32 private constant ROOT_NODE =
        0x0000000000000000000000000000000000000000000000000000000000000000;

    //A contract address to a new upgraded contract if any
    INameWrapperUpgrade public upgradeContract;
    uint64 private constant MAX_EXPIRY = type(uint64).max;

    constructor(
        ENS _ens,
        IBaseRegistrar _registrar,
        IMetadataService _metadataService
    ) {
        ens = _ens;
        registrar = _registrar;
        metadataService = _metadataService;

        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */

        _setData(
            uint256(ETH_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        _setData(
            uint256(ROOT_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        names[ROOT_NODE] = "\x00";
        names[ETH_NODE] = "\x03eth\x00";
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Fuse, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(INameWrapper).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /* ERC1155 */

    function ownerOf(uint256 id)
        public
        view
        override(ERC1155Fuse, INameWrapper)
        returns (address owner)
    {
        return super.ownerOf(id);
    }

    /* Metadata service */

    /**
     * @notice Set the metadata service. Only the owner can do this
     */

    function setMetadataService(IMetadataService _newMetadataService)
        public
        onlyOwner
    {
        metadataService = _newMetadataService;
    }

    /**
     * @notice Get the metadata uri
     * @return String uri of the metadata service
     */

    function uri(uint256 tokenId) public view override returns (string memory) {
        return metadataService.uri(tokenId);
    }

    /**
     * @notice Set the address of the upgradeContract of the contract. only admin can do this
     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time
     * to make the contract not upgradable.
     * @param _upgradeAddress address of an upgraded contract
     */

    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)
        public
        onlyOwner
    {
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), false);
            ens.setApprovalForAll(address(upgradeContract), false);
        }

        upgradeContract = _upgradeAddress;

        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), true);
            ens.setApprovalForAll(address(upgradeContract), true);
        }
    }

    /**
     * @notice Checks if msg.sender is the owner or approved by the owner of a name
     * @param node namehash of the name to check
     */

    modifier onlyTokenOwner(bytes32 node) {
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        _;
    }

    /**
     * @notice Checks if owner or approved by owner
     * @param node namehash of the name to check
     * @param addr which address to check permissions for
     * @return whether or not is owner or approved
     */

    function isTokenOwnerOrApproved(bytes32 node, address addr)
        public
        view
        override
        returns (bool)
    {
        address owner = ownerOf(uint256(node));
        return owner == addr || isApprovedForAll(owner, addr);
    }

    /**
     * @notice Gets fuse permissions for a specific name
     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit
     *      The interface has predefined fuses for all registry permissions, but additional
     *      fuses can be added for other use cases
     *      Also returns expiry, which is when the fuses are set to expire.
     * @param node namehash of the name to check
     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp
     * @return expiry Unix time of when the name expires and fuses are to expire
     */
    function getFuses(bytes32 node)
        public
        view
        override
        returns (uint32 fuses, uint64 expiry)
    {
        (, fuses, expiry) = getData(uint256(node));
        if (fuses == 0 && expiry == 0) {
            bytes memory name = names[node];
            if (name.length == 0) {
                revert NameNotFound();
            }
        }
    }

    /**
     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract
     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar
     * @param label label as a string of the .eth domain to wrap
     * @param wrappedOwner Owner of the name in this contract
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @param resolver resolver contract address
     */

    function wrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) public override returns (uint64) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        address registrant = registrar.ownerOf(tokenId);
        if (
            registrant != msg.sender &&
            !isApprovedForAll(registrant, msg.sender) &&
            !registrar.isApprovedForAll(registrant, msg.sender)
        ) {
            revert Unauthorised(
                _makeNode(ETH_NODE, bytes32(tokenId)),
                msg.sender
            );
        }

        // transfer the token from the user to this contract
        registrar.transferFrom(registrant, address(this), tokenId);

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(tokenId, address(this));

        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Registers a new .eth second-level domain and wraps it.
     *      Only callable by authorised controllers.
     * @param label The label to register (Eg, 'foo' for 'foo.eth').
     * @param wrappedOwner The owner of the wrapped name.
     * @param duration The duration, in seconds, to register the name for.
     * @param resolver The resolver address to set on the ENS registry (optional).
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.
     */

    function registerAndWrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint256 duration,
        address resolver,
        uint32 fuses,
        uint64 expiry
    ) external override onlyController returns (uint256 registrarExpiry) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        registrarExpiry = registrar.register(tokenId, address(this), duration);
        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Renews a .eth second-level domain.
     *      Only callable by authorised controllers.
     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').
     * @param duration The number of seconds to renew the name for.
     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.
     */
    function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));

        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));

        _setData(node, owner, fuses, expiry);
    }

    /**
     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the registry or an authorised caller in the registry
     * @param name The name to wrap, in DNS format
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract address
     */

    function wrap(
        bytes calldata name,
        address wrappedOwner,
        address resolver
    ) public override {
        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
        bytes32 parentNode = name.namehash(offset);
        bytes32 node = _makeNode(parentNode, labelhash);

        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }

        address owner = ens.owner(node);

        if (
            owner != msg.sender &&
            !isApprovedForAll(owner, msg.sender) &&
            !ens.isApprovedForAll(owner, msg.sender)
        ) {
            revert Unauthorised(node, msg.sender);
        }

        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        ens.setOwner(node, address(this));

        _wrap(node, name, wrappedOwner, 0, 0);
    }

    /**
     * @notice Unwraps a .eth domain. e.g. vitalik.eth
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param labelhash labelhash of the .eth domain
     * @param newRegistrant sets the owner in the .eth registrar to this address
     * @param newController sets the owner in the registry to this address
     */

    function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }

    /**
     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param newController sets the owner in the registry to this address
     */

    function unwrap(
        bytes32 parentNode,
        bytes32 labelhash,
        address newController
    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        _unwrap(_makeNode(parentNode, labelhash), newController);
    }

    /**
     * @notice Sets fuses of a name
     * @param node namehash of the name
     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)
     */

    function setFuses(bytes32 node, uint32 fuses)
        public
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_BURN_FUSES)
        returns (uint32)
    {
        if (fuses & PARENT_CANNOT_CONTROL != 0) {
            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.
            revert Unauthorised(node, msg.sender);
        }

        (address owner, uint32 oldFuses, uint64 expiry) = getData(
            uint256(node)
        );

        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
        return fuses;
    }

    /**
     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract
     *     and burning the token of this contract
     * @dev Can be called by the owner of the name in this contract
     * @param label Label as a string of the .eth name to upgrade
     * @param wrappedOwner The owner of the wrapped name
     */

    function upgradeETH2LD(
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);

        upgradeContract.wrapETH2LD(
            label,
            wrappedOwner,
            fuses,
            expiry,
            resolver
        );
    }

    /**
     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner or an authorised caller
     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names
     * @param parentNode namehash of the parent name
     * @param label Label as a string of the name to upgrade
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract for this name
     */

    function upgrade(
        bytes32 parentNode,
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.setSubnodeRecord(
            parentNode,
            label,
            wrappedOwner,
            resolver,
            0,
            fuses,
            expiry
        );
    }

    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param fuses fuses to burn
     * @param expiry when the fuses will expire
     */

    function setChildFuses(
        bytes32 parentNode,
        bytes32 labelhash,
        uint32 fuses,
        uint64 expiry
    ) public {
        bytes32 node = _makeNode(parentNode, labelhash);
        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        uint64 maxExpiry;
        if (parentNode == ETH_NODE) {
            if (!isTokenOwnerOrApproved(node, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            // max expiry is set to the expiry on the registrar
            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        } else {
            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }

            // max expiry is set to the expiry of the parent
            (, , maxExpiry) = getData(uint256(parentNode));
        }

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);

        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed
        if (
            oldFuses & PARENT_CANNOT_CONTROL != 0 &&
            oldFuses | fuses != oldFuses
        ) {
            revert OperationProhibited(node);
        }
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
    }

    /**
     * @notice Sets the subdomain owner in the registry and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry when the fuses will expire
     */

    function setSubnodeOwner(
        bytes32 parentNode,
        string calldata label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
        returns (bytes32 node)
    {
        bytes32 labelhash = keccak256(bytes(label));
        node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);

        if (ens.owner(node) != address(this)) {
            ens.setSubnodeOwner(parentNode, labelhash, address(this));
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param resolver resolver contract in the registry
     * @param ttl ttl in the regsitry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry expiry date for the domain
     */

    function setSubnodeRecord(
        bytes32 parentNode,
        string memory label,
        address newOwner,
        address resolver,
        uint64 ttl,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
    {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets records for the name in the ENS Registry
     * @param node namehash of the name to set a record for
     * @param owner newOwner in the registry
     * @param resolver the resolver contract
     * @param ttl ttl in the registry
     */

    function setRecord(
        bytes32 node,
        address owner,
        address resolver,
        uint64 ttl
    )
        public
        override
        onlyTokenOwner(node)
        operationAllowed(
            node,
            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL
        )
    {
        ens.setRecord(node, address(this), resolver, ttl);
        (address oldOwner, , ) = getData(uint256(node));
        _transfer(oldOwner, owner, uint256(node), 1, "");
    }

    /**
     * @notice Sets resolver contract in the registry
     * @param node namehash of the name
     * @param resolver the resolver contract
     */

    function setResolver(bytes32 node, address resolver)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_RESOLVER)
    {
        ens.setResolver(node, resolver);
    }

    /**
     * @notice Sets TTL in the registry
     * @param node namehash of the name
     * @param ttl TTL in the registry
     */

    function setTTL(bytes32 node, uint64 ttl)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_TTL)
    {
        ens.setTTL(node, ttl);
    }

    /**
     * @dev Allows an operation only if none of the specified fuses are burned.
     * @param node The namehash of the name to check fuses on.
     * @param fuseMask A bitmask of fuses that must not be burned.
     */

    modifier operationAllowed(bytes32 node, uint32 fuseMask) {
        (, uint32 fuses, ) = getData(uint256(node));
        if (fuses & fuseMask != 0) {
            revert OperationProhibited(node);
        }
        _;
    }

    /**
     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord
     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt
     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for
     *      replacing a subdomain. If either conditions are true, then it is possible to call
     *      setSubnodeOwner
     * @param node namehash of the name to check
     * @param labelhash labelhash of the name to check
     */

    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {
        bytes32 subnode = _makeNode(node, labelhash);
        address owner = ens.owner(subnode);

        if (owner == address(0)) {
            (, uint32 fuses, ) = getData(uint256(node));
            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {
                revert OperationProhibited(node);
            }
        } else {
            (, uint32 subnodeFuses, ) = getData(uint256(subnode));
            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {
                revert OperationProhibited(node);
            }
        }

        _;
    }

    /**
     * @notice Checks all Fuses in the mask are burned for the node
     * @param node namehash of the name
     * @param fuseMask the fuses you want to check
     * @return Boolean of whether or not all the selected fuses are burned
     */

    function allFusesBurned(bytes32 node, uint32 fuseMask)
        public
        view
        override
        returns (bool)
    {
        (, uint32 fuses, ) = getData(uint256(node));
        return fuses & fuseMask == fuseMask;
    }

    function onERC721Received(
        address to,
        address,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        //check if it's the eth registrar ERC721
        if (msg.sender != address(registrar)) {
            revert IncorrectTokenType();
        }

        (
            string memory label,
            address owner,
            uint32 fuses,
            uint64 expiry,
            address resolver
        ) = abi.decode(data, (string, address, uint32, uint64, address));

        bytes32 labelhash = bytes32(tokenId);
        bytes32 labelhashFromData = keccak256(bytes(label));

        if (labelhashFromData != labelhash) {
            revert LabelMismatch(labelhashFromData, labelhash);
        }

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(uint256(labelhash), address(this));

        _wrapETH2LD(label, owner, fuses, expiry, resolver);

        return IERC721Receiver(to).onERC721Received.selector;
    }

    /***** Internal functions */

    function _canTransfer(uint32 fuses) internal pure override returns (bool) {
        return fuses & CANNOT_TRANSFER == 0;
    }

    function _makeNode(bytes32 node, bytes32 labelhash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, labelhash));
    }

    function _addLabel(string memory label, bytes memory name)
        internal
        pure
        returns (bytes memory ret)
    {
        if (bytes(label).length < 1) {
            revert LabelTooShort();
        }
        if (bytes(label).length > 255) {
            revert LabelTooLong(label);
        }
        return abi.encodePacked(uint8(bytes(label).length), label, name);
    }

    function _mint(
        bytes32 node,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal override {
        address oldWrappedOwner = ownerOf(uint256(node));
        _canFusesBeBurned(node, fuses);
        if (oldWrappedOwner != address(0)) {
            // burn and unwrap old token of old owner
            _burn(uint256(node));
            emit NameUnwrapped(node, address(0));
        }
        super._mint(node, wrappedOwner, fuses, expiry);
    }

    function _wrap(
        bytes32 node,
        bytes memory name,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        names[node] = name;
        _mint(node, wrappedOwner, fuses, expiry);
        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);
    }

    function _addLabelAndWrap(
        bytes32 parentNode,
        bytes32 node,
        string memory label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        bytes memory name = _addLabel(label, names[parentNode]);
        _wrap(node, name, newOwner, fuses, expiry);
    }

    function _prepareUpgrade(bytes32 node)
        private
        returns (uint32 fuses, uint64 expiry)
    {
        if (address(upgradeContract) == address(0)) {
            revert CannotUpgrade();
        }

        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        (fuses, expiry) = getFuses(node);

        // burn token and fuse data
        _burn(uint256(node));
    }

    function _transferAndBurnFuses(
        bytes32 node,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        (address owner, , ) = getData(uint256(node));
        _transfer(owner, newOwner, uint256(node), 1, "");
        _setFuses(node, newOwner, fuses, expiry);
    }

    // wrapper function for stack limit
    function _getDataAndNormaliseExpiry(
        bytes32 parentNode,
        bytes32 node,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        (, , uint64 maxExpiry) = getData(uint256(parentNode));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _getETH2LDDataAndNormaliseExpiry(
        bytes32 node,
        bytes32 labelhash,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _normaliseExpiry(
        uint64 expiry,
        uint64 oldExpiry,
        uint64 maxExpiry
    ) internal pure returns (uint64) {
        // Expiry cannot be more than maximum allowed
        // .eth names will check registrar, non .eth check parent
        if (expiry > maxExpiry) {
            expiry = maxExpiry;
        }
        // Expiry cannot be less than old expiry
        if (expiry < oldExpiry) {
            expiry = oldExpiry;
        }

        return expiry;
    }

    function _wrapETH2LD(
        string memory label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) private returns (uint64) {
        // Mint a new ERC1155 token with fuses
        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);

        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(
            node,
            labelhash,
            expiry
        );

        _addLabelAndWrap(
            ETH_NODE,
            node,
            label,
            wrappedOwner,
            fuses | PARENT_CANNOT_CONTROL,
            expiry
        );
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        return expiry;
    }

    function _unwrap(bytes32 node, address newOwner) private {
        if (newOwner == address(0x0) || newOwner == address(this)) {
            revert IncorrectTargetOwner(newOwner);
        }

        if (allFusesBurned(node, CANNOT_UNWRAP)) {
            revert OperationProhibited(node);
        }

        // Burn token and fuse data
        _burn(uint256(node));
        ens.setOwner(node, newOwner);

        emit NameUnwrapped(node, newOwner);
    }

    function _setFuses(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _setData(node, owner, fuses, expiry);
        emit FusesSet(node, fuses, expiry);
    }

    function _setData(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _canFusesBeBurned(node, fuses);
        super._setData(uint256(node), owner, fuses, expiry);
    }

    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
        if (
            fuses & ~PARENT_CANNOT_CONTROL != 0 &&
            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
        ) {
            revert OperationProhibited(node);
        }
    }
}
.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "//SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "./ERC1155Fuse.sol";
import "./Controllable.sol";
import "./INameWrapper.sol";
import "./INameWrapperUpgrade.sol";
import "./IMetadataService.sol";
import "../registry/ENS.sol";
import "../ethregistrar/IBaseRegistrar.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./BytesUtil.sol";

error Unauthorised(bytes32 node, address addr);
error NameNotFound();
error IncompatibleParent();
error IncompatibleName(bytes name);
error IncorrectTokenType();
error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);
error LabelTooShort();
error LabelTooLong(string label);
error IncorrectTargetOwner(address owner);
error CannotUpgrade();
error InvalidExpiry(bytes32 node, uint64 expiry);

contract NameWrapper is
    Ownable,
    ERC1155Fuse,
    INameWrapper,
    Controllable,
    IERC721Receiver
{
    using BytesUtils for bytes;
    ENS public immutable override ens;
    IBaseRegistrar public immutable override registrar;
    IMetadataService public override metadataService;
    mapping(bytes32 => bytes) public override names;

    bytes32 private constant ETH_NODE =
        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
    bytes32 private constant ROOT_NODE =
        0x0000000000000000000000000000000000000000000000000000000000000000;

    //A contract address to a new upgraded contract if any
    INameWrapperUpgrade public upgradeContract;
    uint64 private constant MAX_EXPIRY = type(uint64).max;

    constructor(
        ENS _ens,
        IBaseRegistrar _registrar,
        IMetadataService _metadataService
    ) {
        ens = _ens;
        registrar = _registrar;
        metadataService = _metadataService;

        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */

        _setData(
            uint256(ETH_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        _setData(
            uint256(ROOT_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        names[ROOT_NODE] = "\x00";
        names[ETH_NODE] = "\x03eth\x00";
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Fuse, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(INameWrapper).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /* ERC1155 */

    function ownerOf(uint256 id)
        public
        view
        override(ERC1155Fuse, INameWrapper)
        returns (address owner)
    {
        return super.ownerOf(id);
    }

    /* Metadata service */

    /**
     * @notice Set the metadata service. Only the owner can do this
     */

    function setMetadataService(IMetadataService _newMetadataService)
        public
        onlyOwner
    {
        metadataService = _newMetadataService;
    }

    /**
     * @notice Get the metadata uri
     * @return String uri of the metadata service
     */

    function uri(uint256 tokenId) public view override returns (string memory) {
        return metadataService.uri(tokenId);
    }

    /**
     * @notice Set the address of the upgradeContract of the contract. only admin can do this
     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time
     * to make the contract not upgradable.
     * @param _upgradeAddress address of an upgraded contract
     */

    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)
        public
        onlyOwner
    {
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), false);
            ens.setApprovalForAll(address(upgradeContract), false);
        }

        upgradeContract = _upgradeAddress;

        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), true);
            ens.setApprovalForAll(address(upgradeContract), true);
        }
    }

    /**
     * @notice Checks if msg.sender is the owner or approved by the owner of a name
     * @param node namehash of the name to check
     */

    modifier onlyTokenOwner(bytes32 node) {
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        _;
    }

    /**
     * @notice Checks if owner or approved by owner
     * @param node namehash of the name to check
     * @param addr which address to check permissions for
     * @return whether or not is owner or approved
     */

    function isTokenOwnerOrApproved(bytes32 node, address addr)
        public
        view
        override
        returns (bool)
    {
        address owner = ownerOf(uint256(node));
        return owner == addr || isApprovedForAll(owner, addr);
    }

    /**
     * @notice Gets fuse permissions for a specific name
     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit
     *      The interface has predefined fuses for all registry permissions, but additional
     *      fuses can be added for other use cases
     *      Also returns expiry, which is when the fuses are set to expire.
     * @param node namehash of the name to check
     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp
     * @return expiry Unix time of when the name expires and fuses are to expire
     */
    function getFuses(bytes32 node)
        public
        view
        override
        returns (uint32 fuses, uint64 expiry)
    {
        (, fuses, expiry) = getData(uint256(node));
        if (fuses == 0 && expiry == 0) {
            bytes memory name = names[node];
            if (name.length == 0) {
                revert NameNotFound();
            }
        }
    }

    /**
     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract
     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar
     * @param label label as a string of the .eth domain to wrap
     * @param wrappedOwner Owner of the name in this contract
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @param resolver resolver contract address
     */

    function wrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) public override returns (uint64) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        address registrant = registrar.ownerOf(tokenId);
        if (
            registrant != msg.sender &&
            !isApprovedForAll(registrant, msg.sender) &&
            !registrar.isApprovedForAll(registrant, msg.sender)
        ) {
            revert Unauthorised(
                _makeNode(ETH_NODE, bytes32(tokenId)),
                msg.sender
            );
        }

        // transfer the token from the user to this contract
        registrar.transferFrom(registrant, address(this), tokenId);

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(tokenId, address(this));

        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Registers a new .eth second-level domain and wraps it.
     *      Only callable by authorised controllers.
     * @param label The label to register (Eg, 'foo' for 'foo.eth').
     * @param wrappedOwner The owner of the wrapped name.
     * @param duration The duration, in seconds, to register the name for.
     * @param resolver The resolver address to set on the ENS registry (optional).
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.
     */

    function registerAndWrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint256 duration,
        address resolver,
        uint32 fuses,
        uint64 expiry
    ) external override onlyController returns (uint256 registrarExpiry) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        registrarExpiry = registrar.register(tokenId, address(this), duration);
        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Renews a .eth second-level domain.
     *      Only callable by authorised controllers.
     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').
     * @param duration The number of seconds to renew the name for.
     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.
     */
    function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));

        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));

        _setData(node, owner, fuses, expiry);
    }

    /**
     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the registry or an authorised caller in the registry
     * @param name The name to wrap, in DNS format
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract address
     */

    function wrap(
        bytes calldata name,
        address wrappedOwner,
        address resolver
    ) public override {
        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
        bytes32 parentNode = name.namehash(offset);
        bytes32 node = _makeNode(parentNode, labelhash);

        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }

        address owner = ens.owner(node);

        if (
            owner != msg.sender &&
            !isApprovedForAll(owner, msg.sender) &&
            !ens.isApprovedForAll(owner, msg.sender)
        ) {
            revert Unauthorised(node, msg.sender);
        }

        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        ens.setOwner(node, address(this));

        _wrap(node, name, wrappedOwner, 0, 0);
    }

    /**
     * @notice Unwraps a .eth domain. e.g. vitalik.eth
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param labelhash labelhash of the .eth domain
     * @param newRegistrant sets the owner in the .eth registrar to this address
     * @param newController sets the owner in the registry to this address
     */

    function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }

    /**
     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param newController sets the owner in the registry to this address
     */

    function unwrap(
        bytes32 parentNode,
        bytes32 labelhash,
        address newController
    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        _unwrap(_makeNode(parentNode, labelhash), newController);
    }

    /**
     * @notice Sets fuses of a name
     * @param node namehash of the name
     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)
     */

    function setFuses(bytes32 node, uint32 fuses)
        public
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_BURN_FUSES)
        returns (uint32)
    {
        if (fuses & PARENT_CANNOT_CONTROL != 0) {
            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.
            revert Unauthorised(node, msg.sender);
        }

        (address owner, uint32 oldFuses, uint64 expiry) = getData(
            uint256(node)
        );

        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
        return fuses;
    }

    /**
     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract
     *     and burning the token of this contract
     * @dev Can be called by the owner of the name in this contract
     * @param label Label as a string of the .eth name to upgrade
     * @param wrappedOwner The owner of the wrapped name
     */

    function upgradeETH2LD(
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);

        upgradeContract.wrapETH2LD(
            label,
            wrappedOwner,
            fuses,
            expiry,
            resolver
        );
    }

    /**
     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner or an authorised caller
     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names
     * @param parentNode namehash of the parent name
     * @param label Label as a string of the name to upgrade
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract for this name
     */

    function upgrade(
        bytes32 parentNode,
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.setSubnodeRecord(
            parentNode,
            label,
            wrappedOwner,
            resolver,
            0,
            fuses,
            expiry
        );
    }

    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param fuses fuses to burn
     * @param expiry when the fuses will expire
     */

    function setChildFuses(
        bytes32 parentNode,
        bytes32 labelhash,
        uint32 fuses,
        uint64 expiry
    ) public {
        bytes32 node = _makeNode(parentNode, labelhash);
        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        uint64 maxExpiry;
        if (parentNode == ETH_NODE) {
            if (!isTokenOwnerOrApproved(node, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            // max expiry is set to the expiry on the registrar
            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        } else {
            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }

            // max expiry is set to the expiry of the parent
            (, , maxExpiry) = getData(uint256(parentNode));
        }

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);

        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed
        if (
            oldFuses & PARENT_CANNOT_CONTROL != 0 &&
            oldFuses | fuses != oldFuses
        ) {
            revert OperationProhibited(node);
        }
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
    }

    /**
     * @notice Sets the subdomain owner in the registry and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry when the fuses will expire
     */

    function setSubnodeOwner(
        bytes32 parentNode,
        string calldata label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
        returns (bytes32 node)
    {
        bytes32 labelhash = keccak256(bytes(label));
        node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);

        if (ens.owner(node) != address(this)) {
            ens.setSubnodeOwner(parentNode, labelhash, address(this));
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param resolver resolver contract in the registry
     * @param ttl ttl in the regsitry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry expiry date for the domain
     */

    function setSubnodeRecord(
        bytes32 parentNode,
        string memory label,
        address newOwner,
        address resolver,
        uint64 ttl,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
    {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets records for the name in the ENS Registry
     * @param node namehash of the name to set a record for
     * @param owner newOwner in the registry
     * @param resolver the resolver contract
     * @param ttl ttl in the registry
     */

    function setRecord(
        bytes32 node,
        address owner,
        address resolver,
        uint64 ttl
    )
        public
        override
        onlyTokenOwner(node)
        operationAllowed(
            node,
            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL
        )
    {
        ens.setRecord(node, address(this), resolver, ttl);
        (address oldOwner, , ) = getData(uint256(node));
        _transfer(oldOwner, owner, uint256(node), 1, "");
    }

    /**
     * @notice Sets resolver contract in the registry
     * @param node namehash of the name
     * @param resolver the resolver contract
     */

    function setResolver(bytes32 node, address resolver)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_RESOLVER)
    {
        ens.setResolver(node, resolver);
    }

    /**
     * @notice Sets TTL in the registry
     * @param node namehash of the name
     * @param ttl TTL in the registry
     */

    function setTTL(bytes32 node, uint64 ttl)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_TTL)
    {
        ens.setTTL(node, ttl);
    }

    /**
     * @dev Allows an operation only if none of the specified fuses are burned.
     * @param node The namehash of the name to check fuses on.
     * @param fuseMask A bitmask of fuses that must not be burned.
     */

    modifier operationAllowed(bytes32 node, uint32 fuseMask) {
        (, uint32 fuses, ) = getData(uint256(node));
        if (fuses & fuseMask != 0) {
            revert OperationProhibited(node);
        }
        _;
    }

    /**
     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord
     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt
     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for
     *      replacing a subdomain. If either conditions are true, then it is possible to call
     *      setSubnodeOwner
     * @param node namehash of the name to check
     * @param labelhash labelhash of the name to check
     */

    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {
        bytes32 subnode = _makeNode(node, labelhash);
        address owner = ens.owner(subnode);

        if (owner == address(0)) {
            (, uint32 fuses, ) = getData(uint256(node));
            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {
                revert OperationProhibited(node);
            }
        } else {
            (, uint32 subnodeFuses, ) = getData(uint256(subnode));
            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {
                revert OperationProhibited(node);
            }
        }

        _;
    }

    /**
     * @notice Checks all Fuses in the mask are burned for the node
     * @param node namehash of the name
     * @param fuseMask the fuses you want to check
     * @return Boolean of whether or not all the selected fuses are burned
     */

    function allFusesBurned(bytes32 node, uint32 fuseMask)
        public
        view
        override
        returns (bool)
    {
        (, uint32 fuses, ) = getData(uint256(node));
        return fuses & fuseMask == fuseMask;
    }

    function onERC721Received(
        address to,
        address,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        //check if it's the eth registrar ERC721
        if (msg.sender != address(registrar)) {
            revert IncorrectTokenType();
        }

        (
            string memory label,
            address owner,
            uint32 fuses,
            uint64 expiry,
            address resolver
        ) = abi.decode(data, (string, address, uint32, uint64, address));

        bytes32 labelhash = bytes32(tokenId);
        bytes32 labelhashFromData = keccak256(bytes(label));

        if (labelhashFromData != labelhash) {
            revert LabelMismatch(labelhashFromData, labelhash);
        }

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(uint256(labelhash), address(this));

        _wrapETH2LD(label, owner, fuses, expiry, resolver);

        return IERC721Receiver(to).onERC721Received.selector;
    }

    /***** Internal functions */

    function _canTransfer(uint32 fuses) internal pure override returns (bool) {
        return fuses & CANNOT_TRANSFER == 0;
    }

    function _makeNode(bytes32 node, bytes32 labelhash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, labelhash));
    }

    function _addLabel(string memory label, bytes memory name)
        internal
        pure
        returns (bytes memory ret)
    {
        if (bytes(label).length < 1) {
            revert LabelTooShort();
        }
        if (bytes(label).length > 255) {
            revert LabelTooLong(label);
        }
        return abi.encodePacked(uint8(bytes(label).length), label, name);
    }

    function _mint(
        bytes32 node,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal override {
        address oldWrappedOwner = ownerOf(uint256(node));
        _canFusesBeBurned(node, fuses);
        if (oldWrappedOwner != address(0)) {
            // burn and unwrap old token of old owner
            _burn(uint256(node));
            emit NameUnwrapped(node, address(0));
        }
        super._mint(node, wrappedOwner, fuses, expiry);
    }

    function _wrap(
        bytes32 node,
        bytes memory name,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        names[node] = name;
        _mint(node, wrappedOwner, fuses, expiry);
        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);
    }

    function _addLabelAndWrap(
        bytes32 parentNode,
        bytes32 node,
        string memory label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        bytes memory name = _addLabel(label, names[parentNode]);
        _wrap(node, name, newOwner, fuses, expiry);
    }

    function _prepareUpgrade(bytes32 node)
        private
        returns (uint32 fuses, uint64 expiry)
    {
        if (address(upgradeContract) == address(0)) {
            revert CannotUpgrade();
        }

        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        (fuses, expiry) = getFuses(node);

        // burn token and fuse data
        _burn(uint256(node));
    }

    function _transferAndBurnFuses(
        bytes32 node,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        (address owner, , ) = getData(uint256(node));
        _transfer(owner, newOwner, uint256(node), 1, "");
        _setFuses(node, newOwner, fuses, expiry);
    }

    // wrapper function for stack limit
    function _getDataAndNormaliseExpiry(
        bytes32 parentNode,
        bytes32 node,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        (, , uint64 maxExpiry) = getData(uint256(parentNode));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _getETH2LDDataAndNormaliseExpiry(
        bytes32 node,
        bytes32 labelhash,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _normaliseExpiry(
        uint64 expiry,
        uint64 oldExpiry,
        uint64 maxExpiry
    ) internal pure returns (uint64) {
        // Expiry cannot be more than maximum allowed
        // .eth names will check registrar, non .eth check parent
        if (expiry > maxExpiry) {
            expiry = maxExpiry;
        }
        // Expiry cannot be less than old expiry
        if (expiry < oldExpiry) {
            expiry = oldExpiry;
        }

        return expiry;
    }

    function _wrapETH2LD(
        string memory label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) private returns (uint64) {
        // Mint a new ERC1155 token with fuses
        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);

        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(
            node,
            labelhash,
            expiry
        );

        _addLabelAndWrap(
            ETH_NODE,
            node,
            label,
            wrappedOwner,
            fuses | PARENT_CANNOT_CONTROL,
            expiry
        );
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        return expiry;
    }

    function _unwrap(bytes32 node, address newOwner) private {
        if (newOwner == address(0x0) || newOwner == address(this)) {
            revert IncorrectTargetOwner(newOwner);
        }

        if (allFusesBurned(node, CANNOT_UNWRAP)) {
            revert OperationProhibited(node);
        }

        // Burn token and fuse data
        _burn(uint256(node));
        ens.setOwner(node, newOwner);

        emit NameUnwrapped(node, newOwner);
    }

    function _setFuses(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _setData(node, owner, fuses, expiry);
        emit FusesSet(node, fuses, expiry);
    }

    function _setData(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _canFusesBeBurned(node, fuses);
        super._setData(uint256(node), owner, fuses, expiry);
    }

    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
        if (
            fuses & ~PARENT_CANNOT_CONTROL != 0 &&
            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
        ) {
            revert OperationProhibited(node);
        }
    }
}
".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

[2024-01-09 20:36:53 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 20:36:53 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 14277
completion_tokens: 1
total_tokens: 14278
cost: $0.042835


[2024-01-09 20:36:53 INFO] Security Testing Engineer: **Security Testing Engineer<->Solidity Programming Expert on : TestBugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: //SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "./ERC1155Fuse.sol";
import "./Controllable.sol";
import "./INameWrapper.sol";
import "./INameWrapperUpgrade.sol";
import "./IMetadataService.sol";
import "../registry/ENS.sol";
import "../ethregistrar/IBaseRegistrar.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./BytesUtil.sol";

error Unauthorised(bytes32 node, address addr);
error NameNotFound();
error IncompatibleParent();
error IncompatibleName(bytes name);
error IncorrectTokenType();
error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);
error LabelTooShort();
error LabelTooLong(string label);
error IncorrectTargetOwner(address owner);
error CannotUpgrade();
error InvalidExpiry(bytes32 node, uint64 expiry);

contract NameWrapper is
    Ownable,
    ERC1155Fuse,
    INameWrapper,
    Controllable,
    IERC721Receiver
{
    using BytesUtils for bytes;
    ENS public immutable override ens;
    IBaseRegistrar public immutable override registrar;
    IMetadataService public override metadataService;
    mapping(bytes32 => bytes) public override names;

    bytes32 private constant ETH_NODE =
        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
    bytes32 private constant ROOT_NODE =
        0x0000000000000000000000000000000000000000000000000000000000000000;

    //A contract address to a new upgraded contract if any
    INameWrapperUpgrade public upgradeContract;
    uint64 private constant MAX_EXPIRY = type(uint64).max;

    constructor(
        ENS _ens,
        IBaseRegistrar _registrar,
        IMetadataService _metadataService
    ) {
        ens = _ens;
        registrar = _registrar;
        metadataService = _metadataService;

        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */

        _setData(
            uint256(ETH_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        _setData(
            uint256(ROOT_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        names[ROOT_NODE] = "\x00";
        names[ETH_NODE] = "\x03eth\x00";
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Fuse, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(INameWrapper).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /* ERC1155 */

    function ownerOf(uint256 id)
        public
        view
        override(ERC1155Fuse, INameWrapper)
        returns (address owner)
    {
        return super.ownerOf(id);
    }

    /* Metadata service */

    /**
     * @notice Set the metadata service. Only the owner can do this
     */

    function setMetadataService(IMetadataService _newMetadataService)
        public
        onlyOwner
    {
        metadataService = _newMetadataService;
    }

    /**
     * @notice Get the metadata uri
     * @return String uri of the metadata service
     */

    function uri(uint256 tokenId) public view override returns (string memory) {
        return metadataService.uri(tokenId);
    }

    /**
     * @notice Set the address of the upgradeContract of the contract. only admin can do this
     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time
     * to make the contract not upgradable.
     * @param _upgradeAddress address of an upgraded contract
     */

    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)
        public
        onlyOwner
    {
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), false);
            ens.setApprovalForAll(address(upgradeContract), false);
        }

        upgradeContract = _upgradeAddress;

        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), true);
            ens.setApprovalForAll(address(upgradeContract), true);
        }
    }

    /**
     * @notice Checks if msg.sender is the owner or approved by the owner of a name
     * @param node namehash of the name to check
     */

    modifier onlyTokenOwner(bytes32 node) {
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        _;
    }

    /**
     * @notice Checks if owner or approved by owner
     * @param node namehash of the name to check
     * @param addr which address to check permissions for
     * @return whether or not is owner or approved
     */

    function isTokenOwnerOrApproved(bytes32 node, address addr)
        public
        view
        override
        returns (bool)
    {
        address owner = ownerOf(uint256(node));
        return owner == addr || isApprovedForAll(owner, addr);
    }

    /**
     * @notice Gets fuse permissions for a specific name
     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit
     *      The interface has predefined fuses for all registry permissions, but additional
     *      fuses can be added for other use cases
     *      Also returns expiry, which is when the fuses are set to expire.
     * @param node namehash of the name to check
     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp
     * @return expiry Unix time of when the name expires and fuses are to expire
     */
    function getFuses(bytes32 node)
        public
        view
        override
        returns (uint32 fuses, uint64 expiry)
    {
        (, fuses, expiry) = getData(uint256(node));
        if (fuses == 0 && expiry == 0) {
            bytes memory name = names[node];
            if (name.length == 0) {
                revert NameNotFound();
            }
        }
    }

    /**
     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract
     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar
     * @param label label as a string of the .eth domain to wrap
     * @param wrappedOwner Owner of the name in this contract
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @param resolver resolver contract address
     */

    function wrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) public override returns (uint64) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        address registrant = registrar.ownerOf(tokenId);
        if (
            registrant != msg.sender &&
            !isApprovedForAll(registrant, msg.sender) &&
            !registrar.isApprovedForAll(registrant, msg.sender)
        ) {
            revert Unauthorised(
                _makeNode(ETH_NODE, bytes32(tokenId)),
                msg.sender
            );
        }

        // transfer the token from the user to this contract
        registrar.transferFrom(registrant, address(this), tokenId);

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(tokenId, address(this));

        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Registers a new .eth second-level domain and wraps it.
     *      Only callable by authorised controllers.
     * @param label The label to register (Eg, 'foo' for 'foo.eth').
     * @param wrappedOwner The owner of the wrapped name.
     * @param duration The duration, in seconds, to register the name for.
     * @param resolver The resolver address to set on the ENS registry (optional).
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.
     */

    function registerAndWrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint256 duration,
        address resolver,
        uint32 fuses,
        uint64 expiry
    ) external override onlyController returns (uint256 registrarExpiry) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        registrarExpiry = registrar.register(tokenId, address(this), duration);
        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Renews a .eth second-level domain.
     *      Only callable by authorised controllers.
     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').
     * @param duration The number of seconds to renew the name for.
     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.
     */
    function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));

        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));

        _setData(node, owner, fuses, expiry);
    }

    /**
     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the registry or an authorised caller in the registry
     * @param name The name to wrap, in DNS format
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract address
     */

    function wrap(
        bytes calldata name,
        address wrappedOwner,
        address resolver
    ) public override {
        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
        bytes32 parentNode = name.namehash(offset);
        bytes32 node = _makeNode(parentNode, labelhash);

        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }

        address owner = ens.owner(node);

        if (
            owner != msg.sender &&
            !isApprovedForAll(owner, msg.sender) &&
            !ens.isApprovedForAll(owner, msg.sender)
        ) {
            revert Unauthorised(node, msg.sender);
        }

        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        ens.setOwner(node, address(this));

        _wrap(node, name, wrappedOwner, 0, 0);
    }

    /**
     * @notice Unwraps a .eth domain. e.g. vitalik.eth
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param labelhash labelhash of the .eth domain
     * @param newRegistrant sets the owner in the .eth registrar to this address
     * @param newController sets the owner in the registry to this address
     */

    function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }

    /**
     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param newController sets the owner in the registry to this address
     */

    function unwrap(
        bytes32 parentNode,
        bytes32 labelhash,
        address newController
    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        _unwrap(_makeNode(parentNode, labelhash), newController);
    }

    /**
     * @notice Sets fuses of a name
     * @param node namehash of the name
     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)
     */

    function setFuses(bytes32 node, uint32 fuses)
        public
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_BURN_FUSES)
        returns (uint32)
    {
        if (fuses & PARENT_CANNOT_CONTROL != 0) {
            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.
            revert Unauthorised(node, msg.sender);
        }

        (address owner, uint32 oldFuses, uint64 expiry) = getData(
            uint256(node)
        );

        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
        return fuses;
    }

    /**
     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract
     *     and burning the token of this contract
     * @dev Can be called by the owner of the name in this contract
     * @param label Label as a string of the .eth name to upgrade
     * @param wrappedOwner The owner of the wrapped name
     */

    function upgradeETH2LD(
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);

        upgradeContract.wrapETH2LD(
            label,
            wrappedOwner,
            fuses,
            expiry,
            resolver
        );
    }

    /**
     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner or an authorised caller
     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names
     * @param parentNode namehash of the parent name
     * @param label Label as a string of the name to upgrade
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract for this name
     */

    function upgrade(
        bytes32 parentNode,
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.setSubnodeRecord(
            parentNode,
            label,
            wrappedOwner,
            resolver,
            0,
            fuses,
            expiry
        );
    }

    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param fuses fuses to burn
     * @param expiry when the fuses will expire
     */

    function setChildFuses(
        bytes32 parentNode,
        bytes32 labelhash,
        uint32 fuses,
        uint64 expiry
    ) public {
        bytes32 node = _makeNode(parentNode, labelhash);
        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        uint64 maxExpiry;
        if (parentNode == ETH_NODE) {
            if (!isTokenOwnerOrApproved(node, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            // max expiry is set to the expiry on the registrar
            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        } else {
            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }

            // max expiry is set to the expiry of the parent
            (, , maxExpiry) = getData(uint256(parentNode));
        }

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);

        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed
        if (
            oldFuses & PARENT_CANNOT_CONTROL != 0 &&
            oldFuses | fuses != oldFuses
        ) {
            revert OperationProhibited(node);
        }
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
    }

    /**
     * @notice Sets the subdomain owner in the registry and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry when the fuses will expire
     */

    function setSubnodeOwner(
        bytes32 parentNode,
        string calldata label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
        returns (bytes32 node)
    {
        bytes32 labelhash = keccak256(bytes(label));
        node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);

        if (ens.owner(node) != address(this)) {
            ens.setSubnodeOwner(parentNode, labelhash, address(this));
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param resolver resolver contract in the registry
     * @param ttl ttl in the regsitry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry expiry date for the domain
     */

    function setSubnodeRecord(
        bytes32 parentNode,
        string memory label,
        address newOwner,
        address resolver,
        uint64 ttl,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
    {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets records for the name in the ENS Registry
     * @param node namehash of the name to set a record for
     * @param owner newOwner in the registry
     * @param resolver the resolver contract
     * @param ttl ttl in the registry
     */

    function setRecord(
        bytes32 node,
        address owner,
        address resolver,
        uint64 ttl
    )
        public
        override
        onlyTokenOwner(node)
        operationAllowed(
            node,
            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL
        )
    {
        ens.setRecord(node, address(this), resolver, ttl);
        (address oldOwner, , ) = getData(uint256(node));
        _transfer(oldOwner, owner, uint256(node), 1, "");
    }

    /**
     * @notice Sets resolver contract in the registry
     * @param node namehash of the name
     * @param resolver the resolver contract
     */

    function setResolver(bytes32 node, address resolver)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_RESOLVER)
    {
        ens.setResolver(node, resolver);
    }

    /**
     * @notice Sets TTL in the registry
     * @param node namehash of the name
     * @param ttl TTL in the registry
     */

    function setTTL(bytes32 node, uint64 ttl)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_TTL)
    {
        ens.setTTL(node, ttl);
    }

    /**
     * @dev Allows an operation only if none of the specified fuses are burned.
     * @param node The namehash of the name to check fuses on.
     * @param fuseMask A bitmask of fuses that must not be burned.
     */

    modifier operationAllowed(bytes32 node, uint32 fuseMask) {
        (, uint32 fuses, ) = getData(uint256(node));
        if (fuses & fuseMask != 0) {
            revert OperationProhibited(node);
        }
        _;
    }

    /**
     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord
     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt
     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for
     *      replacing a subdomain. If either conditions are true, then it is possible to call
     *      setSubnodeOwner
     * @param node namehash of the name to check
     * @param labelhash labelhash of the name to check
     */

    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {
        bytes32 subnode = _makeNode(node, labelhash);
        address owner = ens.owner(subnode);

        if (owner == address(0)) {
            (, uint32 fuses, ) = getData(uint256(node));
            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {
                revert OperationProhibited(node);
            }
        } else {
            (, uint32 subnodeFuses, ) = getData(uint256(subnode));
            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {
                revert OperationProhibited(node);
            }
        }

        _;
    }

    /**
     * @notice Checks all Fuses in the mask are burned for the node
     * @param node namehash of the name
     * @param fuseMask the fuses you want to check
     * @return Boolean of whether or not all the selected fuses are burned
     */

    function allFusesBurned(bytes32 node, uint32 fuseMask)
        public
        view
        override
        returns (bool)
    {
        (, uint32 fuses, ) = getData(uint256(node));
        return fuses & fuseMask == fuseMask;
    }

    function onERC721Received(
        address to,
        address,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        //check if it's the eth registrar ERC721
        if (msg.sender != address(registrar)) {
            revert IncorrectTokenType();
        }

        (
            string memory label,
            address owner,
            uint32 fuses,
            uint64 expiry,
            address resolver
        ) = abi.decode(data, (string, address, uint32, uint64, address));

        bytes32 labelhash = bytes32(tokenId);
        bytes32 labelhashFromData = keccak256(bytes(label));

        if (labelhashFromData != labelhash) {
            revert LabelMismatch(labelhashFromData, labelhash);
        }

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(uint256(labelhash), address(this));

        _wrapETH2LD(label, owner, fuses, expiry, resolver);

        return IERC721Receiver(to).onERC721Received.selector;
    }

    /***** Internal functions */

    function _canTransfer(uint32 fuses) internal pure override returns (bool) {
        return fuses & CANNOT_TRANSFER == 0;
    }

    function _makeNode(bytes32 node, bytes32 labelhash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, labelhash));
    }

    function _addLabel(string memory label, bytes memory name)
        internal
        pure
        returns (bytes memory ret)
    {
        if (bytes(label).length < 1) {
            revert LabelTooShort();
        }
        if (bytes(label).length > 255) {
            revert LabelTooLong(label);
        }
        return abi.encodePacked(uint8(bytes(label).length), label, name);
    }

    function _mint(
        bytes32 node,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal override {
        address oldWrappedOwner = ownerOf(uint256(node));
        _canFusesBeBurned(node, fuses);
        if (oldWrappedOwner != address(0)) {
            // burn and unwrap old token of old owner
            _burn(uint256(node));
            emit NameUnwrapped(node, address(0));
        }
        super._mint(node, wrappedOwner, fuses, expiry);
    }

    function _wrap(
        bytes32 node,
        bytes memory name,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        names[node] = name;
        _mint(node, wrappedOwner, fuses, expiry);
        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);
    }

    function _addLabelAndWrap(
        bytes32 parentNode,
        bytes32 node,
        string memory label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        bytes memory name = _addLabel(label, names[parentNode]);
        _wrap(node, name, newOwner, fuses, expiry);
    }

    function _prepareUpgrade(bytes32 node)
        private
        returns (uint32 fuses, uint64 expiry)
    {
        if (address(upgradeContract) == address(0)) {
            revert CannotUpgrade();
        }

        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        (fuses, expiry) = getFuses(node);

        // burn token and fuse data
        _burn(uint256(node));
    }

    function _transferAndBurnFuses(
        bytes32 node,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        (address owner, , ) = getData(uint256(node));
        _transfer(owner, newOwner, uint256(node), 1, "");
        _setFuses(node, newOwner, fuses, expiry);
    }

    // wrapper function for stack limit
    function _getDataAndNormaliseExpiry(
        bytes32 parentNode,
        bytes32 node,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        (, , uint64 maxExpiry) = getData(uint256(parentNode));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _getETH2LDDataAndNormaliseExpiry(
        bytes32 node,
        bytes32 labelhash,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _normaliseExpiry(
        uint64 expiry,
        uint64 oldExpiry,
        uint64 maxExpiry
    ) internal pure returns (uint64) {
        // Expiry cannot be more than maximum allowed
        // .eth names will check registrar, non .eth check parent
        if (expiry > maxExpiry) {
            expiry = maxExpiry;
        }
        // Expiry cannot be less than old expiry
        if (expiry < oldExpiry) {
            expiry = oldExpiry;
        }

        return expiry;
    }

    function _wrapETH2LD(
        string memory label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) private returns (uint64) {
        // Mint a new ERC1155 token with fuses
        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);

        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(
            node,
            labelhash,
            expiry
        );

        _addLabelAndWrap(
            ETH_NODE,
            node,
            label,
            wrappedOwner,
            fuses | PARENT_CANNOT_CONTROL,
            expiry
        );
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        return expiry;
    }

    function _unwrap(bytes32 node, address newOwner) private {
        if (newOwner == address(0x0) || newOwner == address(this)) {
            revert IncorrectTargetOwner(newOwner);
        }

        if (allFusesBurned(node, CANNOT_UNWRAP)) {
            revert OperationProhibited(node);
        }

        // Burn token and fuse data
        _burn(uint256(node));
        ens.setOwner(node, newOwner);

        emit NameUnwrapped(node, newOwner);
    }

    function _setFuses(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _setData(node, owner, fuses, expiry);
        emit FusesSet(node, fuses, expiry);
    }

    function _setData(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _canFusesBeBurned(node, fuses);
        super._setData(uint256(node), owner, fuses, expiry);
    }

    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
        if (
            fuses & ~PARENT_CANNOT_CONTROL != 0 &&
            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
        ) {
            revert OperationProhibited(node);
        }
    }
}
.]

###

[2024-01-09 20:36:53 INFO] **[Seminar Conclusion]**:

 ###

[2024-01-09 20:36:53 INFO] **[Post Info]**

Software Info: 

**cost**=$0.000000

**version_updates**=1.0

**num_code_files**=0

**num_png_files**=0

**num_doc_files**=5

**code_lines**=0

**env_lines**=-1

**manual_lines**=-1

**num_utterances**=18

**num_self_reflections**=1

**num_prompt_tokens**=114921

**num_completion_tokens**=5681

**num_total_tokens**=120602

**duration**=92.00s

ChatDev Starts (20240901203521)

ChatDev Ends (20240901203653)



