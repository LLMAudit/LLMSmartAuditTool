[2024-01-09 02:00:01 INFO] **[Preprocessing]**

**ChatDev Starts** (20240901020001)

**Timestamp**: 20240901020001

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { Compound } from "../../integration/lib/Compound.sol";
import { ICErc20 } from "../../../interfaces/external/ICErc20.sol";
import { IComptroller } from "../../../interfaces/external/IComptroller.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title CompoundLeverageModule
 * @author Set Protocol
 *
 * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call
 * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each
 * asset is leveraged when using this module.
 *
 * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 *
 */
contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {
    using Compound for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken
        address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken
        address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset
        ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    /* ============ Events ============ */

    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the trade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping of underlying to CToken. If ETH, then map WETH to cETH
    mapping(IERC20 => ICErc20) public underlyingToCToken;

    // Wrapped Ether address
    IERC20 internal weth;

    // Compound cEther address
    ICErc20 internal cEther;

    // Compound Comptroller contract
    IComptroller internal comptroller;

    // COMP token address
    IERC20 internal compToken;

    // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public collateralCTokenEnabled;

    // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public borrowCTokenEnabled;

    // Mapping of enabled collateral and borrow cTokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list
    bool public anySetAllowed;


    /* ============ Constructor ============ */

    /**
     * Instantiate addresses. Underlying to cToken mapping is created.
     *
     * @param _controller               Address of controller contract
     * @param _compToken                Address of COMP token
     * @param _comptroller              Address of Compound Comptroller
     * @param _cEther                   Address of cEther contract
     * @param _weth                     Address of WETH contract
     */
    constructor(
        IController _controller,
        IERC20 _compToken,
        IComptroller _comptroller,
        ICErc20 _cEther,
        IERC20 _weth
    )
        public
        ModuleBase(_controller)
    {
        compToken = _compToken;
        comptroller = _comptroller;
        cEther = _cEther;
        weth = _weth;

        ICErc20[] memory cTokens = comptroller.getAllMarkets();

        for(uint256 i = 0; i < cTokens.length; i++) {
            ICErc20 cToken = cTokens[i];
            underlyingToCToken[
                cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())
            ] = cToken;
        }
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.
     * Performs a DEX trade, exchanging the borrow asset for collateral asset.
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAsset          Address of asset being borrowed for leverage
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _borrowQuantity       Borrow quantity of asset in position units
     * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantity,
        uint256 _minReceiveQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantity,
            _minReceiveQuantity,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        uint256 _minRepayQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantity,
            _minRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received
     * borrow asset is updated as equity. No protocol fee is charged.
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());

        require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly
        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);

        // Update default position first to save gas on editing borrow position
        _setToken.calculateAndEditDefaultPosition(
            address(_repayAsset),
            deleverInfo.setTotalSupply,
            deleverInfo.preTradeReceiveTokenBalance
        );

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0 // No protocol fee
        );
    }

    /**
     * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral
     * assets, update cToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     *
     * @param _setToken               Instance of the SetToken
     * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value
     */
    function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption
        if (setTotalSupply > 0) {
            // Loop through collateral assets
            address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;
            for(uint256 i = 0; i < collateralCTokens.length; i++) {
                ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);
                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);
                }
            }

            // Loop through borrow assets
            address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;
            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowCTokens.length; i++) {
                ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));

                int256 newPositionUnit = _getBorrowPosition(
                    _setToken,
                    borrowCToken,
                    setTotalSupply,
                    _shouldAccrueInterest
                );

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }


    /**
     * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable
     * collateral and borrow assets that don't exist as positions on the SetToken
     *
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // Enable collateral and borrow assets on Compound
        addCollateralAssets(_setToken, _collateralAssets);

        addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled
     * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Compound and SetToken positions prior to any removal action
        sync(setToken, true);

        address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;
        for (uint256 i = 0; i < borrowCTokens.length; i++) {
            ICErc20 cToken = ICErc20(borrowCTokens[i]);

            // Will exit only if token isn't also being used as collateral
            if(!collateralCTokenEnabled[setToken][cToken]) {
                // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound
                setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[setToken][cToken];
        }

        address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;
        for (uint256 i = 0; i < collateralCTokens.length; i++) {
            ICErc20 cToken = ICErc20(collateralCTokens[i]);

            setToken.invokeExitMarket(cToken, comptroller);

            delete collateralCTokenEnabled[setToken][cToken];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken
     * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];
            require(address(cToken) != address(0), "cToken must exist");
            require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            collateralCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].collateralCTokens.push(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets
     * If there is a borrow balance, collateral asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];
            require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");

            // Note: Will only exit market if cToken is not enabled as a borrow asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete collateralCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 newBorrowAsset = _newBorrowAssets[i];
            ICErc20 cToken = underlyingToCToken[newBorrowAsset];
            require(address(cToken) != address(0), "cToken must exist");
            require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            borrowCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].borrowCTokens.push(address(cToken));
            enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));
        }

        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets
     * If there is a borrow balance, borrow asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];
            require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");

            // Note: Will only exit market if cToken is not enabled as a collateral asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));
            enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));
        }

        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.
     *
     * @param _setToken             Instance of the SetToken
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.
     *
     * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _cToken                   Address of cToken to add
     * @param _underlying               Address of underlying token that maps to cToken
     */
    function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) == address(0), "Already added");
        underlyingToCToken[_underlying] = _cToken;
    }

    /**
     * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _underlying               Address of underlying token to remove
     */
    function removeCompoundMarket(IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) != address(0), "Not added");
        delete underlyingToCToken[_underlying];
    }

    /**
     * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, false);
    }

    /**
     * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.
     * Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, true);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);

        _borrow(_setToken, underlyingToCToken[_component], notionalDebt);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);

        _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt);
    }


    /* ============ External Getter Functions ============ */

    /**
     * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an
     * array of underlying that are borrow assets.
     *
     * @return                    Collateral cToken assets that are enabled
     * @return                    Underlying borrowed assets that are enabled.
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralCTokens,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be
     * unwrapped as it only accepts the underlying ETH.
     */
    function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _mintNotional);

            _setToken.invokeMintCEther(_cToken, _mintNotional);
        } else {
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);

            _setToken.invokeMintCToken(_cToken, _mintNotional);
        }
    }

    /**
     * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.
     */
    function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {
        _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);

        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _redeemNotional);
        }
    }

    /**
     * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.
     */
    function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _repayNotional);

            _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);
        } else {
            // Approve to cToken
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);
            _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);
        }
    }

    /**
     * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.
     */
    function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {
        _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);
        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);
        }
    }

    /**
     * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     *
     * @return receiveTokenQuantity The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
         ISetToken setToken = _actionInfo.setToken;
         uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

         setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * Calculates protocol fee on module and pays protocol fee from SetToken
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)
     */
    function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {
        _updateCollateralPosition(
            actionInfo.setToken,
            actionInfo.collateralCTokenAsset,
            _getCollateralPosition(
                actionInfo.setToken,
                actionInfo.collateralCTokenAsset,
                actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                actionInfo.setToken,
                actionInfo.borrowCTokenAsset,
                actionInfo.setTotalSupply,
                false // Do not accrue interest
            )
        );
    }

    function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_cToken), _newPositionUnit);
    }

    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, "");
    }

    /**
     * Construct the ActionInfo struct for lever and delever
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever
        );
    }

    /**
     * Construct the ActionInfo struct for lever and delever accepting notional units
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            setToken: _setToken,
            collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],
            borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],
            setTotalSupply: totalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }



    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");
        require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");
        require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.
     * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.
     */
    function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {
        uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));
        // Round negative away from 0
        int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);

        return borrowPositionUnit;
    }
}

**project_name**: RealWorld_BA_124_CompoundLeverageModule

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_124_CompoundLeverageModule_RealWord_20240901020001.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-01-09 02:00:01 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { Compound } from "../../integration/lib/Compound.sol"; import { ICErc20 } from "../../../interfaces/external/ICErc20.sol"; import { IComptroller } from "../../../interfaces/external/IComptroller.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol"; import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; /*  * @title CompoundLeverageModule  * @author Set Protocol  *  * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call  * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each  * asset is leveraged when using this module.  *  * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of  * debt when borrowed assets are the same.  *  / contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {     using Compound for ISetToken; /* ============ Structs ============ */  struct EnabledAssets {     address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken     address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken     address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets }  struct ActionInfo {     ISetToken setToken;                      // SetToken instance     IExchangeAdapter exchangeAdapter;        // Exchange adapter instance     uint256 setTotalSupply;                  // Total supply of SetToken     uint256 notionalSendQuantity;            // Total notional quantity sent to exchange     uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange     ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset     ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset     uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance }  /* ============ Events ============ */  event LeverageIncreased(     ISetToken indexed _setToken,     IERC20 indexed _borrowAsset,     IERC20 indexed _collateralAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalBorrowAmount,     uint256 _totalReceiveAmount,     uint256 _protocolFee );  event LeverageDecreased(     ISetToken indexed _setToken,     IERC20 indexed _collateralAsset,     IERC20 indexed _repayAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalRedeemAmount,     uint256 _totalRepayAmount,     uint256 _protocolFee );  event CollateralAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  event BorrowAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  event SetTokenStatusUpdated(     ISetToken indexed _setToken,     bool indexed _added );  event AnySetAllowedUpdated(     bool indexed _anySetAllowed );  /* ============ Constants ============ */  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the trade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Mapping of underlying to CToken. If ETH, then map WETH to cETH mapping(IERC20 =&gt; ICErc20) public underlyingToCToken;  // Wrapped Ether address IERC20 internal weth;  // Compound cEther address ICErc20 internal cEther;  // Compound Comptroller contract IComptroller internal comptroller;  // COMP token address IERC20 internal compToken;  // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public collateralCTokenEnabled;  // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public borrowCTokenEnabled;  // Mapping of enabled collateral and borrow cTokens for syncing positions mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;  // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance mapping(ISetToken =&gt; bool) public allowedSetTokens;  // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list bool public anySetAllowed;   /* ============ Constructor ============ */  /**  * Instantiate addresses. Underlying to cToken mapping is created.  *  * @param _controller               Address of controller contract  * @param _compToken                Address of COMP token  * @param _comptroller              Address of Compound Comptroller  * @param _cEther                   Address of cEther contract  * @param _weth                     Address of WETH contract  */ constructor(     IController _controller,     IERC20 _compToken,     IComptroller _comptroller,     ICErc20 _cEther,     IERC20 _weth )     public     ModuleBase(_controller) {     compToken = _compToken;     comptroller = _comptroller;     cEther = _cEther;     weth = _weth;      ICErc20[] memory cTokens = comptroller.getAllMarkets();      for(uint256 i = 0; i &lt; cTokens.length; i++) {         ICErc20 cToken = cTokens[i];         underlyingToCToken[             cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())         ] = cToken;     } }  /* ============ External Functions ============ */  /**  * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.  * Performs a DEX trade, exchanging the borrow asset for collateral asset.  *  * @param _setToken             Instance of the SetToken  * @param _borrowAsset          Address of asset being borrowed for leverage  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _borrowQuantity       Borrow quantity of asset in position units  * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function lever(     ISetToken _setToken,     IERC20 _borrowAsset,     IERC20 _collateralAsset,     uint256 _borrowQuantity,     uint256 _minReceiveQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // For levering up, send quantity is derived from borrow asset and receive quantity is derived from     // collateral asset     ActionInfo memory leverInfo = _createAndValidateActionInfo(         _setToken,         _borrowAsset,         _collateralAsset,         _borrowQuantity,         _minReceiveQuantity,         _tradeAdapterName,         true     );      _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);      uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);      _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);      _updateLeverPositions(leverInfo, _borrowAsset);      emit LeverageIncreased(         _setToken,         _borrowAsset,         _collateralAsset,         leverInfo.exchangeAdapter,         leverInfo.notionalSendQuantity,         postTradeCollateralQuantity,         protocolFee     ); }  /**  * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled  *  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _repayAsset           Address of asset being repaid  * @param _redeemQuantity       Quantity of collateral asset to delever  * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function delever(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantity,     uint256 _minRepayQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from     // repay asset     ActionInfo memory deleverInfo = _createAndValidateActionInfo(         _setToken,         _collateralAsset,         _repayAsset,         _redeemQuantity,         _minRepayQuantity,         _tradeAdapterName,         false     );      _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);      uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);      _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);      _updateLeverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         repayQuantity,         protocolFee     ); }  /**  * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received  * borrow asset is updated as equity. No protocol fee is charged.  *  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)  * @param _redeemQuantity       Quantity of collateral asset to delever  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function deleverToZeroBorrowBalance(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());      require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");     uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));      ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(         _setToken,         _collateralAsset,         _repayAsset,         notionalRedeemQuantity,         notionalRepayQuantity,         _tradeAdapterName,         false     );      _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);      _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly     _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);      // Update default position first to save gas on editing borrow position     _setToken.calculateAndEditDefaultPosition(         address(_repayAsset),         deleverInfo.setTotalSupply,         deleverInfo.preTradeReceiveTokenBalance     );      _updateLeverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         notionalRepayQuantity,         0 // No protocol fee     ); }  /**  * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral  * assets, update cToken default position. For borrow assets, update external borrow position.  * - Collateral assets may come out of sync when a position is liquidated  * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid  *  * @param _setToken               Instance of the SetToken  * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value  */ function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {     uint256 setTotalSupply = _setToken.totalSupply();      // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption     if (setTotalSupply &gt; 0) {         // Loop through collateral assets         address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;         for(uint256 i = 0; i &lt; collateralCTokens.length; i++) {             ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);             uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();             uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (previousPositionUnit != newPositionUnit) {               _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);             }         }          // Loop through borrow assets         address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;         address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;         for(uint256 i = 0; i &lt; borrowCTokens.length; i++) {             ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);             IERC20 borrowAsset = IERC20(borrowAssets[i]);              int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));              int256 newPositionUnit = _getBorrowPosition(                 _setToken,                 borrowCToken,                 setTotalSupply,                 _shouldAccrueInterest             );              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (newPositionUnit != previousPositionUnit) {                 _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);             }         }     } }   /**  * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable  * collateral and borrow assets that don't exist as positions on the SetToken  *  * @param _setToken             Instance of the SetToken to initialize  * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken  * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken  */ function initialize(     ISetToken _setToken,     IERC20[] memory _collateralAssets,     IERC20[] memory _borrowAssets )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     if (!anySetAllowed) {         require(allowedSetTokens[_setToken], "Not allowed SetToken");     }      // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}     }      // Enable collateral and borrow assets on Compound     addCollateralAssets(_setToken, _collateralAssets);      addBorrowAssets(_setToken, _borrowAssets); }  /**  * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled  * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)  */ function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Sync Compound and SetToken positions prior to any removal action     sync(setToken, true);      address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;     for (uint256 i = 0; i &lt; borrowCTokens.length; i++) {         ICErc20 cToken = ICErc20(borrowCTokens[i]);          // Will exit only if token isn't also being used as collateral         if(!collateralCTokenEnabled[setToken][cToken]) {             // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound             setToken.invokeExitMarket(cToken, comptroller);         }          delete borrowCTokenEnabled[setToken][cToken];     }      address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;     for (uint256 i = 0; i &lt; collateralCTokens.length; i++) {         ICErc20 cToken = ICErc20(collateralCTokens[i]);          setToken.invokeExitMarket(cToken, comptroller);          delete collateralCTokenEnabled[setToken][cToken];     }      delete enabledAssets[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken  * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state  * inconsistencies  *  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets  *  * @param _setToken             Instance of the SetToken  * @param _newCollateralAssets  Addresses of new collateral underlying assets  */ function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {     for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];         require(address(cToken) != address(0), "cToken must exist");         require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");          // Note: Will only enter market if cToken is not enabled as a borrow asset as well         if (!borrowCTokenEnabled[_setToken][cToken]) {             _setToken.invokeEnterMarkets(cToken, comptroller);         }          collateralCTokenEnabled[_setToken][cToken] = true;         enabledAssets[_setToken].collateralCTokens.push(address(cToken));     }      emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets); }  /**  * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets  * If there is a borrow balance, collateral asset cannot be removed  *  * @param _setToken             Instance of the SetToken  * @param _collateralAssets     Addresses of collateral underlying assets to remove  */ function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {     // Sync Compound and SetToken positions prior to any removal action     sync(_setToken, true);      for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];         require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");          // Note: Will only exit market if cToken is not enabled as a borrow asset as well         // If there is an existing borrow balance, will revert and market cannot be exited on Compound         if (!borrowCTokenEnabled[_setToken][cToken]) {             _setToken.invokeExitMarket(cToken, comptroller);         }          delete collateralCTokenEnabled[_setToken][cToken];         enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));     }      emit CollateralAssetsUpdated(_setToken, false, _collateralAssets); }  /**  * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets  *  * @param _setToken             Instance of the SetToken  * @param _newBorrowAssets      Addresses of borrow underlying assets to add  */ function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {     for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {         IERC20 newBorrowAsset = _newBorrowAssets[i];         ICErc20 cToken = underlyingToCToken[newBorrowAsset];         require(address(cToken) != address(0), "cToken must exist");         require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");          // Note: Will only enter market if cToken is not enabled as a borrow asset as well         if (!collateralCTokenEnabled[_setToken][cToken]) {             _setToken.invokeEnterMarkets(cToken, comptroller);         }          borrowCTokenEnabled[_setToken][cToken] = true;         enabledAssets[_setToken].borrowCTokens.push(address(cToken));         enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));     }      emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets); }  /**  * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets  * If there is a borrow balance, borrow asset cannot be removed  *  * @param _setToken             Instance of the SetToken  * @param _borrowAssets         Addresses of borrow underlying assets to remove  */ function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {     // Sync Compound and SetToken positions prior to any removal action     sync(_setToken, true);      for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];         require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");          // Note: Will only exit market if cToken is not enabled as a collateral asset as well         // If there is an existing borrow balance, will revert and market cannot be exited on Compound         if (!collateralCTokenEnabled[_setToken][cToken]) {             _setToken.invokeExitMarket(cToken, comptroller);         }          delete borrowCTokenEnabled[_setToken][cToken];         enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));         enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));     }      emit BorrowAssetsUpdated(_setToken, false, _borrowAssets); }  /**  * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.  *  * @param _setToken             Instance of the SetToken  */ function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {     allowedSetTokens[_setToken] = _status;     emit SetTokenStatusUpdated(_setToken, _status); }  /**  * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.  *  * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled  */ function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {     anySetAllowed = _anySetAllowed;     emit AnySetAllowedUpdated(_anySetAllowed); }  /**  * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.  *  * IMPORTANT: Validations are skipped in order to get contract under bytecode limit  *  * @param _cToken                   Address of cToken to add  * @param _underlying               Address of underlying token that maps to cToken  */ function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {     require(address(underlyingToCToken[_underlying]) == address(0), "Already added");     underlyingToCToken[_underlying] = _cToken; }  /**  * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals  *  * IMPORTANT: Validations are skipped in order to get contract under bytecode limit  *  * @param _underlying               Address of underlying token to remove  */ function removeCompoundMarket(IERC20 _underlying) external onlyOwner {     require(address(underlyingToCToken[_underlying]) != address(0), "Not added");     delete underlyingToCToken[_underlying]; }  /**  * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {     sync(_setToken, false); }  /**  * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.  * Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {     sync(_setToken, true); }  /**  * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {     int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));      require(componentDebt &lt; 0, "Component must be negative");      uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);      _borrow(_setToken, underlyingToCToken[_component], notionalDebt); }  /**  * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {     int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));      require(componentDebt &lt; 0, "Component must be negative");      uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);      _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt); }   /* ============ External Getter Functions ============ */  /**  * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an  * array of underlying that are borrow assets.  *  * @return                    Collateral cToken assets that are enabled  * @return                    Underlying borrowed assets that are enabled.  */ function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {     return (         enabledAssets[_setToken].collateralCTokens,         enabledAssets[_setToken].borrowAssets     ); }  /* ============ Internal Functions ============ */  /**  * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be  * unwrapped as it only accepts the underlying ETH.  */ function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {     if (_cToken == cEther) {         _setToken.invokeUnwrapWETH(address(weth), _mintNotional);          _setToken.invokeMintCEther(_cToken, _mintNotional);     } else {         _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);          _setToken.invokeMintCToken(_cToken, _mintNotional);     } }  /**  * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.  */ function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {     _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);      if (_cToken == cEther) {         _setToken.invokeWrapWETH(address(weth), _redeemNotional);     } }  /**  * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.  */ function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {     if (_cToken == cEther) {         _setToken.invokeUnwrapWETH(address(weth), _repayNotional);          _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);     } else {         // Approve to cToken         _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);         _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);     } }  /**  * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.  */ function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {     _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);     if (_cToken == cEther) {         _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);     } }  /**  * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken  *  * @return receiveTokenQuantity The quantity of tokens received post-trade  */ function _executeTrade(     ActionInfo memory _actionInfo,     IERC20 _sendToken,     IERC20 _receiveToken,     bytes memory _data )     internal     returns (uint256) {      ISetToken setToken = _actionInfo.setToken;      uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;       setToken.invokeApprove(         address(_sendToken),         _actionInfo.exchangeAdapter.getSpender(),         notionalSendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _actionInfo.exchangeAdapter.getTradeCalldata(         address(_sendToken),         address(_receiveToken),         address(setToken),         notionalSendQuantity,         _actionInfo.minNotionalReceiveQuantity,         _data     );      setToken.invoke(targetExchange, callValue, methodData);      uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);     require(         receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,         "Slippage too high"     );      return receiveTokenQuantity; }  /**  * Calculates protocol fee on module and pays protocol fee from SetToken  */ function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {     uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);      payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);      return protocolFeeTotal; }  /**  * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)  */ function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {     _updateCollateralPosition(         actionInfo.setToken,         actionInfo.collateralCTokenAsset,         _getCollateralPosition(             actionInfo.setToken,             actionInfo.collateralCTokenAsset,             actionInfo.setTotalSupply         )     );      _updateBorrowPosition(         actionInfo.setToken,         _borrowAsset,         _getBorrowPosition(             actionInfo.setToken,             actionInfo.borrowCTokenAsset,             actionInfo.setTotalSupply,             false // Do not accrue interest         )     ); }  function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {     _setToken.editDefaultPosition(address(_cToken), _newPositionUnit); }  function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {     _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, ""); }  /**  * Construct the ActionInfo struct for lever and delever  */ function _createAndValidateActionInfo(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _sendQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();      return _createAndValidateActionInfoNotional(         _setToken,         _sendToken,         _receiveToken,         _sendQuantityUnits.preciseMul(totalSupply),         _minReceiveQuantityUnits.preciseMul(totalSupply),         _tradeAdapterName,         _isLever     ); }  /**  * Construct the ActionInfo struct for lever and delever accepting notional units  */ function _createAndValidateActionInfoNotional(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _notionalSendQuantity,     uint256 _minNotionalReceiveQuantity,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();     ActionInfo memory actionInfo = ActionInfo ({         exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),         setToken: _setToken,         collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],         borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],         setTotalSupply: totalSupply,         notionalSendQuantity: _notionalSendQuantity,         minNotionalReceiveQuantity: _minNotionalReceiveQuantity,         preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))     });      _validateCommon(actionInfo);      return actionInfo; }    function _validateCommon(ActionInfo memory _actionInfo) internal view {     require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");     require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");     require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");     require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0"); }  function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {     uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));     return collateralNotionalBalance.preciseDiv(_setTotalSupply); }  /**  * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.  * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.  */ function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {     uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));     // Round negative away from 0     int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);      return borrowPositionUnit; }  } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '/\n    Copyright 2021 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n/\n\npragma solidity 0.6.10;\npragma experimental "ABIEncoderV2";\n\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";\nimport { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\n\nimport { Compound } from "../../integration/lib/Compound.sol";\nimport { ICErc20 } from "../../../interfaces/external/ICErc20.sol";\nimport { IComptroller } from "../../../interfaces/external/IComptroller.sol";\nimport { IController } from "../../../interfaces/IController.sol";\nimport { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";\nimport { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";\nimport { ISetToken } from "../../../interfaces/ISetToken.sol";\nimport { ModuleBase } from "../../lib/ModuleBase.sol";\n\n/\n * @title CompoundLeverageModule\n * @author Set Protocol\n \n * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call\n * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each\n * asset is leveraged when using this module.\n \n * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of\n * debt when borrowed assets are the same.\n \n /\ncontract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {\n    using Compound for ISetToken;\n\n    / ============ Structs ============ /\n\n    struct EnabledAssets {\n        address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken\n        address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken\n        address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets\n    }\n\n    struct ActionInfo {\n        ISetToken setToken;                      // SetToken instance\n        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance\n        uint256 setTotalSupply;                  // Total supply of SetToken\n        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange\n        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange\n        ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset\n        ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset\n        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance\n    }\n\n    / ============ Events ============ /\n\n    event LeverageIncreased(\n        ISetToken indexed _setToken,\n        IERC20 indexed _borrowAsset,\n        IERC20 indexed _collateralAsset,\n        IExchangeAdapter _exchangeAdapter,\n        uint256 _totalBorrowAmount,\n        uint256 _totalReceiveAmount,\n        uint256 _protocolFee\n    );\n\n    event LeverageDecreased(\n        ISetToken indexed _setToken,\n        IERC20 indexed _collateralAsset,\n        IERC20 indexed _repayAsset,\n        IExchangeAdapter _exchangeAdapter,\n        uint256 _totalRedeemAmount,\n        uint256 _totalRepayAmount,\n        uint256 _protocolFee\n    );\n\n    event CollateralAssetsUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added,\n        IERC20[] _assets\n    );\n\n    event BorrowAssetsUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added,\n        IERC20[] _assets\n    );\n\n    event SetTokenStatusUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added\n    );\n\n    event AnySetAllowedUpdated(\n        bool indexed _anySetAllowed\n    );\n\n    / ============ Constants ============ /\n\n    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as\n    // the string as the integration name\n    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";\n\n    // 0 index stores protocol fee % on the controller, charged in the trade function\n    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;\n\n    / ============ State Variables ============ /\n\n    // Mapping of underlying to CToken. If ETH, then map WETH to cETH\n    mapping(IERC20 =&gt; ICErc20) public underlyingToCToken;\n\n    // Wrapped Ether address\n    IERC20 internal weth;\n\n    // Compound cEther address\n    ICErc20 internal cEther;\n\n    // Compound Comptroller contract\n    IComptroller internal comptroller;\n\n    // COMP token address\n    IERC20 internal compToken;\n\n    // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken\n    mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public collateralCTokenEnabled;\n\n    // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken\n    mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public borrowCTokenEnabled;\n\n    // Mapping of enabled collateral and borrow cTokens for syncing positions\n    mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;\n\n    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance\n    mapping(ISetToken =&gt; bool) public allowedSetTokens;\n\n    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list\n    bool public anySetAllowed;\n\n\n    / ============ Constructor ============ /\n\n    /\n     * Instantiate addresses. Underlying to cToken mapping is created.\n     \n     * @param _controller               Address of controller contract\n     * @param _compToken                Address of COMP token\n     * @param _comptroller              Address of Compound Comptroller\n     * @param _cEther                   Address of cEther contract\n     * @param _weth                     Address of WETH contract\n     /\n    constructor(\n        IController _controller,\n        IERC20 _compToken,\n        IComptroller _comptroller,\n        ICErc20 _cEther,\n        IERC20 _weth\n    )\n        public\n        ModuleBase(_controller)\n    {\n        compToken = _compToken;\n        comptroller = _comptroller;\n        cEther = _cEther;\n        weth = _weth;\n\n        ICErc20[] memory cTokens = comptroller.getAllMarkets();\n\n        for(uint256 i = 0; i &lt; cTokens.length; i++) {\n            ICErc20 cToken = cTokens[i];\n            underlyingToCToken[\n                cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())\n            ] = cToken;\n        }\n    }\n\n    / ============ External Functions ============ /\n\n    /\n     * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.\n     * Performs a DEX trade, exchanging the borrow asset for collateral asset.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _borrowAsset          Address of asset being borrowed for leverage\n     * @param _collateralAsset      Address of collateral asset (underlying of cToken)\n     * @param _borrowQuantity       Borrow quantity of asset in position units\n     * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units\n     * @param _tradeAdapterName     Name of trade adapter\n     * @param _tradeData            Arbitrary data for trade\n     /\n    function lever(\n        ISetToken _setToken,\n        IERC20 _borrowAsset,\n        IERC20 _collateralAsset,\n        uint256 _borrowQuantity,\n        uint256 _minReceiveQuantity,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from\n        // collateral asset\n        ActionInfo memory leverInfo = _createAndValidateActionInfo(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            _borrowQuantity,\n            _minReceiveQuantity,\n            _tradeAdapterName,\n            true\n        );\n\n        _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);\n\n        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);\n\n        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n        _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);\n\n        _updateLeverPositions(leverInfo, _borrowAsset);\n\n        emit LeverageIncreased(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            leverInfo.exchangeAdapter,\n            leverInfo.notionalSendQuantity,\n            postTradeCollateralQuantity,\n            protocolFee\n        );\n    }\n\n    /\n     * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _collateralAsset      Address of collateral asset (underlying of cToken)\n     * @param _repayAsset           Address of asset being repaid\n     * @param _redeemQuantity       Quantity of collateral asset to delever\n     * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade\n     * @param _tradeAdapterName     Name of trade adapter\n     * @param _tradeData            Arbitrary data for trade\n     /\n    function delever(\n        ISetToken _setToken,\n        IERC20 _collateralAsset,\n        IERC20 _repayAsset,\n        uint256 _redeemQuantity,\n        uint256 _minRepayQuantity,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from\n        // repay asset\n        ActionInfo memory deleverInfo = _createAndValidateActionInfo(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            _redeemQuantity,\n            _minRepayQuantity,\n            _tradeAdapterName,\n            false\n        );\n\n        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);\n\n        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);\n\n        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);\n\n        _updateLeverPositions(deleverInfo, _repayAsset);\n\n        emit LeverageDecreased(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            deleverInfo.exchangeAdapter,\n            deleverInfo.notionalSendQuantity,\n            repayQuantity,\n            protocolFee\n        );\n    }\n\n    /\n     * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received\n     * borrow asset is updated as equity. No protocol fee is charged.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _collateralAsset      Address of collateral asset (underlying of cToken)\n     * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)\n     * @param _redeemQuantity       Quantity of collateral asset to delever\n     * @param _tradeAdapterName     Name of trade adapter\n     * @param _tradeData            Arbitrary data for trade\n     /\n    function deleverToZeroBorrowBalance(\n        ISetToken _setToken,\n        IERC20 _collateralAsset,\n        IERC20 _repayAsset,\n        uint256 _redeemQuantity,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());\n\n        require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");\n        uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));\n\n        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            notionalRedeemQuantity,\n            notionalRepayQuantity,\n            _tradeAdapterName,\n            false\n        );\n\n        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);\n\n        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n\n        // We use notionalRepayQuantity vs. Compound\'s max value uint256(-1) to handle WETH properly\n        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);\n\n        // Update default position first to save gas on editing borrow position\n        _setToken.calculateAndEditDefaultPosition(\n            address(_repayAsset),\n            deleverInfo.setTotalSupply,\n            deleverInfo.preTradeReceiveTokenBalance\n        );\n\n        _updateLeverPositions(deleverInfo, _repayAsset);\n\n        emit LeverageDecreased(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            deleverInfo.exchangeAdapter,\n            deleverInfo.notionalSendQuantity,\n            notionalRepayQuantity,\n            0 // No protocol fee\n        );\n    }\n\n    /\n     * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral\n     * assets, update cToken default position. For borrow assets, update external borrow position.\n     * - Collateral assets may come out of sync when a position is liquidated\n     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid\n     \n     * @param _setToken               Instance of the SetToken\n     * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value\n     /\n    function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {\n        uint256 setTotalSupply = _setToken.totalSupply();\n\n        // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption\n        if (setTotalSupply &gt; 0) {\n            // Loop through collateral assets\n            address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;\n            for(uint256 i = 0; i &lt; collateralCTokens.length; i++) {\n                ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);\n                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();\n                uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);\n\n                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets\n                if (previousPositionUnit != newPositionUnit) {\n                  _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);\n                }\n            }\n\n            // Loop through borrow assets\n            address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;\n            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;\n            for(uint256 i = 0; i &lt; borrowCTokens.length; i++) {\n                ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);\n                IERC20 borrowAsset = IERC20(borrowAssets[i]);\n\n                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));\n\n                int256 newPositionUnit = _getBorrowPosition(\n                    _setToken,\n                    borrowCToken,\n                    setTotalSupply,\n                    _shouldAccrueInterest\n                );\n\n                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets\n                if (newPositionUnit != previousPositionUnit) {\n                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);\n                }\n            }\n        }\n    }\n\n\n    /\n     * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken\'s manager. Note: managers can enable\n     * collateral and borrow assets that don\'t exist as positions on the SetToken\n     \n     * @param _setToken             Instance of the SetToken to initialize\n     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken\n     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken\n     /\n    function initialize(\n        ISetToken _setToken,\n        IERC20[] memory _collateralAssets,\n        IERC20[] memory _borrowAssets\n    )\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        if (!anySetAllowed) {\n            require(allowedSetTokens[_setToken], "Not allowed SetToken");\n        }\n\n        // Initialize module before trying register\n        _setToken.initializeModule();\n\n        // Get debt issuance module registered to this module and require that it is initialized\n        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");\n\n        // Try if register exists on any of the modules including the debt issuance module\n        address[] memory modules = _setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}\n        }\n\n        // Enable collateral and borrow assets on Compound\n        addCollateralAssets(_setToken, _collateralAssets);\n\n        addBorrowAssets(_setToken, _borrowAssets);\n    }\n\n    /\n     * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled\n     * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)\n     /\n    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {\n        ISetToken setToken = ISetToken(msg.sender);\n\n        // Sync Compound and SetToken positions prior to any removal action\n        sync(setToken, true);\n\n        address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;\n        for (uint256 i = 0; i &lt; borrowCTokens.length; i++) {\n            ICErc20 cToken = ICErc20(borrowCTokens[i]);\n\n            // Will exit only if token isn\'t also being used as collateral\n            if(!collateralCTokenEnabled[setToken][cToken]) {\n                // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound\n                setToken.invokeExitMarket(cToken, comptroller);\n            }\n\n            delete borrowCTokenEnabled[setToken][cToken];\n        }\n\n        address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;\n        for (uint256 i = 0; i &lt; collateralCTokens.length; i++) {\n            ICErc20 cToken = ICErc20(collateralCTokens[i]);\n\n            setToken.invokeExitMarket(cToken, comptroller);\n\n            delete collateralCTokenEnabled[setToken][cToken];\n        }\n\n        delete enabledAssets[setToken];\n\n        // Try if unregister exists on any of the modules\n        address[] memory modules = setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}\n        }\n    }\n\n    /\n     * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken\n     * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state\n     * inconsistencies\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _debtIssuanceModule   Debt issuance module address to register\n     /\n    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {\n        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");\n\n        _debtIssuanceModule.registerToIssuanceModule(_setToken);\n    }\n\n    /\n     * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _newCollateralAssets  Addresses of new collateral underlying assets\n     /\n    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {\n        for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {\n            ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];\n            require(address(cToken) != address(0), "cToken must exist");\n            require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");\n\n            // Note: Will only enter market if cToken is not enabled as a borrow asset as well\n            if (!borrowCTokenEnabled[_setToken][cToken]) {\n                _setToken.invokeEnterMarkets(cToken, comptroller);\n            }\n\n            collateralCTokenEnabled[_setToken][cToken] = true;\n            enabledAssets[_setToken].collateralCTokens.push(address(cToken));\n        }\n\n        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);\n    }\n\n    /\n     * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets\n     * If there is a borrow balance, collateral asset cannot be removed\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _collateralAssets     Addresses of collateral underlying assets to remove\n     /\n    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {\n        // Sync Compound and SetToken positions prior to any removal action\n        sync(_setToken, true);\n\n        for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {\n            ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];\n            require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");\n\n            // Note: Will only exit market if cToken is not enabled as a borrow asset as well\n            // If there is an existing borrow balance, will revert and market cannot be exited on Compound\n            if (!borrowCTokenEnabled[_setToken][cToken]) {\n                _setToken.invokeExitMarket(cToken, comptroller);\n            }\n\n            delete collateralCTokenEnabled[_setToken][cToken];\n            enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));\n        }\n\n        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);\n    }\n\n    /\n     * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _newBorrowAssets      Addresses of borrow underlying assets to add\n     /\n    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {\n        for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {\n            IERC20 newBorrowAsset = _newBorrowAssets[i];\n            ICErc20 cToken = underlyingToCToken[newBorrowAsset];\n            require(address(cToken) != address(0), "cToken must exist");\n            require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");\n\n            // Note: Will only enter market if cToken is not enabled as a borrow asset as well\n            if (!collateralCTokenEnabled[_setToken][cToken]) {\n                _setToken.invokeEnterMarkets(cToken, comptroller);\n            }\n\n            borrowCTokenEnabled[_setToken][cToken] = true;\n            enabledAssets[_setToken].borrowCTokens.push(address(cToken));\n            enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));\n        }\n\n        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);\n    }\n\n    /\n     * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets\n     * If there is a borrow balance, borrow asset cannot be removed\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _borrowAssets         Addresses of borrow underlying assets to remove\n     /\n    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {\n        // Sync Compound and SetToken positions prior to any removal action\n        sync(_setToken, true);\n\n        for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {\n            ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];\n            require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");\n\n            // Note: Will only exit market if cToken is not enabled as a collateral asset as well\n            // If there is an existing borrow balance, will revert and market cannot be exited on Compound\n            if (!collateralCTokenEnabled[_setToken][cToken]) {\n                _setToken.invokeExitMarket(cToken, comptroller);\n            }\n\n            delete borrowCTokenEnabled[_setToken][cToken];\n            enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));\n            enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));\n        }\n\n        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);\n    }\n\n    /\n     * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.\n     \n     * @param _setToken             Instance of the SetToken\n     /\n    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {\n        allowedSetTokens[_setToken] = _status;\n        emit SetTokenStatusUpdated(_setToken, _status);\n    }\n\n    /\n     * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.\n     \n     * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled\n     /\n    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {\n        anySetAllowed = _anySetAllowed;\n        emit AnySetAllowedUpdated(_anySetAllowed);\n    }\n\n    /\n     * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.\n     \n     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit\n     \n     * @param _cToken                   Address of cToken to add\n     * @param _underlying               Address of underlying token that maps to cToken\n     /\n    function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {\n        require(address(underlyingToCToken[_underlying]) == address(0), "Already added");\n        underlyingToCToken[_underlying] = _cToken;\n    }\n\n    /\n     * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals\n     \n     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit\n     \n     * @param _underlying               Address of underlying token to remove\n     */\n    function removeCompoundMarket(IERC20 _underlying) external onlyOwner {\n        require(address(underlyingToCToken[_underlying]) != address(0), "Not added");\n        delete underlyingToCToken[_underlying];\n    }\n\n    /\n     * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.\n     \n     * @param _setToken             Instance of the SetToken\n     /\n    function moduleIssueHook(ISetToken _setToken, uint256 / _setTokenQuantity /) external onlyModule(_setToken) {\n        sync(_setToken, false);\n    }\n\n    /\n     * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.\n     * Only callable by valid module.\n     \n     * @param _setToken             Instance of the SetToken\n     /\n    function moduleRedeemHook(ISetToken _setToken, uint256 / _setTokenQuantity /) external onlyModule(_setToken) {\n        sync(_setToken, true);\n    }\n\n    /\n     * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken\n     * @param _component            Address of component\n     /\n    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool / _isEquity /) external onlyModule(_setToken) {\n        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n\n        require(componentDebt &lt; 0, "Component must be negative");\n\n        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);\n\n        _borrow(_setToken, underlyingToCToken[_component], notionalDebt);\n    }\n\n    /\n     * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken\n     * @param _component            Address of component\n     /\n    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool / _isEquity /) external onlyModule(_setToken) {\n        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n\n        require(componentDebt &lt; 0, "Component must be negative");\n\n        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);\n\n        _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt);\n    }\n\n\n    / ============ External Getter Functions ============ /\n\n    /\n     * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an\n     * array of underlying that are borrow assets.\n     \n     * @return                    Collateral cToken assets that are enabled\n     * @return                    Underlying borrowed assets that are enabled.\n     /\n    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {\n        return (\n            enabledAssets[_setToken].collateralCTokens,\n            enabledAssets[_setToken].borrowAssets\n        );\n    }\n\n    / ============ Internal Functions ============ /\n\n    /\n     * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be\n     * unwrapped as it only accepts the underlying ETH.\n     */\n    function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {\n        if (_cToken == cEther) {\n            _setToken.invokeUnwrapWETH(address(weth), _mintNotional);\n\n            _setToken.invokeMintCEther(_cToken, _mintNotional);\n        } else {\n            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);\n\n            _setToken.invokeMintCToken(_cToken, _mintNotional);\n        }\n    }\n\n    /\n     * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.\n     /\n    function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {\n        _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);\n\n        if (_cToken == cEther) {\n            _setToken.invokeWrapWETH(address(weth), _redeemNotional);\n        }\n    }\n\n    /\n     * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.\n     /\n    function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {\n        if (_cToken == cEther) {\n            _setToken.invokeUnwrapWETH(address(weth), _repayNotional);\n\n            _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);\n        } else {\n            // Approve to cToken\n            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);\n            _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);\n        }\n    }\n\n    /\n     * Invoke the SetToken to interact with the specified cToken to borrow the cToken\'s underlying of the specified borrowQuantity.\n     */\n    function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {\n        _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);\n        if (_cToken == cEther) {\n            _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);\n        }\n    }\n\n    /\n     * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken\n     \n     * @return receiveTokenQuantity The quantity of tokens received post-trade\n     /\n    function _executeTrade(\n        ActionInfo memory _actionInfo,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        bytes memory _data\n    )\n        internal\n        returns (uint256)\n    {\n         ISetToken setToken = _actionInfo.setToken;\n         uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;\n\n         setToken.invokeApprove(\n            address(_sendToken),\n            _actionInfo.exchangeAdapter.getSpender(),\n            notionalSendQuantity\n        );\n\n        (\n            address targetExchange,\n            uint256 callValue,\n            bytes memory methodData\n        ) = _actionInfo.exchangeAdapter.getTradeCalldata(\n            address(_sendToken),\n            address(_receiveToken),\n            address(setToken),\n            notionalSendQuantity,\n            _actionInfo.minNotionalReceiveQuantity,\n            _data\n        );\n\n        setToken.invoke(targetExchange, callValue, methodData);\n\n        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);\n        require(\n            receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,\n            "Slippage too high"\n        );\n\n        return receiveTokenQuantity;\n    }\n\n    /\n     * Calculates protocol fee on module and pays protocol fee from SetToken\n     */\n    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {\n        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);\n\n        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);\n\n        return protocolFeeTotal;\n    }\n\n    /\n     * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)\n     /\n    function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {\n        _updateCollateralPosition(\n            actionInfo.setToken,\n            actionInfo.collateralCTokenAsset,\n            _getCollateralPosition(\n                actionInfo.setToken,\n                actionInfo.collateralCTokenAsset,\n                actionInfo.setTotalSupply\n            )\n        );\n\n        _updateBorrowPosition(\n            actionInfo.setToken,\n            _borrowAsset,\n            _getBorrowPosition(\n                actionInfo.setToken,\n                actionInfo.borrowCTokenAsset,\n                actionInfo.setTotalSupply,\n                false // Do not accrue interest\n            )\n        );\n    }\n\n    function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {\n        _setToken.editDefaultPosition(address(_cToken), _newPositionUnit);\n    }\n\n    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {\n        _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, "");\n    }\n\n    /\n     * Construct the ActionInfo struct for lever and delever\n     /\n    function _createAndValidateActionInfo(\n        ISetToken _setToken,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        uint256 _sendQuantityUnits,\n        uint256 _minReceiveQuantityUnits,\n        string memory _tradeAdapterName,\n        bool _isLever\n    )\n        internal\n        view\n        returns(ActionInfo memory)\n    {\n        uint256 totalSupply = _setToken.totalSupply();\n\n        return _createAndValidateActionInfoNotional(\n            _setToken,\n            _sendToken,\n            _receiveToken,\n            _sendQuantityUnits.preciseMul(totalSupply),\n            _minReceiveQuantityUnits.preciseMul(totalSupply),\n            _tradeAdapterName,\n            _isLever\n        );\n    }\n\n    /\n     * Construct the ActionInfo struct for lever and delever accepting notional units\n     */\n    function _createAndValidateActionInfoNotional(\n        ISetToken _setToken,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        uint256 _notionalSendQuantity,\n        uint256 _minNotionalReceiveQuantity,\n        string memory _tradeAdapterName,\n        bool _isLever\n    )\n        internal\n        view\n        returns(ActionInfo memory)\n    {\n        uint256 totalSupply = _setToken.totalSupply();\n        ActionInfo memory actionInfo = ActionInfo ({\n            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),\n            setToken: _setToken,\n            collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],\n            borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],\n            setTotalSupply: totalSupply,\n            notionalSendQuantity: _notionalSendQuantity,\n            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,\n            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))\n        });\n\n        _validateCommon(actionInfo);\n\n        return actionInfo;\n    }\n\n\n\n    function _validateCommon(ActionInfo memory _actionInfo) internal view {\n        require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");\n        require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");\n        require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");\n        require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0");\n    }\n\n    function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {\n        uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));\n        return collateralNotionalBalance.preciseDiv(_setTotalSupply);\n    }\n\n    /\n     * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.\n     * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.\n     */\n    function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {\n        uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));\n        // Round negative away from 0\n        int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);\n\n        return borrowPositionUnit;\n    }\n}'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 02:00:01 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { Compound } from "../../integration/lib/Compound.sol"; import { ICErc20 } from "../../../interfaces/external/ICErc20.sol"; import { IComptroller } from "../../../interfaces/external/IComptroller.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol"; import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; /*  * @title CompoundLeverageModule  * @author Set Protocol  *  * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call  * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each  * asset is leveraged when using this module.  *  * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of  * debt when borrowed assets are the same.  *  / contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {     using Compound for ISetToken; /* ============ Structs ============ */  struct EnabledAssets {     address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken     address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken     address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets }  struct ActionInfo {     ISetToken setToken;                      // SetToken instance     IExchangeAdapter exchangeAdapter;        // Exchange adapter instance     uint256 setTotalSupply;                  // Total supply of SetToken     uint256 notionalSendQuantity;            // Total notional quantity sent to exchange     uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange     ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset     ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset     uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance }  /* ============ Events ============ */  event LeverageIncreased(     ISetToken indexed _setToken,     IERC20 indexed _borrowAsset,     IERC20 indexed _collateralAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalBorrowAmount,     uint256 _totalReceiveAmount,     uint256 _protocolFee );  event LeverageDecreased(     ISetToken indexed _setToken,     IERC20 indexed _collateralAsset,     IERC20 indexed _repayAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalRedeemAmount,     uint256 _totalRepayAmount,     uint256 _protocolFee );  event CollateralAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  event BorrowAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  event SetTokenStatusUpdated(     ISetToken indexed _setToken,     bool indexed _added );  event AnySetAllowedUpdated(     bool indexed _anySetAllowed );  /* ============ Constants ============ */  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the trade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Mapping of underlying to CToken. If ETH, then map WETH to cETH mapping(IERC20 =&gt; ICErc20) public underlyingToCToken;  // Wrapped Ether address IERC20 internal weth;  // Compound cEther address ICErc20 internal cEther;  // Compound Comptroller contract IComptroller internal comptroller;  // COMP token address IERC20 internal compToken;  // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public collateralCTokenEnabled;  // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public borrowCTokenEnabled;  // Mapping of enabled collateral and borrow cTokens for syncing positions mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;  // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance mapping(ISetToken =&gt; bool) public allowedSetTokens;  // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list bool public anySetAllowed;   /* ============ Constructor ============ */  /**  * Instantiate addresses. Underlying to cToken mapping is created.  *  * @param _controller               Address of controller contract  * @param _compToken                Address of COMP token  * @param _comptroller              Address of Compound Comptroller  * @param _cEther                   Address of cEther contract  * @param _weth                     Address of WETH contract  */ constructor(     IController _controller,     IERC20 _compToken,     IComptroller _comptroller,     ICErc20 _cEther,     IERC20 _weth )     public     ModuleBase(_controller) {     compToken = _compToken;     comptroller = _comptroller;     cEther = _cEther;     weth = _weth;      ICErc20[] memory cTokens = comptroller.getAllMarkets();      for(uint256 i = 0; i &lt; cTokens.length; i++) {         ICErc20 cToken = cTokens[i];         underlyingToCToken[             cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())         ] = cToken;     } }  /* ============ External Functions ============ */  /**  * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.  * Performs a DEX trade, exchanging the borrow asset for collateral asset.  *  * @param _setToken             Instance of the SetToken  * @param _borrowAsset          Address of asset being borrowed for leverage  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _borrowQuantity       Borrow quantity of asset in position units  * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function lever(     ISetToken _setToken,     IERC20 _borrowAsset,     IERC20 _collateralAsset,     uint256 _borrowQuantity,     uint256 _minReceiveQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // For levering up, send quantity is derived from borrow asset and receive quantity is derived from     // collateral asset     ActionInfo memory leverInfo = _createAndValidateActionInfo(         _setToken,         _borrowAsset,         _collateralAsset,         _borrowQuantity,         _minReceiveQuantity,         _tradeAdapterName,         true     );      _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);      uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);      _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);      _updateLeverPositions(leverInfo, _borrowAsset);      emit LeverageIncreased(         _setToken,         _borrowAsset,         _collateralAsset,         leverInfo.exchangeAdapter,         leverInfo.notionalSendQuantity,         postTradeCollateralQuantity,         protocolFee     ); }  /**  * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled  *  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _repayAsset           Address of asset being repaid  * @param _redeemQuantity       Quantity of collateral asset to delever  * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function delever(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantity,     uint256 _minRepayQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from     // repay asset     ActionInfo memory deleverInfo = _createAndValidateActionInfo(         _setToken,         _collateralAsset,         _repayAsset,         _redeemQuantity,         _minRepayQuantity,         _tradeAdapterName,         false     );      _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);      uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);      _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);      _updateLeverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         repayQuantity,         protocolFee     ); }  /**  * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received  * borrow asset is updated as equity. No protocol fee is charged.  *  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)  * @param _redeemQuantity       Quantity of collateral asset to delever  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function deleverToZeroBorrowBalance(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());      require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");     uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));      ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(         _setToken,         _collateralAsset,         _repayAsset,         notionalRedeemQuantity,         notionalRepayQuantity,         _tradeAdapterName,         false     );      _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);      _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly     _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);      // Update default position first to save gas on editing borrow position     _setToken.calculateAndEditDefaultPosition(         address(_repayAsset),         deleverInfo.setTotalSupply,         deleverInfo.preTradeReceiveTokenBalance     );      _updateLeverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         notionalRepayQuantity,         0 // No protocol fee     ); }  /**  * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral  * assets, update cToken default position. For borrow assets, update external borrow position.  * - Collateral assets may come out of sync when a position is liquidated  * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid  *  * @param _setToken               Instance of the SetToken  * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value  */ function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {     uint256 setTotalSupply = _setToken.totalSupply();      // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption     if (setTotalSupply &gt; 0) {         // Loop through collateral assets         address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;         for(uint256 i = 0; i &lt; collateralCTokens.length; i++) {             ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);             uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();             uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (previousPositionUnit != newPositionUnit) {               _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);             }         }          // Loop through borrow assets         address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;         address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;         for(uint256 i = 0; i &lt; borrowCTokens.length; i++) {             ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);             IERC20 borrowAsset = IERC20(borrowAssets[i]);              int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));              int256 newPositionUnit = _getBorrowPosition(                 _setToken,                 borrowCToken,                 setTotalSupply,                 _shouldAccrueInterest             );              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (newPositionUnit != previousPositionUnit) {                 _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);             }         }     } }   /**  * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable  * collateral and borrow assets that don't exist as positions on the SetToken  *  * @param _setToken             Instance of the SetToken to initialize  * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken  * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken  */ function initialize(     ISetToken _setToken,     IERC20[] memory _collateralAssets,     IERC20[] memory _borrowAssets )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     if (!anySetAllowed) {         require(allowedSetTokens[_setToken], "Not allowed SetToken");     }      // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}     }      // Enable collateral and borrow assets on Compound     addCollateralAssets(_setToken, _collateralAssets);      addBorrowAssets(_setToken, _borrowAssets); }  /**  * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled  * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)  */ function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Sync Compound and SetToken positions prior to any removal action     sync(setToken, true);      address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;     for (uint256 i = 0; i &lt; borrowCTokens.length; i++) {         ICErc20 cToken = ICErc20(borrowCTokens[i]);          // Will exit only if token isn't also being used as collateral         if(!collateralCTokenEnabled[setToken][cToken]) {             // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound             setToken.invokeExitMarket(cToken, comptroller);         }          delete borrowCTokenEnabled[setToken][cToken];     }      address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;     for (uint256 i = 0; i &lt; collateralCTokens.length; i++) {         ICErc20 cToken = ICErc20(collateralCTokens[i]);          setToken.invokeExitMarket(cToken, comptroller);          delete collateralCTokenEnabled[setToken][cToken];     }      delete enabledAssets[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken  * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state  * inconsistencies  *  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets  *  * @param _setToken             Instance of the SetToken  * @param _newCollateralAssets  Addresses of new collateral underlying assets  */ function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {     for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];         require(address(cToken) != address(0), "cToken must exist");         require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");          // Note: Will only enter market if cToken is not enabled as a borrow asset as well         if (!borrowCTokenEnabled[_setToken][cToken]) {             _setToken.invokeEnterMarkets(cToken, comptroller);         }          collateralCTokenEnabled[_setToken][cToken] = true;         enabledAssets[_setToken].collateralCTokens.push(address(cToken));     }      emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets); }  /**  * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets  * If there is a borrow balance, collateral asset cannot be removed  *  * @param _setToken             Instance of the SetToken  * @param _collateralAssets     Addresses of collateral underlying assets to remove  */ function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {     // Sync Compound and SetToken positions prior to any removal action     sync(_setToken, true);      for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];         require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");          // Note: Will only exit market if cToken is not enabled as a borrow asset as well         // If there is an existing borrow balance, will revert and market cannot be exited on Compound         if (!borrowCTokenEnabled[_setToken][cToken]) {             _setToken.invokeExitMarket(cToken, comptroller);         }          delete collateralCTokenEnabled[_setToken][cToken];         enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));     }      emit CollateralAssetsUpdated(_setToken, false, _collateralAssets); }  /**  * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets  *  * @param _setToken             Instance of the SetToken  * @param _newBorrowAssets      Addresses of borrow underlying assets to add  */ function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {     for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {         IERC20 newBorrowAsset = _newBorrowAssets[i];         ICErc20 cToken = underlyingToCToken[newBorrowAsset];         require(address(cToken) != address(0), "cToken must exist");         require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");          // Note: Will only enter market if cToken is not enabled as a borrow asset as well         if (!collateralCTokenEnabled[_setToken][cToken]) {             _setToken.invokeEnterMarkets(cToken, comptroller);         }          borrowCTokenEnabled[_setToken][cToken] = true;         enabledAssets[_setToken].borrowCTokens.push(address(cToken));         enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));     }      emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets); }  /**  * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets  * If there is a borrow balance, borrow asset cannot be removed  *  * @param _setToken             Instance of the SetToken  * @param _borrowAssets         Addresses of borrow underlying assets to remove  */ function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {     // Sync Compound and SetToken positions prior to any removal action     sync(_setToken, true);      for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];         require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");          // Note: Will only exit market if cToken is not enabled as a collateral asset as well         // If there is an existing borrow balance, will revert and market cannot be exited on Compound         if (!collateralCTokenEnabled[_setToken][cToken]) {             _setToken.invokeExitMarket(cToken, comptroller);         }          delete borrowCTokenEnabled[_setToken][cToken];         enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));         enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));     }      emit BorrowAssetsUpdated(_setToken, false, _borrowAssets); }  /**  * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.  *  * @param _setToken             Instance of the SetToken  */ function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {     allowedSetTokens[_setToken] = _status;     emit SetTokenStatusUpdated(_setToken, _status); }  /**  * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.  *  * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled  */ function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {     anySetAllowed = _anySetAllowed;     emit AnySetAllowedUpdated(_anySetAllowed); }  /**  * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.  *  * IMPORTANT: Validations are skipped in order to get contract under bytecode limit  *  * @param _cToken                   Address of cToken to add  * @param _underlying               Address of underlying token that maps to cToken  */ function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {     require(address(underlyingToCToken[_underlying]) == address(0), "Already added");     underlyingToCToken[_underlying] = _cToken; }  /**  * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals  *  * IMPORTANT: Validations are skipped in order to get contract under bytecode limit  *  * @param _underlying               Address of underlying token to remove  */ function removeCompoundMarket(IERC20 _underlying) external onlyOwner {     require(address(underlyingToCToken[_underlying]) != address(0), "Not added");     delete underlyingToCToken[_underlying]; }  /**  * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {     sync(_setToken, false); }  /**  * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.  * Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {     sync(_setToken, true); }  /**  * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {     int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));      require(componentDebt &lt; 0, "Component must be negative");      uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);      _borrow(_setToken, underlyingToCToken[_component], notionalDebt); }  /**  * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {     int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));      require(componentDebt &lt; 0, "Component must be negative");      uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);      _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt); }   /* ============ External Getter Functions ============ */  /**  * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an  * array of underlying that are borrow assets.  *  * @return                    Collateral cToken assets that are enabled  * @return                    Underlying borrowed assets that are enabled.  */ function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {     return (         enabledAssets[_setToken].collateralCTokens,         enabledAssets[_setToken].borrowAssets     ); }  /* ============ Internal Functions ============ */  /**  * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be  * unwrapped as it only accepts the underlying ETH.  */ function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {     if (_cToken == cEther) {         _setToken.invokeUnwrapWETH(address(weth), _mintNotional);          _setToken.invokeMintCEther(_cToken, _mintNotional);     } else {         _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);          _setToken.invokeMintCToken(_cToken, _mintNotional);     } }  /**  * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.  */ function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {     _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);      if (_cToken == cEther) {         _setToken.invokeWrapWETH(address(weth), _redeemNotional);     } }  /**  * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.  */ function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {     if (_cToken == cEther) {         _setToken.invokeUnwrapWETH(address(weth), _repayNotional);          _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);     } else {         // Approve to cToken         _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);         _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);     } }  /**  * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.  */ function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {     _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);     if (_cToken == cEther) {         _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);     } }  /**  * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken  *  * @return receiveTokenQuantity The quantity of tokens received post-trade  */ function _executeTrade(     ActionInfo memory _actionInfo,     IERC20 _sendToken,     IERC20 _receiveToken,     bytes memory _data )     internal     returns (uint256) {      ISetToken setToken = _actionInfo.setToken;      uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;       setToken.invokeApprove(         address(_sendToken),         _actionInfo.exchangeAdapter.getSpender(),         notionalSendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _actionInfo.exchangeAdapter.getTradeCalldata(         address(_sendToken),         address(_receiveToken),         address(setToken),         notionalSendQuantity,         _actionInfo.minNotionalReceiveQuantity,         _data     );      setToken.invoke(targetExchange, callValue, methodData);      uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);     require(         receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,         "Slippage too high"     );      return receiveTokenQuantity; }  /**  * Calculates protocol fee on module and pays protocol fee from SetToken  */ function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {     uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);      payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);      return protocolFeeTotal; }  /**  * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)  */ function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {     _updateCollateralPosition(         actionInfo.setToken,         actionInfo.collateralCTokenAsset,         _getCollateralPosition(             actionInfo.setToken,             actionInfo.collateralCTokenAsset,             actionInfo.setTotalSupply         )     );      _updateBorrowPosition(         actionInfo.setToken,         _borrowAsset,         _getBorrowPosition(             actionInfo.setToken,             actionInfo.borrowCTokenAsset,             actionInfo.setTotalSupply,             false // Do not accrue interest         )     ); }  function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {     _setToken.editDefaultPosition(address(_cToken), _newPositionUnit); }  function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {     _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, ""); }  /**  * Construct the ActionInfo struct for lever and delever  */ function _createAndValidateActionInfo(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _sendQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();      return _createAndValidateActionInfoNotional(         _setToken,         _sendToken,         _receiveToken,         _sendQuantityUnits.preciseMul(totalSupply),         _minReceiveQuantityUnits.preciseMul(totalSupply),         _tradeAdapterName,         _isLever     ); }  /**  * Construct the ActionInfo struct for lever and delever accepting notional units  */ function _createAndValidateActionInfoNotional(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _notionalSendQuantity,     uint256 _minNotionalReceiveQuantity,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();     ActionInfo memory actionInfo = ActionInfo ({         exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),         setToken: _setToken,         collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],         borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],         setTotalSupply: totalSupply,         notionalSendQuantity: _notionalSendQuantity,         minNotionalReceiveQuantity: _minNotionalReceiveQuantity,         preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))     });      _validateCommon(actionInfo);      return actionInfo; }    function _validateCommon(ActionInfo memory _actionInfo) internal view {     require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");     require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");     require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");     require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0"); }  function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {     uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));     return collateralNotionalBalance.preciseDiv(_setTotalSupply); }  /**  * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.  * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.  */ function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {     uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));     // Round negative away from 0     int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);      return borrowPositionUnit; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 02:00:01 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { Compound } from "../../integration/lib/Compound.sol";
import { ICErc20 } from "../../../interfaces/external/ICErc20.sol";
import { IComptroller } from "../../../interfaces/external/IComptroller.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title CompoundLeverageModule
 * @author Set Protocol
 *
 * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call
 * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each
 * asset is leveraged when using this module.
 *
 * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 *
 */
contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {
    using Compound for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken
        address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken
        address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset
        ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    /* ============ Events ============ */

    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the trade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping of underlying to CToken. If ETH, then map WETH to cETH
    mapping(IERC20 => ICErc20) public underlyingToCToken;

    // Wrapped Ether address
    IERC20 internal weth;

    // Compound cEther address
    ICErc20 internal cEther;

    // Compound Comptroller contract
    IComptroller internal comptroller;

    // COMP token address
    IERC20 internal compToken;

    // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public collateralCTokenEnabled;

    // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public borrowCTokenEnabled;

    // Mapping of enabled collateral and borrow cTokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list
    bool public anySetAllowed;


    /* ============ Constructor ============ */

    /**
     * Instantiate addresses. Underlying to cToken mapping is created.
     *
     * @param _controller               Address of controller contract
     * @param _compToken                Address of COMP token
     * @param _comptroller              Address of Compound Comptroller
     * @param _cEther                   Address of cEther contract
     * @param _weth                     Address of WETH contract
     */
    constructor(
        IController _controller,
        IERC20 _compToken,
        IComptroller _comptroller,
        ICErc20 _cEther,
        IERC20 _weth
    )
        public
        ModuleBase(_controller)
    {
        compToken = _compToken;
        comptroller = _comptroller;
        cEther = _cEther;
        weth = _weth;

        ICErc20[] memory cTokens = comptroller.getAllMarkets();

        for(uint256 i = 0; i < cTokens.length; i++) {
            ICErc20 cToken = cTokens[i];
            underlyingToCToken[
                cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())
            ] = cToken;
        }
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.
     * Performs a DEX trade, exchanging the borrow asset for collateral asset.
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAsset          Address of asset being borrowed for leverage
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _borrowQuantity       Borrow quantity of asset in position units
     * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantity,
        uint256 _minReceiveQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantity,
            _minReceiveQuantity,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        uint256 _minRepayQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantity,
            _minRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received
     * borrow asset is updated as equity. No protocol fee is charged.
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());

        require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly
        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);

        // Update default position first to save gas on editing borrow position
        _setToken.calculateAndEditDefaultPosition(
            address(_repayAsset),
            deleverInfo.setTotalSupply,
            deleverInfo.preTradeReceiveTokenBalance
        );

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0 // No protocol fee
        );
    }

    /**
     * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral
     * assets, update cToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     *
     * @param _setToken               Instance of the SetToken
     * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value
     */
    function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption
        if (setTotalSupply > 0) {
            // Loop through collateral assets
            address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;
            for(uint256 i = 0; i < collateralCTokens.length; i++) {
                ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);
                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);
                }
            }

            // Loop through borrow assets
            address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;
            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowCTokens.length; i++) {
                ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));

                int256 newPositionUnit = _getBorrowPosition(
                    _setToken,
                    borrowCToken,
                    setTotalSupply,
                    _shouldAccrueInterest
                );

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }


    /**
     * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable
     * collateral and borrow assets that don't exist as positions on the SetToken
     *
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // Enable collateral and borrow assets on Compound
        addCollateralAssets(_setToken, _collateralAssets);

        addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled
     * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Compound and SetToken positions prior to any removal action
        sync(setToken, true);

        address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;
        for (uint256 i = 0; i < borrowCTokens.length; i++) {
            ICErc20 cToken = ICErc20(borrowCTokens[i]);

            // Will exit only if token isn't also being used as collateral
            if(!collateralCTokenEnabled[setToken][cToken]) {
                // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound
                setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[setToken][cToken];
        }

        address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;
        for (uint256 i = 0; i < collateralCTokens.length; i++) {
            ICErc20 cToken = ICErc20(collateralCTokens[i]);

            setToken.invokeExitMarket(cToken, comptroller);

            delete collateralCTokenEnabled[setToken][cToken];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken
     * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];
            require(address(cToken) != address(0), "cToken must exist");
            require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            collateralCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].collateralCTokens.push(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets
     * If there is a borrow balance, collateral asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];
            require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");

            // Note: Will only exit market if cToken is not enabled as a borrow asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete collateralCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 newBorrowAsset = _newBorrowAssets[i];
            ICErc20 cToken = underlyingToCToken[newBorrowAsset];
            require(address(cToken) != address(0), "cToken must exist");
            require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            borrowCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].borrowCTokens.push(address(cToken));
            enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));
        }

        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets
     * If there is a borrow balance, borrow asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];
            require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");

            // Note: Will only exit market if cToken is not enabled as a collateral asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));
            enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));
        }

        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.
     *
     * @param _setToken             Instance of the SetToken
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.
     *
     * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _cToken                   Address of cToken to add
     * @param _underlying               Address of underlying token that maps to cToken
     */
    function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) == address(0), "Already added");
        underlyingToCToken[_underlying] = _cToken;
    }

    /**
     * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _underlying               Address of underlying token to remove
     */
    function removeCompoundMarket(IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) != address(0), "Not added");
        delete underlyingToCToken[_underlying];
    }

    /**
     * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, false);
    }

    /**
     * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.
     * Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, true);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);

        _borrow(_setToken, underlyingToCToken[_component], notionalDebt);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);

        _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt);
    }


    /* ============ External Getter Functions ============ */

    /**
     * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an
     * array of underlying that are borrow assets.
     *
     * @return                    Collateral cToken assets that are enabled
     * @return                    Underlying borrowed assets that are enabled.
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralCTokens,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be
     * unwrapped as it only accepts the underlying ETH.
     */
    function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _mintNotional);

            _setToken.invokeMintCEther(_cToken, _mintNotional);
        } else {
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);

            _setToken.invokeMintCToken(_cToken, _mintNotional);
        }
    }

    /**
     * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.
     */
    function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {
        _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);

        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _redeemNotional);
        }
    }

    /**
     * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.
     */
    function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _repayNotional);

            _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);
        } else {
            // Approve to cToken
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);
            _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);
        }
    }

    /**
     * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.
     */
    function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {
        _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);
        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);
        }
    }

    /**
     * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     *
     * @return receiveTokenQuantity The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
         ISetToken setToken = _actionInfo.setToken;
         uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

         setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * Calculates protocol fee on module and pays protocol fee from SetToken
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)
     */
    function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {
        _updateCollateralPosition(
            actionInfo.setToken,
            actionInfo.collateralCTokenAsset,
            _getCollateralPosition(
                actionInfo.setToken,
                actionInfo.collateralCTokenAsset,
                actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                actionInfo.setToken,
                actionInfo.borrowCTokenAsset,
                actionInfo.setTotalSupply,
                false // Do not accrue interest
            )
        );
    }

    function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_cToken), _newPositionUnit);
    }

    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, "");
    }

    /**
     * Construct the ActionInfo struct for lever and delever
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever
        );
    }

    /**
     * Construct the ActionInfo struct for lever and delever accepting notional units
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            setToken: _setToken,
            collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],
            borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],
            setTotalSupply: totalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }



    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");
        require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");
        require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.
     * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.
     */
    function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {
        uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));
        // Round negative away from 0
        int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);

        return borrowPositionUnit;
    }
}.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "/*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { Compound } from "../../integration/lib/Compound.sol";
import { ICErc20 } from "../../../interfaces/external/ICErc20.sol";
import { IComptroller } from "../../../interfaces/external/IComptroller.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title CompoundLeverageModule
 * @author Set Protocol
 *
 * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call
 * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each
 * asset is leveraged when using this module.
 *
 * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 *
 */
contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {
    using Compound for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken
        address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken
        address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset
        ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    /* ============ Events ============ */

    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the trade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping of underlying to CToken. If ETH, then map WETH to cETH
    mapping(IERC20 => ICErc20) public underlyingToCToken;

    // Wrapped Ether address
    IERC20 internal weth;

    // Compound cEther address
    ICErc20 internal cEther;

    // Compound Comptroller contract
    IComptroller internal comptroller;

    // COMP token address
    IERC20 internal compToken;

    // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public collateralCTokenEnabled;

    // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public borrowCTokenEnabled;

    // Mapping of enabled collateral and borrow cTokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list
    bool public anySetAllowed;


    /* ============ Constructor ============ */

    /**
     * Instantiate addresses. Underlying to cToken mapping is created.
     *
     * @param _controller               Address of controller contract
     * @param _compToken                Address of COMP token
     * @param _comptroller              Address of Compound Comptroller
     * @param _cEther                   Address of cEther contract
     * @param _weth                     Address of WETH contract
     */
    constructor(
        IController _controller,
        IERC20 _compToken,
        IComptroller _comptroller,
        ICErc20 _cEther,
        IERC20 _weth
    )
        public
        ModuleBase(_controller)
    {
        compToken = _compToken;
        comptroller = _comptroller;
        cEther = _cEther;
        weth = _weth;

        ICErc20[] memory cTokens = comptroller.getAllMarkets();

        for(uint256 i = 0; i < cTokens.length; i++) {
            ICErc20 cToken = cTokens[i];
            underlyingToCToken[
                cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())
            ] = cToken;
        }
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.
     * Performs a DEX trade, exchanging the borrow asset for collateral asset.
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAsset          Address of asset being borrowed for leverage
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _borrowQuantity       Borrow quantity of asset in position units
     * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantity,
        uint256 _minReceiveQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantity,
            _minReceiveQuantity,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        uint256 _minRepayQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantity,
            _minRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received
     * borrow asset is updated as equity. No protocol fee is charged.
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());

        require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly
        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);

        // Update default position first to save gas on editing borrow position
        _setToken.calculateAndEditDefaultPosition(
            address(_repayAsset),
            deleverInfo.setTotalSupply,
            deleverInfo.preTradeReceiveTokenBalance
        );

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0 // No protocol fee
        );
    }

    /**
     * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral
     * assets, update cToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     *
     * @param _setToken               Instance of the SetToken
     * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value
     */
    function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption
        if (setTotalSupply > 0) {
            // Loop through collateral assets
            address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;
            for(uint256 i = 0; i < collateralCTokens.length; i++) {
                ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);
                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);
                }
            }

            // Loop through borrow assets
            address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;
            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowCTokens.length; i++) {
                ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));

                int256 newPositionUnit = _getBorrowPosition(
                    _setToken,
                    borrowCToken,
                    setTotalSupply,
                    _shouldAccrueInterest
                );

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }


    /**
     * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable
     * collateral and borrow assets that don't exist as positions on the SetToken
     *
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // Enable collateral and borrow assets on Compound
        addCollateralAssets(_setToken, _collateralAssets);

        addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled
     * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Compound and SetToken positions prior to any removal action
        sync(setToken, true);

        address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;
        for (uint256 i = 0; i < borrowCTokens.length; i++) {
            ICErc20 cToken = ICErc20(borrowCTokens[i]);

            // Will exit only if token isn't also being used as collateral
            if(!collateralCTokenEnabled[setToken][cToken]) {
                // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound
                setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[setToken][cToken];
        }

        address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;
        for (uint256 i = 0; i < collateralCTokens.length; i++) {
            ICErc20 cToken = ICErc20(collateralCTokens[i]);

            setToken.invokeExitMarket(cToken, comptroller);

            delete collateralCTokenEnabled[setToken][cToken];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken
     * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];
            require(address(cToken) != address(0), "cToken must exist");
            require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            collateralCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].collateralCTokens.push(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets
     * If there is a borrow balance, collateral asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];
            require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");

            // Note: Will only exit market if cToken is not enabled as a borrow asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete collateralCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 newBorrowAsset = _newBorrowAssets[i];
            ICErc20 cToken = underlyingToCToken[newBorrowAsset];
            require(address(cToken) != address(0), "cToken must exist");
            require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            borrowCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].borrowCTokens.push(address(cToken));
            enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));
        }

        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets
     * If there is a borrow balance, borrow asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];
            require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");

            // Note: Will only exit market if cToken is not enabled as a collateral asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));
            enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));
        }

        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.
     *
     * @param _setToken             Instance of the SetToken
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.
     *
     * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _cToken                   Address of cToken to add
     * @param _underlying               Address of underlying token that maps to cToken
     */
    function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) == address(0), "Already added");
        underlyingToCToken[_underlying] = _cToken;
    }

    /**
     * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _underlying               Address of underlying token to remove
     */
    function removeCompoundMarket(IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) != address(0), "Not added");
        delete underlyingToCToken[_underlying];
    }

    /**
     * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, false);
    }

    /**
     * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.
     * Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, true);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);

        _borrow(_setToken, underlyingToCToken[_component], notionalDebt);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);

        _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt);
    }


    /* ============ External Getter Functions ============ */

    /**
     * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an
     * array of underlying that are borrow assets.
     *
     * @return                    Collateral cToken assets that are enabled
     * @return                    Underlying borrowed assets that are enabled.
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralCTokens,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be
     * unwrapped as it only accepts the underlying ETH.
     */
    function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _mintNotional);

            _setToken.invokeMintCEther(_cToken, _mintNotional);
        } else {
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);

            _setToken.invokeMintCToken(_cToken, _mintNotional);
        }
    }

    /**
     * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.
     */
    function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {
        _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);

        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _redeemNotional);
        }
    }

    /**
     * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.
     */
    function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _repayNotional);

            _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);
        } else {
            // Approve to cToken
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);
            _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);
        }
    }

    /**
     * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.
     */
    function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {
        _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);
        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);
        }
    }

    /**
     * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     *
     * @return receiveTokenQuantity The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
         ISetToken setToken = _actionInfo.setToken;
         uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

         setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * Calculates protocol fee on module and pays protocol fee from SetToken
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)
     */
    function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {
        _updateCollateralPosition(
            actionInfo.setToken,
            actionInfo.collateralCTokenAsset,
            _getCollateralPosition(
                actionInfo.setToken,
                actionInfo.collateralCTokenAsset,
                actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                actionInfo.setToken,
                actionInfo.borrowCTokenAsset,
                actionInfo.setTotalSupply,
                false // Do not accrue interest
            )
        );
    }

    function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_cToken), _newPositionUnit);
    }

    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, "");
    }

    /**
     * Construct the ActionInfo struct for lever and delever
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever
        );
    }

    /**
     * Construct the ActionInfo struct for lever and delever accepting notional units
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            setToken: _setToken,
            collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],
            borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],
            setTotalSupply: totalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }



    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");
        require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");
        require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.
     * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.
     */
    function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {
        uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));
        // Round negative away from 0
        int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);

        return borrowPositionUnit;
    }
}".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-01-09 02:00:05 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 02:00:05 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 18410
completion_tokens: 1
total_tokens: 18411
cost: $-1.000000


[2024-01-09 02:00:05 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { Compound } from "../../integration/lib/Compound.sol";
import { ICErc20 } from "../../../interfaces/external/ICErc20.sol";
import { IComptroller } from "../../../interfaces/external/IComptroller.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title CompoundLeverageModule
 * @author Set Protocol
 *
 * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call
 * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each
 * asset is leveraged when using this module.
 *
 * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 *
 */
contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {
    using Compound for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken
        address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken
        address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset
        ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    /* ============ Events ============ */

    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the trade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping of underlying to CToken. If ETH, then map WETH to cETH
    mapping(IERC20 => ICErc20) public underlyingToCToken;

    // Wrapped Ether address
    IERC20 internal weth;

    // Compound cEther address
    ICErc20 internal cEther;

    // Compound Comptroller contract
    IComptroller internal comptroller;

    // COMP token address
    IERC20 internal compToken;

    // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public collateralCTokenEnabled;

    // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public borrowCTokenEnabled;

    // Mapping of enabled collateral and borrow cTokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list
    bool public anySetAllowed;


    /* ============ Constructor ============ */

    /**
     * Instantiate addresses. Underlying to cToken mapping is created.
     *
     * @param _controller               Address of controller contract
     * @param _compToken                Address of COMP token
     * @param _comptroller              Address of Compound Comptroller
     * @param _cEther                   Address of cEther contract
     * @param _weth                     Address of WETH contract
     */
    constructor(
        IController _controller,
        IERC20 _compToken,
        IComptroller _comptroller,
        ICErc20 _cEther,
        IERC20 _weth
    )
        public
        ModuleBase(_controller)
    {
        compToken = _compToken;
        comptroller = _comptroller;
        cEther = _cEther;
        weth = _weth;

        ICErc20[] memory cTokens = comptroller.getAllMarkets();

        for(uint256 i = 0; i < cTokens.length; i++) {
            ICErc20 cToken = cTokens[i];
            underlyingToCToken[
                cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())
            ] = cToken;
        }
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.
     * Performs a DEX trade, exchanging the borrow asset for collateral asset.
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAsset          Address of asset being borrowed for leverage
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _borrowQuantity       Borrow quantity of asset in position units
     * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantity,
        uint256 _minReceiveQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantity,
            _minReceiveQuantity,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        uint256 _minRepayQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantity,
            _minRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received
     * borrow asset is updated as equity. No protocol fee is charged.
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());

        require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly
        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);

        // Update default position first to save gas on editing borrow position
        _setToken.calculateAndEditDefaultPosition(
            address(_repayAsset),
            deleverInfo.setTotalSupply,
            deleverInfo.preTradeReceiveTokenBalance
        );

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0 // No protocol fee
        );
    }

    /**
     * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral
     * assets, update cToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     *
     * @param _setToken               Instance of the SetToken
     * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value
     */
    function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption
        if (setTotalSupply > 0) {
            // Loop through collateral assets
            address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;
            for(uint256 i = 0; i < collateralCTokens.length; i++) {
                ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);
                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);
                }
            }

            // Loop through borrow assets
            address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;
            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowCTokens.length; i++) {
                ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));

                int256 newPositionUnit = _getBorrowPosition(
                    _setToken,
                    borrowCToken,
                    setTotalSupply,
                    _shouldAccrueInterest
                );

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }


    /**
     * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable
     * collateral and borrow assets that don't exist as positions on the SetToken
     *
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // Enable collateral and borrow assets on Compound
        addCollateralAssets(_setToken, _collateralAssets);

        addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled
     * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Compound and SetToken positions prior to any removal action
        sync(setToken, true);

        address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;
        for (uint256 i = 0; i < borrowCTokens.length; i++) {
            ICErc20 cToken = ICErc20(borrowCTokens[i]);

            // Will exit only if token isn't also being used as collateral
            if(!collateralCTokenEnabled[setToken][cToken]) {
                // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound
                setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[setToken][cToken];
        }

        address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;
        for (uint256 i = 0; i < collateralCTokens.length; i++) {
            ICErc20 cToken = ICErc20(collateralCTokens[i]);

            setToken.invokeExitMarket(cToken, comptroller);

            delete collateralCTokenEnabled[setToken][cToken];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken
     * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];
            require(address(cToken) != address(0), "cToken must exist");
            require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            collateralCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].collateralCTokens.push(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets
     * If there is a borrow balance, collateral asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];
            require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");

            // Note: Will only exit market if cToken is not enabled as a borrow asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete collateralCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 newBorrowAsset = _newBorrowAssets[i];
            ICErc20 cToken = underlyingToCToken[newBorrowAsset];
            require(address(cToken) != address(0), "cToken must exist");
            require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            borrowCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].borrowCTokens.push(address(cToken));
            enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));
        }

        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets
     * If there is a borrow balance, borrow asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];
            require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");

            // Note: Will only exit market if cToken is not enabled as a collateral asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));
            enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));
        }

        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.
     *
     * @param _setToken             Instance of the SetToken
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.
     *
     * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _cToken                   Address of cToken to add
     * @param _underlying               Address of underlying token that maps to cToken
     */
    function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) == address(0), "Already added");
        underlyingToCToken[_underlying] = _cToken;
    }

    /**
     * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _underlying               Address of underlying token to remove
     */
    function removeCompoundMarket(IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) != address(0), "Not added");
        delete underlyingToCToken[_underlying];
    }

    /**
     * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, false);
    }

    /**
     * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.
     * Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, true);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);

        _borrow(_setToken, underlyingToCToken[_component], notionalDebt);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);

        _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt);
    }


    /* ============ External Getter Functions ============ */

    /**
     * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an
     * array of underlying that are borrow assets.
     *
     * @return                    Collateral cToken assets that are enabled
     * @return                    Underlying borrowed assets that are enabled.
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralCTokens,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be
     * unwrapped as it only accepts the underlying ETH.
     */
    function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _mintNotional);

            _setToken.invokeMintCEther(_cToken, _mintNotional);
        } else {
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);

            _setToken.invokeMintCToken(_cToken, _mintNotional);
        }
    }

    /**
     * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.
     */
    function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {
        _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);

        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _redeemNotional);
        }
    }

    /**
     * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.
     */
    function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _repayNotional);

            _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);
        } else {
            // Approve to cToken
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);
            _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);
        }
    }

    /**
     * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.
     */
    function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {
        _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);
        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);
        }
    }

    /**
     * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     *
     * @return receiveTokenQuantity The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
         ISetToken setToken = _actionInfo.setToken;
         uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

         setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * Calculates protocol fee on module and pays protocol fee from SetToken
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)
     */
    function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {
        _updateCollateralPosition(
            actionInfo.setToken,
            actionInfo.collateralCTokenAsset,
            _getCollateralPosition(
                actionInfo.setToken,
                actionInfo.collateralCTokenAsset,
                actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                actionInfo.setToken,
                actionInfo.borrowCTokenAsset,
                actionInfo.setTotalSupply,
                false // Do not accrue interest
            )
        );
    }

    function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_cToken), _newPositionUnit);
    }

    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, "");
    }

    /**
     * Construct the ActionInfo struct for lever and delever
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever
        );
    }

    /**
     * Construct the ActionInfo struct for lever and delever accepting notional units
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            setToken: _setToken,
            collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],
            borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],
            setTotalSupply: totalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }



    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");
        require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");
        require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.
     * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.
     */
    function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {
        uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));
        // Round negative away from 0
        int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);

        return borrowPositionUnit;
    }
}.]

Let's

[2024-01-09 02:00:05 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { Compound } from "../../integration/lib/Compound.sol"; import { ICErc20 } from "../../../interfaces/external/ICErc20.sol"; import { IComptroller } from "../../../interfaces/external/IComptroller.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol"; import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; /*  * @title CompoundLeverageModule  * @author Set Protocol  *  * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call  * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each  * asset is leveraged when using this module.  *  * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of  * debt when borrowed assets are the same.  *  / contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {     using Compound for ISetToken; /* ============ Structs ============ */  struct EnabledAssets {     address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken     address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken     address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets }  struct ActionInfo {     ISetToken setToken;                      // SetToken instance     IExchangeAdapter exchangeAdapter;        // Exchange adapter instance     uint256 setTotalSupply;                  // Total supply of SetToken     uint256 notionalSendQuantity;            // Total notional quantity sent to exchange     uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange     ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset     ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset     uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance }  /* ============ Events ============ */  event LeverageIncreased(     ISetToken indexed _setToken,     IERC20 indexed _borrowAsset,     IERC20 indexed _collateralAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalBorrowAmount,     uint256 _totalReceiveAmount,     uint256 _protocolFee );  event LeverageDecreased(     ISetToken indexed _setToken,     IERC20 indexed _collateralAsset,     IERC20 indexed _repayAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalRedeemAmount,     uint256 _totalRepayAmount,     uint256 _protocolFee );  event CollateralAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  event BorrowAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  event SetTokenStatusUpdated(     ISetToken indexed _setToken,     bool indexed _added );  event AnySetAllowedUpdated(     bool indexed _anySetAllowed );  /* ============ Constants ============ */  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the trade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Mapping of underlying to CToken. If ETH, then map WETH to cETH mapping(IERC20 =&gt; ICErc20) public underlyingToCToken;  // Wrapped Ether address IERC20 internal weth;  // Compound cEther address ICErc20 internal cEther;  // Compound Comptroller contract IComptroller internal comptroller;  // COMP token address IERC20 internal compToken;  // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public collateralCTokenEnabled;  // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public borrowCTokenEnabled;  // Mapping of enabled collateral and borrow cTokens for syncing positions mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;  // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance mapping(ISetToken =&gt; bool) public allowedSetTokens;  // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list bool public anySetAllowed;   /* ============ Constructor ============ */  /**  * Instantiate addresses. Underlying to cToken mapping is created.  *  * @param _controller               Address of controller contract  * @param _compToken                Address of COMP token  * @param _comptroller              Address of Compound Comptroller  * @param _cEther                   Address of cEther contract  * @param _weth                     Address of WETH contract  */ constructor(     IController _controller,     IERC20 _compToken,     IComptroller _comptroller,     ICErc20 _cEther,     IERC20 _weth )     public     ModuleBase(_controller) {     compToken = _compToken;     comptroller = _comptroller;     cEther = _cEther;     weth = _weth;      ICErc20[] memory cTokens = comptroller.getAllMarkets();      for(uint256 i = 0; i &lt; cTokens.length; i++) {         ICErc20 cToken = cTokens[i];         underlyingToCToken[             cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())         ] = cToken;     } }  /* ============ External Functions ============ */  /**  * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.  * Performs a DEX trade, exchanging the borrow asset for collateral asset.  *  * @param _setToken             Instance of the SetToken  * @param _borrowAsset          Address of asset being borrowed for leverage  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _borrowQuantity       Borrow quantity of asset in position units  * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function lever(     ISetToken _setToken,     IERC20 _borrowAsset,     IERC20 _collateralAsset,     uint256 _borrowQuantity,     uint256 _minReceiveQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // For levering up, send quantity is derived from borrow asset and receive quantity is derived from     // collateral asset     ActionInfo memory leverInfo = _createAndValidateActionInfo(         _setToken,         _borrowAsset,         _collateralAsset,         _borrowQuantity,         _minReceiveQuantity,         _tradeAdapterName,         true     );      _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);      uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);      _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);      _updateLeverPositions(leverInfo, _borrowAsset);      emit LeverageIncreased(         _setToken,         _borrowAsset,         _collateralAsset,         leverInfo.exchangeAdapter,         leverInfo.notionalSendQuantity,         postTradeCollateralQuantity,         protocolFee     ); }  /**  * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled  *  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _repayAsset           Address of asset being repaid  * @param _redeemQuantity       Quantity of collateral asset to delever  * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function delever(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantity,     uint256 _minRepayQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from     // repay asset     ActionInfo memory deleverInfo = _createAndValidateActionInfo(         _setToken,         _collateralAsset,         _repayAsset,         _redeemQuantity,         _minRepayQuantity,         _tradeAdapterName,         false     );      _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);      uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);      _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);      _updateLeverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         repayQuantity,         protocolFee     ); }  /**  * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received  * borrow asset is updated as equity. No protocol fee is charged.  *  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)  * @param _redeemQuantity       Quantity of collateral asset to delever  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function deleverToZeroBorrowBalance(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());      require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");     uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));      ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(         _setToken,         _collateralAsset,         _repayAsset,         notionalRedeemQuantity,         notionalRepayQuantity,         _tradeAdapterName,         false     );      _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);      _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly     _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);      // Update default position first to save gas on editing borrow position     _setToken.calculateAndEditDefaultPosition(         address(_repayAsset),         deleverInfo.setTotalSupply,         deleverInfo.preTradeReceiveTokenBalance     );      _updateLeverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         notionalRepayQuantity,         0 // No protocol fee     ); }  /**  * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral  * assets, update cToken default position. For borrow assets, update external borrow position.  * - Collateral assets may come out of sync when a position is liquidated  * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid  *  * @param _setToken               Instance of the SetToken  * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value  */ function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {     uint256 setTotalSupply = _setToken.totalSupply();      // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption     if (setTotalSupply &gt; 0) {         // Loop through collateral assets         address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;         for(uint256 i = 0; i &lt; collateralCTokens.length; i++) {             ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);             uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();             uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (previousPositionUnit != newPositionUnit) {               _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);             }         }          // Loop through borrow assets         address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;         address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;         for(uint256 i = 0; i &lt; borrowCTokens.length; i++) {             ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);             IERC20 borrowAsset = IERC20(borrowAssets[i]);              int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));              int256 newPositionUnit = _getBorrowPosition(                 _setToken,                 borrowCToken,                 setTotalSupply,                 _shouldAccrueInterest             );              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (newPositionUnit != previousPositionUnit) {                 _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);             }         }     } }   /**  * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable  * collateral and borrow assets that don't exist as positions on the SetToken  *  * @param _setToken             Instance of the SetToken to initialize  * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken  * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken  */ function initialize(     ISetToken _setToken,     IERC20[] memory _collateralAssets,     IERC20[] memory _borrowAssets )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     if (!anySetAllowed) {         require(allowedSetTokens[_setToken], "Not allowed SetToken");     }      // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}     }      // Enable collateral and borrow assets on Compound     addCollateralAssets(_setToken, _collateralAssets);      addBorrowAssets(_setToken, _borrowAssets); }  /**  * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled  * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)  */ function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Sync Compound and SetToken positions prior to any removal action     sync(setToken, true);      address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;     for (uint256 i = 0; i &lt; borrowCTokens.length; i++) {         ICErc20 cToken = ICErc20(borrowCTokens[i]);          // Will exit only if token isn't also being used as collateral         if(!collateralCTokenEnabled[setToken][cToken]) {             // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound             setToken.invokeExitMarket(cToken, comptroller);         }          delete borrowCTokenEnabled[setToken][cToken];     }      address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;     for (uint256 i = 0; i &lt; collateralCTokens.length; i++) {         ICErc20 cToken = ICErc20(collateralCTokens[i]);          setToken.invokeExitMarket(cToken, comptroller);          delete collateralCTokenEnabled[setToken][cToken];     }      delete enabledAssets[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken  * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state  * inconsistencies  *  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets  *  * @param _setToken             Instance of the SetToken  * @param _newCollateralAssets  Addresses of new collateral underlying assets  */ function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {     for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];         require(address(cToken) != address(0), "cToken must exist");         require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");          // Note: Will only enter market if cToken is not enabled as a borrow asset as well         if (!borrowCTokenEnabled[_setToken][cToken]) {             _setToken.invokeEnterMarkets(cToken, comptroller);         }          collateralCTokenEnabled[_setToken][cToken] = true;         enabledAssets[_setToken].collateralCTokens.push(address(cToken));     }      emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets); }  /**  * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets  * If there is a borrow balance, collateral asset cannot be removed  *  * @param _setToken             Instance of the SetToken  * @param _collateralAssets     Addresses of collateral underlying assets to remove  */ function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {     // Sync Compound and SetToken positions prior to any removal action     sync(_setToken, true);      for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];         require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");          // Note: Will only exit market if cToken is not enabled as a borrow asset as well         // If there is an existing borrow balance, will revert and market cannot be exited on Compound         if (!borrowCTokenEnabled[_setToken][cToken]) {             _setToken.invokeExitMarket(cToken, comptroller);         }          delete collateralCTokenEnabled[_setToken][cToken];         enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));     }      emit CollateralAssetsUpdated(_setToken, false, _collateralAssets); }  /**  * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets  *  * @param _setToken             Instance of the SetToken  * @param _newBorrowAssets      Addresses of borrow underlying assets to add  */ function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {     for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {         IERC20 newBorrowAsset = _newBorrowAssets[i];         ICErc20 cToken = underlyingToCToken[newBorrowAsset];         require(address(cToken) != address(0), "cToken must exist");         require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");          // Note: Will only enter market if cToken is not enabled as a borrow asset as well         if (!collateralCTokenEnabled[_setToken][cToken]) {             _setToken.invokeEnterMarkets(cToken, comptroller);         }          borrowCTokenEnabled[_setToken][cToken] = true;         enabledAssets[_setToken].borrowCTokens.push(address(cToken));         enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));     }      emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets); }  /**  * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets  * If there is a borrow balance, borrow asset cannot be removed  *  * @param _setToken             Instance of the SetToken  * @param _borrowAssets         Addresses of borrow underlying assets to remove  */ function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {     // Sync Compound and SetToken positions prior to any removal action     sync(_setToken, true);      for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];         require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");          // Note: Will only exit market if cToken is not enabled as a collateral asset as well         // If there is an existing borrow balance, will revert and market cannot be exited on Compound         if (!collateralCTokenEnabled[_setToken][cToken]) {             _setToken.invokeExitMarket(cToken, comptroller);         }          delete borrowCTokenEnabled[_setToken][cToken];         enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));         enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));     }      emit BorrowAssetsUpdated(_setToken, false, _borrowAssets); }  /**  * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.  *  * @param _setToken             Instance of the SetToken  */ function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {     allowedSetTokens[_setToken] = _status;     emit SetTokenStatusUpdated(_setToken, _status); }  /**  * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.  *  * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled  */ function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {     anySetAllowed = _anySetAllowed;     emit AnySetAllowedUpdated(_anySetAllowed); }  /**  * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.  *  * IMPORTANT: Validations are skipped in order to get contract under bytecode limit  *  * @param _cToken                   Address of cToken to add  * @param _underlying               Address of underlying token that maps to cToken  */ function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {     require(address(underlyingToCToken[_underlying]) == address(0), "Already added");     underlyingToCToken[_underlying] = _cToken; }  /**  * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals  *  * IMPORTANT: Validations are skipped in order to get contract under bytecode limit  *  * @param _underlying               Address of underlying token to remove  */ function removeCompoundMarket(IERC20 _underlying) external onlyOwner {     require(address(underlyingToCToken[_underlying]) != address(0), "Not added");     delete underlyingToCToken[_underlying]; }  /**  * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {     sync(_setToken, false); }  /**  * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.  * Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {     sync(_setToken, true); }  /**  * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {     int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));      require(componentDebt &lt; 0, "Component must be negative");      uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);      _borrow(_setToken, underlyingToCToken[_component], notionalDebt); }  /**  * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {     int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));      require(componentDebt &lt; 0, "Component must be negative");      uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);      _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt); }   /* ============ External Getter Functions ============ */  /**  * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an  * array of underlying that are borrow assets.  *  * @return                    Collateral cToken assets that are enabled  * @return                    Underlying borrowed assets that are enabled.  */ function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {     return (         enabledAssets[_setToken].collateralCTokens,         enabledAssets[_setToken].borrowAssets     ); }  /* ============ Internal Functions ============ */  /**  * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be  * unwrapped as it only accepts the underlying ETH.  */ function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {     if (_cToken == cEther) {         _setToken.invokeUnwrapWETH(address(weth), _mintNotional);          _setToken.invokeMintCEther(_cToken, _mintNotional);     } else {         _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);          _setToken.invokeMintCToken(_cToken, _mintNotional);     } }  /**  * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.  */ function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {     _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);      if (_cToken == cEther) {         _setToken.invokeWrapWETH(address(weth), _redeemNotional);     } }  /**  * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.  */ function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {     if (_cToken == cEther) {         _setToken.invokeUnwrapWETH(address(weth), _repayNotional);          _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);     } else {         // Approve to cToken         _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);         _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);     } }  /**  * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.  */ function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {     _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);     if (_cToken == cEther) {         _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);     } }  /**  * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken  *  * @return receiveTokenQuantity The quantity of tokens received post-trade  */ function _executeTrade(     ActionInfo memory _actionInfo,     IERC20 _sendToken,     IERC20 _receiveToken,     bytes memory _data )     internal     returns (uint256) {      ISetToken setToken = _actionInfo.setToken;      uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;       setToken.invokeApprove(         address(_sendToken),         _actionInfo.exchangeAdapter.getSpender(),         notionalSendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _actionInfo.exchangeAdapter.getTradeCalldata(         address(_sendToken),         address(_receiveToken),         address(setToken),         notionalSendQuantity,         _actionInfo.minNotionalReceiveQuantity,         _data     );      setToken.invoke(targetExchange, callValue, methodData);      uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);     require(         receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,         "Slippage too high"     );      return receiveTokenQuantity; }  /**  * Calculates protocol fee on module and pays protocol fee from SetToken  */ function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {     uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);      payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);      return protocolFeeTotal; }  /**  * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)  */ function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {     _updateCollateralPosition(         actionInfo.setToken,         actionInfo.collateralCTokenAsset,         _getCollateralPosition(             actionInfo.setToken,             actionInfo.collateralCTokenAsset,             actionInfo.setTotalSupply         )     );      _updateBorrowPosition(         actionInfo.setToken,         _borrowAsset,         _getBorrowPosition(             actionInfo.setToken,             actionInfo.borrowCTokenAsset,             actionInfo.setTotalSupply,             false // Do not accrue interest         )     ); }  function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {     _setToken.editDefaultPosition(address(_cToken), _newPositionUnit); }  function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {     _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, ""); }  /**  * Construct the ActionInfo struct for lever and delever  */ function _createAndValidateActionInfo(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _sendQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();      return _createAndValidateActionInfoNotional(         _setToken,         _sendToken,         _receiveToken,         _sendQuantityUnits.preciseMul(totalSupply),         _minReceiveQuantityUnits.preciseMul(totalSupply),         _tradeAdapterName,         _isLever     ); }  /**  * Construct the ActionInfo struct for lever and delever accepting notional units  */ function _createAndValidateActionInfoNotional(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _notionalSendQuantity,     uint256 _minNotionalReceiveQuantity,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();     ActionInfo memory actionInfo = ActionInfo ({         exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),         setToken: _setToken,         collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],         borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],         setTotalSupply: totalSupply,         notionalSendQuantity: _notionalSendQuantity,         minNotionalReceiveQuantity: _minNotionalReceiveQuantity,         preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))     });      _validateCommon(actionInfo);      return actionInfo; }    function _validateCommon(ActionInfo memory _actionInfo) internal view {     require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");     require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");     require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");     require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0"); }  function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {     uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));     return collateralNotionalBalance.preciseDiv(_setTotalSupply); }  /**  * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.  * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.  */ function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {     uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));     // Round negative away from 0     int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);      return borrowPositionUnit; }  } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: /\n    Copyright 2021 Set Labs Inc.\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n    SPDX-License-Identifier: Apache License, Version 2.0\n/\npragma solidity 0.6.10;\npragma experimental "ABIEncoderV2";\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";\nimport { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\nimport { Compound } from "../../integration/lib/Compound.sol";\nimport { ICErc20 } from "../../../interfaces/external/ICErc20.sol";\nimport { IComptroller } from "../../../interfaces/external/IComptroller.sol";\nimport { IController } from "../../../interfaces/IController.sol";\nimport { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";\nimport { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";\nimport { ISetToken } from "../../../interfaces/ISetToken.sol";\nimport { ModuleBase } from "../../lib/ModuleBase.sol";\n/\n * @title CompoundLeverageModule\n * @author Set Protocol\n \n * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call\n * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each\n * asset is leveraged when using this module.\n \n * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of\n * debt when borrowed assets are the same.\n \n /\ncontract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {\n    using Compound for ISetToken;\n    / ============ Structs ============ /\n    struct EnabledAssets {\n        address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken\n        address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken\n        address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets\n    }\n    struct ActionInfo {\n        ISetToken setToken;                      // SetToken instance\n        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance\n        uint256 setTotalSupply;                  // Total supply of SetToken\n        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange\n        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange\n        ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset\n        ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset\n        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance\n    }\n    / ============ Events ============ /\n    event LeverageIncreased(\n        ISetToken indexed _setToken,\n        IERC20 indexed _borrowAsset,\n        IERC20 indexed _collateralAsset,\n        IExchangeAdapter _exchangeAdapter,\n        uint256 _totalBorrowAmount,\n        uint256 _totalReceiveAmount,\n        uint256 _protocolFee\n    );\n    event LeverageDecreased(\n        ISetToken indexed _setToken,\n        IERC20 indexed _collateralAsset,\n        IERC20 indexed _repayAsset,\n        IExchangeAdapter _exchangeAdapter,\n        uint256 _totalRedeemAmount,\n        uint256 _totalRepayAmount,\n        uint256 _protocolFee\n    );\n    event CollateralAssetsUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added,\n        IERC20[] _assets\n    );\n    event BorrowAssetsUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added,\n        IERC20[] _assets\n    );\n    event SetTokenStatusUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added\n    );\n    event AnySetAllowedUpdated(\n        bool indexed _anySetAllowed\n    );\n    / ============ Constants ============ /\n    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as\n    // the string as the integration name\n    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";\n    // 0 index stores protocol fee % on the controller, charged in the trade function\n    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;\n    / ============ State Variables ============ /\n    // Mapping of underlying to CToken. If ETH, then map WETH to cETH\n    mapping(IERC20 =&gt; ICErc20) public underlyingToCToken;\n    // Wrapped Ether address\n    IERC20 internal weth;\n    // Compound cEther address\n    ICErc20 internal cEther;\n    // Compound Comptroller contract\n    IComptroller internal comptroller;\n    // COMP token address\n    IERC20 internal compToken;\n    // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken\n    mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public collateralCTokenEnabled;\n    // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken\n    mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public borrowCTokenEnabled;\n    // Mapping of enabled collateral and borrow cTokens for syncing positions\n    mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;\n    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance\n    mapping(ISetToken =&gt; bool) public allowedSetTokens;\n    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list\n    bool public anySetAllowed;\n\n    / ============ Constructor ============ /\n    /\n     * Instantiate addresses. Underlying to cToken mapping is created.\n     \n     * @param _controller               Address of controller contract\n     * @param _compToken                Address of COMP token\n     * @param _comptroller              Address of Compound Comptroller\n     * @param _cEther                   Address of cEther contract\n     * @param _weth                     Address of WETH contract\n     /\n    constructor(\n        IController _controller,\n        IERC20 _compToken,\n        IComptroller _comptroller,\n        ICErc20 _cEther,\n        IERC20 _weth\n    )\n        public\n        ModuleBase(_controller)\n    {\n        compToken = _compToken;\n        comptroller = _comptroller;\n        cEther = _cEther;\n        weth = _weth;\n        ICErc20[] memory cTokens = comptroller.getAllMarkets();\n        for(uint256 i = 0; i &lt; cTokens.length; i++) {\n            ICErc20 cToken = cTokens[i];\n            underlyingToCToken[\n                cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())\n            ] = cToken;\n        }\n    }\n    / ============ External Functions ============ /\n    /\n     * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.\n     * Performs a DEX trade, exchanging the borrow asset for collateral asset.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _borrowAsset          Address of asset being borrowed for leverage\n     * @param _collateralAsset      Address of collateral asset (underlying of cToken)\n     * @param _borrowQuantity       Borrow quantity of asset in position units\n     * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units\n     * @param _tradeAdapterName     Name of trade adapter\n     * @param _tradeData            Arbitrary data for trade\n     /\n    function lever(\n        ISetToken _setToken,\n        IERC20 _borrowAsset,\n        IERC20 _collateralAsset,\n        uint256 _borrowQuantity,\n        uint256 _minReceiveQuantity,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from\n        // collateral asset\n        ActionInfo memory leverInfo = _createAndValidateActionInfo(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            _borrowQuantity,\n            _minReceiveQuantity,\n            _tradeAdapterName,\n            true\n        );\n        _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);\n        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);\n        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);\n        _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);\n        _updateLeverPositions(leverInfo, _borrowAsset);\n        emit LeverageIncreased(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            leverInfo.exchangeAdapter,\n            leverInfo.notionalSendQuantity,\n            postTradeCollateralQuantity,\n            protocolFee\n        );\n    }\n    /\n     * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _collateralAsset      Address of collateral asset (underlying of cToken)\n     * @param _repayAsset           Address of asset being repaid\n     * @param _redeemQuantity       Quantity of collateral asset to delever\n     * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade\n     * @param _tradeAdapterName     Name of trade adapter\n     * @param _tradeData            Arbitrary data for trade\n     /\n    function delever(\n        ISetToken _setToken,\n        IERC20 _collateralAsset,\n        IERC20 _repayAsset,\n        uint256 _redeemQuantity,\n        uint256 _minRepayQuantity,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from\n        // repay asset\n        ActionInfo memory deleverInfo = _createAndValidateActionInfo(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            _redeemQuantity,\n            _minRepayQuantity,\n            _tradeAdapterName,\n            false\n        );\n        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);\n        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);\n        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);\n        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);\n        _updateLeverPositions(deleverInfo, _repayAsset);\n        emit LeverageDecreased(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            deleverInfo.exchangeAdapter,\n            deleverInfo.notionalSendQuantity,\n            repayQuantity,\n            protocolFee\n        );\n    }\n    /\n     * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received\n     * borrow asset is updated as equity. No protocol fee is charged.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _collateralAsset      Address of collateral asset (underlying of cToken)\n     * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)\n     * @param _redeemQuantity       Quantity of collateral asset to delever\n     * @param _tradeAdapterName     Name of trade adapter\n     * @param _tradeData            Arbitrary data for trade\n     /\n    function deleverToZeroBorrowBalance(\n        ISetToken _setToken,\n        IERC20 _collateralAsset,\n        IERC20 _repayAsset,\n        uint256 _redeemQuantity,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());\n        require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");\n        uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));\n        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            notionalRedeemQuantity,\n            notionalRepayQuantity,\n            _tradeAdapterName,\n            false\n        );\n        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);\n        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n        // We use notionalRepayQuantity vs. Compound\'s max value uint256(-1) to handle WETH properly\n        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);\n        // Update default position first to save gas on editing borrow position\n        _setToken.calculateAndEditDefaultPosition(\n            address(_repayAsset),\n            deleverInfo.setTotalSupply,\n            deleverInfo.preTradeReceiveTokenBalance\n        );\n        _updateLeverPositions(deleverInfo, _repayAsset);\n        emit LeverageDecreased(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            deleverInfo.exchangeAdapter,\n            deleverInfo.notionalSendQuantity,\n            notionalRepayQuantity,\n            0 // No protocol fee\n        );\n    }\n    /\n     * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral\n     * assets, update cToken default position. For borrow assets, update external borrow position.\n     * - Collateral assets may come out of sync when a position is liquidated\n     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid\n     \n     * @param _setToken               Instance of the SetToken\n     * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value\n     /\n    function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {\n        uint256 setTotalSupply = _setToken.totalSupply();\n        // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption\n        if (setTotalSupply &gt; 0) {\n            // Loop through collateral assets\n            address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;\n            for(uint256 i = 0; i &lt; collateralCTokens.length; i++) {\n                ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);\n                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();\n                uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);\n                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets\n                if (previousPositionUnit != newPositionUnit) {\n                  _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);\n                }\n            }\n            // Loop through borrow assets\n            address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;\n            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;\n            for(uint256 i = 0; i &lt; borrowCTokens.length; i++) {\n                ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);\n                IERC20 borrowAsset = IERC20(borrowAssets[i]);\n                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));\n                int256 newPositionUnit = _getBorrowPosition(\n                    _setToken,\n                    borrowCToken,\n                    setTotalSupply,\n                    _shouldAccrueInterest\n                );\n                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets\n                if (newPositionUnit != previousPositionUnit) {\n                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);\n                }\n            }\n        }\n    }\n\n    /\n     * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken\'s manager. Note: managers can enable\n     * collateral and borrow assets that don\'t exist as positions on the SetToken\n     \n     * @param _setToken             Instance of the SetToken to initialize\n     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken\n     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken\n     /\n    function initialize(\n        ISetToken _setToken,\n        IERC20[] memory _collateralAssets,\n        IERC20[] memory _borrowAssets\n    )\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        if (!anySetAllowed) {\n            require(allowedSetTokens[_setToken], "Not allowed SetToken");\n        }\n        // Initialize module before trying register\n        _setToken.initializeModule();\n        // Get debt issuance module registered to this module and require that it is initialized\n        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");\n        // Try if register exists on any of the modules including the debt issuance module\n        address[] memory modules = _setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}\n        }\n        // Enable collateral and borrow assets on Compound\n        addCollateralAssets(_setToken, _collateralAssets);\n        addBorrowAssets(_setToken, _borrowAssets);\n    }\n    /\n     * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled\n     * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)\n     /\n    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {\n        ISetToken setToken = ISetToken(msg.sender);\n        // Sync Compound and SetToken positions prior to any removal action\n        sync(setToken, true);\n        address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;\n        for (uint256 i = 0; i &lt; borrowCTokens.length; i++) {\n            ICErc20 cToken = ICErc20(borrowCTokens[i]);\n            // Will exit only if token isn\'t also being used as collateral\n            if(!collateralCTokenEnabled[setToken][cToken]) {\n                // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound\n                setToken.invokeExitMarket(cToken, comptroller);\n            }\n            delete borrowCTokenEnabled[setToken][cToken];\n        }\n        address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;\n        for (uint256 i = 0; i &lt; collateralCTokens.length; i++) {\n            ICErc20 cToken = ICErc20(collateralCTokens[i]);\n            setToken.invokeExitMarket(cToken, comptroller);\n            delete collateralCTokenEnabled[setToken][cToken];\n        }\n        delete enabledAssets[setToken];\n        // Try if unregister exists on any of the modules\n        address[] memory modules = setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}\n        }\n    }\n    /\n     * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken\n     * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state\n     * inconsistencies\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _debtIssuanceModule   Debt issuance module address to register\n     /\n    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {\n        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");\n        _debtIssuanceModule.registerToIssuanceModule(_setToken);\n    }\n    /\n     * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _newCollateralAssets  Addresses of new collateral underlying assets\n     /\n    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {\n        for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {\n            ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];\n            require(address(cToken) != address(0), "cToken must exist");\n            require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");\n            // Note: Will only enter market if cToken is not enabled as a borrow asset as well\n            if (!borrowCTokenEnabled[_setToken][cToken]) {\n                _setToken.invokeEnterMarkets(cToken, comptroller);\n            }\n            collateralCTokenEnabled[_setToken][cToken] = true;\n            enabledAssets[_setToken].collateralCTokens.push(address(cToken));\n        }\n        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);\n    }\n    /\n     * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets\n     * If there is a borrow balance, collateral asset cannot be removed\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _collateralAssets     Addresses of collateral underlying assets to remove\n     /\n    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {\n        // Sync Compound and SetToken positions prior to any removal action\n        sync(_setToken, true);\n        for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {\n            ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];\n            require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");\n            // Note: Will only exit market if cToken is not enabled as a borrow asset as well\n            // If there is an existing borrow balance, will revert and market cannot be exited on Compound\n            if (!borrowCTokenEnabled[_setToken][cToken]) {\n                _setToken.invokeExitMarket(cToken, comptroller);\n            }\n            delete collateralCTokenEnabled[_setToken][cToken];\n            enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));\n        }\n        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);\n    }\n    /\n     * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _newBorrowAssets      Addresses of borrow underlying assets to add\n     /\n    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {\n        for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {\n            IERC20 newBorrowAsset = _newBorrowAssets[i];\n            ICErc20 cToken = underlyingToCToken[newBorrowAsset];\n            require(address(cToken) != address(0), "cToken must exist");\n            require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");\n            // Note: Will only enter market if cToken is not enabled as a borrow asset as well\n            if (!collateralCTokenEnabled[_setToken][cToken]) {\n                _setToken.invokeEnterMarkets(cToken, comptroller);\n            }\n            borrowCTokenEnabled[_setToken][cToken] = true;\n            enabledAssets[_setToken].borrowCTokens.push(address(cToken));\n            enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));\n        }\n        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);\n    }\n    /\n     * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets\n     * If there is a borrow balance, borrow asset cannot be removed\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _borrowAssets         Addresses of borrow underlying assets to remove\n     /\n    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {\n        // Sync Compound and SetToken positions prior to any removal action\n        sync(_setToken, true);\n        for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {\n            ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];\n            require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");\n            // Note: Will only exit market if cToken is not enabled as a collateral asset as well\n            // If there is an existing borrow balance, will revert and market cannot be exited on Compound\n            if (!collateralCTokenEnabled[_setToken][cToken]) {\n                _setToken.invokeExitMarket(cToken, comptroller);\n            }\n            delete borrowCTokenEnabled[_setToken][cToken];\n            enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));\n            enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));\n        }\n        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);\n    }\n    /\n     * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.\n     \n     * @param _setToken             Instance of the SetToken\n     /\n    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {\n        allowedSetTokens[_setToken] = _status;\n        emit SetTokenStatusUpdated(_setToken, _status);\n    }\n    /\n     * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.\n     \n     * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled\n     /\n    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {\n        anySetAllowed = _anySetAllowed;\n        emit AnySetAllowedUpdated(_anySetAllowed);\n    }\n    /\n     * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.\n     \n     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit\n     \n     * @param _cToken                   Address of cToken to add\n     * @param _underlying               Address of underlying token that maps to cToken\n     /\n    function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {\n        require(address(underlyingToCToken[_underlying]) == address(0), "Already added");\n        underlyingToCToken[_underlying] = _cToken;\n    }\n    /\n     * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals\n     \n     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit\n     \n     * @param _underlying               Address of underlying token to remove\n     */\n    function removeCompoundMarket(IERC20 _underlying) external onlyOwner {\n        require(address(underlyingToCToken[_underlying]) != address(0), "Not added");\n        delete underlyingToCToken[_underlying];\n    }\n    /\n     * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.\n     \n     * @param _setToken             Instance of the SetToken\n     /\n    function moduleIssueHook(ISetToken _setToken, uint256 / _setTokenQuantity /) external onlyModule(_setToken) {\n        sync(_setToken, false);\n    }\n    /\n     * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.\n     * Only callable by valid module.\n     \n     * @param _setToken             Instance of the SetToken\n     /\n    function moduleRedeemHook(ISetToken _setToken, uint256 / _setTokenQuantity /) external onlyModule(_setToken) {\n        sync(_setToken, true);\n    }\n    /\n     * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken\n     * @param _component            Address of component\n     /\n    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool / _isEquity /) external onlyModule(_setToken) {\n        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n        require(componentDebt &lt; 0, "Component must be negative");\n        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);\n        _borrow(_setToken, underlyingToCToken[_component], notionalDebt);\n    }\n    /\n     * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken\n     * @param _component            Address of component\n     /\n    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool / _isEquity /) external onlyModule(_setToken) {\n        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n        require(componentDebt &lt; 0, "Component must be negative");\n        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);\n        _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt);\n    }\n\n    / ============ External Getter Functions ============ /\n    /\n     * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an\n     * array of underlying that are borrow assets.\n     \n     * @return                    Collateral cToken assets that are enabled\n     * @return                    Underlying borrowed assets that are enabled.\n     /\n    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {\n        return (\n            enabledAssets[_setToken].collateralCTokens,\n            enabledAssets[_setToken].borrowAssets\n        );\n    }\n    / ============ Internal Functions ============ /\n    /\n     * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be\n     * unwrapped as it only accepts the underlying ETH.\n     */\n    function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {\n        if (_cToken == cEther) {\n            _setToken.invokeUnwrapWETH(address(weth), _mintNotional);\n            _setToken.invokeMintCEther(_cToken, _mintNotional);\n        } else {\n            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);\n            _setToken.invokeMintCToken(_cToken, _mintNotional);\n        }\n    }\n    /\n     * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.\n     /\n    function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {\n        _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);\n        if (_cToken == cEther) {\n            _setToken.invokeWrapWETH(address(weth), _redeemNotional);\n        }\n    }\n    /\n     * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.\n     /\n    function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {\n        if (_cToken == cEther) {\n            _setToken.invokeUnwrapWETH(address(weth), _repayNotional);\n            _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);\n        } else {\n            // Approve to cToken\n            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);\n            _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);\n        }\n    }\n    /\n     * Invoke the SetToken to interact with the specified cToken to borrow the cToken\'s underlying of the specified borrowQuantity.\n     */\n    function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {\n        _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);\n        if (_cToken == cEther) {\n            _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);\n        }\n    }\n    /\n     * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken\n     \n     * @return receiveTokenQuantity The quantity of tokens received post-trade\n     /\n    function _executeTrade(\n        ActionInfo memory _actionInfo,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        bytes memory _data\n    )\n        internal\n        returns (uint256)\n    {\n         ISetToken setToken = _actionInfo.setToken;\n         uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;\n         setToken.invokeApprove(\n            address(_sendToken),\n            _actionInfo.exchangeAdapter.getSpender(),\n            notionalSendQuantity\n        );\n        (\n            address targetExchange,\n            uint256 callValue,\n            bytes memory methodData\n        ) = _actionInfo.exchangeAdapter.getTradeCalldata(\n            address(_sendToken),\n            address(_receiveToken),\n            address(setToken),\n            notionalSendQuantity,\n            _actionInfo.minNotionalReceiveQuantity,\n            _data\n        );\n        setToken.invoke(targetExchange, callValue, methodData);\n        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);\n        require(\n            receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,\n            "Slippage too high"\n        );\n        return receiveTokenQuantity;\n    }\n    /\n     * Calculates protocol fee on module and pays protocol fee from SetToken\n     */\n    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {\n        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);\n        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);\n        return protocolFeeTotal;\n    }\n    /\n     * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)\n     /\n    function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {\n        _updateCollateralPosition(\n            actionInfo.setToken,\n            actionInfo.collateralCTokenAsset,\n            _getCollateralPosition(\n                actionInfo.setToken,\n                actionInfo.collateralCTokenAsset,\n                actionInfo.setTotalSupply\n            )\n        );\n        _updateBorrowPosition(\n            actionInfo.setToken,\n            _borrowAsset,\n            _getBorrowPosition(\n                actionInfo.setToken,\n                actionInfo.borrowCTokenAsset,\n                actionInfo.setTotalSupply,\n                false // Do not accrue interest\n            )\n        );\n    }\n    function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {\n        _setToken.editDefaultPosition(address(_cToken), _newPositionUnit);\n    }\n    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {\n        _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, "");\n    }\n    /\n     * Construct the ActionInfo struct for lever and delever\n     /\n    function _createAndValidateActionInfo(\n        ISetToken _setToken,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        uint256 _sendQuantityUnits,\n        uint256 _minReceiveQuantityUnits,\n        string memory _tradeAdapterName,\n        bool _isLever\n    )\n        internal\n        view\n        returns(ActionInfo memory)\n    {\n        uint256 totalSupply = _setToken.totalSupply();\n        return _createAndValidateActionInfoNotional(\n            _setToken,\n            _sendToken,\n            _receiveToken,\n            _sendQuantityUnits.preciseMul(totalSupply),\n            _minReceiveQuantityUnits.preciseMul(totalSupply),\n            _tradeAdapterName,\n            _isLever\n        );\n    }\n    /\n     * Construct the ActionInfo struct for lever and delever accepting notional units\n     */\n    function _createAndValidateActionInfoNotional(\n        ISetToken _setToken,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        uint256 _notionalSendQuantity,\n        uint256 _minNotionalReceiveQuantity,\n        string memory _tradeAdapterName,\n        bool _isLever\n    )\n        internal\n        view\n        returns(ActionInfo memory)\n    {\n        uint256 totalSupply = _setToken.totalSupply();\n        ActionInfo memory actionInfo = ActionInfo ({\n            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),\n            setToken: _setToken,\n            collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],\n            borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],\n            setTotalSupply: totalSupply,\n            notionalSendQuantity: _notionalSendQuantity,\n            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,\n            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))\n        });\n        _validateCommon(actionInfo);\n        return actionInfo;\n    }\n\n    function _validateCommon(ActionInfo memory _actionInfo) internal view {\n        require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");\n        require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");\n        require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");\n        require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0");\n    }\n    function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {\n        uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));\n        return collateralNotionalBalance.preciseDiv(_setTotalSupply);\n    }\n    /\n     * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.\n     * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.\n     /\n    function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {\n        uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));\n        // Round negative away from 0\n        int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);\n        return borrowPositionUnit;\n    }\n}.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "/\n    Copyright 2021 Set Labs Inc.\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n    SPDX-License-Identifier: Apache License, Version 2.0\n/\npragma solidity 0.6.10;\npragma experimental "ABIEncoderV2";\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";\nimport { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\nimport { Compound } from "../../integration/lib/Compound.sol";\nimport { ICErc20 } from "../../../interfaces/external/ICErc20.sol";\nimport { IComptroller } from "../../../interfaces/external/IComptroller.sol";\nimport { IController } from "../../../interfaces/IController.sol";\nimport { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";\nimport { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";\nimport { ISetToken } from "../../../interfaces/ISetToken.sol";\nimport { ModuleBase } from "../../lib/ModuleBase.sol";\n/\n * @title CompoundLeverageModule\n * @author Set Protocol\n \n * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call\n * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each\n * asset is leveraged when using this module.\n \n * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of\n * debt when borrowed assets are the same.\n \n /\ncontract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {\n    using Compound for ISetToken;\n    / ============ Structs ============ /\n    struct EnabledAssets {\n        address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken\n        address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken\n        address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets\n    }\n    struct ActionInfo {\n        ISetToken setToken;                      // SetToken instance\n        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance\n        uint256 setTotalSupply;                  // Total supply of SetToken\n        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange\n        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange\n        ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset\n        ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset\n        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance\n    }\n    / ============ Events ============ /\n    event LeverageIncreased(\n        ISetToken indexed _setToken,\n        IERC20 indexed _borrowAsset,\n        IERC20 indexed _collateralAsset,\n        IExchangeAdapter _exchangeAdapter,\n        uint256 _totalBorrowAmount,\n        uint256 _totalReceiveAmount,\n        uint256 _protocolFee\n    );\n    event LeverageDecreased(\n        ISetToken indexed _setToken,\n        IERC20 indexed _collateralAsset,\n        IERC20 indexed _repayAsset,\n        IExchangeAdapter _exchangeAdapter,\n        uint256 _totalRedeemAmount,\n        uint256 _totalRepayAmount,\n        uint256 _protocolFee\n    );\n    event CollateralAssetsUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added,\n        IERC20[] _assets\n    );\n    event BorrowAssetsUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added,\n        IERC20[] _assets\n    );\n    event SetTokenStatusUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added\n    );\n    event AnySetAllowedUpdated(\n        bool indexed _anySetAllowed\n    );\n    / ============ Constants ============ /\n    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as\n    // the string as the integration name\n    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";\n    // 0 index stores protocol fee % on the controller, charged in the trade function\n    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;\n    / ============ State Variables ============ /\n    // Mapping of underlying to CToken. If ETH, then map WETH to cETH\n    mapping(IERC20 =&gt; ICErc20) public underlyingToCToken;\n    // Wrapped Ether address\n    IERC20 internal weth;\n    // Compound cEther address\n    ICErc20 internal cEther;\n    // Compound Comptroller contract\n    IComptroller internal comptroller;\n    // COMP token address\n    IERC20 internal compToken;\n    // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken\n    mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public collateralCTokenEnabled;\n    // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken\n    mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public borrowCTokenEnabled;\n    // Mapping of enabled collateral and borrow cTokens for syncing positions\n    mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;\n    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance\n    mapping(ISetToken =&gt; bool) public allowedSetTokens;\n    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list\n    bool public anySetAllowed;\n\n    / ============ Constructor ============ /\n    /\n     * Instantiate addresses. Underlying to cToken mapping is created.\n     \n     * @param _controller               Address of controller contract\n     * @param _compToken                Address of COMP token\n     * @param _comptroller              Address of Compound Comptroller\n     * @param _cEther                   Address of cEther contract\n     * @param _weth                     Address of WETH contract\n     /\n    constructor(\n        IController _controller,\n        IERC20 _compToken,\n        IComptroller _comptroller,\n        ICErc20 _cEther,\n        IERC20 _weth\n    )\n        public\n        ModuleBase(_controller)\n    {\n        compToken = _compToken;\n        comptroller = _comptroller;\n        cEther = _cEther;\n        weth = _weth;\n        ICErc20[] memory cTokens = comptroller.getAllMarkets();\n        for(uint256 i = 0; i &lt; cTokens.length; i++) {\n            ICErc20 cToken = cTokens[i];\n            underlyingToCToken[\n                cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())\n            ] = cToken;\n        }\n    }\n    / ============ External Functions ============ /\n    /\n     * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.\n     * Performs a DEX trade, exchanging the borrow asset for collateral asset.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _borrowAsset          Address of asset being borrowed for leverage\n     * @param _collateralAsset      Address of collateral asset (underlying of cToken)\n     * @param _borrowQuantity       Borrow quantity of asset in position units\n     * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units\n     * @param _tradeAdapterName     Name of trade adapter\n     * @param _tradeData            Arbitrary data for trade\n     /\n    function lever(\n        ISetToken _setToken,\n        IERC20 _borrowAsset,\n        IERC20 _collateralAsset,\n        uint256 _borrowQuantity,\n        uint256 _minReceiveQuantity,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from\n        // collateral asset\n        ActionInfo memory leverInfo = _createAndValidateActionInfo(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            _borrowQuantity,\n            _minReceiveQuantity,\n            _tradeAdapterName,\n            true\n        );\n        _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);\n        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);\n        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);\n        _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);\n        _updateLeverPositions(leverInfo, _borrowAsset);\n        emit LeverageIncreased(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            leverInfo.exchangeAdapter,\n            leverInfo.notionalSendQuantity,\n            postTradeCollateralQuantity,\n            protocolFee\n        );\n    }\n    /\n     * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _collateralAsset      Address of collateral asset (underlying of cToken)\n     * @param _repayAsset           Address of asset being repaid\n     * @param _redeemQuantity       Quantity of collateral asset to delever\n     * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade\n     * @param _tradeAdapterName     Name of trade adapter\n     * @param _tradeData            Arbitrary data for trade\n     /\n    function delever(\n        ISetToken _setToken,\n        IERC20 _collateralAsset,\n        IERC20 _repayAsset,\n        uint256 _redeemQuantity,\n        uint256 _minRepayQuantity,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from\n        // repay asset\n        ActionInfo memory deleverInfo = _createAndValidateActionInfo(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            _redeemQuantity,\n            _minRepayQuantity,\n            _tradeAdapterName,\n            false\n        );\n        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);\n        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);\n        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);\n        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);\n        _updateLeverPositions(deleverInfo, _repayAsset);\n        emit LeverageDecreased(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            deleverInfo.exchangeAdapter,\n            deleverInfo.notionalSendQuantity,\n            repayQuantity,\n            protocolFee\n        );\n    }\n    /\n     * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received\n     * borrow asset is updated as equity. No protocol fee is charged.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _collateralAsset      Address of collateral asset (underlying of cToken)\n     * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)\n     * @param _redeemQuantity       Quantity of collateral asset to delever\n     * @param _tradeAdapterName     Name of trade adapter\n     * @param _tradeData            Arbitrary data for trade\n     /\n    function deleverToZeroBorrowBalance(\n        ISetToken _setToken,\n        IERC20 _collateralAsset,\n        IERC20 _repayAsset,\n        uint256 _redeemQuantity,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());\n        require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");\n        uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));\n        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            notionalRedeemQuantity,\n            notionalRepayQuantity,\n            _tradeAdapterName,\n            false\n        );\n        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);\n        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n        // We use notionalRepayQuantity vs. Compound\'s max value uint256(-1) to handle WETH properly\n        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);\n        // Update default position first to save gas on editing borrow position\n        _setToken.calculateAndEditDefaultPosition(\n            address(_repayAsset),\n            deleverInfo.setTotalSupply,\n            deleverInfo.preTradeReceiveTokenBalance\n        );\n        _updateLeverPositions(deleverInfo, _repayAsset);\n        emit LeverageDecreased(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            deleverInfo.exchangeAdapter,\n            deleverInfo.notionalSendQuantity,\n            notionalRepayQuantity,\n            0 // No protocol fee\n        );\n    }\n    /\n     * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral\n     * assets, update cToken default position. For borrow assets, update external borrow position.\n     * - Collateral assets may come out of sync when a position is liquidated\n     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid\n     \n     * @param _setToken               Instance of the SetToken\n     * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value\n     /\n    function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {\n        uint256 setTotalSupply = _setToken.totalSupply();\n        // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption\n        if (setTotalSupply &gt; 0) {\n            // Loop through collateral assets\n            address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;\n            for(uint256 i = 0; i &lt; collateralCTokens.length; i++) {\n                ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);\n                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();\n                uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);\n                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets\n                if (previousPositionUnit != newPositionUnit) {\n                  _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);\n                }\n            }\n            // Loop through borrow assets\n            address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;\n            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;\n            for(uint256 i = 0; i &lt; borrowCTokens.length; i++) {\n                ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);\n                IERC20 borrowAsset = IERC20(borrowAssets[i]);\n                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));\n                int256 newPositionUnit = _getBorrowPosition(\n                    _setToken,\n                    borrowCToken,\n                    setTotalSupply,\n                    _shouldAccrueInterest\n                );\n                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets\n                if (newPositionUnit != previousPositionUnit) {\n                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);\n                }\n            }\n        }\n    }\n\n    /\n     * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken\'s manager. Note: managers can enable\n     * collateral and borrow assets that don\'t exist as positions on the SetToken\n     \n     * @param _setToken             Instance of the SetToken to initialize\n     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken\n     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken\n     /\n    function initialize(\n        ISetToken _setToken,\n        IERC20[] memory _collateralAssets,\n        IERC20[] memory _borrowAssets\n    )\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        if (!anySetAllowed) {\n            require(allowedSetTokens[_setToken], "Not allowed SetToken");\n        }\n        // Initialize module before trying register\n        _setToken.initializeModule();\n        // Get debt issuance module registered to this module and require that it is initialized\n        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");\n        // Try if register exists on any of the modules including the debt issuance module\n        address[] memory modules = _setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}\n        }\n        // Enable collateral and borrow assets on Compound\n        addCollateralAssets(_setToken, _collateralAssets);\n        addBorrowAssets(_setToken, _borrowAssets);\n    }\n    /\n     * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled\n     * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)\n     /\n    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {\n        ISetToken setToken = ISetToken(msg.sender);\n        // Sync Compound and SetToken positions prior to any removal action\n        sync(setToken, true);\n        address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;\n        for (uint256 i = 0; i &lt; borrowCTokens.length; i++) {\n            ICErc20 cToken = ICErc20(borrowCTokens[i]);\n            // Will exit only if token isn\'t also being used as collateral\n            if(!collateralCTokenEnabled[setToken][cToken]) {\n                // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound\n                setToken.invokeExitMarket(cToken, comptroller);\n            }\n            delete borrowCTokenEnabled[setToken][cToken];\n        }\n        address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;\n        for (uint256 i = 0; i &lt; collateralCTokens.length; i++) {\n            ICErc20 cToken = ICErc20(collateralCTokens[i]);\n            setToken.invokeExitMarket(cToken, comptroller);\n            delete collateralCTokenEnabled[setToken][cToken];\n        }\n        delete enabledAssets[setToken];\n        // Try if unregister exists on any of the modules\n        address[] memory modules = setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}\n        }\n    }\n    /\n     * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken\n     * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state\n     * inconsistencies\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _debtIssuanceModule   Debt issuance module address to register\n     /\n    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {\n        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");\n        _debtIssuanceModule.registerToIssuanceModule(_setToken);\n    }\n    /\n     * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _newCollateralAssets  Addresses of new collateral underlying assets\n     /\n    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {\n        for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {\n            ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];\n            require(address(cToken) != address(0), "cToken must exist");\n            require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");\n            // Note: Will only enter market if cToken is not enabled as a borrow asset as well\n            if (!borrowCTokenEnabled[_setToken][cToken]) {\n                _setToken.invokeEnterMarkets(cToken, comptroller);\n            }\n            collateralCTokenEnabled[_setToken][cToken] = true;\n            enabledAssets[_setToken].collateralCTokens.push(address(cToken));\n        }\n        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);\n    }\n    /\n     * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets\n     * If there is a borrow balance, collateral asset cannot be removed\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _collateralAssets     Addresses of collateral underlying assets to remove\n     /\n    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {\n        // Sync Compound and SetToken positions prior to any removal action\n        sync(_setToken, true);\n        for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {\n            ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];\n            require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");\n            // Note: Will only exit market if cToken is not enabled as a borrow asset as well\n            // If there is an existing borrow balance, will revert and market cannot be exited on Compound\n            if (!borrowCTokenEnabled[_setToken][cToken]) {\n                _setToken.invokeExitMarket(cToken, comptroller);\n            }\n            delete collateralCTokenEnabled[_setToken][cToken];\n            enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));\n        }\n        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);\n    }\n    /\n     * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _newBorrowAssets      Addresses of borrow underlying assets to add\n     /\n    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {\n        for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {\n            IERC20 newBorrowAsset = _newBorrowAssets[i];\n            ICErc20 cToken = underlyingToCToken[newBorrowAsset];\n            require(address(cToken) != address(0), "cToken must exist");\n            require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");\n            // Note: Will only enter market if cToken is not enabled as a borrow asset as well\n            if (!collateralCTokenEnabled[_setToken][cToken]) {\n                _setToken.invokeEnterMarkets(cToken, comptroller);\n            }\n            borrowCTokenEnabled[_setToken][cToken] = true;\n            enabledAssets[_setToken].borrowCTokens.push(address(cToken));\n            enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));\n        }\n        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);\n    }\n    /\n     * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets\n     * If there is a borrow balance, borrow asset cannot be removed\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _borrowAssets         Addresses of borrow underlying assets to remove\n     /\n    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {\n        // Sync Compound and SetToken positions prior to any removal action\n        sync(_setToken, true);\n        for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {\n            ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];\n            require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");\n            // Note: Will only exit market if cToken is not enabled as a collateral asset as well\n            // If there is an existing borrow balance, will revert and market cannot be exited on Compound\n            if (!collateralCTokenEnabled[_setToken][cToken]) {\n                _setToken.invokeExitMarket(cToken, comptroller);\n            }\n            delete borrowCTokenEnabled[_setToken][cToken];\n            enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));\n            enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));\n        }\n        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);\n    }\n    /\n     * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.\n     \n     * @param _setToken             Instance of the SetToken\n     /\n    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {\n        allowedSetTokens[_setToken] = _status;\n        emit SetTokenStatusUpdated(_setToken, _status);\n    }\n    /\n     * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.\n     \n     * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled\n     /\n    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {\n        anySetAllowed = _anySetAllowed;\n        emit AnySetAllowedUpdated(_anySetAllowed);\n    }\n    /\n     * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.\n     \n     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit\n     \n     * @param _cToken                   Address of cToken to add\n     * @param _underlying               Address of underlying token that maps to cToken\n     /\n    function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {\n        require(address(underlyingToCToken[_underlying]) == address(0), "Already added");\n        underlyingToCToken[_underlying] = _cToken;\n    }\n    /\n     * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals\n     \n     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit\n     \n     * @param _underlying               Address of underlying token to remove\n     /\n    function removeCompoundMarket(IERC20 _underlying) external onlyOwner {\n        require(address(underlyingToCToken[_underlying]) != address(0), "Not added");\n        delete underlyingToCToken[_underlying];\n    }\n    /\n     * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.\n     \n     * @param _setToken             Instance of the SetToken\n     /\n    function moduleIssueHook(ISetToken _setToken, uint256 / _setTokenQuantity /) external onlyModule(_setToken) {\n        sync(_setToken, false);\n    }\n    /\n     * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.\n     * Only callable by valid module.\n     \n     * @param _setToken             Instance of the SetToken\n     /\n    function moduleRedeemHook(ISetToken _setToken, uint256 / _setTokenQuantity /) external onlyModule(_setToken) {\n        sync(_setToken, true);\n    }\n    /\n     * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken\n     * @param _component            Address of component\n     /\n    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool / _isEquity /) external onlyModule(_setToken) {\n        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n        require(componentDebt &lt; 0, "Component must be negative");\n        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);\n        _borrow(_setToken, underlyingToCToken[_component], notionalDebt);\n    }\n    /\n     * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken\n     * @param _component            Address of component\n     /\n    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool / _isEquity /) external onlyModule(_setToken) {\n        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n        require(componentDebt &lt; 0, "Component must be negative");\n        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);\n        _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt);\n    }\n\n    / ============ External Getter Functions ============ /\n    /\n     * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an\n     * array of underlying that are borrow assets.\n     \n     * @return                    Collateral cToken assets that are enabled\n     * @return                    Underlying borrowed assets that are enabled.\n     /\n    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {\n        return (\n            enabledAssets[_setToken].collateralCTokens,\n            enabledAssets[_setToken].borrowAssets\n        );\n    }\n    / ============ Internal Functions ============ /\n    /\n     * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be\n     * unwrapped as it only accepts the underlying ETH.\n     /\n    function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {\n        if (_cToken == cEther) {\n            _setToken.invokeUnwrapWETH(address(weth), _mintNotional);\n            _setToken.invokeMintCEther(_cToken, _mintNotional);\n        } else {\n            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);\n            _setToken.invokeMintCToken(_cToken, _mintNotional);\n        }\n    }\n    /\n     * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.\n     /\n    function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {\n        _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);\n        if (_cToken == cEther) {\n            _setToken.invokeWrapWETH(address(weth), _redeemNotional);\n        }\n    }\n    /\n     * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.\n     */\n    function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {\n        if (_cToken == cEther) {\n            _setToken.invokeUnwrapWETH(address(weth), _repayNotional);\n            _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);\n        } else {\n            // Approve to cToken\n            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);\n            _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);\n        }\n    }\n    /\n     * Invoke the SetToken to interact with the specified cToken to borrow the cToken\'s underlying of the specified borrowQuantity.\n     /\n    function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {\n        _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);\n        if (_cToken == cEther) {\n            _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);\n        }\n    }\n    /\n     * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken\n     \n     * @return receiveTokenQuantity The quantity of tokens received post-trade\n     /\n    function _executeTrade(\n        ActionInfo memory _actionInfo,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        bytes memory _data\n    )\n        internal\n        returns (uint256)\n    {\n         ISetToken setToken = _actionInfo.setToken;\n         uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;\n         setToken.invokeApprove(\n            address(_sendToken),\n            _actionInfo.exchangeAdapter.getSpender(),\n            notionalSendQuantity\n        );\n        (\n            address targetExchange,\n            uint256 callValue,\n            bytes memory methodData\n        ) = _actionInfo.exchangeAdapter.getTradeCalldata(\n            address(_sendToken),\n            address(_receiveToken),\n            address(setToken),\n            notionalSendQuantity,\n            _actionInfo.minNotionalReceiveQuantity,\n            _data\n        );\n        setToken.invoke(targetExchange, callValue, methodData);\n        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);\n        require(\n            receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,\n            "Slippage too high"\n        );\n        return receiveTokenQuantity;\n    }\n    /\n     * Calculates protocol fee on module and pays protocol fee from SetToken\n     /\n    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {\n        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);\n        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);\n        return protocolFeeTotal;\n    }\n    /\n     * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)\n     */\n    function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {\n        _updateCollateralPosition(\n            actionInfo.setToken,\n            actionInfo.collateralCTokenAsset,\n            _getCollateralPosition(\n                actionInfo.setToken,\n                actionInfo.collateralCTokenAsset,\n                actionInfo.setTotalSupply\n            )\n        );\n        _updateBorrowPosition(\n            actionInfo.setToken,\n            _borrowAsset,\n            _getBorrowPosition(\n                actionInfo.setToken,\n                actionInfo.borrowCTokenAsset,\n                actionInfo.setTotalSupply,\n                false // Do not accrue interest\n            )\n        );\n    }\n    function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {\n        _setToken.editDefaultPosition(address(_cToken), _newPositionUnit);\n    }\n    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {\n        _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, "");\n    }\n    /\n     * Construct the ActionInfo struct for lever and delever\n     /\n    function _createAndValidateActionInfo(\n        ISetToken _setToken,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        uint256 _sendQuantityUnits,\n        uint256 _minReceiveQuantityUnits,\n        string memory _tradeAdapterName,\n        bool _isLever\n    )\n        internal\n        view\n        returns(ActionInfo memory)\n    {\n        uint256 totalSupply = _setToken.totalSupply();\n        return _createAndValidateActionInfoNotional(\n            _setToken,\n            _sendToken,\n            _receiveToken,\n            _sendQuantityUnits.preciseMul(totalSupply),\n            _minReceiveQuantityUnits.preciseMul(totalSupply),\n            _tradeAdapterName,\n            _isLever\n        );\n    }\n    /\n     * Construct the ActionInfo struct for lever and delever accepting notional units\n     /\n    function _createAndValidateActionInfoNotional(\n        ISetToken _setToken,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        uint256 _notionalSendQuantity,\n        uint256 _minNotionalReceiveQuantity,\n        string memory _tradeAdapterName,\n        bool _isLever\n    )\n        internal\n        view\n        returns(ActionInfo memory)\n    {\n        uint256 totalSupply = _setToken.totalSupply();\n        ActionInfo memory actionInfo = ActionInfo ({\n            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),\n            setToken: _setToken,\n            collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],\n            borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],\n            setTotalSupply: totalSupply,\n            notionalSendQuantity: _notionalSendQuantity,\n            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,\n            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))\n        });\n        _validateCommon(actionInfo);\n        return actionInfo;\n    }\n\n    function _validateCommon(ActionInfo memory _actionInfo) internal view {\n        require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");\n        require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");\n        require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");\n        require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0");\n    }\n    function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {\n        uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));\n        return collateralNotionalBalance.preciseDiv(_setTotalSupply);\n    }\n    /*\n     * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.\n     * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.\n     /\n    function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {\n        uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));\n        // Round negative away from 0\n        int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);\n        return borrowPositionUnit;\n    }\n}".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 02:00:05 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { Compound } from "../../integration/lib/Compound.sol"; import { ICErc20 } from "../../../interfaces/external/ICErc20.sol"; import { IComptroller } from "../../../interfaces/external/IComptroller.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol"; import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; /*  * @title CompoundLeverageModule  * @author Set Protocol  *  * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call  * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each  * asset is leveraged when using this module.  *  * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of  * debt when borrowed assets are the same.  *  / contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {     using Compound for ISetToken; /* ============ Structs ============ */  struct EnabledAssets {     address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken     address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken     address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets }  struct ActionInfo {     ISetToken setToken;                      // SetToken instance     IExchangeAdapter exchangeAdapter;        // Exchange adapter instance     uint256 setTotalSupply;                  // Total supply of SetToken     uint256 notionalSendQuantity;            // Total notional quantity sent to exchange     uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange     ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset     ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset     uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance }  /* ============ Events ============ */  event LeverageIncreased(     ISetToken indexed _setToken,     IERC20 indexed _borrowAsset,     IERC20 indexed _collateralAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalBorrowAmount,     uint256 _totalReceiveAmount,     uint256 _protocolFee );  event LeverageDecreased(     ISetToken indexed _setToken,     IERC20 indexed _collateralAsset,     IERC20 indexed _repayAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalRedeemAmount,     uint256 _totalRepayAmount,     uint256 _protocolFee );  event CollateralAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  event BorrowAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  event SetTokenStatusUpdated(     ISetToken indexed _setToken,     bool indexed _added );  event AnySetAllowedUpdated(     bool indexed _anySetAllowed );  /* ============ Constants ============ */  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the trade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Mapping of underlying to CToken. If ETH, then map WETH to cETH mapping(IERC20 =&gt; ICErc20) public underlyingToCToken;  // Wrapped Ether address IERC20 internal weth;  // Compound cEther address ICErc20 internal cEther;  // Compound Comptroller contract IComptroller internal comptroller;  // COMP token address IERC20 internal compToken;  // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public collateralCTokenEnabled;  // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public borrowCTokenEnabled;  // Mapping of enabled collateral and borrow cTokens for syncing positions mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;  // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance mapping(ISetToken =&gt; bool) public allowedSetTokens;  // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list bool public anySetAllowed;   /* ============ Constructor ============ */  /**  * Instantiate addresses. Underlying to cToken mapping is created.  *  * @param _controller               Address of controller contract  * @param _compToken                Address of COMP token  * @param _comptroller              Address of Compound Comptroller  * @param _cEther                   Address of cEther contract  * @param _weth                     Address of WETH contract  */ constructor(     IController _controller,     IERC20 _compToken,     IComptroller _comptroller,     ICErc20 _cEther,     IERC20 _weth )     public     ModuleBase(_controller) {     compToken = _compToken;     comptroller = _comptroller;     cEther = _cEther;     weth = _weth;      ICErc20[] memory cTokens = comptroller.getAllMarkets();      for(uint256 i = 0; i &lt; cTokens.length; i++) {         ICErc20 cToken = cTokens[i];         underlyingToCToken[             cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())         ] = cToken;     } }  /* ============ External Functions ============ */  /**  * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.  * Performs a DEX trade, exchanging the borrow asset for collateral asset.  *  * @param _setToken             Instance of the SetToken  * @param _borrowAsset          Address of asset being borrowed for leverage  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _borrowQuantity       Borrow quantity of asset in position units  * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function lever(     ISetToken _setToken,     IERC20 _borrowAsset,     IERC20 _collateralAsset,     uint256 _borrowQuantity,     uint256 _minReceiveQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // For levering up, send quantity is derived from borrow asset and receive quantity is derived from     // collateral asset     ActionInfo memory leverInfo = _createAndValidateActionInfo(         _setToken,         _borrowAsset,         _collateralAsset,         _borrowQuantity,         _minReceiveQuantity,         _tradeAdapterName,         true     );      _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);      uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);      _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);      _updateLeverPositions(leverInfo, _borrowAsset);      emit LeverageIncreased(         _setToken,         _borrowAsset,         _collateralAsset,         leverInfo.exchangeAdapter,         leverInfo.notionalSendQuantity,         postTradeCollateralQuantity,         protocolFee     ); }  /**  * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled  *  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _repayAsset           Address of asset being repaid  * @param _redeemQuantity       Quantity of collateral asset to delever  * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function delever(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantity,     uint256 _minRepayQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from     // repay asset     ActionInfo memory deleverInfo = _createAndValidateActionInfo(         _setToken,         _collateralAsset,         _repayAsset,         _redeemQuantity,         _minRepayQuantity,         _tradeAdapterName,         false     );      _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);      uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);      _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);      _updateLeverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         repayQuantity,         protocolFee     ); }  /**  * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received  * borrow asset is updated as equity. No protocol fee is charged.  *  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)  * @param _redeemQuantity       Quantity of collateral asset to delever  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function deleverToZeroBorrowBalance(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());      require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");     uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));      ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(         _setToken,         _collateralAsset,         _repayAsset,         notionalRedeemQuantity,         notionalRepayQuantity,         _tradeAdapterName,         false     );      _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);      _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly     _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);      // Update default position first to save gas on editing borrow position     _setToken.calculateAndEditDefaultPosition(         address(_repayAsset),         deleverInfo.setTotalSupply,         deleverInfo.preTradeReceiveTokenBalance     );      _updateLeverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         notionalRepayQuantity,         0 // No protocol fee     ); }  /**  * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral  * assets, update cToken default position. For borrow assets, update external borrow position.  * - Collateral assets may come out of sync when a position is liquidated  * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid  *  * @param _setToken               Instance of the SetToken  * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value  */ function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {     uint256 setTotalSupply = _setToken.totalSupply();      // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption     if (setTotalSupply &gt; 0) {         // Loop through collateral assets         address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;         for(uint256 i = 0; i &lt; collateralCTokens.length; i++) {             ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);             uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();             uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (previousPositionUnit != newPositionUnit) {               _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);             }         }          // Loop through borrow assets         address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;         address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;         for(uint256 i = 0; i &lt; borrowCTokens.length; i++) {             ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);             IERC20 borrowAsset = IERC20(borrowAssets[i]);              int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));              int256 newPositionUnit = _getBorrowPosition(                 _setToken,                 borrowCToken,                 setTotalSupply,                 _shouldAccrueInterest             );              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (newPositionUnit != previousPositionUnit) {                 _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);             }         }     } }   /**  * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable  * collateral and borrow assets that don't exist as positions on the SetToken  *  * @param _setToken             Instance of the SetToken to initialize  * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken  * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken  */ function initialize(     ISetToken _setToken,     IERC20[] memory _collateralAssets,     IERC20[] memory _borrowAssets )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     if (!anySetAllowed) {         require(allowedSetTokens[_setToken], "Not allowed SetToken");     }      // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}     }      // Enable collateral and borrow assets on Compound     addCollateralAssets(_setToken, _collateralAssets);      addBorrowAssets(_setToken, _borrowAssets); }  /**  * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled  * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)  */ function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Sync Compound and SetToken positions prior to any removal action     sync(setToken, true);      address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;     for (uint256 i = 0; i &lt; borrowCTokens.length; i++) {         ICErc20 cToken = ICErc20(borrowCTokens[i]);          // Will exit only if token isn't also being used as collateral         if(!collateralCTokenEnabled[setToken][cToken]) {             // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound             setToken.invokeExitMarket(cToken, comptroller);         }          delete borrowCTokenEnabled[setToken][cToken];     }      address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;     for (uint256 i = 0; i &lt; collateralCTokens.length; i++) {         ICErc20 cToken = ICErc20(collateralCTokens[i]);          setToken.invokeExitMarket(cToken, comptroller);          delete collateralCTokenEnabled[setToken][cToken];     }      delete enabledAssets[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken  * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state  * inconsistencies  *  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets  *  * @param _setToken             Instance of the SetToken  * @param _newCollateralAssets  Addresses of new collateral underlying assets  */ function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {     for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];         require(address(cToken) != address(0), "cToken must exist");         require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");          // Note: Will only enter market if cToken is not enabled as a borrow asset as well         if (!borrowCTokenEnabled[_setToken][cToken]) {             _setToken.invokeEnterMarkets(cToken, comptroller);         }          collateralCTokenEnabled[_setToken][cToken] = true;         enabledAssets[_setToken].collateralCTokens.push(address(cToken));     }      emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets); }  /**  * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets  * If there is a borrow balance, collateral asset cannot be removed  *  * @param _setToken             Instance of the SetToken  * @param _collateralAssets     Addresses of collateral underlying assets to remove  */ function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {     // Sync Compound and SetToken positions prior to any removal action     sync(_setToken, true);      for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];         require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");          // Note: Will only exit market if cToken is not enabled as a borrow asset as well         // If there is an existing borrow balance, will revert and market cannot be exited on Compound         if (!borrowCTokenEnabled[_setToken][cToken]) {             _setToken.invokeExitMarket(cToken, comptroller);         }          delete collateralCTokenEnabled[_setToken][cToken];         enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));     }      emit CollateralAssetsUpdated(_setToken, false, _collateralAssets); }  /**  * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets  *  * @param _setToken             Instance of the SetToken  * @param _newBorrowAssets      Addresses of borrow underlying assets to add  */ function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {     for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {         IERC20 newBorrowAsset = _newBorrowAssets[i];         ICErc20 cToken = underlyingToCToken[newBorrowAsset];         require(address(cToken) != address(0), "cToken must exist");         require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");          // Note: Will only enter market if cToken is not enabled as a borrow asset as well         if (!collateralCTokenEnabled[_setToken][cToken]) {             _setToken.invokeEnterMarkets(cToken, comptroller);         }          borrowCTokenEnabled[_setToken][cToken] = true;         enabledAssets[_setToken].borrowCTokens.push(address(cToken));         enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));     }      emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets); }  /**  * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets  * If there is a borrow balance, borrow asset cannot be removed  *  * @param _setToken             Instance of the SetToken  * @param _borrowAssets         Addresses of borrow underlying assets to remove  */ function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {     // Sync Compound and SetToken positions prior to any removal action     sync(_setToken, true);      for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];         require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");          // Note: Will only exit market if cToken is not enabled as a collateral asset as well         // If there is an existing borrow balance, will revert and market cannot be exited on Compound         if (!collateralCTokenEnabled[_setToken][cToken]) {             _setToken.invokeExitMarket(cToken, comptroller);         }          delete borrowCTokenEnabled[_setToken][cToken];         enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));         enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));     }      emit BorrowAssetsUpdated(_setToken, false, _borrowAssets); }  /**  * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.  *  * @param _setToken             Instance of the SetToken  */ function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {     allowedSetTokens[_setToken] = _status;     emit SetTokenStatusUpdated(_setToken, _status); }  /**  * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.  *  * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled  */ function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {     anySetAllowed = _anySetAllowed;     emit AnySetAllowedUpdated(_anySetAllowed); }  /**  * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.  *  * IMPORTANT: Validations are skipped in order to get contract under bytecode limit  *  * @param _cToken                   Address of cToken to add  * @param _underlying               Address of underlying token that maps to cToken  */ function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {     require(address(underlyingToCToken[_underlying]) == address(0), "Already added");     underlyingToCToken[_underlying] = _cToken; }  /**  * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals  *  * IMPORTANT: Validations are skipped in order to get contract under bytecode limit  *  * @param _underlying               Address of underlying token to remove  */ function removeCompoundMarket(IERC20 _underlying) external onlyOwner {     require(address(underlyingToCToken[_underlying]) != address(0), "Not added");     delete underlyingToCToken[_underlying]; }  /**  * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {     sync(_setToken, false); }  /**  * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.  * Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {     sync(_setToken, true); }  /**  * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {     int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));      require(componentDebt &lt; 0, "Component must be negative");      uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);      _borrow(_setToken, underlyingToCToken[_component], notionalDebt); }  /**  * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {     int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));      require(componentDebt &lt; 0, "Component must be negative");      uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);      _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt); }   /* ============ External Getter Functions ============ */  /**  * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an  * array of underlying that are borrow assets.  *  * @return                    Collateral cToken assets that are enabled  * @return                    Underlying borrowed assets that are enabled.  */ function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {     return (         enabledAssets[_setToken].collateralCTokens,         enabledAssets[_setToken].borrowAssets     ); }  /* ============ Internal Functions ============ */  /**  * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be  * unwrapped as it only accepts the underlying ETH.  */ function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {     if (_cToken == cEther) {         _setToken.invokeUnwrapWETH(address(weth), _mintNotional);          _setToken.invokeMintCEther(_cToken, _mintNotional);     } else {         _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);          _setToken.invokeMintCToken(_cToken, _mintNotional);     } }  /**  * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.  */ function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {     _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);      if (_cToken == cEther) {         _setToken.invokeWrapWETH(address(weth), _redeemNotional);     } }  /**  * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.  */ function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {     if (_cToken == cEther) {         _setToken.invokeUnwrapWETH(address(weth), _repayNotional);          _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);     } else {         // Approve to cToken         _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);         _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);     } }  /**  * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.  */ function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {     _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);     if (_cToken == cEther) {         _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);     } }  /**  * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken  *  * @return receiveTokenQuantity The quantity of tokens received post-trade  */ function _executeTrade(     ActionInfo memory _actionInfo,     IERC20 _sendToken,     IERC20 _receiveToken,     bytes memory _data )     internal     returns (uint256) {      ISetToken setToken = _actionInfo.setToken;      uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;       setToken.invokeApprove(         address(_sendToken),         _actionInfo.exchangeAdapter.getSpender(),         notionalSendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _actionInfo.exchangeAdapter.getTradeCalldata(         address(_sendToken),         address(_receiveToken),         address(setToken),         notionalSendQuantity,         _actionInfo.minNotionalReceiveQuantity,         _data     );      setToken.invoke(targetExchange, callValue, methodData);      uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);     require(         receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,         "Slippage too high"     );      return receiveTokenQuantity; }  /**  * Calculates protocol fee on module and pays protocol fee from SetToken  */ function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {     uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);      payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);      return protocolFeeTotal; }  /**  * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)  */ function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {     _updateCollateralPosition(         actionInfo.setToken,         actionInfo.collateralCTokenAsset,         _getCollateralPosition(             actionInfo.setToken,             actionInfo.collateralCTokenAsset,             actionInfo.setTotalSupply         )     );      _updateBorrowPosition(         actionInfo.setToken,         _borrowAsset,         _getBorrowPosition(             actionInfo.setToken,             actionInfo.borrowCTokenAsset,             actionInfo.setTotalSupply,             false // Do not accrue interest         )     ); }  function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {     _setToken.editDefaultPosition(address(_cToken), _newPositionUnit); }  function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {     _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, ""); }  /**  * Construct the ActionInfo struct for lever and delever  */ function _createAndValidateActionInfo(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _sendQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();      return _createAndValidateActionInfoNotional(         _setToken,         _sendToken,         _receiveToken,         _sendQuantityUnits.preciseMul(totalSupply),         _minReceiveQuantityUnits.preciseMul(totalSupply),         _tradeAdapterName,         _isLever     ); }  /**  * Construct the ActionInfo struct for lever and delever accepting notional units  */ function _createAndValidateActionInfoNotional(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _notionalSendQuantity,     uint256 _minNotionalReceiveQuantity,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();     ActionInfo memory actionInfo = ActionInfo ({         exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),         setToken: _setToken,         collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],         borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],         setTotalSupply: totalSupply,         notionalSendQuantity: _notionalSendQuantity,         minNotionalReceiveQuantity: _minNotionalReceiveQuantity,         preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))     });      _validateCommon(actionInfo);      return actionInfo; }    function _validateCommon(ActionInfo memory _actionInfo) internal view {     require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");     require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");     require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");     require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0"); }  function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {     uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));     return collateralNotionalBalance.preciseDiv(_setTotalSupply); }  /**  * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.  * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.  */ function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {     uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));     // Round negative away from 0     int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);      return borrowPositionUnit; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 02:00:05 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { Compound } from "../../integration/lib/Compound.sol";
import { ICErc20 } from "../../../interfaces/external/ICErc20.sol";
import { IComptroller } from "../../../interfaces/external/IComptroller.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title CompoundLeverageModule
 * @author Set Protocol
 *
 * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call
 * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each
 * asset is leveraged when using this module.
 *
 * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 *
 */
contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {
    using Compound for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken
        address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken
        address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset
        ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    /* ============ Events ============ */

    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the trade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping of underlying to CToken. If ETH, then map WETH to cETH
    mapping(IERC20 => ICErc20) public underlyingToCToken;

    // Wrapped Ether address
    IERC20 internal weth;

    // Compound cEther address
    ICErc20 internal cEther;

    // Compound Comptroller contract
    IComptroller internal comptroller;

    // COMP token address
    IERC20 internal compToken;

    // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public collateralCTokenEnabled;

    // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public borrowCTokenEnabled;

    // Mapping of enabled collateral and borrow cTokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list
    bool public anySetAllowed;


    /* ============ Constructor ============ */

    /**
     * Instantiate addresses. Underlying to cToken mapping is created.
     *
     * @param _controller               Address of controller contract
     * @param _compToken                Address of COMP token
     * @param _comptroller              Address of Compound Comptroller
     * @param _cEther                   Address of cEther contract
     * @param _weth                     Address of WETH contract
     */
    constructor(
        IController _controller,
        IERC20 _compToken,
        IComptroller _comptroller,
        ICErc20 _cEther,
        IERC20 _weth
    )
        public
        ModuleBase(_controller)
    {
        compToken = _compToken;
        comptroller = _comptroller;
        cEther = _cEther;
        weth = _weth;

        ICErc20[] memory cTokens = comptroller.getAllMarkets();

        for(uint256 i = 0; i < cTokens.length; i++) {
            ICErc20 cToken = cTokens[i];
            underlyingToCToken[
                cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())
            ] = cToken;
        }
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.
     * Performs a DEX trade, exchanging the borrow asset for collateral asset.
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAsset          Address of asset being borrowed for leverage
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _borrowQuantity       Borrow quantity of asset in position units
     * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantity,
        uint256 _minReceiveQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantity,
            _minReceiveQuantity,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        uint256 _minRepayQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantity,
            _minRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received
     * borrow asset is updated as equity. No protocol fee is charged.
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());

        require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly
        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);

        // Update default position first to save gas on editing borrow position
        _setToken.calculateAndEditDefaultPosition(
            address(_repayAsset),
            deleverInfo.setTotalSupply,
            deleverInfo.preTradeReceiveTokenBalance
        );

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0 // No protocol fee
        );
    }

    /**
     * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral
     * assets, update cToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     *
     * @param _setToken               Instance of the SetToken
     * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value
     */
    function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption
        if (setTotalSupply > 0) {
            // Loop through collateral assets
            address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;
            for(uint256 i = 0; i < collateralCTokens.length; i++) {
                ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);
                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);
                }
            }

            // Loop through borrow assets
            address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;
            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowCTokens.length; i++) {
                ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));

                int256 newPositionUnit = _getBorrowPosition(
                    _setToken,
                    borrowCToken,
                    setTotalSupply,
                    _shouldAccrueInterest
                );

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }


    /**
     * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable
     * collateral and borrow assets that don't exist as positions on the SetToken
     *
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // Enable collateral and borrow assets on Compound
        addCollateralAssets(_setToken, _collateralAssets);

        addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled
     * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Compound and SetToken positions prior to any removal action
        sync(setToken, true);

        address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;
        for (uint256 i = 0; i < borrowCTokens.length; i++) {
            ICErc20 cToken = ICErc20(borrowCTokens[i]);

            // Will exit only if token isn't also being used as collateral
            if(!collateralCTokenEnabled[setToken][cToken]) {
                // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound
                setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[setToken][cToken];
        }

        address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;
        for (uint256 i = 0; i < collateralCTokens.length; i++) {
            ICErc20 cToken = ICErc20(collateralCTokens[i]);

            setToken.invokeExitMarket(cToken, comptroller);

            delete collateralCTokenEnabled[setToken][cToken];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken
     * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];
            require(address(cToken) != address(0), "cToken must exist");
            require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            collateralCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].collateralCTokens.push(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets
     * If there is a borrow balance, collateral asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];
            require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");

            // Note: Will only exit market if cToken is not enabled as a borrow asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete collateralCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 newBorrowAsset = _newBorrowAssets[i];
            ICErc20 cToken = underlyingToCToken[newBorrowAsset];
            require(address(cToken) != address(0), "cToken must exist");
            require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            borrowCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].borrowCTokens.push(address(cToken));
            enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));
        }

        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets
     * If there is a borrow balance, borrow asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];
            require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");

            // Note: Will only exit market if cToken is not enabled as a collateral asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));
            enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));
        }

        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.
     *
     * @param _setToken             Instance of the SetToken
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.
     *
     * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _cToken                   Address of cToken to add
     * @param _underlying               Address of underlying token that maps to cToken
     */
    function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) == address(0), "Already added");
        underlyingToCToken[_underlying] = _cToken;
    }

    /**
     * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _underlying               Address of underlying token to remove
     */
    function removeCompoundMarket(IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) != address(0), "Not added");
        delete underlyingToCToken[_underlying];
    }

    /**
     * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, false);
    }

    /**
     * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.
     * Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, true);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);

        _borrow(_setToken, underlyingToCToken[_component], notionalDebt);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);

        _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt);
    }


    /* ============ External Getter Functions ============ */

    /**
     * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an
     * array of underlying that are borrow assets.
     *
     * @return                    Collateral cToken assets that are enabled
     * @return                    Underlying borrowed assets that are enabled.
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralCTokens,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be
     * unwrapped as it only accepts the underlying ETH.
     */
    function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _mintNotional);

            _setToken.invokeMintCEther(_cToken, _mintNotional);
        } else {
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);

            _setToken.invokeMintCToken(_cToken, _mintNotional);
        }
    }

    /**
     * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.
     */
    function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {
        _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);

        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _redeemNotional);
        }
    }

    /**
     * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.
     */
    function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _repayNotional);

            _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);
        } else {
            // Approve to cToken
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);
            _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);
        }
    }

    /**
     * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.
     */
    function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {
        _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);
        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);
        }
    }

    /**
     * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     *
     * @return receiveTokenQuantity The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
         ISetToken setToken = _actionInfo.setToken;
         uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

         setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * Calculates protocol fee on module and pays protocol fee from SetToken
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)
     */
    function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {
        _updateCollateralPosition(
            actionInfo.setToken,
            actionInfo.collateralCTokenAsset,
            _getCollateralPosition(
                actionInfo.setToken,
                actionInfo.collateralCTokenAsset,
                actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                actionInfo.setToken,
                actionInfo.borrowCTokenAsset,
                actionInfo.setTotalSupply,
                false // Do not accrue interest
            )
        );
    }

    function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_cToken), _newPositionUnit);
    }

    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, "");
    }

    /**
     * Construct the ActionInfo struct for lever and delever
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever
        );
    }

    /**
     * Construct the ActionInfo struct for lever and delever accepting notional units
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            setToken: _setToken,
            collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],
            borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],
            setTotalSupply: totalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }



    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");
        require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");
        require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.
     * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.
     */
    function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {
        uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));
        // Round negative away from 0
        int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);

        return borrowPositionUnit;
    }
}.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    SPDX-License-Identifier: Apache License, Version 2.0
*/
pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { Compound } from "../../integration/lib/Compound.sol";
import { ICErc20 } from "../../../interfaces/external/ICErc20.sol";
import { IComptroller } from "../../../interfaces/external/IComptroller.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";
/**
 * @title CompoundLeverageModule
 * @author Set Protocol
 *
 * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call
 * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each
 * asset is leveraged when using this module.
 *
 * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 *
 */
contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {
    using Compound for ISetToken;
    /* ============ Structs ============ */
    struct EnabledAssets {
        address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken
        address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken
        address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets
    }
    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset
        ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }
    /* ============ Events ============ */
    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );
    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );
    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );
    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );
    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );
    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );
    /* ============ Constants ============ */
    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";
    // 0 index stores protocol fee % on the controller, charged in the trade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;
    /* ============ State Variables ============ */
    // Mapping of underlying to CToken. If ETH, then map WETH to cETH
    mapping(IERC20 => ICErc20) public underlyingToCToken;
    // Wrapped Ether address
    IERC20 internal weth;
    // Compound cEther address
    ICErc20 internal cEther;
    // Compound Comptroller contract
    IComptroller internal comptroller;
    // COMP token address
    IERC20 internal compToken;
    // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public collateralCTokenEnabled;
    // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public borrowCTokenEnabled;
    // Mapping of enabled collateral and borrow cTokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;
    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;
    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list
    bool public anySetAllowed;

    /* ============ Constructor ============ */
    /**
     * Instantiate addresses. Underlying to cToken mapping is created.
     *
     * @param _controller               Address of controller contract
     * @param _compToken                Address of COMP token
     * @param _comptroller              Address of Compound Comptroller
     * @param _cEther                   Address of cEther contract
     * @param _weth                     Address of WETH contract
     */
    constructor(
        IController _controller,
        IERC20 _compToken,
        IComptroller _comptroller,
        ICErc20 _cEther,
        IERC20 _weth
    )
        public
        ModuleBase(_controller)
    {
        compToken = _compToken;
        comptroller = _comptroller;
        cEther = _cEther;
        weth = _weth;
        ICErc20[] memory cTokens = comptroller.getAllMarkets();
        for(uint256 i = 0; i < cTokens.length; i++) {
            ICErc20 cToken = cTokens[i];
            underlyingToCToken[
                cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())
            ] = cToken;
        }
    }
    /* ============ External Functions ============ */
    /**
     * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.
     * Performs a DEX trade, exchanging the borrow asset for collateral asset.
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAsset          Address of asset being borrowed for leverage
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _borrowQuantity       Borrow quantity of asset in position units
     * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantity,
        uint256 _minReceiveQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantity,
            _minReceiveQuantity,
            _tradeAdapterName,
            true
        );
        _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);
        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);
        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);
        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);
        _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);
        _updateLeverPositions(leverInfo, _borrowAsset);
        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }
    /**
     * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        uint256 _minRepayQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantity,
            _minRepayQuantity,
            _tradeAdapterName,
            false
        );
        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);
        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);
        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);
        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);
        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);
        _updateLeverPositions(deleverInfo, _repayAsset);
        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }
    /**
     * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received
     * borrow asset is updated as equity. No protocol fee is charged.
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());
        require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));
        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false
        );
        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);
        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);
        // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly
        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);
        // Update default position first to save gas on editing borrow position
        _setToken.calculateAndEditDefaultPosition(
            address(_repayAsset),
            deleverInfo.setTotalSupply,
            deleverInfo.preTradeReceiveTokenBalance
        );
        _updateLeverPositions(deleverInfo, _repayAsset);
        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0 // No protocol fee
        );
    }
    /**
     * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral
     * assets, update cToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     *
     * @param _setToken               Instance of the SetToken
     * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value
     */
    function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();
        // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption
        if (setTotalSupply > 0) {
            // Loop through collateral assets
            address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;
            for(uint256 i = 0; i < collateralCTokens.length; i++) {
                ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);
                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);
                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);
                }
            }
            // Loop through borrow assets
            address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;
            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowCTokens.length; i++) {
                ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);
                IERC20 borrowAsset = IERC20(borrowAssets[i]);
                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));
                int256 newPositionUnit = _getBorrowPosition(
                    _setToken,
                    borrowCToken,
                    setTotalSupply,
                    _shouldAccrueInterest
                );
                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }

    /**
     * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable
     * collateral and borrow assets that don't exist as positions on the SetToken
     *
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }
        // Initialize module before trying register
        _setToken.initializeModule();
        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");
        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }
        // Enable collateral and borrow assets on Compound
        addCollateralAssets(_setToken, _collateralAssets);
        addBorrowAssets(_setToken, _borrowAssets);
    }
    /**
     * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled
     * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);
        // Sync Compound and SetToken positions prior to any removal action
        sync(setToken, true);
        address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;
        for (uint256 i = 0; i < borrowCTokens.length; i++) {
            ICErc20 cToken = ICErc20(borrowCTokens[i]);
            // Will exit only if token isn't also being used as collateral
            if(!collateralCTokenEnabled[setToken][cToken]) {
                // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound
                setToken.invokeExitMarket(cToken, comptroller);
            }
            delete borrowCTokenEnabled[setToken][cToken];
        }
        address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;
        for (uint256 i = 0; i < collateralCTokens.length; i++) {
            ICErc20 cToken = ICErc20(collateralCTokens[i]);
            setToken.invokeExitMarket(cToken, comptroller);
            delete collateralCTokenEnabled[setToken][cToken];
        }
        delete enabledAssets[setToken];
        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }
    /**
     * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken
     * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");
        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }
    /**
     * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];
            require(address(cToken) != address(0), "cToken must exist");
            require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");
            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }
            collateralCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].collateralCTokens.push(address(cToken));
        }
        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }
    /**
     * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets
     * If there is a borrow balance, collateral asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);
        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];
            require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");
            // Note: Will only exit market if cToken is not enabled as a borrow asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }
            delete collateralCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));
        }
        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }
    /**
     * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 newBorrowAsset = _newBorrowAssets[i];
            ICErc20 cToken = underlyingToCToken[newBorrowAsset];
            require(address(cToken) != address(0), "cToken must exist");
            require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");
            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }
            borrowCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].borrowCTokens.push(address(cToken));
            enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }
    /**
     * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets
     * If there is a borrow balance, borrow asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);
        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];
            require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");
            // Note: Will only exit market if cToken is not enabled as a collateral asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }
            delete borrowCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));
            enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));
        }
        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }
    /**
     * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.
     *
     * @param _setToken             Instance of the SetToken
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }
    /**
     * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.
     *
     * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }
    /**
     * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _cToken                   Address of cToken to add
     * @param _underlying               Address of underlying token that maps to cToken
     */
    function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) == address(0), "Already added");
        underlyingToCToken[_underlying] = _cToken;
    }
    /**
     * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _underlying               Address of underlying token to remove
     */
    function removeCompoundMarket(IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) != address(0), "Not added");
        delete underlyingToCToken[_underlying];
    }
    /**
     * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, false);
    }
    /**
     * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.
     * Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, true);
    }
    /**
     * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));
        require(componentDebt < 0, "Component must be negative");
        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);
        _borrow(_setToken, underlyingToCToken[_component], notionalDebt);
    }
    /**
     * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));
        require(componentDebt < 0, "Component must be negative");
        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);
        _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt);
    }

    /* ============ External Getter Functions ============ */
    /**
     * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an
     * array of underlying that are borrow assets.
     *
     * @return                    Collateral cToken assets that are enabled
     * @return                    Underlying borrowed assets that are enabled.
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralCTokens,
            enabledAssets[_setToken].borrowAssets
        );
    }
    /* ============ Internal Functions ============ */
    /**
     * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be
     * unwrapped as it only accepts the underlying ETH.
     */
    function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _mintNotional);
            _setToken.invokeMintCEther(_cToken, _mintNotional);
        } else {
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);
            _setToken.invokeMintCToken(_cToken, _mintNotional);
        }
    }
    /**
     * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.
     */
    function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {
        _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);
        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _redeemNotional);
        }
    }
    /**
     * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.
     */
    function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _repayNotional);
            _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);
        } else {
            // Approve to cToken
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);
            _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);
        }
    }
    /**
     * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.
     */
    function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {
        _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);
        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);
        }
    }
    /**
     * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     *
     * @return receiveTokenQuantity The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
         ISetToken setToken = _actionInfo.setToken;
         uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;
         setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );
        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );
        setToken.invoke(targetExchange, callValue, methodData);
        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );
        return receiveTokenQuantity;
    }
    /**
     * Calculates protocol fee on module and pays protocol fee from SetToken
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);
        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);
        return protocolFeeTotal;
    }
    /**
     * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)
     */
    function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {
        _updateCollateralPosition(
            actionInfo.setToken,
            actionInfo.collateralCTokenAsset,
            _getCollateralPosition(
                actionInfo.setToken,
                actionInfo.collateralCTokenAsset,
                actionInfo.setTotalSupply
            )
        );
        _updateBorrowPosition(
            actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                actionInfo.setToken,
                actionInfo.borrowCTokenAsset,
                actionInfo.setTotalSupply,
                false // Do not accrue interest
            )
        );
    }
    function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_cToken), _newPositionUnit);
    }
    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, "");
    }
    /**
     * Construct the ActionInfo struct for lever and delever
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();
        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever
        );
    }
    /**
     * Construct the ActionInfo struct for lever and delever accepting notional units
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            setToken: _setToken,
            collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],
            borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],
            setTotalSupply: totalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });
        _validateCommon(actionInfo);
        return actionInfo;
    }

    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");
        require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");
        require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }
    function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }
    /**
     * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.
     * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.
     */
    function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {
        uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));
        // Round negative away from 0
        int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);
        return borrowPositionUnit;
    }
}.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "/*
    Copyright 2021 Set Labs Inc.
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    SPDX-License-Identifier: Apache License, Version 2.0
*/
pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { Compound } from "../../integration/lib/Compound.sol";
import { ICErc20 } from "../../../interfaces/external/ICErc20.sol";
import { IComptroller } from "../../../interfaces/external/IComptroller.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";
/**
 * @title CompoundLeverageModule
 * @author Set Protocol
 *
 * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call
 * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each
 * asset is leveraged when using this module.
 *
 * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 *
 */
contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {
    using Compound for ISetToken;
    /* ============ Structs ============ */
    struct EnabledAssets {
        address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken
        address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken
        address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets
    }
    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset
        ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }
    /* ============ Events ============ */
    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );
    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );
    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );
    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );
    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );
    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );
    /* ============ Constants ============ */
    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";
    // 0 index stores protocol fee % on the controller, charged in the trade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;
    /* ============ State Variables ============ */
    // Mapping of underlying to CToken. If ETH, then map WETH to cETH
    mapping(IERC20 => ICErc20) public underlyingToCToken;
    // Wrapped Ether address
    IERC20 internal weth;
    // Compound cEther address
    ICErc20 internal cEther;
    // Compound Comptroller contract
    IComptroller internal comptroller;
    // COMP token address
    IERC20 internal compToken;
    // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public collateralCTokenEnabled;
    // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public borrowCTokenEnabled;
    // Mapping of enabled collateral and borrow cTokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;
    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;
    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list
    bool public anySetAllowed;

    /* ============ Constructor ============ */
    /**
     * Instantiate addresses. Underlying to cToken mapping is created.
     *
     * @param _controller               Address of controller contract
     * @param _compToken                Address of COMP token
     * @param _comptroller              Address of Compound Comptroller
     * @param _cEther                   Address of cEther contract
     * @param _weth                     Address of WETH contract
     */
    constructor(
        IController _controller,
        IERC20 _compToken,
        IComptroller _comptroller,
        ICErc20 _cEther,
        IERC20 _weth
    )
        public
        ModuleBase(_controller)
    {
        compToken = _compToken;
        comptroller = _comptroller;
        cEther = _cEther;
        weth = _weth;
        ICErc20[] memory cTokens = comptroller.getAllMarkets();
        for(uint256 i = 0; i < cTokens.length; i++) {
            ICErc20 cToken = cTokens[i];
            underlyingToCToken[
                cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())
            ] = cToken;
        }
    }
    /* ============ External Functions ============ */
    /**
     * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.
     * Performs a DEX trade, exchanging the borrow asset for collateral asset.
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAsset          Address of asset being borrowed for leverage
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _borrowQuantity       Borrow quantity of asset in position units
     * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantity,
        uint256 _minReceiveQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantity,
            _minReceiveQuantity,
            _tradeAdapterName,
            true
        );
        _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);
        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);
        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);
        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);
        _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);
        _updateLeverPositions(leverInfo, _borrowAsset);
        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }
    /**
     * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        uint256 _minRepayQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantity,
            _minRepayQuantity,
            _tradeAdapterName,
            false
        );
        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);
        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);
        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);
        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);
        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);
        _updateLeverPositions(deleverInfo, _repayAsset);
        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }
    /**
     * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received
     * borrow asset is updated as equity. No protocol fee is charged.
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());
        require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));
        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false
        );
        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);
        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);
        // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly
        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);
        // Update default position first to save gas on editing borrow position
        _setToken.calculateAndEditDefaultPosition(
            address(_repayAsset),
            deleverInfo.setTotalSupply,
            deleverInfo.preTradeReceiveTokenBalance
        );
        _updateLeverPositions(deleverInfo, _repayAsset);
        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0 // No protocol fee
        );
    }
    /**
     * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral
     * assets, update cToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     *
     * @param _setToken               Instance of the SetToken
     * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value
     */
    function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();
        // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption
        if (setTotalSupply > 0) {
            // Loop through collateral assets
            address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;
            for(uint256 i = 0; i < collateralCTokens.length; i++) {
                ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);
                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);
                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);
                }
            }
            // Loop through borrow assets
            address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;
            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowCTokens.length; i++) {
                ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);
                IERC20 borrowAsset = IERC20(borrowAssets[i]);
                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));
                int256 newPositionUnit = _getBorrowPosition(
                    _setToken,
                    borrowCToken,
                    setTotalSupply,
                    _shouldAccrueInterest
                );
                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }

    /**
     * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable
     * collateral and borrow assets that don't exist as positions on the SetToken
     *
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }
        // Initialize module before trying register
        _setToken.initializeModule();
        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");
        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }
        // Enable collateral and borrow assets on Compound
        addCollateralAssets(_setToken, _collateralAssets);
        addBorrowAssets(_setToken, _borrowAssets);
    }
    /**
     * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled
     * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);
        // Sync Compound and SetToken positions prior to any removal action
        sync(setToken, true);
        address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;
        for (uint256 i = 0; i < borrowCTokens.length; i++) {
            ICErc20 cToken = ICErc20(borrowCTokens[i]);
            // Will exit only if token isn't also being used as collateral
            if(!collateralCTokenEnabled[setToken][cToken]) {
                // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound
                setToken.invokeExitMarket(cToken, comptroller);
            }
            delete borrowCTokenEnabled[setToken][cToken];
        }
        address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;
        for (uint256 i = 0; i < collateralCTokens.length; i++) {
            ICErc20 cToken = ICErc20(collateralCTokens[i]);
            setToken.invokeExitMarket(cToken, comptroller);
            delete collateralCTokenEnabled[setToken][cToken];
        }
        delete enabledAssets[setToken];
        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }
    /**
     * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken
     * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");
        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }
    /**
     * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];
            require(address(cToken) != address(0), "cToken must exist");
            require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");
            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }
            collateralCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].collateralCTokens.push(address(cToken));
        }
        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }
    /**
     * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets
     * If there is a borrow balance, collateral asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);
        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];
            require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");
            // Note: Will only exit market if cToken is not enabled as a borrow asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }
            delete collateralCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));
        }
        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }
    /**
     * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 newBorrowAsset = _newBorrowAssets[i];
            ICErc20 cToken = underlyingToCToken[newBorrowAsset];
            require(address(cToken) != address(0), "cToken must exist");
            require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");
            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }
            borrowCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].borrowCTokens.push(address(cToken));
            enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }
    /**
     * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets
     * If there is a borrow balance, borrow asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);
        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];
            require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");
            // Note: Will only exit market if cToken is not enabled as a collateral asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }
            delete borrowCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));
            enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));
        }
        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }
    /**
     * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.
     *
     * @param _setToken             Instance of the SetToken
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }
    /**
     * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.
     *
     * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }
    /**
     * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _cToken                   Address of cToken to add
     * @param _underlying               Address of underlying token that maps to cToken
     */
    function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) == address(0), "Already added");
        underlyingToCToken[_underlying] = _cToken;
    }
    /**
     * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _underlying               Address of underlying token to remove
     */
    function removeCompoundMarket(IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) != address(0), "Not added");
        delete underlyingToCToken[_underlying];
    }
    /**
     * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, false);
    }
    /**
     * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.
     * Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, true);
    }
    /**
     * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));
        require(componentDebt < 0, "Component must be negative");
        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);
        _borrow(_setToken, underlyingToCToken[_component], notionalDebt);
    }
    /**
     * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));
        require(componentDebt < 0, "Component must be negative");
        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);
        _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt);
    }

    /* ============ External Getter Functions ============ */
    /**
     * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an
     * array of underlying that are borrow assets.
     *
     * @return                    Collateral cToken assets that are enabled
     * @return                    Underlying borrowed assets that are enabled.
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralCTokens,
            enabledAssets[_setToken].borrowAssets
        );
    }
    /* ============ Internal Functions ============ */
    /**
     * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be
     * unwrapped as it only accepts the underlying ETH.
     */
    function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _mintNotional);
            _setToken.invokeMintCEther(_cToken, _mintNotional);
        } else {
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);
            _setToken.invokeMintCToken(_cToken, _mintNotional);
        }
    }
    /**
     * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.
     */
    function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {
        _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);
        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _redeemNotional);
        }
    }
    /**
     * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.
     */
    function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _repayNotional);
            _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);
        } else {
            // Approve to cToken
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);
            _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);
        }
    }
    /**
     * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.
     */
    function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {
        _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);
        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);
        }
    }
    /**
     * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     *
     * @return receiveTokenQuantity The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
         ISetToken setToken = _actionInfo.setToken;
         uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;
         setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );
        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );
        setToken.invoke(targetExchange, callValue, methodData);
        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );
        return receiveTokenQuantity;
    }
    /**
     * Calculates protocol fee on module and pays protocol fee from SetToken
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);
        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);
        return protocolFeeTotal;
    }
    /**
     * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)
     */
    function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {
        _updateCollateralPosition(
            actionInfo.setToken,
            actionInfo.collateralCTokenAsset,
            _getCollateralPosition(
                actionInfo.setToken,
                actionInfo.collateralCTokenAsset,
                actionInfo.setTotalSupply
            )
        );
        _updateBorrowPosition(
            actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                actionInfo.setToken,
                actionInfo.borrowCTokenAsset,
                actionInfo.setTotalSupply,
                false // Do not accrue interest
            )
        );
    }
    function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_cToken), _newPositionUnit);
    }
    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, "");
    }
    /**
     * Construct the ActionInfo struct for lever and delever
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();
        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever
        );
    }
    /**
     * Construct the ActionInfo struct for lever and delever accepting notional units
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            setToken: _setToken,
            collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],
            borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],
            setTotalSupply: totalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });
        _validateCommon(actionInfo);
        return actionInfo;
    }

    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");
        require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");
        require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }
    function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }
    /**
     * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.
     * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.
     */
    function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {
        uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));
        // Round negative away from 0
        int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);
        return borrowPositionUnit;
    }
}".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-01-09 02:00:08 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 02:00:08 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 27670
completion_tokens: 1
total_tokens: 27671
cost: $-1.000000


[2024-01-09 02:00:08 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { Compound } from "../../integration/lib/Compound.sol";
import { ICErc20 } from "../../../interfaces/external/ICErc20.sol";
import { IComptroller } from "../../../interfaces/external/IComptroller.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title CompoundLeverageModule
 * @author Set Protocol
 *
 * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call
 * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each
 * asset is leveraged when using this module.
 *
 * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 *
 */
contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {
    using Compound for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken
        address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken
        address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset
        ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    /* ============ Events ============ */

    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the trade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping of underlying to CToken. If ETH, then map WETH to cETH
    mapping(IERC20 => ICErc20) public underlyingToCToken;

    // Wrapped Ether address
    IERC20 internal weth;

    // Compound cEther address
    ICErc20 internal cEther;

    // Compound Comptroller contract
    IComptroller internal comptroller;

    // COMP token address
    IERC20 internal compToken;

    // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public collateralCTokenEnabled;

    // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public borrowCTokenEnabled;

    // Mapping of enabled collateral and borrow cTokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list
    bool public anySetAllowed;


    /* ============ Constructor ============ */

    /**
     * Instantiate addresses. Underlying to cToken mapping is created.
     *
     * @param _controller               Address of controller contract
     * @param _compToken                Address of COMP token
     * @param _comptroller              Address of Compound Comptroller
     * @param _cEther                   Address of cEther contract
     * @param _weth                     Address of WETH contract
     */
    constructor(
        IController _controller,
        IERC20 _compToken,
        IComptroller _comptroller,
        ICErc20 _cEther,
        IERC20 _weth
    )
        public
        ModuleBase(_controller)
    {
        compToken = _compToken;
        comptroller = _comptroller;
        cEther = _cEther;
        weth = _weth;

        ICErc20[] memory cTokens = comptroller.getAllMarkets();

        for(uint256 i = 0; i < cTokens.length; i++) {
            ICErc20 cToken = cTokens[i];
            underlyingToCToken[
                cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())
            ] = cToken;
        }
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.
     * Performs a DEX trade, exchanging the borrow asset for collateral asset.
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAsset          Address of asset being borrowed for leverage
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _borrowQuantity       Borrow quantity of asset in position units
     * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantity,
        uint256 _minReceiveQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantity,
            _minReceiveQuantity,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        uint256 _minRepayQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantity,
            _minRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received
     * borrow asset is updated as equity. No protocol fee is charged.
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());

        require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly
        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);

        // Update default position first to save gas on editing borrow position
        _setToken.calculateAndEditDefaultPosition(
            address(_repayAsset),
            deleverInfo.setTotalSupply,
            deleverInfo.preTradeReceiveTokenBalance
        );

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0 // No protocol fee
        );
    }

    /**
     * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral
     * assets, update cToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     *
     * @param _setToken               Instance of the SetToken
     * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value
     */
    function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption
        if (setTotalSupply > 0) {
            // Loop through collateral assets
            address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;
            for(uint256 i = 0; i < collateralCTokens.length; i++) {
                ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);
                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);
                }
            }

            // Loop through borrow assets
            address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;
            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowCTokens.length; i++) {
                ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));

                int256 newPositionUnit = _getBorrowPosition(
                    _setToken,
                    borrowCToken,
                    setTotalSupply,
                    _shouldAccrueInterest
                );

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }


    /**
     * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable
     * collateral and borrow assets that don't exist as positions on the SetToken
     *
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // Enable collateral and borrow assets on Compound
        addCollateralAssets(_setToken, _collateralAssets);

        addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled
     * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Compound and SetToken positions prior to any removal action
        sync(setToken, true);

        address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;
        for (uint256 i = 0; i < borrowCTokens.length; i++) {
            ICErc20 cToken = ICErc20(borrowCTokens[i]);

            // Will exit only if token isn't also being used as collateral
            if(!collateralCTokenEnabled[setToken][cToken]) {
                // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound
                setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[setToken][cToken];
        }

        address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;
        for (uint256 i = 0; i < collateralCTokens.length; i++) {
            ICErc20 cToken = ICErc20(collateralCTokens[i]);

            setToken.invokeExitMarket(cToken, comptroller);

            delete collateralCTokenEnabled[setToken][cToken];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken
     * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];
            require(address(cToken) != address(0), "cToken must exist");
            require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            collateralCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].collateralCTokens.push(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets
     * If there is a borrow balance, collateral asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];
            require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");

            // Note: Will only exit market if cToken is not enabled as a borrow asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete collateralCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 newBorrowAsset = _newBorrowAssets[i];
            ICErc20 cToken = underlyingToCToken[newBorrowAsset];
            require(address(cToken) != address(0), "cToken must exist");
            require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            borrowCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].borrowCTokens.push(address(cToken));
            enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));
        }

        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets
     * If there is a borrow balance, borrow asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];
            require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");

            // Note: Will only exit market if cToken is not enabled as a collateral asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));
            enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));
        }

        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.
     *
     * @param _setToken             Instance of the SetToken
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.
     *
     * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _cToken                   Address of cToken to add
     * @param _underlying               Address of underlying token that maps to cToken
     */
    function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) == address(0), "Already added");
        underlyingToCToken[_underlying] = _cToken;
    }

    /**
     * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _underlying               Address of underlying token to remove
     */
    function removeCompoundMarket(IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) != address(0), "Not added");
        delete underlyingToCToken[_underlying];
    }

    /**
     * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, false);
    }

    /**
     * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.
     * Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, true);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);

        _borrow(_setToken, underlyingToCToken[_component], notionalDebt);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);

        _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt);
    }


    /* ============ External Getter Functions ============ */

    /**
     * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an
     * array of underlying that are borrow assets.
     *
     * @return                    Collateral cToken assets that are enabled
     * @return                    Underlying borrowed assets that are enabled.
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralCTokens,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be
     * unwrapped as it only accepts the underlying ETH.
     */
    function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _mintNotional);

            _setToken.invokeMintCEther(_cToken, _mintNotional);
        } else {
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);

            _setToken.invokeMintCToken(_cToken, _mintNotional);
        }
    }

    /**
     * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.
     */
    function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {
        _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);

        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _redeemNotional);
        }
    }

    /**
     * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.
     */
    function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _repayNotional);

            _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);
        } else {
            // Approve to cToken
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);
            _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);
        }
    }

    /**
     * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.
     */
    function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {
        _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);
        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);
        }
    }

    /**
     * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     *
     * @return receiveTokenQuantity The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
         ISetToken setToken = _actionInfo.setToken;
         uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

         setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * Calculates protocol fee on module and pays protocol fee from SetToken
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)
     */
    function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {
        _updateCollateralPosition(
            actionInfo.setToken,
            actionInfo.collateralCTokenAsset,
            _getCollateralPosition(
                actionInfo.setToken,
                actionInfo.collateralCTokenAsset,
                actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                actionInfo.setToken,
                actionInfo.borrowCTokenAsset,
                actionInfo.setTotalSupply,
                false // Do not accrue interest
            )
        );
    }

    function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_cToken), _newPositionUnit);
    }

    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, "");
    }

    /**
     * Construct the ActionInfo struct for lever and delever
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever
        );
    }

    /**
     * Construct the ActionInfo struct for lever and delever accepting notional units
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            setToken: _setToken,
            collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],
            borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],
            setTotalSupply: totalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }



    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");
        require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");
        require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.
     * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.
     */
    function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {
        uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));
        // Round negative away from 0
        int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);

        return borrowPositionUnit;
    }
}.]

Security

[2024-01-09 02:00:08 INFO] **[Seminar Conclusion]**:

 Security

[2024-01-09 02:00:08 INFO] **[Seminar Conclusion]**:

 <INFO> Security

[2024-01-09 02:00:08 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-01-09 02:00:09 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { Compound } from "../../integration/lib/Compound.sol"; import { ICErc20 } from "../../../interfaces/external/ICErc20.sol"; import { IComptroller } from "../../../interfaces/external/IComptroller.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol"; import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; /*  * @title CompoundLeverageModule  * @author Set Protocol  *  * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call  * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each  * asset is leveraged when using this module.  *  * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of  * debt when borrowed assets are the same.  *  / contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {     using Compound for ISetToken; /* ============ Structs ============ */  struct EnabledAssets {     address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken     address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken     address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets }  struct ActionInfo {     ISetToken setToken;                      // SetToken instance     IExchangeAdapter exchangeAdapter;        // Exchange adapter instance     uint256 setTotalSupply;                  // Total supply of SetToken     uint256 notionalSendQuantity;            // Total notional quantity sent to exchange     uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange     ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset     ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset     uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance }  /* ============ Events ============ */  event LeverageIncreased(     ISetToken indexed _setToken,     IERC20 indexed _borrowAsset,     IERC20 indexed _collateralAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalBorrowAmount,     uint256 _totalReceiveAmount,     uint256 _protocolFee );  event LeverageDecreased(     ISetToken indexed _setToken,     IERC20 indexed _collateralAsset,     IERC20 indexed _repayAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalRedeemAmount,     uint256 _totalRepayAmount,     uint256 _protocolFee );  event CollateralAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  event BorrowAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  event SetTokenStatusUpdated(     ISetToken indexed _setToken,     bool indexed _added );  event AnySetAllowedUpdated(     bool indexed _anySetAllowed );  /* ============ Constants ============ */  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the trade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Mapping of underlying to CToken. If ETH, then map WETH to cETH mapping(IERC20 =&gt; ICErc20) public underlyingToCToken;  // Wrapped Ether address IERC20 internal weth;  // Compound cEther address ICErc20 internal cEther;  // Compound Comptroller contract IComptroller internal comptroller;  // COMP token address IERC20 internal compToken;  // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public collateralCTokenEnabled;  // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public borrowCTokenEnabled;  // Mapping of enabled collateral and borrow cTokens for syncing positions mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;  // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance mapping(ISetToken =&gt; bool) public allowedSetTokens;  // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list bool public anySetAllowed;   /* ============ Constructor ============ */  /**  * Instantiate addresses. Underlying to cToken mapping is created.  *  * @param _controller               Address of controller contract  * @param _compToken                Address of COMP token  * @param _comptroller              Address of Compound Comptroller  * @param _cEther                   Address of cEther contract  * @param _weth                     Address of WETH contract  */ constructor(     IController _controller,     IERC20 _compToken,     IComptroller _comptroller,     ICErc20 _cEther,     IERC20 _weth )     public     ModuleBase(_controller) {     compToken = _compToken;     comptroller = _comptroller;     cEther = _cEther;     weth = _weth;      ICErc20[] memory cTokens = comptroller.getAllMarkets();      for(uint256 i = 0; i &lt; cTokens.length; i++) {         ICErc20 cToken = cTokens[i];         underlyingToCToken[             cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())         ] = cToken;     } }  /* ============ External Functions ============ */  /**  * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.  * Performs a DEX trade, exchanging the borrow asset for collateral asset.  *  * @param _setToken             Instance of the SetToken  * @param _borrowAsset          Address of asset being borrowed for leverage  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _borrowQuantity       Borrow quantity of asset in position units  * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function lever(     ISetToken _setToken,     IERC20 _borrowAsset,     IERC20 _collateralAsset,     uint256 _borrowQuantity,     uint256 _minReceiveQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // For levering up, send quantity is derived from borrow asset and receive quantity is derived from     // collateral asset     ActionInfo memory leverInfo = _createAndValidateActionInfo(         _setToken,         _borrowAsset,         _collateralAsset,         _borrowQuantity,         _minReceiveQuantity,         _tradeAdapterName,         true     );      _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);      uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);      _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);      _updateLeverPositions(leverInfo, _borrowAsset);      emit LeverageIncreased(         _setToken,         _borrowAsset,         _collateralAsset,         leverInfo.exchangeAdapter,         leverInfo.notionalSendQuantity,         postTradeCollateralQuantity,         protocolFee     ); }  /**  * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled  *  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _repayAsset           Address of asset being repaid  * @param _redeemQuantity       Quantity of collateral asset to delever  * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function delever(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantity,     uint256 _minRepayQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from     // repay asset     ActionInfo memory deleverInfo = _createAndValidateActionInfo(         _setToken,         _collateralAsset,         _repayAsset,         _redeemQuantity,         _minRepayQuantity,         _tradeAdapterName,         false     );      _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);      uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);      _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);      _updateLeverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         repayQuantity,         protocolFee     ); }  /**  * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received  * borrow asset is updated as equity. No protocol fee is charged.  *  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)  * @param _redeemQuantity       Quantity of collateral asset to delever  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function deleverToZeroBorrowBalance(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());      require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");     uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));      ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(         _setToken,         _collateralAsset,         _repayAsset,         notionalRedeemQuantity,         notionalRepayQuantity,         _tradeAdapterName,         false     );      _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);      _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly     _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);      // Update default position first to save gas on editing borrow position     _setToken.calculateAndEditDefaultPosition(         address(_repayAsset),         deleverInfo.setTotalSupply,         deleverInfo.preTradeReceiveTokenBalance     );      _updateLeverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         notionalRepayQuantity,         0 // No protocol fee     ); }  /**  * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral  * assets, update cToken default position. For borrow assets, update external borrow position.  * - Collateral assets may come out of sync when a position is liquidated  * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid  *  * @param _setToken               Instance of the SetToken  * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value  */ function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {     uint256 setTotalSupply = _setToken.totalSupply();      // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption     if (setTotalSupply &gt; 0) {         // Loop through collateral assets         address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;         for(uint256 i = 0; i &lt; collateralCTokens.length; i++) {             ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);             uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();             uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (previousPositionUnit != newPositionUnit) {               _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);             }         }          // Loop through borrow assets         address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;         address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;         for(uint256 i = 0; i &lt; borrowCTokens.length; i++) {             ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);             IERC20 borrowAsset = IERC20(borrowAssets[i]);              int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));              int256 newPositionUnit = _getBorrowPosition(                 _setToken,                 borrowCToken,                 setTotalSupply,                 _shouldAccrueInterest             );              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (newPositionUnit != previousPositionUnit) {                 _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);             }         }     } }   /**  * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable  * collateral and borrow assets that don't exist as positions on the SetToken  *  * @param _setToken             Instance of the SetToken to initialize  * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken  * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken  */ function initialize(     ISetToken _setToken,     IERC20[] memory _collateralAssets,     IERC20[] memory _borrowAssets )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     if (!anySetAllowed) {         require(allowedSetTokens[_setToken], "Not allowed SetToken");     }      // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}     }      // Enable collateral and borrow assets on Compound     addCollateralAssets(_setToken, _collateralAssets);      addBorrowAssets(_setToken, _borrowAssets); }  /**  * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled  * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)  */ function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Sync Compound and SetToken positions prior to any removal action     sync(setToken, true);      address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;     for (uint256 i = 0; i &lt; borrowCTokens.length; i++) {         ICErc20 cToken = ICErc20(borrowCTokens[i]);          // Will exit only if token isn't also being used as collateral         if(!collateralCTokenEnabled[setToken][cToken]) {             // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound             setToken.invokeExitMarket(cToken, comptroller);         }          delete borrowCTokenEnabled[setToken][cToken];     }      address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;     for (uint256 i = 0; i &lt; collateralCTokens.length; i++) {         ICErc20 cToken = ICErc20(collateralCTokens[i]);          setToken.invokeExitMarket(cToken, comptroller);          delete collateralCTokenEnabled[setToken][cToken];     }      delete enabledAssets[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken  * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state  * inconsistencies  *  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets  *  * @param _setToken             Instance of the SetToken  * @param _newCollateralAssets  Addresses of new collateral underlying assets  */ function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {     for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];         require(address(cToken) != address(0), "cToken must exist");         require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");          // Note: Will only enter market if cToken is not enabled as a borrow asset as well         if (!borrowCTokenEnabled[_setToken][cToken]) {             _setToken.invokeEnterMarkets(cToken, comptroller);         }          collateralCTokenEnabled[_setToken][cToken] = true;         enabledAssets[_setToken].collateralCTokens.push(address(cToken));     }      emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets); }  /**  * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets  * If there is a borrow balance, collateral asset cannot be removed  *  * @param _setToken             Instance of the SetToken  * @param _collateralAssets     Addresses of collateral underlying assets to remove  */ function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {     // Sync Compound and SetToken positions prior to any removal action     sync(_setToken, true);      for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];         require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");          // Note: Will only exit market if cToken is not enabled as a borrow asset as well         // If there is an existing borrow balance, will revert and market cannot be exited on Compound         if (!borrowCTokenEnabled[_setToken][cToken]) {             _setToken.invokeExitMarket(cToken, comptroller);         }          delete collateralCTokenEnabled[_setToken][cToken];         enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));     }      emit CollateralAssetsUpdated(_setToken, false, _collateralAssets); }  /**  * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets  *  * @param _setToken             Instance of the SetToken  * @param _newBorrowAssets      Addresses of borrow underlying assets to add  */ function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {     for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {         IERC20 newBorrowAsset = _newBorrowAssets[i];         ICErc20 cToken = underlyingToCToken[newBorrowAsset];         require(address(cToken) != address(0), "cToken must exist");         require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");          // Note: Will only enter market if cToken is not enabled as a borrow asset as well         if (!collateralCTokenEnabled[_setToken][cToken]) {             _setToken.invokeEnterMarkets(cToken, comptroller);         }          borrowCTokenEnabled[_setToken][cToken] = true;         enabledAssets[_setToken].borrowCTokens.push(address(cToken));         enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));     }      emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets); }  /**  * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets  * If there is a borrow balance, borrow asset cannot be removed  *  * @param _setToken             Instance of the SetToken  * @param _borrowAssets         Addresses of borrow underlying assets to remove  */ function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {     // Sync Compound and SetToken positions prior to any removal action     sync(_setToken, true);      for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];         require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");          // Note: Will only exit market if cToken is not enabled as a collateral asset as well         // If there is an existing borrow balance, will revert and market cannot be exited on Compound         if (!collateralCTokenEnabled[_setToken][cToken]) {             _setToken.invokeExitMarket(cToken, comptroller);         }          delete borrowCTokenEnabled[_setToken][cToken];         enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));         enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));     }      emit BorrowAssetsUpdated(_setToken, false, _borrowAssets); }  /**  * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.  *  * @param _setToken             Instance of the SetToken  */ function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {     allowedSetTokens[_setToken] = _status;     emit SetTokenStatusUpdated(_setToken, _status); }  /**  * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.  *  * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled  */ function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {     anySetAllowed = _anySetAllowed;     emit AnySetAllowedUpdated(_anySetAllowed); }  /**  * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.  *  * IMPORTANT: Validations are skipped in order to get contract under bytecode limit  *  * @param _cToken                   Address of cToken to add  * @param _underlying               Address of underlying token that maps to cToken  */ function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {     require(address(underlyingToCToken[_underlying]) == address(0), "Already added");     underlyingToCToken[_underlying] = _cToken; }  /**  * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals  *  * IMPORTANT: Validations are skipped in order to get contract under bytecode limit  *  * @param _underlying               Address of underlying token to remove  */ function removeCompoundMarket(IERC20 _underlying) external onlyOwner {     require(address(underlyingToCToken[_underlying]) != address(0), "Not added");     delete underlyingToCToken[_underlying]; }  /**  * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {     sync(_setToken, false); }  /**  * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.  * Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {     sync(_setToken, true); }  /**  * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {     int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));      require(componentDebt &lt; 0, "Component must be negative");      uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);      _borrow(_setToken, underlyingToCToken[_component], notionalDebt); }  /**  * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {     int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));      require(componentDebt &lt; 0, "Component must be negative");      uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);      _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt); }   /* ============ External Getter Functions ============ */  /**  * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an  * array of underlying that are borrow assets.  *  * @return                    Collateral cToken assets that are enabled  * @return                    Underlying borrowed assets that are enabled.  */ function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {     return (         enabledAssets[_setToken].collateralCTokens,         enabledAssets[_setToken].borrowAssets     ); }  /* ============ Internal Functions ============ */  /**  * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be  * unwrapped as it only accepts the underlying ETH.  */ function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {     if (_cToken == cEther) {         _setToken.invokeUnwrapWETH(address(weth), _mintNotional);          _setToken.invokeMintCEther(_cToken, _mintNotional);     } else {         _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);          _setToken.invokeMintCToken(_cToken, _mintNotional);     } }  /**  * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.  */ function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {     _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);      if (_cToken == cEther) {         _setToken.invokeWrapWETH(address(weth), _redeemNotional);     } }  /**  * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.  */ function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {     if (_cToken == cEther) {         _setToken.invokeUnwrapWETH(address(weth), _repayNotional);          _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);     } else {         // Approve to cToken         _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);         _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);     } }  /**  * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.  */ function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {     _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);     if (_cToken == cEther) {         _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);     } }  /**  * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken  *  * @return receiveTokenQuantity The quantity of tokens received post-trade  */ function _executeTrade(     ActionInfo memory _actionInfo,     IERC20 _sendToken,     IERC20 _receiveToken,     bytes memory _data )     internal     returns (uint256) {      ISetToken setToken = _actionInfo.setToken;      uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;       setToken.invokeApprove(         address(_sendToken),         _actionInfo.exchangeAdapter.getSpender(),         notionalSendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _actionInfo.exchangeAdapter.getTradeCalldata(         address(_sendToken),         address(_receiveToken),         address(setToken),         notionalSendQuantity,         _actionInfo.minNotionalReceiveQuantity,         _data     );      setToken.invoke(targetExchange, callValue, methodData);      uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);     require(         receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,         "Slippage too high"     );      return receiveTokenQuantity; }  /**  * Calculates protocol fee on module and pays protocol fee from SetToken  */ function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {     uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);      payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);      return protocolFeeTotal; }  /**  * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)  */ function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {     _updateCollateralPosition(         actionInfo.setToken,         actionInfo.collateralCTokenAsset,         _getCollateralPosition(             actionInfo.setToken,             actionInfo.collateralCTokenAsset,             actionInfo.setTotalSupply         )     );      _updateBorrowPosition(         actionInfo.setToken,         _borrowAsset,         _getBorrowPosition(             actionInfo.setToken,             actionInfo.borrowCTokenAsset,             actionInfo.setTotalSupply,             false // Do not accrue interest         )     ); }  function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {     _setToken.editDefaultPosition(address(_cToken), _newPositionUnit); }  function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {     _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, ""); }  /**  * Construct the ActionInfo struct for lever and delever  */ function _createAndValidateActionInfo(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _sendQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();      return _createAndValidateActionInfoNotional(         _setToken,         _sendToken,         _receiveToken,         _sendQuantityUnits.preciseMul(totalSupply),         _minReceiveQuantityUnits.preciseMul(totalSupply),         _tradeAdapterName,         _isLever     ); }  /**  * Construct the ActionInfo struct for lever and delever accepting notional units  */ function _createAndValidateActionInfoNotional(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _notionalSendQuantity,     uint256 _minNotionalReceiveQuantity,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();     ActionInfo memory actionInfo = ActionInfo ({         exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),         setToken: _setToken,         collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],         borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],         setTotalSupply: totalSupply,         notionalSendQuantity: _notionalSendQuantity,         minNotionalReceiveQuantity: _minNotionalReceiveQuantity,         preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))     });      _validateCommon(actionInfo);      return actionInfo; }    function _validateCommon(ActionInfo memory _actionInfo) internal view {     require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");     require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");     require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");     require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0"); }  function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {     uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));     return collateralNotionalBalance.preciseDiv(_setTotalSupply); }  /**  * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.  * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.  */ function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {     uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));     // Round negative away from 0     int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);      return borrowPositionUnit; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '/\n    Copyright 2021 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n/\n\npragma solidity 0.6.10;\npragma experimental "ABIEncoderV2";\n\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";\nimport { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\n\nimport { Compound } from "../../integration/lib/Compound.sol";\nimport { ICErc20 } from "../../../interfaces/external/ICErc20.sol";\nimport { IComptroller } from "../../../interfaces/external/IComptroller.sol";\nimport { IController } from "../../../interfaces/IController.sol";\nimport { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";\nimport { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";\nimport { ISetToken } from "../../../interfaces/ISetToken.sol";\nimport { ModuleBase } from "../../lib/ModuleBase.sol";\n\n/\n * @title CompoundLeverageModule\n * @author Set Protocol\n \n * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call\n * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each\n * asset is leveraged when using this module.\n \n * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of\n * debt when borrowed assets are the same.\n \n /\ncontract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {\n    using Compound for ISetToken;\n\n    / ============ Structs ============ /\n\n    struct EnabledAssets {\n        address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken\n        address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken\n        address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets\n    }\n\n    struct ActionInfo {\n        ISetToken setToken;                      // SetToken instance\n        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance\n        uint256 setTotalSupply;                  // Total supply of SetToken\n        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange\n        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange\n        ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset\n        ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset\n        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance\n    }\n\n    / ============ Events ============ /\n\n    event LeverageIncreased(\n        ISetToken indexed _setToken,\n        IERC20 indexed _borrowAsset,\n        IERC20 indexed _collateralAsset,\n        IExchangeAdapter _exchangeAdapter,\n        uint256 _totalBorrowAmount,\n        uint256 _totalReceiveAmount,\n        uint256 _protocolFee\n    );\n\n    event LeverageDecreased(\n        ISetToken indexed _setToken,\n        IERC20 indexed _collateralAsset,\n        IERC20 indexed _repayAsset,\n        IExchangeAdapter _exchangeAdapter,\n        uint256 _totalRedeemAmount,\n        uint256 _totalRepayAmount,\n        uint256 _protocolFee\n    );\n\n    event CollateralAssetsUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added,\n        IERC20[] _assets\n    );\n\n    event BorrowAssetsUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added,\n        IERC20[] _assets\n    );\n\n    event SetTokenStatusUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added\n    );\n\n    event AnySetAllowedUpdated(\n        bool indexed _anySetAllowed\n    );\n\n    / ============ Constants ============ /\n\n    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as\n    // the string as the integration name\n    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";\n\n    // 0 index stores protocol fee % on the controller, charged in the trade function\n    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;\n\n    / ============ State Variables ============ /\n\n    // Mapping of underlying to CToken. If ETH, then map WETH to cETH\n    mapping(IERC20 =&gt; ICErc20) public underlyingToCToken;\n\n    // Wrapped Ether address\n    IERC20 internal weth;\n\n    // Compound cEther address\n    ICErc20 internal cEther;\n\n    // Compound Comptroller contract\n    IComptroller internal comptroller;\n\n    // COMP token address\n    IERC20 internal compToken;\n\n    // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken\n    mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public collateralCTokenEnabled;\n\n    // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken\n    mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public borrowCTokenEnabled;\n\n    // Mapping of enabled collateral and borrow cTokens for syncing positions\n    mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;\n\n    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance\n    mapping(ISetToken =&gt; bool) public allowedSetTokens;\n\n    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list\n    bool public anySetAllowed;\n\n\n    / ============ Constructor ============ /\n\n    /\n     * Instantiate addresses. Underlying to cToken mapping is created.\n     \n     * @param _controller               Address of controller contract\n     * @param _compToken                Address of COMP token\n     * @param _comptroller              Address of Compound Comptroller\n     * @param _cEther                   Address of cEther contract\n     * @param _weth                     Address of WETH contract\n     /\n    constructor(\n        IController _controller,\n        IERC20 _compToken,\n        IComptroller _comptroller,\n        ICErc20 _cEther,\n        IERC20 _weth\n    )\n        public\n        ModuleBase(_controller)\n    {\n        compToken = _compToken;\n        comptroller = _comptroller;\n        cEther = _cEther;\n        weth = _weth;\n\n        ICErc20[] memory cTokens = comptroller.getAllMarkets();\n\n        for(uint256 i = 0; i &lt; cTokens.length; i++) {\n            ICErc20 cToken = cTokens[i];\n            underlyingToCToken[\n                cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())\n            ] = cToken;\n        }\n    }\n\n    / ============ External Functions ============ /\n\n    /\n     * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.\n     * Performs a DEX trade, exchanging the borrow asset for collateral asset.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _borrowAsset          Address of asset being borrowed for leverage\n     * @param _collateralAsset      Address of collateral asset (underlying of cToken)\n     * @param _borrowQuantity       Borrow quantity of asset in position units\n     * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units\n     * @param _tradeAdapterName     Name of trade adapter\n     * @param _tradeData            Arbitrary data for trade\n     /\n    function lever(\n        ISetToken _setToken,\n        IERC20 _borrowAsset,\n        IERC20 _collateralAsset,\n        uint256 _borrowQuantity,\n        uint256 _minReceiveQuantity,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from\n        // collateral asset\n        ActionInfo memory leverInfo = _createAndValidateActionInfo(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            _borrowQuantity,\n            _minReceiveQuantity,\n            _tradeAdapterName,\n            true\n        );\n\n        _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);\n\n        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);\n\n        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n        _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);\n\n        _updateLeverPositions(leverInfo, _borrowAsset);\n\n        emit LeverageIncreased(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            leverInfo.exchangeAdapter,\n            leverInfo.notionalSendQuantity,\n            postTradeCollateralQuantity,\n            protocolFee\n        );\n    }\n\n    /\n     * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _collateralAsset      Address of collateral asset (underlying of cToken)\n     * @param _repayAsset           Address of asset being repaid\n     * @param _redeemQuantity       Quantity of collateral asset to delever\n     * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade\n     * @param _tradeAdapterName     Name of trade adapter\n     * @param _tradeData            Arbitrary data for trade\n     /\n    function delever(\n        ISetToken _setToken,\n        IERC20 _collateralAsset,\n        IERC20 _repayAsset,\n        uint256 _redeemQuantity,\n        uint256 _minRepayQuantity,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from\n        // repay asset\n        ActionInfo memory deleverInfo = _createAndValidateActionInfo(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            _redeemQuantity,\n            _minRepayQuantity,\n            _tradeAdapterName,\n            false\n        );\n\n        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);\n\n        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);\n\n        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);\n\n        _updateLeverPositions(deleverInfo, _repayAsset);\n\n        emit LeverageDecreased(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            deleverInfo.exchangeAdapter,\n            deleverInfo.notionalSendQuantity,\n            repayQuantity,\n            protocolFee\n        );\n    }\n\n    /\n     * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received\n     * borrow asset is updated as equity. No protocol fee is charged.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _collateralAsset      Address of collateral asset (underlying of cToken)\n     * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)\n     * @param _redeemQuantity       Quantity of collateral asset to delever\n     * @param _tradeAdapterName     Name of trade adapter\n     * @param _tradeData            Arbitrary data for trade\n     /\n    function deleverToZeroBorrowBalance(\n        ISetToken _setToken,\n        IERC20 _collateralAsset,\n        IERC20 _repayAsset,\n        uint256 _redeemQuantity,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());\n\n        require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");\n        uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));\n\n        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            notionalRedeemQuantity,\n            notionalRepayQuantity,\n            _tradeAdapterName,\n            false\n        );\n\n        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);\n\n        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n\n        // We use notionalRepayQuantity vs. Compound\'s max value uint256(-1) to handle WETH properly\n        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);\n\n        // Update default position first to save gas on editing borrow position\n        _setToken.calculateAndEditDefaultPosition(\n            address(_repayAsset),\n            deleverInfo.setTotalSupply,\n            deleverInfo.preTradeReceiveTokenBalance\n        );\n\n        _updateLeverPositions(deleverInfo, _repayAsset);\n\n        emit LeverageDecreased(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            deleverInfo.exchangeAdapter,\n            deleverInfo.notionalSendQuantity,\n            notionalRepayQuantity,\n            0 // No protocol fee\n        );\n    }\n\n    /\n     * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral\n     * assets, update cToken default position. For borrow assets, update external borrow position.\n     * - Collateral assets may come out of sync when a position is liquidated\n     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid\n     \n     * @param _setToken               Instance of the SetToken\n     * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value\n     /\n    function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {\n        uint256 setTotalSupply = _setToken.totalSupply();\n\n        // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption\n        if (setTotalSupply &gt; 0) {\n            // Loop through collateral assets\n            address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;\n            for(uint256 i = 0; i &lt; collateralCTokens.length; i++) {\n                ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);\n                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();\n                uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);\n\n                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets\n                if (previousPositionUnit != newPositionUnit) {\n                  _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);\n                }\n            }\n\n            // Loop through borrow assets\n            address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;\n            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;\n            for(uint256 i = 0; i &lt; borrowCTokens.length; i++) {\n                ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);\n                IERC20 borrowAsset = IERC20(borrowAssets[i]);\n\n                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));\n\n                int256 newPositionUnit = _getBorrowPosition(\n                    _setToken,\n                    borrowCToken,\n                    setTotalSupply,\n                    _shouldAccrueInterest\n                );\n\n                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets\n                if (newPositionUnit != previousPositionUnit) {\n                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);\n                }\n            }\n        }\n    }\n\n\n    /\n     * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken\'s manager. Note: managers can enable\n     * collateral and borrow assets that don\'t exist as positions on the SetToken\n     \n     * @param _setToken             Instance of the SetToken to initialize\n     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken\n     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken\n     /\n    function initialize(\n        ISetToken _setToken,\n        IERC20[] memory _collateralAssets,\n        IERC20[] memory _borrowAssets\n    )\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        if (!anySetAllowed) {\n            require(allowedSetTokens[_setToken], "Not allowed SetToken");\n        }\n\n        // Initialize module before trying register\n        _setToken.initializeModule();\n\n        // Get debt issuance module registered to this module and require that it is initialized\n        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");\n\n        // Try if register exists on any of the modules including the debt issuance module\n        address[] memory modules = _setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}\n        }\n\n        // Enable collateral and borrow assets on Compound\n        addCollateralAssets(_setToken, _collateralAssets);\n\n        addBorrowAssets(_setToken, _borrowAssets);\n    }\n\n    /\n     * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled\n     * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)\n     /\n    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {\n        ISetToken setToken = ISetToken(msg.sender);\n\n        // Sync Compound and SetToken positions prior to any removal action\n        sync(setToken, true);\n\n        address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;\n        for (uint256 i = 0; i &lt; borrowCTokens.length; i++) {\n            ICErc20 cToken = ICErc20(borrowCTokens[i]);\n\n            // Will exit only if token isn\'t also being used as collateral\n            if(!collateralCTokenEnabled[setToken][cToken]) {\n                // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound\n                setToken.invokeExitMarket(cToken, comptroller);\n            }\n\n            delete borrowCTokenEnabled[setToken][cToken];\n        }\n\n        address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;\n        for (uint256 i = 0; i &lt; collateralCTokens.length; i++) {\n            ICErc20 cToken = ICErc20(collateralCTokens[i]);\n\n            setToken.invokeExitMarket(cToken, comptroller);\n\n            delete collateralCTokenEnabled[setToken][cToken];\n        }\n\n        delete enabledAssets[setToken];\n\n        // Try if unregister exists on any of the modules\n        address[] memory modules = setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}\n        }\n    }\n\n    /\n     * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken\n     * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state\n     * inconsistencies\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _debtIssuanceModule   Debt issuance module address to register\n     /\n    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {\n        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");\n\n        _debtIssuanceModule.registerToIssuanceModule(_setToken);\n    }\n\n    /\n     * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _newCollateralAssets  Addresses of new collateral underlying assets\n     /\n    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {\n        for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {\n            ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];\n            require(address(cToken) != address(0), "cToken must exist");\n            require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");\n\n            // Note: Will only enter market if cToken is not enabled as a borrow asset as well\n            if (!borrowCTokenEnabled[_setToken][cToken]) {\n                _setToken.invokeEnterMarkets(cToken, comptroller);\n            }\n\n            collateralCTokenEnabled[_setToken][cToken] = true;\n            enabledAssets[_setToken].collateralCTokens.push(address(cToken));\n        }\n\n        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);\n    }\n\n    /\n     * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets\n     * If there is a borrow balance, collateral asset cannot be removed\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _collateralAssets     Addresses of collateral underlying assets to remove\n     /\n    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {\n        // Sync Compound and SetToken positions prior to any removal action\n        sync(_setToken, true);\n\n        for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {\n            ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];\n            require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");\n\n            // Note: Will only exit market if cToken is not enabled as a borrow asset as well\n            // If there is an existing borrow balance, will revert and market cannot be exited on Compound\n            if (!borrowCTokenEnabled[_setToken][cToken]) {\n                _setToken.invokeExitMarket(cToken, comptroller);\n            }\n\n            delete collateralCTokenEnabled[_setToken][cToken];\n            enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));\n        }\n\n        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);\n    }\n\n    /\n     * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _newBorrowAssets      Addresses of borrow underlying assets to add\n     /\n    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {\n        for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {\n            IERC20 newBorrowAsset = _newBorrowAssets[i];\n            ICErc20 cToken = underlyingToCToken[newBorrowAsset];\n            require(address(cToken) != address(0), "cToken must exist");\n            require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");\n\n            // Note: Will only enter market if cToken is not enabled as a borrow asset as well\n            if (!collateralCTokenEnabled[_setToken][cToken]) {\n                _setToken.invokeEnterMarkets(cToken, comptroller);\n            }\n\n            borrowCTokenEnabled[_setToken][cToken] = true;\n            enabledAssets[_setToken].borrowCTokens.push(address(cToken));\n            enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));\n        }\n\n        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);\n    }\n\n    /\n     * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets\n     * If there is a borrow balance, borrow asset cannot be removed\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _borrowAssets         Addresses of borrow underlying assets to remove\n     /\n    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {\n        // Sync Compound and SetToken positions prior to any removal action\n        sync(_setToken, true);\n\n        for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {\n            ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];\n            require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");\n\n            // Note: Will only exit market if cToken is not enabled as a collateral asset as well\n            // If there is an existing borrow balance, will revert and market cannot be exited on Compound\n            if (!collateralCTokenEnabled[_setToken][cToken]) {\n                _setToken.invokeExitMarket(cToken, comptroller);\n            }\n\n            delete borrowCTokenEnabled[_setToken][cToken];\n            enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));\n            enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));\n        }\n\n        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);\n    }\n\n    /\n     * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.\n     \n     * @param _setToken             Instance of the SetToken\n     /\n    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {\n        allowedSetTokens[_setToken] = _status;\n        emit SetTokenStatusUpdated(_setToken, _status);\n    }\n\n    /\n     * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.\n     \n     * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled\n     /\n    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {\n        anySetAllowed = _anySetAllowed;\n        emit AnySetAllowedUpdated(_anySetAllowed);\n    }\n\n    /\n     * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.\n     \n     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit\n     \n     * @param _cToken                   Address of cToken to add\n     * @param _underlying               Address of underlying token that maps to cToken\n     /\n    function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {\n        require(address(underlyingToCToken[_underlying]) == address(0), "Already added");\n        underlyingToCToken[_underlying] = _cToken;\n    }\n\n    /\n     * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals\n     \n     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit\n     \n     * @param _underlying               Address of underlying token to remove\n     */\n    function removeCompoundMarket(IERC20 _underlying) external onlyOwner {\n        require(address(underlyingToCToken[_underlying]) != address(0), "Not added");\n        delete underlyingToCToken[_underlying];\n    }\n\n    /\n     * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.\n     \n     * @param _setToken             Instance of the SetToken\n     /\n    function moduleIssueHook(ISetToken _setToken, uint256 / _setTokenQuantity /) external onlyModule(_setToken) {\n        sync(_setToken, false);\n    }\n\n    /\n     * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.\n     * Only callable by valid module.\n     \n     * @param _setToken             Instance of the SetToken\n     /\n    function moduleRedeemHook(ISetToken _setToken, uint256 / _setTokenQuantity /) external onlyModule(_setToken) {\n        sync(_setToken, true);\n    }\n\n    /\n     * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken\n     * @param _component            Address of component\n     /\n    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool / _isEquity /) external onlyModule(_setToken) {\n        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n\n        require(componentDebt &lt; 0, "Component must be negative");\n\n        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);\n\n        _borrow(_setToken, underlyingToCToken[_component], notionalDebt);\n    }\n\n    /\n     * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken\n     * @param _component            Address of component\n     /\n    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool / _isEquity /) external onlyModule(_setToken) {\n        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n\n        require(componentDebt &lt; 0, "Component must be negative");\n\n        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);\n\n        _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt);\n    }\n\n\n    / ============ External Getter Functions ============ /\n\n    /\n     * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an\n     * array of underlying that are borrow assets.\n     \n     * @return                    Collateral cToken assets that are enabled\n     * @return                    Underlying borrowed assets that are enabled.\n     /\n    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {\n        return (\n            enabledAssets[_setToken].collateralCTokens,\n            enabledAssets[_setToken].borrowAssets\n        );\n    }\n\n    / ============ Internal Functions ============ /\n\n    /\n     * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be\n     * unwrapped as it only accepts the underlying ETH.\n     */\n    function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {\n        if (_cToken == cEther) {\n            _setToken.invokeUnwrapWETH(address(weth), _mintNotional);\n\n            _setToken.invokeMintCEther(_cToken, _mintNotional);\n        } else {\n            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);\n\n            _setToken.invokeMintCToken(_cToken, _mintNotional);\n        }\n    }\n\n    /\n     * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.\n     /\n    function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {\n        _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);\n\n        if (_cToken == cEther) {\n            _setToken.invokeWrapWETH(address(weth), _redeemNotional);\n        }\n    }\n\n    /\n     * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.\n     /\n    function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {\n        if (_cToken == cEther) {\n            _setToken.invokeUnwrapWETH(address(weth), _repayNotional);\n\n            _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);\n        } else {\n            // Approve to cToken\n            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);\n            _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);\n        }\n    }\n\n    /\n     * Invoke the SetToken to interact with the specified cToken to borrow the cToken\'s underlying of the specified borrowQuantity.\n     */\n    function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {\n        _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);\n        if (_cToken == cEther) {\n            _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);\n        }\n    }\n\n    /\n     * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken\n     \n     * @return receiveTokenQuantity The quantity of tokens received post-trade\n     /\n    function _executeTrade(\n        ActionInfo memory _actionInfo,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        bytes memory _data\n    )\n        internal\n        returns (uint256)\n    {\n         ISetToken setToken = _actionInfo.setToken;\n         uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;\n\n         setToken.invokeApprove(\n            address(_sendToken),\n            _actionInfo.exchangeAdapter.getSpender(),\n            notionalSendQuantity\n        );\n\n        (\n            address targetExchange,\n            uint256 callValue,\n            bytes memory methodData\n        ) = _actionInfo.exchangeAdapter.getTradeCalldata(\n            address(_sendToken),\n            address(_receiveToken),\n            address(setToken),\n            notionalSendQuantity,\n            _actionInfo.minNotionalReceiveQuantity,\n            _data\n        );\n\n        setToken.invoke(targetExchange, callValue, methodData);\n\n        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);\n        require(\n            receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,\n            "Slippage too high"\n        );\n\n        return receiveTokenQuantity;\n    }\n\n    /\n     * Calculates protocol fee on module and pays protocol fee from SetToken\n     */\n    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {\n        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);\n\n        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);\n\n        return protocolFeeTotal;\n    }\n\n    /\n     * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)\n     /\n    function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {\n        _updateCollateralPosition(\n            actionInfo.setToken,\n            actionInfo.collateralCTokenAsset,\n            _getCollateralPosition(\n                actionInfo.setToken,\n                actionInfo.collateralCTokenAsset,\n                actionInfo.setTotalSupply\n            )\n        );\n\n        _updateBorrowPosition(\n            actionInfo.setToken,\n            _borrowAsset,\n            _getBorrowPosition(\n                actionInfo.setToken,\n                actionInfo.borrowCTokenAsset,\n                actionInfo.setTotalSupply,\n                false // Do not accrue interest\n            )\n        );\n    }\n\n    function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {\n        _setToken.editDefaultPosition(address(_cToken), _newPositionUnit);\n    }\n\n    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {\n        _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, "");\n    }\n\n    /\n     * Construct the ActionInfo struct for lever and delever\n     /\n    function _createAndValidateActionInfo(\n        ISetToken _setToken,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        uint256 _sendQuantityUnits,\n        uint256 _minReceiveQuantityUnits,\n        string memory _tradeAdapterName,\n        bool _isLever\n    )\n        internal\n        view\n        returns(ActionInfo memory)\n    {\n        uint256 totalSupply = _setToken.totalSupply();\n\n        return _createAndValidateActionInfoNotional(\n            _setToken,\n            _sendToken,\n            _receiveToken,\n            _sendQuantityUnits.preciseMul(totalSupply),\n            _minReceiveQuantityUnits.preciseMul(totalSupply),\n            _tradeAdapterName,\n            _isLever\n        );\n    }\n\n    /\n     * Construct the ActionInfo struct for lever and delever accepting notional units\n     */\n    function _createAndValidateActionInfoNotional(\n        ISetToken _setToken,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        uint256 _notionalSendQuantity,\n        uint256 _minNotionalReceiveQuantity,\n        string memory _tradeAdapterName,\n        bool _isLever\n    )\n        internal\n        view\n        returns(ActionInfo memory)\n    {\n        uint256 totalSupply = _setToken.totalSupply();\n        ActionInfo memory actionInfo = ActionInfo ({\n            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),\n            setToken: _setToken,\n            collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],\n            borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],\n            setTotalSupply: totalSupply,\n            notionalSendQuantity: _notionalSendQuantity,\n            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,\n            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))\n        });\n\n        _validateCommon(actionInfo);\n\n        return actionInfo;\n    }\n\n\n\n    function _validateCommon(ActionInfo memory _actionInfo) internal view {\n        require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");\n        require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");\n        require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");\n        require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0");\n    }\n\n    function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {\n        uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));\n        return collateralNotionalBalance.preciseDiv(_setTotalSupply);\n    }\n\n    /\n     * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.\n     * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.\n     */\n    function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {\n        uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));\n        // Round negative away from 0\n        int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);\n\n        return borrowPositionUnit;\n    }\n}', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 02:00:09 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { Compound } from "../../integration/lib/Compound.sol"; import { ICErc20 } from "../../../interfaces/external/ICErc20.sol"; import { IComptroller } from "../../../interfaces/external/IComptroller.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol"; import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; /*  * @title CompoundLeverageModule  * @author Set Protocol  *  * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call  * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each  * asset is leveraged when using this module.  *  * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of  * debt when borrowed assets are the same.  *  / contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {     using Compound for ISetToken; /* ============ Structs ============ */  struct EnabledAssets {     address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken     address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken     address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets }  struct ActionInfo {     ISetToken setToken;                      // SetToken instance     IExchangeAdapter exchangeAdapter;        // Exchange adapter instance     uint256 setTotalSupply;                  // Total supply of SetToken     uint256 notionalSendQuantity;            // Total notional quantity sent to exchange     uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange     ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset     ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset     uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance }  /* ============ Events ============ */  event LeverageIncreased(     ISetToken indexed _setToken,     IERC20 indexed _borrowAsset,     IERC20 indexed _collateralAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalBorrowAmount,     uint256 _totalReceiveAmount,     uint256 _protocolFee );  event LeverageDecreased(     ISetToken indexed _setToken,     IERC20 indexed _collateralAsset,     IERC20 indexed _repayAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalRedeemAmount,     uint256 _totalRepayAmount,     uint256 _protocolFee );  event CollateralAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  event BorrowAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  event SetTokenStatusUpdated(     ISetToken indexed _setToken,     bool indexed _added );  event AnySetAllowedUpdated(     bool indexed _anySetAllowed );  /* ============ Constants ============ */  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the trade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Mapping of underlying to CToken. If ETH, then map WETH to cETH mapping(IERC20 =&gt; ICErc20) public underlyingToCToken;  // Wrapped Ether address IERC20 internal weth;  // Compound cEther address ICErc20 internal cEther;  // Compound Comptroller contract IComptroller internal comptroller;  // COMP token address IERC20 internal compToken;  // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public collateralCTokenEnabled;  // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public borrowCTokenEnabled;  // Mapping of enabled collateral and borrow cTokens for syncing positions mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;  // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance mapping(ISetToken =&gt; bool) public allowedSetTokens;  // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list bool public anySetAllowed;   /* ============ Constructor ============ */  /**  * Instantiate addresses. Underlying to cToken mapping is created.  *  * @param _controller               Address of controller contract  * @param _compToken                Address of COMP token  * @param _comptroller              Address of Compound Comptroller  * @param _cEther                   Address of cEther contract  * @param _weth                     Address of WETH contract  */ constructor(     IController _controller,     IERC20 _compToken,     IComptroller _comptroller,     ICErc20 _cEther,     IERC20 _weth )     public     ModuleBase(_controller) {     compToken = _compToken;     comptroller = _comptroller;     cEther = _cEther;     weth = _weth;      ICErc20[] memory cTokens = comptroller.getAllMarkets();      for(uint256 i = 0; i &lt; cTokens.length; i++) {         ICErc20 cToken = cTokens[i];         underlyingToCToken[             cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())         ] = cToken;     } }  /* ============ External Functions ============ */  /**  * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.  * Performs a DEX trade, exchanging the borrow asset for collateral asset.  *  * @param _setToken             Instance of the SetToken  * @param _borrowAsset          Address of asset being borrowed for leverage  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _borrowQuantity       Borrow quantity of asset in position units  * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function lever(     ISetToken _setToken,     IERC20 _borrowAsset,     IERC20 _collateralAsset,     uint256 _borrowQuantity,     uint256 _minReceiveQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // For levering up, send quantity is derived from borrow asset and receive quantity is derived from     // collateral asset     ActionInfo memory leverInfo = _createAndValidateActionInfo(         _setToken,         _borrowAsset,         _collateralAsset,         _borrowQuantity,         _minReceiveQuantity,         _tradeAdapterName,         true     );      _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);      uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);      _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);      _updateLeverPositions(leverInfo, _borrowAsset);      emit LeverageIncreased(         _setToken,         _borrowAsset,         _collateralAsset,         leverInfo.exchangeAdapter,         leverInfo.notionalSendQuantity,         postTradeCollateralQuantity,         protocolFee     ); }  /**  * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled  *  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _repayAsset           Address of asset being repaid  * @param _redeemQuantity       Quantity of collateral asset to delever  * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function delever(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantity,     uint256 _minRepayQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from     // repay asset     ActionInfo memory deleverInfo = _createAndValidateActionInfo(         _setToken,         _collateralAsset,         _repayAsset,         _redeemQuantity,         _minRepayQuantity,         _tradeAdapterName,         false     );      _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);      uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);      _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);      _updateLeverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         repayQuantity,         protocolFee     ); }  /**  * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received  * borrow asset is updated as equity. No protocol fee is charged.  *  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)  * @param _redeemQuantity       Quantity of collateral asset to delever  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function deleverToZeroBorrowBalance(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());      require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");     uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));      ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(         _setToken,         _collateralAsset,         _repayAsset,         notionalRedeemQuantity,         notionalRepayQuantity,         _tradeAdapterName,         false     );      _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);      _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly     _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);      // Update default position first to save gas on editing borrow position     _setToken.calculateAndEditDefaultPosition(         address(_repayAsset),         deleverInfo.setTotalSupply,         deleverInfo.preTradeReceiveTokenBalance     );      _updateLeverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         notionalRepayQuantity,         0 // No protocol fee     ); }  /**  * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral  * assets, update cToken default position. For borrow assets, update external borrow position.  * - Collateral assets may come out of sync when a position is liquidated  * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid  *  * @param _setToken               Instance of the SetToken  * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value  */ function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {     uint256 setTotalSupply = _setToken.totalSupply();      // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption     if (setTotalSupply &gt; 0) {         // Loop through collateral assets         address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;         for(uint256 i = 0; i &lt; collateralCTokens.length; i++) {             ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);             uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();             uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (previousPositionUnit != newPositionUnit) {               _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);             }         }          // Loop through borrow assets         address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;         address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;         for(uint256 i = 0; i &lt; borrowCTokens.length; i++) {             ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);             IERC20 borrowAsset = IERC20(borrowAssets[i]);              int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));              int256 newPositionUnit = _getBorrowPosition(                 _setToken,                 borrowCToken,                 setTotalSupply,                 _shouldAccrueInterest             );              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (newPositionUnit != previousPositionUnit) {                 _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);             }         }     } }   /**  * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable  * collateral and borrow assets that don't exist as positions on the SetToken  *  * @param _setToken             Instance of the SetToken to initialize  * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken  * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken  */ function initialize(     ISetToken _setToken,     IERC20[] memory _collateralAssets,     IERC20[] memory _borrowAssets )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     if (!anySetAllowed) {         require(allowedSetTokens[_setToken], "Not allowed SetToken");     }      // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}     }      // Enable collateral and borrow assets on Compound     addCollateralAssets(_setToken, _collateralAssets);      addBorrowAssets(_setToken, _borrowAssets); }  /**  * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled  * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)  */ function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Sync Compound and SetToken positions prior to any removal action     sync(setToken, true);      address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;     for (uint256 i = 0; i &lt; borrowCTokens.length; i++) {         ICErc20 cToken = ICErc20(borrowCTokens[i]);          // Will exit only if token isn't also being used as collateral         if(!collateralCTokenEnabled[setToken][cToken]) {             // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound             setToken.invokeExitMarket(cToken, comptroller);         }          delete borrowCTokenEnabled[setToken][cToken];     }      address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;     for (uint256 i = 0; i &lt; collateralCTokens.length; i++) {         ICErc20 cToken = ICErc20(collateralCTokens[i]);          setToken.invokeExitMarket(cToken, comptroller);          delete collateralCTokenEnabled[setToken][cToken];     }      delete enabledAssets[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken  * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state  * inconsistencies  *  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets  *  * @param _setToken             Instance of the SetToken  * @param _newCollateralAssets  Addresses of new collateral underlying assets  */ function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {     for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];         require(address(cToken) != address(0), "cToken must exist");         require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");          // Note: Will only enter market if cToken is not enabled as a borrow asset as well         if (!borrowCTokenEnabled[_setToken][cToken]) {             _setToken.invokeEnterMarkets(cToken, comptroller);         }          collateralCTokenEnabled[_setToken][cToken] = true;         enabledAssets[_setToken].collateralCTokens.push(address(cToken));     }      emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets); }  /**  * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets  * If there is a borrow balance, collateral asset cannot be removed  *  * @param _setToken             Instance of the SetToken  * @param _collateralAssets     Addresses of collateral underlying assets to remove  */ function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {     // Sync Compound and SetToken positions prior to any removal action     sync(_setToken, true);      for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];         require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");          // Note: Will only exit market if cToken is not enabled as a borrow asset as well         // If there is an existing borrow balance, will revert and market cannot be exited on Compound         if (!borrowCTokenEnabled[_setToken][cToken]) {             _setToken.invokeExitMarket(cToken, comptroller);         }          delete collateralCTokenEnabled[_setToken][cToken];         enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));     }      emit CollateralAssetsUpdated(_setToken, false, _collateralAssets); }  /**  * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets  *  * @param _setToken             Instance of the SetToken  * @param _newBorrowAssets      Addresses of borrow underlying assets to add  */ function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {     for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {         IERC20 newBorrowAsset = _newBorrowAssets[i];         ICErc20 cToken = underlyingToCToken[newBorrowAsset];         require(address(cToken) != address(0), "cToken must exist");         require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");          // Note: Will only enter market if cToken is not enabled as a borrow asset as well         if (!collateralCTokenEnabled[_setToken][cToken]) {             _setToken.invokeEnterMarkets(cToken, comptroller);         }          borrowCTokenEnabled[_setToken][cToken] = true;         enabledAssets[_setToken].borrowCTokens.push(address(cToken));         enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));     }      emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets); }  /**  * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets  * If there is a borrow balance, borrow asset cannot be removed  *  * @param _setToken             Instance of the SetToken  * @param _borrowAssets         Addresses of borrow underlying assets to remove  */ function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {     // Sync Compound and SetToken positions prior to any removal action     sync(_setToken, true);      for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];         require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");          // Note: Will only exit market if cToken is not enabled as a collateral asset as well         // If there is an existing borrow balance, will revert and market cannot be exited on Compound         if (!collateralCTokenEnabled[_setToken][cToken]) {             _setToken.invokeExitMarket(cToken, comptroller);         }          delete borrowCTokenEnabled[_setToken][cToken];         enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));         enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));     }      emit BorrowAssetsUpdated(_setToken, false, _borrowAssets); }  /**  * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.  *  * @param _setToken             Instance of the SetToken  */ function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {     allowedSetTokens[_setToken] = _status;     emit SetTokenStatusUpdated(_setToken, _status); }  /**  * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.  *  * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled  */ function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {     anySetAllowed = _anySetAllowed;     emit AnySetAllowedUpdated(_anySetAllowed); }  /**  * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.  *  * IMPORTANT: Validations are skipped in order to get contract under bytecode limit  *  * @param _cToken                   Address of cToken to add  * @param _underlying               Address of underlying token that maps to cToken  */ function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {     require(address(underlyingToCToken[_underlying]) == address(0), "Already added");     underlyingToCToken[_underlying] = _cToken; }  /**  * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals  *  * IMPORTANT: Validations are skipped in order to get contract under bytecode limit  *  * @param _underlying               Address of underlying token to remove  */ function removeCompoundMarket(IERC20 _underlying) external onlyOwner {     require(address(underlyingToCToken[_underlying]) != address(0), "Not added");     delete underlyingToCToken[_underlying]; }  /**  * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {     sync(_setToken, false); }  /**  * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.  * Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {     sync(_setToken, true); }  /**  * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {     int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));      require(componentDebt &lt; 0, "Component must be negative");      uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);      _borrow(_setToken, underlyingToCToken[_component], notionalDebt); }  /**  * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {     int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));      require(componentDebt &lt; 0, "Component must be negative");      uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);      _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt); }   /* ============ External Getter Functions ============ */  /**  * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an  * array of underlying that are borrow assets.  *  * @return                    Collateral cToken assets that are enabled  * @return                    Underlying borrowed assets that are enabled.  */ function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {     return (         enabledAssets[_setToken].collateralCTokens,         enabledAssets[_setToken].borrowAssets     ); }  /* ============ Internal Functions ============ */  /**  * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be  * unwrapped as it only accepts the underlying ETH.  */ function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {     if (_cToken == cEther) {         _setToken.invokeUnwrapWETH(address(weth), _mintNotional);          _setToken.invokeMintCEther(_cToken, _mintNotional);     } else {         _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);          _setToken.invokeMintCToken(_cToken, _mintNotional);     } }  /**  * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.  */ function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {     _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);      if (_cToken == cEther) {         _setToken.invokeWrapWETH(address(weth), _redeemNotional);     } }  /**  * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.  */ function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {     if (_cToken == cEther) {         _setToken.invokeUnwrapWETH(address(weth), _repayNotional);          _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);     } else {         // Approve to cToken         _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);         _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);     } }  /**  * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.  */ function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {     _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);     if (_cToken == cEther) {         _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);     } }  /**  * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken  *  * @return receiveTokenQuantity The quantity of tokens received post-trade  */ function _executeTrade(     ActionInfo memory _actionInfo,     IERC20 _sendToken,     IERC20 _receiveToken,     bytes memory _data )     internal     returns (uint256) {      ISetToken setToken = _actionInfo.setToken;      uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;       setToken.invokeApprove(         address(_sendToken),         _actionInfo.exchangeAdapter.getSpender(),         notionalSendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _actionInfo.exchangeAdapter.getTradeCalldata(         address(_sendToken),         address(_receiveToken),         address(setToken),         notionalSendQuantity,         _actionInfo.minNotionalReceiveQuantity,         _data     );      setToken.invoke(targetExchange, callValue, methodData);      uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);     require(         receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,         "Slippage too high"     );      return receiveTokenQuantity; }  /**  * Calculates protocol fee on module and pays protocol fee from SetToken  */ function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {     uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);      payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);      return protocolFeeTotal; }  /**  * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)  */ function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {     _updateCollateralPosition(         actionInfo.setToken,         actionInfo.collateralCTokenAsset,         _getCollateralPosition(             actionInfo.setToken,             actionInfo.collateralCTokenAsset,             actionInfo.setTotalSupply         )     );      _updateBorrowPosition(         actionInfo.setToken,         _borrowAsset,         _getBorrowPosition(             actionInfo.setToken,             actionInfo.borrowCTokenAsset,             actionInfo.setTotalSupply,             false // Do not accrue interest         )     ); }  function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {     _setToken.editDefaultPosition(address(_cToken), _newPositionUnit); }  function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {     _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, ""); }  /**  * Construct the ActionInfo struct for lever and delever  */ function _createAndValidateActionInfo(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _sendQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();      return _createAndValidateActionInfoNotional(         _setToken,         _sendToken,         _receiveToken,         _sendQuantityUnits.preciseMul(totalSupply),         _minReceiveQuantityUnits.preciseMul(totalSupply),         _tradeAdapterName,         _isLever     ); }  /**  * Construct the ActionInfo struct for lever and delever accepting notional units  */ function _createAndValidateActionInfoNotional(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _notionalSendQuantity,     uint256 _minNotionalReceiveQuantity,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();     ActionInfo memory actionInfo = ActionInfo ({         exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),         setToken: _setToken,         collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],         borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],         setTotalSupply: totalSupply,         notionalSendQuantity: _notionalSendQuantity,         minNotionalReceiveQuantity: _minNotionalReceiveQuantity,         preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))     });      _validateCommon(actionInfo);      return actionInfo; }    function _validateCommon(ActionInfo memory _actionInfo) internal view {     require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");     require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");     require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");     require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0"); }  function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {     uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));     return collateralNotionalBalance.preciseDiv(_setTotalSupply); }  /**  * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.  * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.  */ function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {     uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));     // Round negative away from 0     int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);      return borrowPositionUnit; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 02:00:09 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { Compound } from "../../integration/lib/Compound.sol";
import { ICErc20 } from "../../../interfaces/external/ICErc20.sol";
import { IComptroller } from "../../../interfaces/external/IComptroller.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title CompoundLeverageModule
 * @author Set Protocol
 *
 * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call
 * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each
 * asset is leveraged when using this module.
 *
 * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 *
 */
contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {
    using Compound for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken
        address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken
        address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset
        ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    /* ============ Events ============ */

    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the trade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping of underlying to CToken. If ETH, then map WETH to cETH
    mapping(IERC20 => ICErc20) public underlyingToCToken;

    // Wrapped Ether address
    IERC20 internal weth;

    // Compound cEther address
    ICErc20 internal cEther;

    // Compound Comptroller contract
    IComptroller internal comptroller;

    // COMP token address
    IERC20 internal compToken;

    // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public collateralCTokenEnabled;

    // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public borrowCTokenEnabled;

    // Mapping of enabled collateral and borrow cTokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list
    bool public anySetAllowed;


    /* ============ Constructor ============ */

    /**
     * Instantiate addresses. Underlying to cToken mapping is created.
     *
     * @param _controller               Address of controller contract
     * @param _compToken                Address of COMP token
     * @param _comptroller              Address of Compound Comptroller
     * @param _cEther                   Address of cEther contract
     * @param _weth                     Address of WETH contract
     */
    constructor(
        IController _controller,
        IERC20 _compToken,
        IComptroller _comptroller,
        ICErc20 _cEther,
        IERC20 _weth
    )
        public
        ModuleBase(_controller)
    {
        compToken = _compToken;
        comptroller = _comptroller;
        cEther = _cEther;
        weth = _weth;

        ICErc20[] memory cTokens = comptroller.getAllMarkets();

        for(uint256 i = 0; i < cTokens.length; i++) {
            ICErc20 cToken = cTokens[i];
            underlyingToCToken[
                cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())
            ] = cToken;
        }
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.
     * Performs a DEX trade, exchanging the borrow asset for collateral asset.
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAsset          Address of asset being borrowed for leverage
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _borrowQuantity       Borrow quantity of asset in position units
     * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantity,
        uint256 _minReceiveQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantity,
            _minReceiveQuantity,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        uint256 _minRepayQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantity,
            _minRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received
     * borrow asset is updated as equity. No protocol fee is charged.
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());

        require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly
        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);

        // Update default position first to save gas on editing borrow position
        _setToken.calculateAndEditDefaultPosition(
            address(_repayAsset),
            deleverInfo.setTotalSupply,
            deleverInfo.preTradeReceiveTokenBalance
        );

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0 // No protocol fee
        );
    }

    /**
     * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral
     * assets, update cToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     *
     * @param _setToken               Instance of the SetToken
     * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value
     */
    function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption
        if (setTotalSupply > 0) {
            // Loop through collateral assets
            address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;
            for(uint256 i = 0; i < collateralCTokens.length; i++) {
                ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);
                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);
                }
            }

            // Loop through borrow assets
            address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;
            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowCTokens.length; i++) {
                ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));

                int256 newPositionUnit = _getBorrowPosition(
                    _setToken,
                    borrowCToken,
                    setTotalSupply,
                    _shouldAccrueInterest
                );

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }


    /**
     * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable
     * collateral and borrow assets that don't exist as positions on the SetToken
     *
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // Enable collateral and borrow assets on Compound
        addCollateralAssets(_setToken, _collateralAssets);

        addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled
     * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Compound and SetToken positions prior to any removal action
        sync(setToken, true);

        address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;
        for (uint256 i = 0; i < borrowCTokens.length; i++) {
            ICErc20 cToken = ICErc20(borrowCTokens[i]);

            // Will exit only if token isn't also being used as collateral
            if(!collateralCTokenEnabled[setToken][cToken]) {
                // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound
                setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[setToken][cToken];
        }

        address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;
        for (uint256 i = 0; i < collateralCTokens.length; i++) {
            ICErc20 cToken = ICErc20(collateralCTokens[i]);

            setToken.invokeExitMarket(cToken, comptroller);

            delete collateralCTokenEnabled[setToken][cToken];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken
     * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];
            require(address(cToken) != address(0), "cToken must exist");
            require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            collateralCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].collateralCTokens.push(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets
     * If there is a borrow balance, collateral asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];
            require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");

            // Note: Will only exit market if cToken is not enabled as a borrow asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete collateralCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 newBorrowAsset = _newBorrowAssets[i];
            ICErc20 cToken = underlyingToCToken[newBorrowAsset];
            require(address(cToken) != address(0), "cToken must exist");
            require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            borrowCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].borrowCTokens.push(address(cToken));
            enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));
        }

        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets
     * If there is a borrow balance, borrow asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];
            require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");

            // Note: Will only exit market if cToken is not enabled as a collateral asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));
            enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));
        }

        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.
     *
     * @param _setToken             Instance of the SetToken
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.
     *
     * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _cToken                   Address of cToken to add
     * @param _underlying               Address of underlying token that maps to cToken
     */
    function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) == address(0), "Already added");
        underlyingToCToken[_underlying] = _cToken;
    }

    /**
     * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _underlying               Address of underlying token to remove
     */
    function removeCompoundMarket(IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) != address(0), "Not added");
        delete underlyingToCToken[_underlying];
    }

    /**
     * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, false);
    }

    /**
     * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.
     * Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, true);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);

        _borrow(_setToken, underlyingToCToken[_component], notionalDebt);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);

        _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt);
    }


    /* ============ External Getter Functions ============ */

    /**
     * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an
     * array of underlying that are borrow assets.
     *
     * @return                    Collateral cToken assets that are enabled
     * @return                    Underlying borrowed assets that are enabled.
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralCTokens,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be
     * unwrapped as it only accepts the underlying ETH.
     */
    function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _mintNotional);

            _setToken.invokeMintCEther(_cToken, _mintNotional);
        } else {
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);

            _setToken.invokeMintCToken(_cToken, _mintNotional);
        }
    }

    /**
     * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.
     */
    function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {
        _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);

        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _redeemNotional);
        }
    }

    /**
     * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.
     */
    function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _repayNotional);

            _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);
        } else {
            // Approve to cToken
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);
            _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);
        }
    }

    /**
     * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.
     */
    function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {
        _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);
        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);
        }
    }

    /**
     * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     *
     * @return receiveTokenQuantity The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
         ISetToken setToken = _actionInfo.setToken;
         uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

         setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * Calculates protocol fee on module and pays protocol fee from SetToken
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)
     */
    function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {
        _updateCollateralPosition(
            actionInfo.setToken,
            actionInfo.collateralCTokenAsset,
            _getCollateralPosition(
                actionInfo.setToken,
                actionInfo.collateralCTokenAsset,
                actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                actionInfo.setToken,
                actionInfo.borrowCTokenAsset,
                actionInfo.setTotalSupply,
                false // Do not accrue interest
            )
        );
    }

    function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_cToken), _newPositionUnit);
    }

    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, "");
    }

    /**
     * Construct the ActionInfo struct for lever and delever
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever
        );
    }

    /**
     * Construct the ActionInfo struct for lever and delever accepting notional units
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            setToken: _setToken,
            collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],
            borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],
            setTotalSupply: totalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }



    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");
        require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");
        require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.
     * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.
     */
    function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {
        uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));
        // Round negative away from 0
        int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);

        return borrowPositionUnit;
    }
}.]

Given the user's task and the brainstorming ideas provided:
Task: "/*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { Compound } from "../../integration/lib/Compound.sol";
import { ICErc20 } from "../../../interfaces/external/ICErc20.sol";
import { IComptroller } from "../../../interfaces/external/IComptroller.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title CompoundLeverageModule
 * @author Set Protocol
 *
 * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call
 * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each
 * asset is leveraged when using this module.
 *
 * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 *
 */
contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {
    using Compound for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken
        address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken
        address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset
        ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    /* ============ Events ============ */

    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the trade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping of underlying to CToken. If ETH, then map WETH to cETH
    mapping(IERC20 => ICErc20) public underlyingToCToken;

    // Wrapped Ether address
    IERC20 internal weth;

    // Compound cEther address
    ICErc20 internal cEther;

    // Compound Comptroller contract
    IComptroller internal comptroller;

    // COMP token address
    IERC20 internal compToken;

    // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public collateralCTokenEnabled;

    // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public borrowCTokenEnabled;

    // Mapping of enabled collateral and borrow cTokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list
    bool public anySetAllowed;


    /* ============ Constructor ============ */

    /**
     * Instantiate addresses. Underlying to cToken mapping is created.
     *
     * @param _controller               Address of controller contract
     * @param _compToken                Address of COMP token
     * @param _comptroller              Address of Compound Comptroller
     * @param _cEther                   Address of cEther contract
     * @param _weth                     Address of WETH contract
     */
    constructor(
        IController _controller,
        IERC20 _compToken,
        IComptroller _comptroller,
        ICErc20 _cEther,
        IERC20 _weth
    )
        public
        ModuleBase(_controller)
    {
        compToken = _compToken;
        comptroller = _comptroller;
        cEther = _cEther;
        weth = _weth;

        ICErc20[] memory cTokens = comptroller.getAllMarkets();

        for(uint256 i = 0; i < cTokens.length; i++) {
            ICErc20 cToken = cTokens[i];
            underlyingToCToken[
                cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())
            ] = cToken;
        }
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.
     * Performs a DEX trade, exchanging the borrow asset for collateral asset.
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAsset          Address of asset being borrowed for leverage
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _borrowQuantity       Borrow quantity of asset in position units
     * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantity,
        uint256 _minReceiveQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantity,
            _minReceiveQuantity,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        uint256 _minRepayQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantity,
            _minRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received
     * borrow asset is updated as equity. No protocol fee is charged.
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());

        require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly
        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);

        // Update default position first to save gas on editing borrow position
        _setToken.calculateAndEditDefaultPosition(
            address(_repayAsset),
            deleverInfo.setTotalSupply,
            deleverInfo.preTradeReceiveTokenBalance
        );

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0 // No protocol fee
        );
    }

    /**
     * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral
     * assets, update cToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     *
     * @param _setToken               Instance of the SetToken
     * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value
     */
    function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption
        if (setTotalSupply > 0) {
            // Loop through collateral assets
            address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;
            for(uint256 i = 0; i < collateralCTokens.length; i++) {
                ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);
                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);
                }
            }

            // Loop through borrow assets
            address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;
            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowCTokens.length; i++) {
                ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));

                int256 newPositionUnit = _getBorrowPosition(
                    _setToken,
                    borrowCToken,
                    setTotalSupply,
                    _shouldAccrueInterest
                );

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }


    /**
     * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable
     * collateral and borrow assets that don't exist as positions on the SetToken
     *
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // Enable collateral and borrow assets on Compound
        addCollateralAssets(_setToken, _collateralAssets);

        addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled
     * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Compound and SetToken positions prior to any removal action
        sync(setToken, true);

        address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;
        for (uint256 i = 0; i < borrowCTokens.length; i++) {
            ICErc20 cToken = ICErc20(borrowCTokens[i]);

            // Will exit only if token isn't also being used as collateral
            if(!collateralCTokenEnabled[setToken][cToken]) {
                // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound
                setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[setToken][cToken];
        }

        address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;
        for (uint256 i = 0; i < collateralCTokens.length; i++) {
            ICErc20 cToken = ICErc20(collateralCTokens[i]);

            setToken.invokeExitMarket(cToken, comptroller);

            delete collateralCTokenEnabled[setToken][cToken];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken
     * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];
            require(address(cToken) != address(0), "cToken must exist");
            require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            collateralCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].collateralCTokens.push(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets
     * If there is a borrow balance, collateral asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];
            require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");

            // Note: Will only exit market if cToken is not enabled as a borrow asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete collateralCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 newBorrowAsset = _newBorrowAssets[i];
            ICErc20 cToken = underlyingToCToken[newBorrowAsset];
            require(address(cToken) != address(0), "cToken must exist");
            require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            borrowCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].borrowCTokens.push(address(cToken));
            enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));
        }

        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets
     * If there is a borrow balance, borrow asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];
            require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");

            // Note: Will only exit market if cToken is not enabled as a collateral asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));
            enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));
        }

        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.
     *
     * @param _setToken             Instance of the SetToken
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.
     *
     * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _cToken                   Address of cToken to add
     * @param _underlying               Address of underlying token that maps to cToken
     */
    function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) == address(0), "Already added");
        underlyingToCToken[_underlying] = _cToken;
    }

    /**
     * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _underlying               Address of underlying token to remove
     */
    function removeCompoundMarket(IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) != address(0), "Not added");
        delete underlyingToCToken[_underlying];
    }

    /**
     * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, false);
    }

    /**
     * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.
     * Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, true);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);

        _borrow(_setToken, underlyingToCToken[_component], notionalDebt);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);

        _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt);
    }


    /* ============ External Getter Functions ============ */

    /**
     * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an
     * array of underlying that are borrow assets.
     *
     * @return                    Collateral cToken assets that are enabled
     * @return                    Underlying borrowed assets that are enabled.
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralCTokens,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be
     * unwrapped as it only accepts the underlying ETH.
     */
    function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _mintNotional);

            _setToken.invokeMintCEther(_cToken, _mintNotional);
        } else {
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);

            _setToken.invokeMintCToken(_cToken, _mintNotional);
        }
    }

    /**
     * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.
     */
    function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {
        _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);

        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _redeemNotional);
        }
    }

    /**
     * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.
     */
    function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _repayNotional);

            _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);
        } else {
            // Approve to cToken
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);
            _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);
        }
    }

    /**
     * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.
     */
    function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {
        _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);
        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);
        }
    }

    /**
     * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     *
     * @return receiveTokenQuantity The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
         ISetToken setToken = _actionInfo.setToken;
         uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

         setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * Calculates protocol fee on module and pays protocol fee from SetToken
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)
     */
    function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {
        _updateCollateralPosition(
            actionInfo.setToken,
            actionInfo.collateralCTokenAsset,
            _getCollateralPosition(
                actionInfo.setToken,
                actionInfo.collateralCTokenAsset,
                actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                actionInfo.setToken,
                actionInfo.borrowCTokenAsset,
                actionInfo.setTotalSupply,
                false // Do not accrue interest
            )
        );
    }

    function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_cToken), _newPositionUnit);
    }

    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, "");
    }

    /**
     * Construct the ActionInfo struct for lever and delever
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever
        );
    }

    /**
     * Construct the ActionInfo struct for lever and delever accepting notional units
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            setToken: _setToken,
            collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],
            borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],
            setTotalSupply: totalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }



    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");
        require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");
        require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.
     * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.
     */
    function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {
        uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));
        // Round negative away from 0
        int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);

        return borrowPositionUnit;
    }
}".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-01-09 02:00:11 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 02:00:11 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 18401
completion_tokens: 1
total_tokens: 18402
cost: $-1.000000


[2024-01-09 02:00:11 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { Compound } from "../../integration/lib/Compound.sol";
import { ICErc20 } from "../../../interfaces/external/ICErc20.sol";
import { IComptroller } from "../../../interfaces/external/IComptroller.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title CompoundLeverageModule
 * @author Set Protocol
 *
 * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call
 * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each
 * asset is leveraged when using this module.
 *
 * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 *
 */
contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {
    using Compound for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken
        address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken
        address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset
        ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    /* ============ Events ============ */

    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the trade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping of underlying to CToken. If ETH, then map WETH to cETH
    mapping(IERC20 => ICErc20) public underlyingToCToken;

    // Wrapped Ether address
    IERC20 internal weth;

    // Compound cEther address
    ICErc20 internal cEther;

    // Compound Comptroller contract
    IComptroller internal comptroller;

    // COMP token address
    IERC20 internal compToken;

    // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public collateralCTokenEnabled;

    // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public borrowCTokenEnabled;

    // Mapping of enabled collateral and borrow cTokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list
    bool public anySetAllowed;


    /* ============ Constructor ============ */

    /**
     * Instantiate addresses. Underlying to cToken mapping is created.
     *
     * @param _controller               Address of controller contract
     * @param _compToken                Address of COMP token
     * @param _comptroller              Address of Compound Comptroller
     * @param _cEther                   Address of cEther contract
     * @param _weth                     Address of WETH contract
     */
    constructor(
        IController _controller,
        IERC20 _compToken,
        IComptroller _comptroller,
        ICErc20 _cEther,
        IERC20 _weth
    )
        public
        ModuleBase(_controller)
    {
        compToken = _compToken;
        comptroller = _comptroller;
        cEther = _cEther;
        weth = _weth;

        ICErc20[] memory cTokens = comptroller.getAllMarkets();

        for(uint256 i = 0; i < cTokens.length; i++) {
            ICErc20 cToken = cTokens[i];
            underlyingToCToken[
                cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())
            ] = cToken;
        }
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.
     * Performs a DEX trade, exchanging the borrow asset for collateral asset.
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAsset          Address of asset being borrowed for leverage
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _borrowQuantity       Borrow quantity of asset in position units
     * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantity,
        uint256 _minReceiveQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantity,
            _minReceiveQuantity,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        uint256 _minRepayQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantity,
            _minRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received
     * borrow asset is updated as equity. No protocol fee is charged.
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());

        require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly
        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);

        // Update default position first to save gas on editing borrow position
        _setToken.calculateAndEditDefaultPosition(
            address(_repayAsset),
            deleverInfo.setTotalSupply,
            deleverInfo.preTradeReceiveTokenBalance
        );

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0 // No protocol fee
        );
    }

    /**
     * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral
     * assets, update cToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     *
     * @param _setToken               Instance of the SetToken
     * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value
     */
    function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption
        if (setTotalSupply > 0) {
            // Loop through collateral assets
            address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;
            for(uint256 i = 0; i < collateralCTokens.length; i++) {
                ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);
                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);
                }
            }

            // Loop through borrow assets
            address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;
            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowCTokens.length; i++) {
                ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));

                int256 newPositionUnit = _getBorrowPosition(
                    _setToken,
                    borrowCToken,
                    setTotalSupply,
                    _shouldAccrueInterest
                );

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }


    /**
     * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable
     * collateral and borrow assets that don't exist as positions on the SetToken
     *
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // Enable collateral and borrow assets on Compound
        addCollateralAssets(_setToken, _collateralAssets);

        addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled
     * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Compound and SetToken positions prior to any removal action
        sync(setToken, true);

        address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;
        for (uint256 i = 0; i < borrowCTokens.length; i++) {
            ICErc20 cToken = ICErc20(borrowCTokens[i]);

            // Will exit only if token isn't also being used as collateral
            if(!collateralCTokenEnabled[setToken][cToken]) {
                // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound
                setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[setToken][cToken];
        }

        address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;
        for (uint256 i = 0; i < collateralCTokens.length; i++) {
            ICErc20 cToken = ICErc20(collateralCTokens[i]);

            setToken.invokeExitMarket(cToken, comptroller);

            delete collateralCTokenEnabled[setToken][cToken];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken
     * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];
            require(address(cToken) != address(0), "cToken must exist");
            require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            collateralCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].collateralCTokens.push(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets
     * If there is a borrow balance, collateral asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];
            require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");

            // Note: Will only exit market if cToken is not enabled as a borrow asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete collateralCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 newBorrowAsset = _newBorrowAssets[i];
            ICErc20 cToken = underlyingToCToken[newBorrowAsset];
            require(address(cToken) != address(0), "cToken must exist");
            require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            borrowCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].borrowCTokens.push(address(cToken));
            enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));
        }

        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets
     * If there is a borrow balance, borrow asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];
            require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");

            // Note: Will only exit market if cToken is not enabled as a collateral asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));
            enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));
        }

        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.
     *
     * @param _setToken             Instance of the SetToken
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.
     *
     * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _cToken                   Address of cToken to add
     * @param _underlying               Address of underlying token that maps to cToken
     */
    function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) == address(0), "Already added");
        underlyingToCToken[_underlying] = _cToken;
    }

    /**
     * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _underlying               Address of underlying token to remove
     */
    function removeCompoundMarket(IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) != address(0), "Not added");
        delete underlyingToCToken[_underlying];
    }

    /**
     * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, false);
    }

    /**
     * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.
     * Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, true);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);

        _borrow(_setToken, underlyingToCToken[_component], notionalDebt);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);

        _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt);
    }


    /* ============ External Getter Functions ============ */

    /**
     * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an
     * array of underlying that are borrow assets.
     *
     * @return                    Collateral cToken assets that are enabled
     * @return                    Underlying borrowed assets that are enabled.
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralCTokens,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be
     * unwrapped as it only accepts the underlying ETH.
     */
    function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _mintNotional);

            _setToken.invokeMintCEther(_cToken, _mintNotional);
        } else {
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);

            _setToken.invokeMintCToken(_cToken, _mintNotional);
        }
    }

    /**
     * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.
     */
    function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {
        _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);

        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _redeemNotional);
        }
    }

    /**
     * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.
     */
    function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _repayNotional);

            _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);
        } else {
            // Approve to cToken
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);
            _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);
        }
    }

    /**
     * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.
     */
    function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {
        _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);
        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);
        }
    }

    /**
     * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     *
     * @return receiveTokenQuantity The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
         ISetToken setToken = _actionInfo.setToken;
         uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

         setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * Calculates protocol fee on module and pays protocol fee from SetToken
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)
     */
    function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {
        _updateCollateralPosition(
            actionInfo.setToken,
            actionInfo.collateralCTokenAsset,
            _getCollateralPosition(
                actionInfo.setToken,
                actionInfo.collateralCTokenAsset,
                actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                actionInfo.setToken,
                actionInfo.borrowCTokenAsset,
                actionInfo.setTotalSupply,
                false // Do not accrue interest
            )
        );
    }

    function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_cToken), _newPositionUnit);
    }

    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, "");
    }

    /**
     * Construct the ActionInfo struct for lever and delever
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever
        );
    }

    /**
     * Construct the ActionInfo struct for lever and delever accepting notional units
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            setToken: _setToken,
            collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],
            borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],
            setTotalSupply: totalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }



    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");
        require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");
        require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.
     * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.
     */
    function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {
        uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));
        // Round negative away from 0
        int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);

        return borrowPositionUnit;
    }
}.]

###

[2024-01-09 02:00:11 INFO] **[Seminar Conclusion]**:

 ###

[2024-01-09 02:00:11 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-01-09 02:00:11 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { Compound } from "../../integration/lib/Compound.sol"; import { ICErc20 } from "../../../interfaces/external/ICErc20.sol"; import { IComptroller } from "../../../interfaces/external/IComptroller.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol"; import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; /*  * @title CompoundLeverageModule  * @author Set Protocol  *  * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call  * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each  * asset is leveraged when using this module.  *  * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of  * debt when borrowed assets are the same.  *  / contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {     using Compound for ISetToken; /* ============ Structs ============ */  struct EnabledAssets {     address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken     address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken     address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets }  struct ActionInfo {     ISetToken setToken;                      // SetToken instance     IExchangeAdapter exchangeAdapter;        // Exchange adapter instance     uint256 setTotalSupply;                  // Total supply of SetToken     uint256 notionalSendQuantity;            // Total notional quantity sent to exchange     uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange     ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset     ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset     uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance }  /* ============ Events ============ */  event LeverageIncreased(     ISetToken indexed _setToken,     IERC20 indexed _borrowAsset,     IERC20 indexed _collateralAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalBorrowAmount,     uint256 _totalReceiveAmount,     uint256 _protocolFee );  event LeverageDecreased(     ISetToken indexed _setToken,     IERC20 indexed _collateralAsset,     IERC20 indexed _repayAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalRedeemAmount,     uint256 _totalRepayAmount,     uint256 _protocolFee );  event CollateralAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  event BorrowAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  event SetTokenStatusUpdated(     ISetToken indexed _setToken,     bool indexed _added );  event AnySetAllowedUpdated(     bool indexed _anySetAllowed );  /* ============ Constants ============ */  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the trade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Mapping of underlying to CToken. If ETH, then map WETH to cETH mapping(IERC20 =&gt; ICErc20) public underlyingToCToken;  // Wrapped Ether address IERC20 internal weth;  // Compound cEther address ICErc20 internal cEther;  // Compound Comptroller contract IComptroller internal comptroller;  // COMP token address IERC20 internal compToken;  // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public collateralCTokenEnabled;  // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public borrowCTokenEnabled;  // Mapping of enabled collateral and borrow cTokens for syncing positions mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;  // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance mapping(ISetToken =&gt; bool) public allowedSetTokens;  // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list bool public anySetAllowed;   /* ============ Constructor ============ */  /**  * Instantiate addresses. Underlying to cToken mapping is created.  *  * @param _controller               Address of controller contract  * @param _compToken                Address of COMP token  * @param _comptroller              Address of Compound Comptroller  * @param _cEther                   Address of cEther contract  * @param _weth                     Address of WETH contract  */ constructor(     IController _controller,     IERC20 _compToken,     IComptroller _comptroller,     ICErc20 _cEther,     IERC20 _weth )     public     ModuleBase(_controller) {     compToken = _compToken;     comptroller = _comptroller;     cEther = _cEther;     weth = _weth;      ICErc20[] memory cTokens = comptroller.getAllMarkets();      for(uint256 i = 0; i &lt; cTokens.length; i++) {         ICErc20 cToken = cTokens[i];         underlyingToCToken[             cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())         ] = cToken;     } }  /* ============ External Functions ============ */  /**  * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.  * Performs a DEX trade, exchanging the borrow asset for collateral asset.  *  * @param _setToken             Instance of the SetToken  * @param _borrowAsset          Address of asset being borrowed for leverage  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _borrowQuantity       Borrow quantity of asset in position units  * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function lever(     ISetToken _setToken,     IERC20 _borrowAsset,     IERC20 _collateralAsset,     uint256 _borrowQuantity,     uint256 _minReceiveQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // For levering up, send quantity is derived from borrow asset and receive quantity is derived from     // collateral asset     ActionInfo memory leverInfo = _createAndValidateActionInfo(         _setToken,         _borrowAsset,         _collateralAsset,         _borrowQuantity,         _minReceiveQuantity,         _tradeAdapterName,         true     );      _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);      uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);      _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);      _updateLeverPositions(leverInfo, _borrowAsset);      emit LeverageIncreased(         _setToken,         _borrowAsset,         _collateralAsset,         leverInfo.exchangeAdapter,         leverInfo.notionalSendQuantity,         postTradeCollateralQuantity,         protocolFee     ); }  /**  * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled  *  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _repayAsset           Address of asset being repaid  * @param _redeemQuantity       Quantity of collateral asset to delever  * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function delever(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantity,     uint256 _minRepayQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from     // repay asset     ActionInfo memory deleverInfo = _createAndValidateActionInfo(         _setToken,         _collateralAsset,         _repayAsset,         _redeemQuantity,         _minRepayQuantity,         _tradeAdapterName,         false     );      _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);      uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);      _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);      _updateLeverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         repayQuantity,         protocolFee     ); }  /**  * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received  * borrow asset is updated as equity. No protocol fee is charged.  *  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)  * @param _redeemQuantity       Quantity of collateral asset to delever  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function deleverToZeroBorrowBalance(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());      require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");     uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));      ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(         _setToken,         _collateralAsset,         _repayAsset,         notionalRedeemQuantity,         notionalRepayQuantity,         _tradeAdapterName,         false     );      _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);      _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly     _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);      // Update default position first to save gas on editing borrow position     _setToken.calculateAndEditDefaultPosition(         address(_repayAsset),         deleverInfo.setTotalSupply,         deleverInfo.preTradeReceiveTokenBalance     );      _updateLeverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         notionalRepayQuantity,         0 // No protocol fee     ); }  /**  * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral  * assets, update cToken default position. For borrow assets, update external borrow position.  * - Collateral assets may come out of sync when a position is liquidated  * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid  *  * @param _setToken               Instance of the SetToken  * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value  */ function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {     uint256 setTotalSupply = _setToken.totalSupply();      // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption     if (setTotalSupply &gt; 0) {         // Loop through collateral assets         address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;         for(uint256 i = 0; i &lt; collateralCTokens.length; i++) {             ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);             uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();             uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (previousPositionUnit != newPositionUnit) {               _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);             }         }          // Loop through borrow assets         address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;         address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;         for(uint256 i = 0; i &lt; borrowCTokens.length; i++) {             ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);             IERC20 borrowAsset = IERC20(borrowAssets[i]);              int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));              int256 newPositionUnit = _getBorrowPosition(                 _setToken,                 borrowCToken,                 setTotalSupply,                 _shouldAccrueInterest             );              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (newPositionUnit != previousPositionUnit) {                 _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);             }         }     } }   /**  * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable  * collateral and borrow assets that don't exist as positions on the SetToken  *  * @param _setToken             Instance of the SetToken to initialize  * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken  * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken  */ function initialize(     ISetToken _setToken,     IERC20[] memory _collateralAssets,     IERC20[] memory _borrowAssets )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     if (!anySetAllowed) {         require(allowedSetTokens[_setToken], "Not allowed SetToken");     }      // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}     }      // Enable collateral and borrow assets on Compound     addCollateralAssets(_setToken, _collateralAssets);      addBorrowAssets(_setToken, _borrowAssets); }  /**  * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled  * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)  */ function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Sync Compound and SetToken positions prior to any removal action     sync(setToken, true);      address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;     for (uint256 i = 0; i &lt; borrowCTokens.length; i++) {         ICErc20 cToken = ICErc20(borrowCTokens[i]);          // Will exit only if token isn't also being used as collateral         if(!collateralCTokenEnabled[setToken][cToken]) {             // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound             setToken.invokeExitMarket(cToken, comptroller);         }          delete borrowCTokenEnabled[setToken][cToken];     }      address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;     for (uint256 i = 0; i &lt; collateralCTokens.length; i++) {         ICErc20 cToken = ICErc20(collateralCTokens[i]);          setToken.invokeExitMarket(cToken, comptroller);          delete collateralCTokenEnabled[setToken][cToken];     }      delete enabledAssets[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken  * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state  * inconsistencies  *  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets  *  * @param _setToken             Instance of the SetToken  * @param _newCollateralAssets  Addresses of new collateral underlying assets  */ function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {     for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];         require(address(cToken) != address(0), "cToken must exist");         require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");          // Note: Will only enter market if cToken is not enabled as a borrow asset as well         if (!borrowCTokenEnabled[_setToken][cToken]) {             _setToken.invokeEnterMarkets(cToken, comptroller);         }          collateralCTokenEnabled[_setToken][cToken] = true;         enabledAssets[_setToken].collateralCTokens.push(address(cToken));     }      emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets); }  /**  * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets  * If there is a borrow balance, collateral asset cannot be removed  *  * @param _setToken             Instance of the SetToken  * @param _collateralAssets     Addresses of collateral underlying assets to remove  */ function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {     // Sync Compound and SetToken positions prior to any removal action     sync(_setToken, true);      for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];         require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");          // Note: Will only exit market if cToken is not enabled as a borrow asset as well         // If there is an existing borrow balance, will revert and market cannot be exited on Compound         if (!borrowCTokenEnabled[_setToken][cToken]) {             _setToken.invokeExitMarket(cToken, comptroller);         }          delete collateralCTokenEnabled[_setToken][cToken];         enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));     }      emit CollateralAssetsUpdated(_setToken, false, _collateralAssets); }  /**  * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets  *  * @param _setToken             Instance of the SetToken  * @param _newBorrowAssets      Addresses of borrow underlying assets to add  */ function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {     for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {         IERC20 newBorrowAsset = _newBorrowAssets[i];         ICErc20 cToken = underlyingToCToken[newBorrowAsset];         require(address(cToken) != address(0), "cToken must exist");         require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");          // Note: Will only enter market if cToken is not enabled as a borrow asset as well         if (!collateralCTokenEnabled[_setToken][cToken]) {             _setToken.invokeEnterMarkets(cToken, comptroller);         }          borrowCTokenEnabled[_setToken][cToken] = true;         enabledAssets[_setToken].borrowCTokens.push(address(cToken));         enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));     }      emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets); }  /**  * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets  * If there is a borrow balance, borrow asset cannot be removed  *  * @param _setToken             Instance of the SetToken  * @param _borrowAssets         Addresses of borrow underlying assets to remove  */ function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {     // Sync Compound and SetToken positions prior to any removal action     sync(_setToken, true);      for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];         require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");          // Note: Will only exit market if cToken is not enabled as a collateral asset as well         // If there is an existing borrow balance, will revert and market cannot be exited on Compound         if (!collateralCTokenEnabled[_setToken][cToken]) {             _setToken.invokeExitMarket(cToken, comptroller);         }          delete borrowCTokenEnabled[_setToken][cToken];         enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));         enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));     }      emit BorrowAssetsUpdated(_setToken, false, _borrowAssets); }  /**  * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.  *  * @param _setToken             Instance of the SetToken  */ function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {     allowedSetTokens[_setToken] = _status;     emit SetTokenStatusUpdated(_setToken, _status); }  /**  * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.  *  * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled  */ function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {     anySetAllowed = _anySetAllowed;     emit AnySetAllowedUpdated(_anySetAllowed); }  /**  * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.  *  * IMPORTANT: Validations are skipped in order to get contract under bytecode limit  *  * @param _cToken                   Address of cToken to add  * @param _underlying               Address of underlying token that maps to cToken  */ function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {     require(address(underlyingToCToken[_underlying]) == address(0), "Already added");     underlyingToCToken[_underlying] = _cToken; }  /**  * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals  *  * IMPORTANT: Validations are skipped in order to get contract under bytecode limit  *  * @param _underlying               Address of underlying token to remove  */ function removeCompoundMarket(IERC20 _underlying) external onlyOwner {     require(address(underlyingToCToken[_underlying]) != address(0), "Not added");     delete underlyingToCToken[_underlying]; }  /**  * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {     sync(_setToken, false); }  /**  * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.  * Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {     sync(_setToken, true); }  /**  * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {     int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));      require(componentDebt &lt; 0, "Component must be negative");      uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);      _borrow(_setToken, underlyingToCToken[_component], notionalDebt); }  /**  * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {     int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));      require(componentDebt &lt; 0, "Component must be negative");      uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);      _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt); }   /* ============ External Getter Functions ============ */  /**  * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an  * array of underlying that are borrow assets.  *  * @return                    Collateral cToken assets that are enabled  * @return                    Underlying borrowed assets that are enabled.  */ function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {     return (         enabledAssets[_setToken].collateralCTokens,         enabledAssets[_setToken].borrowAssets     ); }  /* ============ Internal Functions ============ */  /**  * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be  * unwrapped as it only accepts the underlying ETH.  */ function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {     if (_cToken == cEther) {         _setToken.invokeUnwrapWETH(address(weth), _mintNotional);          _setToken.invokeMintCEther(_cToken, _mintNotional);     } else {         _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);          _setToken.invokeMintCToken(_cToken, _mintNotional);     } }  /**  * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.  */ function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {     _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);      if (_cToken == cEther) {         _setToken.invokeWrapWETH(address(weth), _redeemNotional);     } }  /**  * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.  */ function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {     if (_cToken == cEther) {         _setToken.invokeUnwrapWETH(address(weth), _repayNotional);          _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);     } else {         // Approve to cToken         _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);         _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);     } }  /**  * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.  */ function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {     _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);     if (_cToken == cEther) {         _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);     } }  /**  * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken  *  * @return receiveTokenQuantity The quantity of tokens received post-trade  */ function _executeTrade(     ActionInfo memory _actionInfo,     IERC20 _sendToken,     IERC20 _receiveToken,     bytes memory _data )     internal     returns (uint256) {      ISetToken setToken = _actionInfo.setToken;      uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;       setToken.invokeApprove(         address(_sendToken),         _actionInfo.exchangeAdapter.getSpender(),         notionalSendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _actionInfo.exchangeAdapter.getTradeCalldata(         address(_sendToken),         address(_receiveToken),         address(setToken),         notionalSendQuantity,         _actionInfo.minNotionalReceiveQuantity,         _data     );      setToken.invoke(targetExchange, callValue, methodData);      uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);     require(         receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,         "Slippage too high"     );      return receiveTokenQuantity; }  /**  * Calculates protocol fee on module and pays protocol fee from SetToken  */ function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {     uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);      payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);      return protocolFeeTotal; }  /**  * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)  */ function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {     _updateCollateralPosition(         actionInfo.setToken,         actionInfo.collateralCTokenAsset,         _getCollateralPosition(             actionInfo.setToken,             actionInfo.collateralCTokenAsset,             actionInfo.setTotalSupply         )     );      _updateBorrowPosition(         actionInfo.setToken,         _borrowAsset,         _getBorrowPosition(             actionInfo.setToken,             actionInfo.borrowCTokenAsset,             actionInfo.setTotalSupply,             false // Do not accrue interest         )     ); }  function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {     _setToken.editDefaultPosition(address(_cToken), _newPositionUnit); }  function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {     _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, ""); }  /**  * Construct the ActionInfo struct for lever and delever  */ function _createAndValidateActionInfo(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _sendQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();      return _createAndValidateActionInfoNotional(         _setToken,         _sendToken,         _receiveToken,         _sendQuantityUnits.preciseMul(totalSupply),         _minReceiveQuantityUnits.preciseMul(totalSupply),         _tradeAdapterName,         _isLever     ); }  /**  * Construct the ActionInfo struct for lever and delever accepting notional units  */ function _createAndValidateActionInfoNotional(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _notionalSendQuantity,     uint256 _minNotionalReceiveQuantity,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();     ActionInfo memory actionInfo = ActionInfo ({         exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),         setToken: _setToken,         collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],         borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],         setTotalSupply: totalSupply,         notionalSendQuantity: _notionalSendQuantity,         minNotionalReceiveQuantity: _minNotionalReceiveQuantity,         preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))     });      _validateCommon(actionInfo);      return actionInfo; }    function _validateCommon(ActionInfo memory _actionInfo) internal view {     require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");     require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");     require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");     require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0"); }  function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {     uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));     return collateralNotionalBalance.preciseDiv(_setTotalSupply); }  /**  * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.  * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.  */ function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {     uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));     // Round negative away from 0     int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);      return borrowPositionUnit; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 02:00:11 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { Compound } from "../../integration/lib/Compound.sol"; import { ICErc20 } from "../../../interfaces/external/ICErc20.sol"; import { IComptroller } from "../../../interfaces/external/IComptroller.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol"; import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; /*  * @title CompoundLeverageModule  * @author Set Protocol  *  * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call  * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each  * asset is leveraged when using this module.  *  * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of  * debt when borrowed assets are the same.  *  / contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {     using Compound for ISetToken; /* ============ Structs ============ */  struct EnabledAssets {     address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken     address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken     address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets }  struct ActionInfo {     ISetToken setToken;                      // SetToken instance     IExchangeAdapter exchangeAdapter;        // Exchange adapter instance     uint256 setTotalSupply;                  // Total supply of SetToken     uint256 notionalSendQuantity;            // Total notional quantity sent to exchange     uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange     ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset     ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset     uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance }  /* ============ Events ============ */  event LeverageIncreased(     ISetToken indexed _setToken,     IERC20 indexed _borrowAsset,     IERC20 indexed _collateralAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalBorrowAmount,     uint256 _totalReceiveAmount,     uint256 _protocolFee );  event LeverageDecreased(     ISetToken indexed _setToken,     IERC20 indexed _collateralAsset,     IERC20 indexed _repayAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalRedeemAmount,     uint256 _totalRepayAmount,     uint256 _protocolFee );  event CollateralAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  event BorrowAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  event SetTokenStatusUpdated(     ISetToken indexed _setToken,     bool indexed _added );  event AnySetAllowedUpdated(     bool indexed _anySetAllowed );  /* ============ Constants ============ */  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the trade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Mapping of underlying to CToken. If ETH, then map WETH to cETH mapping(IERC20 =&gt; ICErc20) public underlyingToCToken;  // Wrapped Ether address IERC20 internal weth;  // Compound cEther address ICErc20 internal cEther;  // Compound Comptroller contract IComptroller internal comptroller;  // COMP token address IERC20 internal compToken;  // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public collateralCTokenEnabled;  // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public borrowCTokenEnabled;  // Mapping of enabled collateral and borrow cTokens for syncing positions mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;  // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance mapping(ISetToken =&gt; bool) public allowedSetTokens;  // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list bool public anySetAllowed;   /* ============ Constructor ============ */  /**  * Instantiate addresses. Underlying to cToken mapping is created.  *  * @param _controller               Address of controller contract  * @param _compToken                Address of COMP token  * @param _comptroller              Address of Compound Comptroller  * @param _cEther                   Address of cEther contract  * @param _weth                     Address of WETH contract  */ constructor(     IController _controller,     IERC20 _compToken,     IComptroller _comptroller,     ICErc20 _cEther,     IERC20 _weth )     public     ModuleBase(_controller) {     compToken = _compToken;     comptroller = _comptroller;     cEther = _cEther;     weth = _weth;      ICErc20[] memory cTokens = comptroller.getAllMarkets();      for(uint256 i = 0; i &lt; cTokens.length; i++) {         ICErc20 cToken = cTokens[i];         underlyingToCToken[             cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())         ] = cToken;     } }  /* ============ External Functions ============ */  /**  * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.  * Performs a DEX trade, exchanging the borrow asset for collateral asset.  *  * @param _setToken             Instance of the SetToken  * @param _borrowAsset          Address of asset being borrowed for leverage  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _borrowQuantity       Borrow quantity of asset in position units  * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function lever(     ISetToken _setToken,     IERC20 _borrowAsset,     IERC20 _collateralAsset,     uint256 _borrowQuantity,     uint256 _minReceiveQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // For levering up, send quantity is derived from borrow asset and receive quantity is derived from     // collateral asset     ActionInfo memory leverInfo = _createAndValidateActionInfo(         _setToken,         _borrowAsset,         _collateralAsset,         _borrowQuantity,         _minReceiveQuantity,         _tradeAdapterName,         true     );      _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);      uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);      _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);      _updateLeverPositions(leverInfo, _borrowAsset);      emit LeverageIncreased(         _setToken,         _borrowAsset,         _collateralAsset,         leverInfo.exchangeAdapter,         leverInfo.notionalSendQuantity,         postTradeCollateralQuantity,         protocolFee     ); }  /**  * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled  *  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _repayAsset           Address of asset being repaid  * @param _redeemQuantity       Quantity of collateral asset to delever  * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function delever(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantity,     uint256 _minRepayQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from     // repay asset     ActionInfo memory deleverInfo = _createAndValidateActionInfo(         _setToken,         _collateralAsset,         _repayAsset,         _redeemQuantity,         _minRepayQuantity,         _tradeAdapterName,         false     );      _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);      uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);      _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);      _updateLeverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         repayQuantity,         protocolFee     ); }  /**  * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received  * borrow asset is updated as equity. No protocol fee is charged.  *  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)  * @param _redeemQuantity       Quantity of collateral asset to delever  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function deleverToZeroBorrowBalance(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());      require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");     uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));      ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(         _setToken,         _collateralAsset,         _repayAsset,         notionalRedeemQuantity,         notionalRepayQuantity,         _tradeAdapterName,         false     );      _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);      _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly     _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);      // Update default position first to save gas on editing borrow position     _setToken.calculateAndEditDefaultPosition(         address(_repayAsset),         deleverInfo.setTotalSupply,         deleverInfo.preTradeReceiveTokenBalance     );      _updateLeverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         notionalRepayQuantity,         0 // No protocol fee     ); }  /**  * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral  * assets, update cToken default position. For borrow assets, update external borrow position.  * - Collateral assets may come out of sync when a position is liquidated  * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid  *  * @param _setToken               Instance of the SetToken  * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value  */ function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {     uint256 setTotalSupply = _setToken.totalSupply();      // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption     if (setTotalSupply &gt; 0) {         // Loop through collateral assets         address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;         for(uint256 i = 0; i &lt; collateralCTokens.length; i++) {             ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);             uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();             uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (previousPositionUnit != newPositionUnit) {               _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);             }         }          // Loop through borrow assets         address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;         address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;         for(uint256 i = 0; i &lt; borrowCTokens.length; i++) {             ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);             IERC20 borrowAsset = IERC20(borrowAssets[i]);              int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));              int256 newPositionUnit = _getBorrowPosition(                 _setToken,                 borrowCToken,                 setTotalSupply,                 _shouldAccrueInterest             );              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (newPositionUnit != previousPositionUnit) {                 _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);             }         }     } }   /**  * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable  * collateral and borrow assets that don't exist as positions on the SetToken  *  * @param _setToken             Instance of the SetToken to initialize  * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken  * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken  */ function initialize(     ISetToken _setToken,     IERC20[] memory _collateralAssets,     IERC20[] memory _borrowAssets )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     if (!anySetAllowed) {         require(allowedSetTokens[_setToken], "Not allowed SetToken");     }      // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}     }      // Enable collateral and borrow assets on Compound     addCollateralAssets(_setToken, _collateralAssets);      addBorrowAssets(_setToken, _borrowAssets); }  /**  * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled  * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)  */ function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Sync Compound and SetToken positions prior to any removal action     sync(setToken, true);      address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;     for (uint256 i = 0; i &lt; borrowCTokens.length; i++) {         ICErc20 cToken = ICErc20(borrowCTokens[i]);          // Will exit only if token isn't also being used as collateral         if(!collateralCTokenEnabled[setToken][cToken]) {             // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound             setToken.invokeExitMarket(cToken, comptroller);         }          delete borrowCTokenEnabled[setToken][cToken];     }      address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;     for (uint256 i = 0; i &lt; collateralCTokens.length; i++) {         ICErc20 cToken = ICErc20(collateralCTokens[i]);          setToken.invokeExitMarket(cToken, comptroller);          delete collateralCTokenEnabled[setToken][cToken];     }      delete enabledAssets[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken  * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state  * inconsistencies  *  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets  *  * @param _setToken             Instance of the SetToken  * @param _newCollateralAssets  Addresses of new collateral underlying assets  */ function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {     for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];         require(address(cToken) != address(0), "cToken must exist");         require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");          // Note: Will only enter market if cToken is not enabled as a borrow asset as well         if (!borrowCTokenEnabled[_setToken][cToken]) {             _setToken.invokeEnterMarkets(cToken, comptroller);         }          collateralCTokenEnabled[_setToken][cToken] = true;         enabledAssets[_setToken].collateralCTokens.push(address(cToken));     }      emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets); }  /**  * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets  * If there is a borrow balance, collateral asset cannot be removed  *  * @param _setToken             Instance of the SetToken  * @param _collateralAssets     Addresses of collateral underlying assets to remove  */ function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {     // Sync Compound and SetToken positions prior to any removal action     sync(_setToken, true);      for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];         require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");          // Note: Will only exit market if cToken is not enabled as a borrow asset as well         // If there is an existing borrow balance, will revert and market cannot be exited on Compound         if (!borrowCTokenEnabled[_setToken][cToken]) {             _setToken.invokeExitMarket(cToken, comptroller);         }          delete collateralCTokenEnabled[_setToken][cToken];         enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));     }      emit CollateralAssetsUpdated(_setToken, false, _collateralAssets); }  /**  * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets  *  * @param _setToken             Instance of the SetToken  * @param _newBorrowAssets      Addresses of borrow underlying assets to add  */ function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {     for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {         IERC20 newBorrowAsset = _newBorrowAssets[i];         ICErc20 cToken = underlyingToCToken[newBorrowAsset];         require(address(cToken) != address(0), "cToken must exist");         require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");          // Note: Will only enter market if cToken is not enabled as a borrow asset as well         if (!collateralCTokenEnabled[_setToken][cToken]) {             _setToken.invokeEnterMarkets(cToken, comptroller);         }          borrowCTokenEnabled[_setToken][cToken] = true;         enabledAssets[_setToken].borrowCTokens.push(address(cToken));         enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));     }      emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets); }  /**  * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets  * If there is a borrow balance, borrow asset cannot be removed  *  * @param _setToken             Instance of the SetToken  * @param _borrowAssets         Addresses of borrow underlying assets to remove  */ function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {     // Sync Compound and SetToken positions prior to any removal action     sync(_setToken, true);      for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];         require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");          // Note: Will only exit market if cToken is not enabled as a collateral asset as well         // If there is an existing borrow balance, will revert and market cannot be exited on Compound         if (!collateralCTokenEnabled[_setToken][cToken]) {             _setToken.invokeExitMarket(cToken, comptroller);         }          delete borrowCTokenEnabled[_setToken][cToken];         enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));         enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));     }      emit BorrowAssetsUpdated(_setToken, false, _borrowAssets); }  /**  * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.  *  * @param _setToken             Instance of the SetToken  */ function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {     allowedSetTokens[_setToken] = _status;     emit SetTokenStatusUpdated(_setToken, _status); }  /**  * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.  *  * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled  */ function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {     anySetAllowed = _anySetAllowed;     emit AnySetAllowedUpdated(_anySetAllowed); }  /**  * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.  *  * IMPORTANT: Validations are skipped in order to get contract under bytecode limit  *  * @param _cToken                   Address of cToken to add  * @param _underlying               Address of underlying token that maps to cToken  */ function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {     require(address(underlyingToCToken[_underlying]) == address(0), "Already added");     underlyingToCToken[_underlying] = _cToken; }  /**  * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals  *  * IMPORTANT: Validations are skipped in order to get contract under bytecode limit  *  * @param _underlying               Address of underlying token to remove  */ function removeCompoundMarket(IERC20 _underlying) external onlyOwner {     require(address(underlyingToCToken[_underlying]) != address(0), "Not added");     delete underlyingToCToken[_underlying]; }  /**  * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {     sync(_setToken, false); }  /**  * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.  * Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {     sync(_setToken, true); }  /**  * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {     int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));      require(componentDebt &lt; 0, "Component must be negative");      uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);      _borrow(_setToken, underlyingToCToken[_component], notionalDebt); }  /**  * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {     int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));      require(componentDebt &lt; 0, "Component must be negative");      uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);      _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt); }   /* ============ External Getter Functions ============ */  /**  * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an  * array of underlying that are borrow assets.  *  * @return                    Collateral cToken assets that are enabled  * @return                    Underlying borrowed assets that are enabled.  */ function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {     return (         enabledAssets[_setToken].collateralCTokens,         enabledAssets[_setToken].borrowAssets     ); }  /* ============ Internal Functions ============ */  /**  * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be  * unwrapped as it only accepts the underlying ETH.  */ function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {     if (_cToken == cEther) {         _setToken.invokeUnwrapWETH(address(weth), _mintNotional);          _setToken.invokeMintCEther(_cToken, _mintNotional);     } else {         _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);          _setToken.invokeMintCToken(_cToken, _mintNotional);     } }  /**  * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.  */ function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {     _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);      if (_cToken == cEther) {         _setToken.invokeWrapWETH(address(weth), _redeemNotional);     } }  /**  * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.  */ function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {     if (_cToken == cEther) {         _setToken.invokeUnwrapWETH(address(weth), _repayNotional);          _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);     } else {         // Approve to cToken         _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);         _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);     } }  /**  * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.  */ function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {     _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);     if (_cToken == cEther) {         _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);     } }  /**  * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken  *  * @return receiveTokenQuantity The quantity of tokens received post-trade  */ function _executeTrade(     ActionInfo memory _actionInfo,     IERC20 _sendToken,     IERC20 _receiveToken,     bytes memory _data )     internal     returns (uint256) {      ISetToken setToken = _actionInfo.setToken;      uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;       setToken.invokeApprove(         address(_sendToken),         _actionInfo.exchangeAdapter.getSpender(),         notionalSendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _actionInfo.exchangeAdapter.getTradeCalldata(         address(_sendToken),         address(_receiveToken),         address(setToken),         notionalSendQuantity,         _actionInfo.minNotionalReceiveQuantity,         _data     );      setToken.invoke(targetExchange, callValue, methodData);      uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);     require(         receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,         "Slippage too high"     );      return receiveTokenQuantity; }  /**  * Calculates protocol fee on module and pays protocol fee from SetToken  */ function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {     uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);      payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);      return protocolFeeTotal; }  /**  * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)  */ function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {     _updateCollateralPosition(         actionInfo.setToken,         actionInfo.collateralCTokenAsset,         _getCollateralPosition(             actionInfo.setToken,             actionInfo.collateralCTokenAsset,             actionInfo.setTotalSupply         )     );      _updateBorrowPosition(         actionInfo.setToken,         _borrowAsset,         _getBorrowPosition(             actionInfo.setToken,             actionInfo.borrowCTokenAsset,             actionInfo.setTotalSupply,             false // Do not accrue interest         )     ); }  function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {     _setToken.editDefaultPosition(address(_cToken), _newPositionUnit); }  function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {     _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, ""); }  /**  * Construct the ActionInfo struct for lever and delever  */ function _createAndValidateActionInfo(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _sendQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();      return _createAndValidateActionInfoNotional(         _setToken,         _sendToken,         _receiveToken,         _sendQuantityUnits.preciseMul(totalSupply),         _minReceiveQuantityUnits.preciseMul(totalSupply),         _tradeAdapterName,         _isLever     ); }  /**  * Construct the ActionInfo struct for lever and delever accepting notional units  */ function _createAndValidateActionInfoNotional(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _notionalSendQuantity,     uint256 _minNotionalReceiveQuantity,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();     ActionInfo memory actionInfo = ActionInfo ({         exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),         setToken: _setToken,         collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],         borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],         setTotalSupply: totalSupply,         notionalSendQuantity: _notionalSendQuantity,         minNotionalReceiveQuantity: _minNotionalReceiveQuantity,         preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))     });      _validateCommon(actionInfo);      return actionInfo; }    function _validateCommon(ActionInfo memory _actionInfo) internal view {     require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");     require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");     require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");     require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0"); }  function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {     uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));     return collateralNotionalBalance.preciseDiv(_setTotalSupply); }  /**  * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.  * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.  */ function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {     uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));     // Round negative away from 0     int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);      return borrowPositionUnit; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 02:00:11 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { Compound } from "../../integration/lib/Compound.sol";
import { ICErc20 } from "../../../interfaces/external/ICErc20.sol";
import { IComptroller } from "../../../interfaces/external/IComptroller.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title CompoundLeverageModule
 * @author Set Protocol
 *
 * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call
 * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each
 * asset is leveraged when using this module.
 *
 * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 *
 */
contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {
    using Compound for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken
        address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken
        address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset
        ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    /* ============ Events ============ */

    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the trade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping of underlying to CToken. If ETH, then map WETH to cETH
    mapping(IERC20 => ICErc20) public underlyingToCToken;

    // Wrapped Ether address
    IERC20 internal weth;

    // Compound cEther address
    ICErc20 internal cEther;

    // Compound Comptroller contract
    IComptroller internal comptroller;

    // COMP token address
    IERC20 internal compToken;

    // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public collateralCTokenEnabled;

    // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public borrowCTokenEnabled;

    // Mapping of enabled collateral and borrow cTokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list
    bool public anySetAllowed;


    /* ============ Constructor ============ */

    /**
     * Instantiate addresses. Underlying to cToken mapping is created.
     *
     * @param _controller               Address of controller contract
     * @param _compToken                Address of COMP token
     * @param _comptroller              Address of Compound Comptroller
     * @param _cEther                   Address of cEther contract
     * @param _weth                     Address of WETH contract
     */
    constructor(
        IController _controller,
        IERC20 _compToken,
        IComptroller _comptroller,
        ICErc20 _cEther,
        IERC20 _weth
    )
        public
        ModuleBase(_controller)
    {
        compToken = _compToken;
        comptroller = _comptroller;
        cEther = _cEther;
        weth = _weth;

        ICErc20[] memory cTokens = comptroller.getAllMarkets();

        for(uint256 i = 0; i < cTokens.length; i++) {
            ICErc20 cToken = cTokens[i];
            underlyingToCToken[
                cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())
            ] = cToken;
        }
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.
     * Performs a DEX trade, exchanging the borrow asset for collateral asset.
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAsset          Address of asset being borrowed for leverage
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _borrowQuantity       Borrow quantity of asset in position units
     * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantity,
        uint256 _minReceiveQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantity,
            _minReceiveQuantity,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        uint256 _minRepayQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantity,
            _minRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received
     * borrow asset is updated as equity. No protocol fee is charged.
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());

        require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly
        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);

        // Update default position first to save gas on editing borrow position
        _setToken.calculateAndEditDefaultPosition(
            address(_repayAsset),
            deleverInfo.setTotalSupply,
            deleverInfo.preTradeReceiveTokenBalance
        );

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0 // No protocol fee
        );
    }

    /**
     * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral
     * assets, update cToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     *
     * @param _setToken               Instance of the SetToken
     * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value
     */
    function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption
        if (setTotalSupply > 0) {
            // Loop through collateral assets
            address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;
            for(uint256 i = 0; i < collateralCTokens.length; i++) {
                ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);
                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);
                }
            }

            // Loop through borrow assets
            address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;
            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowCTokens.length; i++) {
                ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));

                int256 newPositionUnit = _getBorrowPosition(
                    _setToken,
                    borrowCToken,
                    setTotalSupply,
                    _shouldAccrueInterest
                );

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }


    /**
     * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable
     * collateral and borrow assets that don't exist as positions on the SetToken
     *
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // Enable collateral and borrow assets on Compound
        addCollateralAssets(_setToken, _collateralAssets);

        addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled
     * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Compound and SetToken positions prior to any removal action
        sync(setToken, true);

        address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;
        for (uint256 i = 0; i < borrowCTokens.length; i++) {
            ICErc20 cToken = ICErc20(borrowCTokens[i]);

            // Will exit only if token isn't also being used as collateral
            if(!collateralCTokenEnabled[setToken][cToken]) {
                // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound
                setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[setToken][cToken];
        }

        address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;
        for (uint256 i = 0; i < collateralCTokens.length; i++) {
            ICErc20 cToken = ICErc20(collateralCTokens[i]);

            setToken.invokeExitMarket(cToken, comptroller);

            delete collateralCTokenEnabled[setToken][cToken];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken
     * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];
            require(address(cToken) != address(0), "cToken must exist");
            require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            collateralCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].collateralCTokens.push(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets
     * If there is a borrow balance, collateral asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];
            require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");

            // Note: Will only exit market if cToken is not enabled as a borrow asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete collateralCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 newBorrowAsset = _newBorrowAssets[i];
            ICErc20 cToken = underlyingToCToken[newBorrowAsset];
            require(address(cToken) != address(0), "cToken must exist");
            require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            borrowCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].borrowCTokens.push(address(cToken));
            enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));
        }

        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets
     * If there is a borrow balance, borrow asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];
            require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");

            // Note: Will only exit market if cToken is not enabled as a collateral asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));
            enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));
        }

        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.
     *
     * @param _setToken             Instance of the SetToken
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.
     *
     * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _cToken                   Address of cToken to add
     * @param _underlying               Address of underlying token that maps to cToken
     */
    function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) == address(0), "Already added");
        underlyingToCToken[_underlying] = _cToken;
    }

    /**
     * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _underlying               Address of underlying token to remove
     */
    function removeCompoundMarket(IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) != address(0), "Not added");
        delete underlyingToCToken[_underlying];
    }

    /**
     * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, false);
    }

    /**
     * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.
     * Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, true);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);

        _borrow(_setToken, underlyingToCToken[_component], notionalDebt);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);

        _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt);
    }


    /* ============ External Getter Functions ============ */

    /**
     * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an
     * array of underlying that are borrow assets.
     *
     * @return                    Collateral cToken assets that are enabled
     * @return                    Underlying borrowed assets that are enabled.
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralCTokens,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be
     * unwrapped as it only accepts the underlying ETH.
     */
    function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _mintNotional);

            _setToken.invokeMintCEther(_cToken, _mintNotional);
        } else {
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);

            _setToken.invokeMintCToken(_cToken, _mintNotional);
        }
    }

    /**
     * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.
     */
    function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {
        _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);

        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _redeemNotional);
        }
    }

    /**
     * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.
     */
    function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _repayNotional);

            _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);
        } else {
            // Approve to cToken
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);
            _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);
        }
    }

    /**
     * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.
     */
    function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {
        _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);
        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);
        }
    }

    /**
     * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     *
     * @return receiveTokenQuantity The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
         ISetToken setToken = _actionInfo.setToken;
         uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

         setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * Calculates protocol fee on module and pays protocol fee from SetToken
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)
     */
    function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {
        _updateCollateralPosition(
            actionInfo.setToken,
            actionInfo.collateralCTokenAsset,
            _getCollateralPosition(
                actionInfo.setToken,
                actionInfo.collateralCTokenAsset,
                actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                actionInfo.setToken,
                actionInfo.borrowCTokenAsset,
                actionInfo.setTotalSupply,
                false // Do not accrue interest
            )
        );
    }

    function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_cToken), _newPositionUnit);
    }

    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, "");
    }

    /**
     * Construct the ActionInfo struct for lever and delever
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever
        );
    }

    /**
     * Construct the ActionInfo struct for lever and delever accepting notional units
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            setToken: _setToken,
            collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],
            borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],
            setTotalSupply: totalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }



    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");
        require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");
        require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.
     * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.
     */
    function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {
        uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));
        // Round negative away from 0
        int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);

        return borrowPositionUnit;
    }
}.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-01-09 02:00:24 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 02:00:24 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 9259
completion_tokens: 967
total_tokens: 10226
cost: $-1.000000


[2024-01-09 02:00:24 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { Compound } from "../../integration/lib/Compound.sol";
import { ICErc20 } from "../../../interfaces/external/ICErc20.sol";
import { IComptroller } from "../../../interfaces/external/IComptroller.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title CompoundLeverageModule
 * @author Set Protocol
 *
 * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call
 * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each
 * asset is leveraged when using this module.
 *
 * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 *
 */
contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {
    using Compound for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken
        address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken
        address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset
        ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    /* ============ Events ============ */

    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the trade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping of underlying to CToken. If ETH, then map WETH to cETH
    mapping(IERC20 => ICErc20) public underlyingToCToken;

    // Wrapped Ether address
    IERC20 internal weth;

    // Compound cEther address
    ICErc20 internal cEther;

    // Compound Comptroller contract
    IComptroller internal comptroller;

    // COMP token address
    IERC20 internal compToken;

    // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public collateralCTokenEnabled;

    // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public borrowCTokenEnabled;

    // Mapping of enabled collateral and borrow cTokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list
    bool public anySetAllowed;


    /* ============ Constructor ============ */

    /**
     * Instantiate addresses. Underlying to cToken mapping is created.
     *
     * @param _controller               Address of controller contract
     * @param _compToken                Address of COMP token
     * @param _comptroller              Address of Compound Comptroller
     * @param _cEther                   Address of cEther contract
     * @param _weth                     Address of WETH contract
     */
    constructor(
        IController _controller,
        IERC20 _compToken,
        IComptroller _comptroller,
        ICErc20 _cEther,
        IERC20 _weth
    )
        public
        ModuleBase(_controller)
    {
        compToken = _compToken;
        comptroller = _comptroller;
        cEther = _cEther;
        weth = _weth;

        ICErc20[] memory cTokens = comptroller.getAllMarkets();

        for(uint256 i = 0; i < cTokens.length; i++) {
            ICErc20 cToken = cTokens[i];
            underlyingToCToken[
                cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())
            ] = cToken;
        }
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.
     * Performs a DEX trade, exchanging the borrow asset for collateral asset.
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAsset          Address of asset being borrowed for leverage
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _borrowQuantity       Borrow quantity of asset in position units
     * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantity,
        uint256 _minReceiveQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantity,
            _minReceiveQuantity,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        uint256 _minRepayQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantity,
            _minRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received
     * borrow asset is updated as equity. No protocol fee is charged.
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());

        require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly
        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);

        // Update default position first to save gas on editing borrow position
        _setToken.calculateAndEditDefaultPosition(
            address(_repayAsset),
            deleverInfo.setTotalSupply,
            deleverInfo.preTradeReceiveTokenBalance
        );

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0 // No protocol fee
        );
    }

    /**
     * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral
     * assets, update cToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     *
     * @param _setToken               Instance of the SetToken
     * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value
     */
    function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption
        if (setTotalSupply > 0) {
            // Loop through collateral assets
            address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;
            for(uint256 i = 0; i < collateralCTokens.length; i++) {
                ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);
                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);
                }
            }

            // Loop through borrow assets
            address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;
            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowCTokens.length; i++) {
                ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));

                int256 newPositionUnit = _getBorrowPosition(
                    _setToken,
                    borrowCToken,
                    setTotalSupply,
                    _shouldAccrueInterest
                );

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }


    /**
     * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable
     * collateral and borrow assets that don't exist as positions on the SetToken
     *
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // Enable collateral and borrow assets on Compound
        addCollateralAssets(_setToken, _collateralAssets);

        addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled
     * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Compound and SetToken positions prior to any removal action
        sync(setToken, true);

        address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;
        for (uint256 i = 0; i < borrowCTokens.length; i++) {
            ICErc20 cToken = ICErc20(borrowCTokens[i]);

            // Will exit only if token isn't also being used as collateral
            if(!collateralCTokenEnabled[setToken][cToken]) {
                // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound
                setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[setToken][cToken];
        }

        address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;
        for (uint256 i = 0; i < collateralCTokens.length; i++) {
            ICErc20 cToken = ICErc20(collateralCTokens[i]);

            setToken.invokeExitMarket(cToken, comptroller);

            delete collateralCTokenEnabled[setToken][cToken];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken
     * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];
            require(address(cToken) != address(0), "cToken must exist");
            require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            collateralCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].collateralCTokens.push(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets
     * If there is a borrow balance, collateral asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];
            require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");

            // Note: Will only exit market if cToken is not enabled as a borrow asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete collateralCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 newBorrowAsset = _newBorrowAssets[i];
            ICErc20 cToken = underlyingToCToken[newBorrowAsset];
            require(address(cToken) != address(0), "cToken must exist");
            require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            borrowCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].borrowCTokens.push(address(cToken));
            enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));
        }

        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets
     * If there is a borrow balance, borrow asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];
            require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");

            // Note: Will only exit market if cToken is not enabled as a collateral asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));
            enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));
        }

        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.
     *
     * @param _setToken             Instance of the SetToken
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.
     *
     * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _cToken                   Address of cToken to add
     * @param _underlying               Address of underlying token that maps to cToken
     */
    function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) == address(0), "Already added");
        underlyingToCToken[_underlying] = _cToken;
    }

    /**
     * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _underlying               Address of underlying token to remove
     */
    function removeCompoundMarket(IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) != address(0), "Not added");
        delete underlyingToCToken[_underlying];
    }

    /**
     * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, false);
    }

    /**
     * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.
     * Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, true);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);

        _borrow(_setToken, underlyingToCToken[_component], notionalDebt);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);

        _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt);
    }


    /* ============ External Getter Functions ============ */

    /**
     * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an
     * array of underlying that are borrow assets.
     *
     * @return                    Collateral cToken assets that are enabled
     * @return                    Underlying borrowed assets that are enabled.
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralCTokens,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be
     * unwrapped as it only accepts the underlying ETH.
     */
    function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _mintNotional);

            _setToken.invokeMintCEther(_cToken, _mintNotional);
        } else {
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);

            _setToken.invokeMintCToken(_cToken, _mintNotional);
        }
    }

    /**
     * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.
     */
    function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {
        _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);

        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _redeemNotional);
        }
    }

    /**
     * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.
     */
    function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _repayNotional);

            _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);
        } else {
            // Approve to cToken
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);
            _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);
        }
    }

    /**
     * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.
     */
    function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {
        _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);
        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);
        }
    }

    /**
     * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     *
     * @return receiveTokenQuantity The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
         ISetToken setToken = _actionInfo.setToken;
         uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

         setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * Calculates protocol fee on module and pays protocol fee from SetToken
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)
     */
    function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {
        _updateCollateralPosition(
            actionInfo.setToken,
            actionInfo.collateralCTokenAsset,
            _getCollateralPosition(
                actionInfo.setToken,
                actionInfo.collateralCTokenAsset,
                actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                actionInfo.setToken,
                actionInfo.borrowCTokenAsset,
                actionInfo.setTotalSupply,
                false // Do not accrue interest
            )
        );
    }

    function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_cToken), _newPositionUnit);
    }

    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, "");
    }

    /**
     * Construct the ActionInfo struct for lever and delever
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever
        );
    }

    /**
     * Construct the ActionInfo struct for lever and delever accepting notional units
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            setToken: _setToken,
            collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],
            borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],
            setTotalSupply: totalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }



    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");
        require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");
        require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.
     * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.
     */
    function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {
        uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));
        // Round negative away from 0
        int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);

        return borrowPositionUnit;
    }
}.]

Based on the provided Solidity smart contract code for the `CompoundLeverageModule`, here is a summary of potential security vulnerabilities and issues identified:

### Summary of Security Vulnerabilities

1. **Reentrancy Risks**:
   - Although the contract uses `ReentrancyGuard`, there are multiple external calls (e.g., `_executeTrade`, `_borrow`, `_repayBorrow`, etc.) that could potentially lead to reentrancy attacks if not handled correctly. It is crucial to ensure that state changes occur before external calls.

2. **Access Control**:
   - The contract relies on modifiers like `onlyManagerAndValidSet`, `onlyValidAndInitializedSet`, and `onlyOwner` for access control. If these modifiers are not implemented correctly or if there are any flaws in their logic, unauthorized users might gain access to sensitive functions.

3. **Slippage Vulnerability**:
   - The `lever` and `delever` functions include a slippage check (`require(receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity, "Slippage too high")`). If the slippage is not properly managed, it could lead to significant losses during trades.

4. **Gas Limit Issues**:
   - The contract contains loops (e.g., in the `sync` function) that iterate over arrays of collateral and borrow assets. If the number of assets is large, this could lead to exceeding the gas limit during execution, causing transactions to fail.

5. **Lack of Input Validation**:
   - Functions like `addCollateralAssets` and `addBorrowAssets` do not validate the input arrays for duplicates or zero addresses, which could lead to unexpected behavior or state corruption.

6. **Protocol Fee Calculation**:
   - The protocol fee calculation in `_accrueProtocolFee` is based on a fixed index (`PROTOCOL_TRADE_FEE_INDEX`). If the fee structure changes or if there's an error in the fee calculation logic, it could lead to incorrect fee deductions.

7. **Potential for Front-Running**:
   - The contract does not implement any mechanisms to prevent front-running attacks, especially in functions that involve trading or borrowing. This could allow malicious actors to exploit the timing of transactions.

8. **Error Handling**:
   - The contract uses `try/catch` for some external calls, but there are many other external calls that do not handle errors explicitly. This could lead to unexpected contract states if an external call fails.

9. **Initialization Risks**:
   - The `initialize` function allows managers to enable collateral and borrow assets. If a malicious manager is able to call this function, they could enable risky assets that could jeopardize the safety of the contract.

### Comprehensive Analysis Report

The `CompoundLeverageModule` contract is designed to facilitate leveraged trading using the Compound protocol. While it incorporates several best practices, such as using OpenZeppelin's `ReentrancyGuard` and `Ownable`, there are notable vulnerabilities that need to be addressed to ensure the contract's security and reliability.

1. **Reentrancy Protection**: The use of `ReentrancyGuard` is a positive aspect; however, the contract's reliance on external calls necessitates careful management of state changes to prevent reentrancy attacks.

2. **Access Control**: The contract's access control mechanisms must be rigorously tested to prevent unauthorized access. Any flaws in the implementation of these modifiers could lead to severe security breaches.

3. **Trade Execution Risks**: The slippage checks are essential for protecting against unfavorable trades, but they must be robustly implemented to avoid significant financial losses.

4. **Gas Efficiency**: The potential for gas limit issues in functions that loop through asset arrays should be mitigated by implementing checks on the number of assets or optimizing the logic to reduce gas consumption.

5. **Input Validation**: Comprehensive input validation is necessary to prevent state corruption and ensure that only valid assets are added to the contract.

6. **Protocol Fee Management**: The protocol fee calculation should be flexible and adaptable to changes in the fee structure to prevent financial discrepancies.

7. **Front-Running Prevention**: Implementing mechanisms to mitigate front-running risks is crucial for maintaining the integrity of trades executed through the contract.

8. **Error Handling**: Enhanced error handling for external calls will improve the contract's resilience against unexpected failures.

9. **Initialization Security**: The initialization process must be secured to prevent malicious actors from enabling risky assets that could compromise the contract's safety.

In conclusion, while the `CompoundLeverageModule` contract demonstrates a solid foundation for leveraged trading, addressing the identified vulnerabilities is critical for ensuring its security and reliability in a production environment. A thorough audit and testing phase should be conducted to validate the effectiveness of the implemented security measures.

[2024-01-09 02:00:24 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code for the `CompoundLeverageModule`, here is a summary of potential security vulnerabilities and issues identified:

### Summary of Security Vulnerabilities

1. **Reentrancy Risks**:
   - Although the contract uses `ReentrancyGuard`, there are multiple external calls (e.g., `_executeTrade`, `_borrow`, `_repayBorrow`, etc.) that could potentially lead to reentrancy attacks if not handled correctly. It is crucial to ensure that state changes occur before external calls.

2. **Access Control**:
   - The contract relies on modifiers like `onlyManagerAndValidSet`, `onlyValidAndInitializedSet`, and `onlyOwner` for access control. If these modifiers are not implemented correctly or if there are any flaws in their logic, unauthorized users might gain access to sensitive functions.

3. **Slippage Vulnerability**:
   - The `lever` and `delever` functions include a slippage check (`require(receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity, "Slippage too high")`). If the slippage is not properly managed, it could lead to significant losses during trades.

4. **Gas Limit Issues**:
   - The contract contains loops (e.g., in the `sync` function) that iterate over arrays of collateral and borrow assets. If the number of assets is large, this could lead to exceeding the gas limit during execution, causing transactions to fail.

5. **Lack of Input Validation**:
   - Functions like `addCollateralAssets` and `addBorrowAssets` do not validate the input arrays for duplicates or zero addresses, which could lead to unexpected behavior or state corruption.

6. **Protocol Fee Calculation**:
   - The protocol fee calculation in `_accrueProtocolFee` is based on a fixed index (`PROTOCOL_TRADE_FEE_INDEX`). If the fee structure changes or if there's an error in the fee calculation logic, it could lead to incorrect fee deductions.

7. **Potential for Front-Running**:
   - The contract does not implement any mechanisms to prevent front-running attacks, especially in functions that involve trading or borrowing. This could allow malicious actors to exploit the timing of transactions.

8. **Error Handling**:
   - The contract uses `try/catch` for some external calls, but there are many other external calls that do not handle errors explicitly. This could lead to unexpected contract states if an external call fails.

9. **Initialization Risks**:
   - The `initialize` function allows managers to enable collateral and borrow assets. If a malicious manager is able to call this function, they could enable risky assets that could jeopardize the safety of the contract.

### Comprehensive Analysis Report

The `CompoundLeverageModule` contract is designed to facilitate leveraged trading using the Compound protocol. While it incorporates several best practices, such as using OpenZeppelin's `ReentrancyGuard` and `Ownable`, there are notable vulnerabilities that need to be addressed to ensure the contract's security and reliability.

1. **Reentrancy Protection**: The use of `ReentrancyGuard` is a positive aspect; however, the contract's reliance on external calls necessitates careful management of state changes to prevent reentrancy attacks.

2. **Access Control**: The contract's access control mechanisms must be rigorously tested to prevent unauthorized access. Any flaws in the implementation of these modifiers could lead to severe security breaches.

3. **Trade Execution Risks**: The slippage checks are essential for protecting against unfavorable trades, but they must be robustly implemented to avoid significant financial losses.

4. **Gas Efficiency**: The potential for gas limit issues in functions that loop through asset arrays should be mitigated by implementing checks on the number of assets or optimizing the logic to reduce gas consumption.

5. **Input Validation**: Comprehensive input validation is necessary to prevent state corruption and ensure that only valid assets are added to the contract.

6. **Protocol Fee Management**: The protocol fee calculation should be flexible and adaptable to changes in the fee structure to prevent financial discrepancies.

7. **Front-Running Prevention**: Implementing mechanisms to mitigate front-running risks is crucial for maintaining the integrity of trades executed through the contract.

8. **Error Handling**: Enhanced error handling for external calls will improve the contract's resilience against unexpected failures.

9. **Initialization Security**: The initialization process must be secured to prevent malicious actors from enabling risky assets that could compromise the contract's safety.

In conclusion, while the `CompoundLeverageModule` contract demonstrates a solid foundation for leveraged trading, addressing the identified vulnerabilities is critical for ensuring its security and reliability in a production environment. A thorough audit and testing phase should be conducted to validate the effectiveness of the implemented security measures.

[2024-01-09 02:00:24 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-01-09 02:00:24 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { Compound } from "../../integration/lib/Compound.sol"; import { ICErc20 } from "../../../interfaces/external/ICErc20.sol"; import { IComptroller } from "../../../interfaces/external/IComptroller.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol"; import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; /*  * @title CompoundLeverageModule  * @author Set Protocol  *  * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call  * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each  * asset is leveraged when using this module.  *  * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of  * debt when borrowed assets are the same.  *  / contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {     using Compound for ISetToken; /* ============ Structs ============ */  struct EnabledAssets {     address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken     address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken     address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets }  struct ActionInfo {     ISetToken setToken;                      // SetToken instance     IExchangeAdapter exchangeAdapter;        // Exchange adapter instance     uint256 setTotalSupply;                  // Total supply of SetToken     uint256 notionalSendQuantity;            // Total notional quantity sent to exchange     uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange     ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset     ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset     uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance }  /* ============ Events ============ */  event LeverageIncreased(     ISetToken indexed _setToken,     IERC20 indexed _borrowAsset,     IERC20 indexed _collateralAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalBorrowAmount,     uint256 _totalReceiveAmount,     uint256 _protocolFee );  event LeverageDecreased(     ISetToken indexed _setToken,     IERC20 indexed _collateralAsset,     IERC20 indexed _repayAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalRedeemAmount,     uint256 _totalRepayAmount,     uint256 _protocolFee );  event CollateralAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  event BorrowAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  event SetTokenStatusUpdated(     ISetToken indexed _setToken,     bool indexed _added );  event AnySetAllowedUpdated(     bool indexed _anySetAllowed );  /* ============ Constants ============ */  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the trade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Mapping of underlying to CToken. If ETH, then map WETH to cETH mapping(IERC20 =&gt; ICErc20) public underlyingToCToken;  // Wrapped Ether address IERC20 internal weth;  // Compound cEther address ICErc20 internal cEther;  // Compound Comptroller contract IComptroller internal comptroller;  // COMP token address IERC20 internal compToken;  // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public collateralCTokenEnabled;  // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public borrowCTokenEnabled;  // Mapping of enabled collateral and borrow cTokens for syncing positions mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;  // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance mapping(ISetToken =&gt; bool) public allowedSetTokens;  // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list bool public anySetAllowed;   /* ============ Constructor ============ */  /**  * Instantiate addresses. Underlying to cToken mapping is created.  *  * @param _controller               Address of controller contract  * @param _compToken                Address of COMP token  * @param _comptroller              Address of Compound Comptroller  * @param _cEther                   Address of cEther contract  * @param _weth                     Address of WETH contract  */ constructor(     IController _controller,     IERC20 _compToken,     IComptroller _comptroller,     ICErc20 _cEther,     IERC20 _weth )     public     ModuleBase(_controller) {     compToken = _compToken;     comptroller = _comptroller;     cEther = _cEther;     weth = _weth;      ICErc20[] memory cTokens = comptroller.getAllMarkets();      for(uint256 i = 0; i &lt; cTokens.length; i++) {         ICErc20 cToken = cTokens[i];         underlyingToCToken[             cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())         ] = cToken;     } }  /* ============ External Functions ============ */  /**  * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.  * Performs a DEX trade, exchanging the borrow asset for collateral asset.  *  * @param _setToken             Instance of the SetToken  * @param _borrowAsset          Address of asset being borrowed for leverage  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _borrowQuantity       Borrow quantity of asset in position units  * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function lever(     ISetToken _setToken,     IERC20 _borrowAsset,     IERC20 _collateralAsset,     uint256 _borrowQuantity,     uint256 _minReceiveQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // For levering up, send quantity is derived from borrow asset and receive quantity is derived from     // collateral asset     ActionInfo memory leverInfo = _createAndValidateActionInfo(         _setToken,         _borrowAsset,         _collateralAsset,         _borrowQuantity,         _minReceiveQuantity,         _tradeAdapterName,         true     );      _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);      uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);      _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);      _updateLeverPositions(leverInfo, _borrowAsset);      emit LeverageIncreased(         _setToken,         _borrowAsset,         _collateralAsset,         leverInfo.exchangeAdapter,         leverInfo.notionalSendQuantity,         postTradeCollateralQuantity,         protocolFee     ); }  /**  * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled  *  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _repayAsset           Address of asset being repaid  * @param _redeemQuantity       Quantity of collateral asset to delever  * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function delever(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantity,     uint256 _minRepayQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from     // repay asset     ActionInfo memory deleverInfo = _createAndValidateActionInfo(         _setToken,         _collateralAsset,         _repayAsset,         _redeemQuantity,         _minRepayQuantity,         _tradeAdapterName,         false     );      _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);      uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);      _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);      _updateLeverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         repayQuantity,         protocolFee     ); }  /**  * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received  * borrow asset is updated as equity. No protocol fee is charged.  *  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)  * @param _redeemQuantity       Quantity of collateral asset to delever  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function deleverToZeroBorrowBalance(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());      require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");     uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));      ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(         _setToken,         _collateralAsset,         _repayAsset,         notionalRedeemQuantity,         notionalRepayQuantity,         _tradeAdapterName,         false     );      _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);      _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly     _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);      // Update default position first to save gas on editing borrow position     _setToken.calculateAndEditDefaultPosition(         address(_repayAsset),         deleverInfo.setTotalSupply,         deleverInfo.preTradeReceiveTokenBalance     );      _updateLeverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         notionalRepayQuantity,         0 // No protocol fee     ); }  /**  * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral  * assets, update cToken default position. For borrow assets, update external borrow position.  * - Collateral assets may come out of sync when a position is liquidated  * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid  *  * @param _setToken               Instance of the SetToken  * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value  */ function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {     uint256 setTotalSupply = _setToken.totalSupply();      // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption     if (setTotalSupply &gt; 0) {         // Loop through collateral assets         address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;         for(uint256 i = 0; i &lt; collateralCTokens.length; i++) {             ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);             uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();             uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (previousPositionUnit != newPositionUnit) {               _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);             }         }          // Loop through borrow assets         address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;         address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;         for(uint256 i = 0; i &lt; borrowCTokens.length; i++) {             ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);             IERC20 borrowAsset = IERC20(borrowAssets[i]);              int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));              int256 newPositionUnit = _getBorrowPosition(                 _setToken,                 borrowCToken,                 setTotalSupply,                 _shouldAccrueInterest             );              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (newPositionUnit != previousPositionUnit) {                 _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);             }         }     } }   /**  * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable  * collateral and borrow assets that don't exist as positions on the SetToken  *  * @param _setToken             Instance of the SetToken to initialize  * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken  * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken  */ function initialize(     ISetToken _setToken,     IERC20[] memory _collateralAssets,     IERC20[] memory _borrowAssets )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     if (!anySetAllowed) {         require(allowedSetTokens[_setToken], "Not allowed SetToken");     }      // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}     }      // Enable collateral and borrow assets on Compound     addCollateralAssets(_setToken, _collateralAssets);      addBorrowAssets(_setToken, _borrowAssets); }  /**  * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled  * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)  */ function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Sync Compound and SetToken positions prior to any removal action     sync(setToken, true);      address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;     for (uint256 i = 0; i &lt; borrowCTokens.length; i++) {         ICErc20 cToken = ICErc20(borrowCTokens[i]);          // Will exit only if token isn't also being used as collateral         if(!collateralCTokenEnabled[setToken][cToken]) {             // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound             setToken.invokeExitMarket(cToken, comptroller);         }          delete borrowCTokenEnabled[setToken][cToken];     }      address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;     for (uint256 i = 0; i &lt; collateralCTokens.length; i++) {         ICErc20 cToken = ICErc20(collateralCTokens[i]);          setToken.invokeExitMarket(cToken, comptroller);          delete collateralCTokenEnabled[setToken][cToken];     }      delete enabledAssets[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken  * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state  * inconsistencies  *  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets  *  * @param _setToken             Instance of the SetToken  * @param _newCollateralAssets  Addresses of new collateral underlying assets  */ function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {     for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];         require(address(cToken) != address(0), "cToken must exist");         require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");          // Note: Will only enter market if cToken is not enabled as a borrow asset as well         if (!borrowCTokenEnabled[_setToken][cToken]) {             _setToken.invokeEnterMarkets(cToken, comptroller);         }          collateralCTokenEnabled[_setToken][cToken] = true;         enabledAssets[_setToken].collateralCTokens.push(address(cToken));     }      emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets); }  /**  * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets  * If there is a borrow balance, collateral asset cannot be removed  *  * @param _setToken             Instance of the SetToken  * @param _collateralAssets     Addresses of collateral underlying assets to remove  */ function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {     // Sync Compound and SetToken positions prior to any removal action     sync(_setToken, true);      for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];         require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");          // Note: Will only exit market if cToken is not enabled as a borrow asset as well         // If there is an existing borrow balance, will revert and market cannot be exited on Compound         if (!borrowCTokenEnabled[_setToken][cToken]) {             _setToken.invokeExitMarket(cToken, comptroller);         }          delete collateralCTokenEnabled[_setToken][cToken];         enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));     }      emit CollateralAssetsUpdated(_setToken, false, _collateralAssets); }  /**  * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets  *  * @param _setToken             Instance of the SetToken  * @param _newBorrowAssets      Addresses of borrow underlying assets to add  */ function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {     for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {         IERC20 newBorrowAsset = _newBorrowAssets[i];         ICErc20 cToken = underlyingToCToken[newBorrowAsset];         require(address(cToken) != address(0), "cToken must exist");         require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");          // Note: Will only enter market if cToken is not enabled as a borrow asset as well         if (!collateralCTokenEnabled[_setToken][cToken]) {             _setToken.invokeEnterMarkets(cToken, comptroller);         }          borrowCTokenEnabled[_setToken][cToken] = true;         enabledAssets[_setToken].borrowCTokens.push(address(cToken));         enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));     }      emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets); }  /**  * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets  * If there is a borrow balance, borrow asset cannot be removed  *  * @param _setToken             Instance of the SetToken  * @param _borrowAssets         Addresses of borrow underlying assets to remove  */ function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {     // Sync Compound and SetToken positions prior to any removal action     sync(_setToken, true);      for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];         require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");          // Note: Will only exit market if cToken is not enabled as a collateral asset as well         // If there is an existing borrow balance, will revert and market cannot be exited on Compound         if (!collateralCTokenEnabled[_setToken][cToken]) {             _setToken.invokeExitMarket(cToken, comptroller);         }          delete borrowCTokenEnabled[_setToken][cToken];         enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));         enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));     }      emit BorrowAssetsUpdated(_setToken, false, _borrowAssets); }  /**  * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.  *  * @param _setToken             Instance of the SetToken  */ function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {     allowedSetTokens[_setToken] = _status;     emit SetTokenStatusUpdated(_setToken, _status); }  /**  * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.  *  * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled  */ function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {     anySetAllowed = _anySetAllowed;     emit AnySetAllowedUpdated(_anySetAllowed); }  /**  * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.  *  * IMPORTANT: Validations are skipped in order to get contract under bytecode limit  *  * @param _cToken                   Address of cToken to add  * @param _underlying               Address of underlying token that maps to cToken  */ function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {     require(address(underlyingToCToken[_underlying]) == address(0), "Already added");     underlyingToCToken[_underlying] = _cToken; }  /**  * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals  *  * IMPORTANT: Validations are skipped in order to get contract under bytecode limit  *  * @param _underlying               Address of underlying token to remove  */ function removeCompoundMarket(IERC20 _underlying) external onlyOwner {     require(address(underlyingToCToken[_underlying]) != address(0), "Not added");     delete underlyingToCToken[_underlying]; }  /**  * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {     sync(_setToken, false); }  /**  * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.  * Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {     sync(_setToken, true); }  /**  * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {     int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));      require(componentDebt &lt; 0, "Component must be negative");      uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);      _borrow(_setToken, underlyingToCToken[_component], notionalDebt); }  /**  * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {     int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));      require(componentDebt &lt; 0, "Component must be negative");      uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);      _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt); }   /* ============ External Getter Functions ============ */  /**  * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an  * array of underlying that are borrow assets.  *  * @return                    Collateral cToken assets that are enabled  * @return                    Underlying borrowed assets that are enabled.  */ function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {     return (         enabledAssets[_setToken].collateralCTokens,         enabledAssets[_setToken].borrowAssets     ); }  /* ============ Internal Functions ============ */  /**  * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be  * unwrapped as it only accepts the underlying ETH.  */ function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {     if (_cToken == cEther) {         _setToken.invokeUnwrapWETH(address(weth), _mintNotional);          _setToken.invokeMintCEther(_cToken, _mintNotional);     } else {         _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);          _setToken.invokeMintCToken(_cToken, _mintNotional);     } }  /**  * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.  */ function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {     _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);      if (_cToken == cEther) {         _setToken.invokeWrapWETH(address(weth), _redeemNotional);     } }  /**  * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.  */ function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {     if (_cToken == cEther) {         _setToken.invokeUnwrapWETH(address(weth), _repayNotional);          _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);     } else {         // Approve to cToken         _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);         _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);     } }  /**  * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.  */ function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {     _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);     if (_cToken == cEther) {         _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);     } }  /**  * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken  *  * @return receiveTokenQuantity The quantity of tokens received post-trade  */ function _executeTrade(     ActionInfo memory _actionInfo,     IERC20 _sendToken,     IERC20 _receiveToken,     bytes memory _data )     internal     returns (uint256) {      ISetToken setToken = _actionInfo.setToken;      uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;       setToken.invokeApprove(         address(_sendToken),         _actionInfo.exchangeAdapter.getSpender(),         notionalSendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _actionInfo.exchangeAdapter.getTradeCalldata(         address(_sendToken),         address(_receiveToken),         address(setToken),         notionalSendQuantity,         _actionInfo.minNotionalReceiveQuantity,         _data     );      setToken.invoke(targetExchange, callValue, methodData);      uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);     require(         receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,         "Slippage too high"     );      return receiveTokenQuantity; }  /**  * Calculates protocol fee on module and pays protocol fee from SetToken  */ function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {     uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);      payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);      return protocolFeeTotal; }  /**  * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)  */ function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {     _updateCollateralPosition(         actionInfo.setToken,         actionInfo.collateralCTokenAsset,         _getCollateralPosition(             actionInfo.setToken,             actionInfo.collateralCTokenAsset,             actionInfo.setTotalSupply         )     );      _updateBorrowPosition(         actionInfo.setToken,         _borrowAsset,         _getBorrowPosition(             actionInfo.setToken,             actionInfo.borrowCTokenAsset,             actionInfo.setTotalSupply,             false // Do not accrue interest         )     ); }  function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {     _setToken.editDefaultPosition(address(_cToken), _newPositionUnit); }  function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {     _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, ""); }  /**  * Construct the ActionInfo struct for lever and delever  */ function _createAndValidateActionInfo(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _sendQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();      return _createAndValidateActionInfoNotional(         _setToken,         _sendToken,         _receiveToken,         _sendQuantityUnits.preciseMul(totalSupply),         _minReceiveQuantityUnits.preciseMul(totalSupply),         _tradeAdapterName,         _isLever     ); }  /**  * Construct the ActionInfo struct for lever and delever accepting notional units  */ function _createAndValidateActionInfoNotional(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _notionalSendQuantity,     uint256 _minNotionalReceiveQuantity,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();     ActionInfo memory actionInfo = ActionInfo ({         exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),         setToken: _setToken,         collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],         borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],         setTotalSupply: totalSupply,         notionalSendQuantity: _notionalSendQuantity,         minNotionalReceiveQuantity: _minNotionalReceiveQuantity,         preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))     });      _validateCommon(actionInfo);      return actionInfo; }    function _validateCommon(ActionInfo memory _actionInfo) internal view {     require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");     require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");     require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");     require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0"); }  function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {     uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));     return collateralNotionalBalance.preciseDiv(_setTotalSupply); }  /**  * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.  * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.  */ function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {     uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));     // Round negative away from 0     int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);      return borrowPositionUnit; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '/\n    Copyright 2021 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n/\n\npragma solidity 0.6.10;\npragma experimental "ABIEncoderV2";\n\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";\nimport { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\n\nimport { Compound } from "../../integration/lib/Compound.sol";\nimport { ICErc20 } from "../../../interfaces/external/ICErc20.sol";\nimport { IComptroller } from "../../../interfaces/external/IComptroller.sol";\nimport { IController } from "../../../interfaces/IController.sol";\nimport { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";\nimport { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";\nimport { ISetToken } from "../../../interfaces/ISetToken.sol";\nimport { ModuleBase } from "../../lib/ModuleBase.sol";\n\n/\n * @title CompoundLeverageModule\n * @author Set Protocol\n \n * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call\n * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each\n * asset is leveraged when using this module.\n \n * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of\n * debt when borrowed assets are the same.\n \n /\ncontract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {\n    using Compound for ISetToken;\n\n    / ============ Structs ============ /\n\n    struct EnabledAssets {\n        address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken\n        address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken\n        address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets\n    }\n\n    struct ActionInfo {\n        ISetToken setToken;                      // SetToken instance\n        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance\n        uint256 setTotalSupply;                  // Total supply of SetToken\n        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange\n        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange\n        ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset\n        ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset\n        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance\n    }\n\n    / ============ Events ============ /\n\n    event LeverageIncreased(\n        ISetToken indexed _setToken,\n        IERC20 indexed _borrowAsset,\n        IERC20 indexed _collateralAsset,\n        IExchangeAdapter _exchangeAdapter,\n        uint256 _totalBorrowAmount,\n        uint256 _totalReceiveAmount,\n        uint256 _protocolFee\n    );\n\n    event LeverageDecreased(\n        ISetToken indexed _setToken,\n        IERC20 indexed _collateralAsset,\n        IERC20 indexed _repayAsset,\n        IExchangeAdapter _exchangeAdapter,\n        uint256 _totalRedeemAmount,\n        uint256 _totalRepayAmount,\n        uint256 _protocolFee\n    );\n\n    event CollateralAssetsUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added,\n        IERC20[] _assets\n    );\n\n    event BorrowAssetsUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added,\n        IERC20[] _assets\n    );\n\n    event SetTokenStatusUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added\n    );\n\n    event AnySetAllowedUpdated(\n        bool indexed _anySetAllowed\n    );\n\n    / ============ Constants ============ /\n\n    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as\n    // the string as the integration name\n    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";\n\n    // 0 index stores protocol fee % on the controller, charged in the trade function\n    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;\n\n    / ============ State Variables ============ /\n\n    // Mapping of underlying to CToken. If ETH, then map WETH to cETH\n    mapping(IERC20 =&gt; ICErc20) public underlyingToCToken;\n\n    // Wrapped Ether address\n    IERC20 internal weth;\n\n    // Compound cEther address\n    ICErc20 internal cEther;\n\n    // Compound Comptroller contract\n    IComptroller internal comptroller;\n\n    // COMP token address\n    IERC20 internal compToken;\n\n    // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken\n    mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public collateralCTokenEnabled;\n\n    // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken\n    mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public borrowCTokenEnabled;\n\n    // Mapping of enabled collateral and borrow cTokens for syncing positions\n    mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;\n\n    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance\n    mapping(ISetToken =&gt; bool) public allowedSetTokens;\n\n    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list\n    bool public anySetAllowed;\n\n\n    / ============ Constructor ============ /\n\n    /\n     * Instantiate addresses. Underlying to cToken mapping is created.\n     \n     * @param _controller               Address of controller contract\n     * @param _compToken                Address of COMP token\n     * @param _comptroller              Address of Compound Comptroller\n     * @param _cEther                   Address of cEther contract\n     * @param _weth                     Address of WETH contract\n     /\n    constructor(\n        IController _controller,\n        IERC20 _compToken,\n        IComptroller _comptroller,\n        ICErc20 _cEther,\n        IERC20 _weth\n    )\n        public\n        ModuleBase(_controller)\n    {\n        compToken = _compToken;\n        comptroller = _comptroller;\n        cEther = _cEther;\n        weth = _weth;\n\n        ICErc20[] memory cTokens = comptroller.getAllMarkets();\n\n        for(uint256 i = 0; i &lt; cTokens.length; i++) {\n            ICErc20 cToken = cTokens[i];\n            underlyingToCToken[\n                cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())\n            ] = cToken;\n        }\n    }\n\n    / ============ External Functions ============ /\n\n    /\n     * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.\n     * Performs a DEX trade, exchanging the borrow asset for collateral asset.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _borrowAsset          Address of asset being borrowed for leverage\n     * @param _collateralAsset      Address of collateral asset (underlying of cToken)\n     * @param _borrowQuantity       Borrow quantity of asset in position units\n     * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units\n     * @param _tradeAdapterName     Name of trade adapter\n     * @param _tradeData            Arbitrary data for trade\n     /\n    function lever(\n        ISetToken _setToken,\n        IERC20 _borrowAsset,\n        IERC20 _collateralAsset,\n        uint256 _borrowQuantity,\n        uint256 _minReceiveQuantity,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from\n        // collateral asset\n        ActionInfo memory leverInfo = _createAndValidateActionInfo(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            _borrowQuantity,\n            _minReceiveQuantity,\n            _tradeAdapterName,\n            true\n        );\n\n        _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);\n\n        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);\n\n        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n        _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);\n\n        _updateLeverPositions(leverInfo, _borrowAsset);\n\n        emit LeverageIncreased(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            leverInfo.exchangeAdapter,\n            leverInfo.notionalSendQuantity,\n            postTradeCollateralQuantity,\n            protocolFee\n        );\n    }\n\n    /\n     * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _collateralAsset      Address of collateral asset (underlying of cToken)\n     * @param _repayAsset           Address of asset being repaid\n     * @param _redeemQuantity       Quantity of collateral asset to delever\n     * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade\n     * @param _tradeAdapterName     Name of trade adapter\n     * @param _tradeData            Arbitrary data for trade\n     /\n    function delever(\n        ISetToken _setToken,\n        IERC20 _collateralAsset,\n        IERC20 _repayAsset,\n        uint256 _redeemQuantity,\n        uint256 _minRepayQuantity,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from\n        // repay asset\n        ActionInfo memory deleverInfo = _createAndValidateActionInfo(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            _redeemQuantity,\n            _minRepayQuantity,\n            _tradeAdapterName,\n            false\n        );\n\n        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);\n\n        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);\n\n        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);\n\n        _updateLeverPositions(deleverInfo, _repayAsset);\n\n        emit LeverageDecreased(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            deleverInfo.exchangeAdapter,\n            deleverInfo.notionalSendQuantity,\n            repayQuantity,\n            protocolFee\n        );\n    }\n\n    /\n     * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received\n     * borrow asset is updated as equity. No protocol fee is charged.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _collateralAsset      Address of collateral asset (underlying of cToken)\n     * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)\n     * @param _redeemQuantity       Quantity of collateral asset to delever\n     * @param _tradeAdapterName     Name of trade adapter\n     * @param _tradeData            Arbitrary data for trade\n     /\n    function deleverToZeroBorrowBalance(\n        ISetToken _setToken,\n        IERC20 _collateralAsset,\n        IERC20 _repayAsset,\n        uint256 _redeemQuantity,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());\n\n        require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");\n        uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));\n\n        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            notionalRedeemQuantity,\n            notionalRepayQuantity,\n            _tradeAdapterName,\n            false\n        );\n\n        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);\n\n        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n\n        // We use notionalRepayQuantity vs. Compound\'s max value uint256(-1) to handle WETH properly\n        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);\n\n        // Update default position first to save gas on editing borrow position\n        _setToken.calculateAndEditDefaultPosition(\n            address(_repayAsset),\n            deleverInfo.setTotalSupply,\n            deleverInfo.preTradeReceiveTokenBalance\n        );\n\n        _updateLeverPositions(deleverInfo, _repayAsset);\n\n        emit LeverageDecreased(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            deleverInfo.exchangeAdapter,\n            deleverInfo.notionalSendQuantity,\n            notionalRepayQuantity,\n            0 // No protocol fee\n        );\n    }\n\n    /\n     * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral\n     * assets, update cToken default position. For borrow assets, update external borrow position.\n     * - Collateral assets may come out of sync when a position is liquidated\n     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid\n     \n     * @param _setToken               Instance of the SetToken\n     * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value\n     /\n    function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {\n        uint256 setTotalSupply = _setToken.totalSupply();\n\n        // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption\n        if (setTotalSupply &gt; 0) {\n            // Loop through collateral assets\n            address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;\n            for(uint256 i = 0; i &lt; collateralCTokens.length; i++) {\n                ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);\n                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();\n                uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);\n\n                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets\n                if (previousPositionUnit != newPositionUnit) {\n                  _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);\n                }\n            }\n\n            // Loop through borrow assets\n            address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;\n            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;\n            for(uint256 i = 0; i &lt; borrowCTokens.length; i++) {\n                ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);\n                IERC20 borrowAsset = IERC20(borrowAssets[i]);\n\n                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));\n\n                int256 newPositionUnit = _getBorrowPosition(\n                    _setToken,\n                    borrowCToken,\n                    setTotalSupply,\n                    _shouldAccrueInterest\n                );\n\n                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets\n                if (newPositionUnit != previousPositionUnit) {\n                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);\n                }\n            }\n        }\n    }\n\n\n    /\n     * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken\'s manager. Note: managers can enable\n     * collateral and borrow assets that don\'t exist as positions on the SetToken\n     \n     * @param _setToken             Instance of the SetToken to initialize\n     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken\n     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken\n     /\n    function initialize(\n        ISetToken _setToken,\n        IERC20[] memory _collateralAssets,\n        IERC20[] memory _borrowAssets\n    )\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        if (!anySetAllowed) {\n            require(allowedSetTokens[_setToken], "Not allowed SetToken");\n        }\n\n        // Initialize module before trying register\n        _setToken.initializeModule();\n\n        // Get debt issuance module registered to this module and require that it is initialized\n        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");\n\n        // Try if register exists on any of the modules including the debt issuance module\n        address[] memory modules = _setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}\n        }\n\n        // Enable collateral and borrow assets on Compound\n        addCollateralAssets(_setToken, _collateralAssets);\n\n        addBorrowAssets(_setToken, _borrowAssets);\n    }\n\n    /\n     * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled\n     * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)\n     /\n    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {\n        ISetToken setToken = ISetToken(msg.sender);\n\n        // Sync Compound and SetToken positions prior to any removal action\n        sync(setToken, true);\n\n        address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;\n        for (uint256 i = 0; i &lt; borrowCTokens.length; i++) {\n            ICErc20 cToken = ICErc20(borrowCTokens[i]);\n\n            // Will exit only if token isn\'t also being used as collateral\n            if(!collateralCTokenEnabled[setToken][cToken]) {\n                // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound\n                setToken.invokeExitMarket(cToken, comptroller);\n            }\n\n            delete borrowCTokenEnabled[setToken][cToken];\n        }\n\n        address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;\n        for (uint256 i = 0; i &lt; collateralCTokens.length; i++) {\n            ICErc20 cToken = ICErc20(collateralCTokens[i]);\n\n            setToken.invokeExitMarket(cToken, comptroller);\n\n            delete collateralCTokenEnabled[setToken][cToken];\n        }\n\n        delete enabledAssets[setToken];\n\n        // Try if unregister exists on any of the modules\n        address[] memory modules = setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}\n        }\n    }\n\n    /\n     * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken\n     * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state\n     * inconsistencies\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _debtIssuanceModule   Debt issuance module address to register\n     /\n    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {\n        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");\n\n        _debtIssuanceModule.registerToIssuanceModule(_setToken);\n    }\n\n    /\n     * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _newCollateralAssets  Addresses of new collateral underlying assets\n     /\n    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {\n        for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {\n            ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];\n            require(address(cToken) != address(0), "cToken must exist");\n            require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");\n\n            // Note: Will only enter market if cToken is not enabled as a borrow asset as well\n            if (!borrowCTokenEnabled[_setToken][cToken]) {\n                _setToken.invokeEnterMarkets(cToken, comptroller);\n            }\n\n            collateralCTokenEnabled[_setToken][cToken] = true;\n            enabledAssets[_setToken].collateralCTokens.push(address(cToken));\n        }\n\n        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);\n    }\n\n    /\n     * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets\n     * If there is a borrow balance, collateral asset cannot be removed\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _collateralAssets     Addresses of collateral underlying assets to remove\n     /\n    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {\n        // Sync Compound and SetToken positions prior to any removal action\n        sync(_setToken, true);\n\n        for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {\n            ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];\n            require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");\n\n            // Note: Will only exit market if cToken is not enabled as a borrow asset as well\n            // If there is an existing borrow balance, will revert and market cannot be exited on Compound\n            if (!borrowCTokenEnabled[_setToken][cToken]) {\n                _setToken.invokeExitMarket(cToken, comptroller);\n            }\n\n            delete collateralCTokenEnabled[_setToken][cToken];\n            enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));\n        }\n\n        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);\n    }\n\n    /\n     * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _newBorrowAssets      Addresses of borrow underlying assets to add\n     /\n    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {\n        for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {\n            IERC20 newBorrowAsset = _newBorrowAssets[i];\n            ICErc20 cToken = underlyingToCToken[newBorrowAsset];\n            require(address(cToken) != address(0), "cToken must exist");\n            require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");\n\n            // Note: Will only enter market if cToken is not enabled as a borrow asset as well\n            if (!collateralCTokenEnabled[_setToken][cToken]) {\n                _setToken.invokeEnterMarkets(cToken, comptroller);\n            }\n\n            borrowCTokenEnabled[_setToken][cToken] = true;\n            enabledAssets[_setToken].borrowCTokens.push(address(cToken));\n            enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));\n        }\n\n        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);\n    }\n\n    /\n     * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets\n     * If there is a borrow balance, borrow asset cannot be removed\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _borrowAssets         Addresses of borrow underlying assets to remove\n     /\n    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {\n        // Sync Compound and SetToken positions prior to any removal action\n        sync(_setToken, true);\n\n        for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {\n            ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];\n            require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");\n\n            // Note: Will only exit market if cToken is not enabled as a collateral asset as well\n            // If there is an existing borrow balance, will revert and market cannot be exited on Compound\n            if (!collateralCTokenEnabled[_setToken][cToken]) {\n                _setToken.invokeExitMarket(cToken, comptroller);\n            }\n\n            delete borrowCTokenEnabled[_setToken][cToken];\n            enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));\n            enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));\n        }\n\n        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);\n    }\n\n    /\n     * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.\n     \n     * @param _setToken             Instance of the SetToken\n     /\n    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {\n        allowedSetTokens[_setToken] = _status;\n        emit SetTokenStatusUpdated(_setToken, _status);\n    }\n\n    /\n     * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.\n     \n     * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled\n     /\n    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {\n        anySetAllowed = _anySetAllowed;\n        emit AnySetAllowedUpdated(_anySetAllowed);\n    }\n\n    /\n     * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.\n     \n     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit\n     \n     * @param _cToken                   Address of cToken to add\n     * @param _underlying               Address of underlying token that maps to cToken\n     /\n    function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {\n        require(address(underlyingToCToken[_underlying]) == address(0), "Already added");\n        underlyingToCToken[_underlying] = _cToken;\n    }\n\n    /\n     * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals\n     \n     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit\n     \n     * @param _underlying               Address of underlying token to remove\n     */\n    function removeCompoundMarket(IERC20 _underlying) external onlyOwner {\n        require(address(underlyingToCToken[_underlying]) != address(0), "Not added");\n        delete underlyingToCToken[_underlying];\n    }\n\n    /\n     * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.\n     \n     * @param _setToken             Instance of the SetToken\n     /\n    function moduleIssueHook(ISetToken _setToken, uint256 / _setTokenQuantity /) external onlyModule(_setToken) {\n        sync(_setToken, false);\n    }\n\n    /\n     * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.\n     * Only callable by valid module.\n     \n     * @param _setToken             Instance of the SetToken\n     /\n    function moduleRedeemHook(ISetToken _setToken, uint256 / _setTokenQuantity /) external onlyModule(_setToken) {\n        sync(_setToken, true);\n    }\n\n    /\n     * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken\n     * @param _component            Address of component\n     /\n    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool / _isEquity /) external onlyModule(_setToken) {\n        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n\n        require(componentDebt &lt; 0, "Component must be negative");\n\n        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);\n\n        _borrow(_setToken, underlyingToCToken[_component], notionalDebt);\n    }\n\n    /\n     * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken\n     * @param _component            Address of component\n     /\n    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool / _isEquity /) external onlyModule(_setToken) {\n        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n\n        require(componentDebt &lt; 0, "Component must be negative");\n\n        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);\n\n        _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt);\n    }\n\n\n    / ============ External Getter Functions ============ /\n\n    /\n     * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an\n     * array of underlying that are borrow assets.\n     \n     * @return                    Collateral cToken assets that are enabled\n     * @return                    Underlying borrowed assets that are enabled.\n     /\n    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {\n        return (\n            enabledAssets[_setToken].collateralCTokens,\n            enabledAssets[_setToken].borrowAssets\n        );\n    }\n\n    / ============ Internal Functions ============ /\n\n    /\n     * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be\n     * unwrapped as it only accepts the underlying ETH.\n     */\n    function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {\n        if (_cToken == cEther) {\n            _setToken.invokeUnwrapWETH(address(weth), _mintNotional);\n\n            _setToken.invokeMintCEther(_cToken, _mintNotional);\n        } else {\n            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);\n\n            _setToken.invokeMintCToken(_cToken, _mintNotional);\n        }\n    }\n\n    /\n     * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.\n     /\n    function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {\n        _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);\n\n        if (_cToken == cEther) {\n            _setToken.invokeWrapWETH(address(weth), _redeemNotional);\n        }\n    }\n\n    /\n     * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.\n     /\n    function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {\n        if (_cToken == cEther) {\n            _setToken.invokeUnwrapWETH(address(weth), _repayNotional);\n\n            _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);\n        } else {\n            // Approve to cToken\n            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);\n            _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);\n        }\n    }\n\n    /\n     * Invoke the SetToken to interact with the specified cToken to borrow the cToken\'s underlying of the specified borrowQuantity.\n     */\n    function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {\n        _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);\n        if (_cToken == cEther) {\n            _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);\n        }\n    }\n\n    /\n     * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken\n     \n     * @return receiveTokenQuantity The quantity of tokens received post-trade\n     /\n    function _executeTrade(\n        ActionInfo memory _actionInfo,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        bytes memory _data\n    )\n        internal\n        returns (uint256)\n    {\n         ISetToken setToken = _actionInfo.setToken;\n         uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;\n\n         setToken.invokeApprove(\n            address(_sendToken),\n            _actionInfo.exchangeAdapter.getSpender(),\n            notionalSendQuantity\n        );\n\n        (\n            address targetExchange,\n            uint256 callValue,\n            bytes memory methodData\n        ) = _actionInfo.exchangeAdapter.getTradeCalldata(\n            address(_sendToken),\n            address(_receiveToken),\n            address(setToken),\n            notionalSendQuantity,\n            _actionInfo.minNotionalReceiveQuantity,\n            _data\n        );\n\n        setToken.invoke(targetExchange, callValue, methodData);\n\n        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);\n        require(\n            receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,\n            "Slippage too high"\n        );\n\n        return receiveTokenQuantity;\n    }\n\n    /\n     * Calculates protocol fee on module and pays protocol fee from SetToken\n     */\n    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {\n        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);\n\n        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);\n\n        return protocolFeeTotal;\n    }\n\n    /\n     * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)\n     /\n    function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {\n        _updateCollateralPosition(\n            actionInfo.setToken,\n            actionInfo.collateralCTokenAsset,\n            _getCollateralPosition(\n                actionInfo.setToken,\n                actionInfo.collateralCTokenAsset,\n                actionInfo.setTotalSupply\n            )\n        );\n\n        _updateBorrowPosition(\n            actionInfo.setToken,\n            _borrowAsset,\n            _getBorrowPosition(\n                actionInfo.setToken,\n                actionInfo.borrowCTokenAsset,\n                actionInfo.setTotalSupply,\n                false // Do not accrue interest\n            )\n        );\n    }\n\n    function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {\n        _setToken.editDefaultPosition(address(_cToken), _newPositionUnit);\n    }\n\n    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {\n        _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, "");\n    }\n\n    /\n     * Construct the ActionInfo struct for lever and delever\n     /\n    function _createAndValidateActionInfo(\n        ISetToken _setToken,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        uint256 _sendQuantityUnits,\n        uint256 _minReceiveQuantityUnits,\n        string memory _tradeAdapterName,\n        bool _isLever\n    )\n        internal\n        view\n        returns(ActionInfo memory)\n    {\n        uint256 totalSupply = _setToken.totalSupply();\n\n        return _createAndValidateActionInfoNotional(\n            _setToken,\n            _sendToken,\n            _receiveToken,\n            _sendQuantityUnits.preciseMul(totalSupply),\n            _minReceiveQuantityUnits.preciseMul(totalSupply),\n            _tradeAdapterName,\n            _isLever\n        );\n    }\n\n    /\n     * Construct the ActionInfo struct for lever and delever accepting notional units\n     */\n    function _createAndValidateActionInfoNotional(\n        ISetToken _setToken,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        uint256 _notionalSendQuantity,\n        uint256 _minNotionalReceiveQuantity,\n        string memory _tradeAdapterName,\n        bool _isLever\n    )\n        internal\n        view\n        returns(ActionInfo memory)\n    {\n        uint256 totalSupply = _setToken.totalSupply();\n        ActionInfo memory actionInfo = ActionInfo ({\n            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),\n            setToken: _setToken,\n            collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],\n            borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],\n            setTotalSupply: totalSupply,\n            notionalSendQuantity: _notionalSendQuantity,\n            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,\n            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))\n        });\n\n        _validateCommon(actionInfo);\n\n        return actionInfo;\n    }\n\n\n\n    function _validateCommon(ActionInfo memory _actionInfo) internal view {\n        require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");\n        require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");\n        require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");\n        require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0");\n    }\n\n    function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {\n        uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));\n        return collateralNotionalBalance.preciseDiv(_setTotalSupply);\n    }\n\n    /\n     * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.\n     * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.\n     */\n    function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {\n        uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));\n        // Round negative away from 0\n        int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);\n\n        return borrowPositionUnit;\n    }\n}', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 02:00:24 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { Compound } from "../../integration/lib/Compound.sol"; import { ICErc20 } from "../../../interfaces/external/ICErc20.sol"; import { IComptroller } from "../../../interfaces/external/IComptroller.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol"; import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; /*  * @title CompoundLeverageModule  * @author Set Protocol  *  * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call  * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each  * asset is leveraged when using this module.  *  * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of  * debt when borrowed assets are the same.  *  / contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {     using Compound for ISetToken; /* ============ Structs ============ */  struct EnabledAssets {     address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken     address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken     address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets }  struct ActionInfo {     ISetToken setToken;                      // SetToken instance     IExchangeAdapter exchangeAdapter;        // Exchange adapter instance     uint256 setTotalSupply;                  // Total supply of SetToken     uint256 notionalSendQuantity;            // Total notional quantity sent to exchange     uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange     ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset     ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset     uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance }  /* ============ Events ============ */  event LeverageIncreased(     ISetToken indexed _setToken,     IERC20 indexed _borrowAsset,     IERC20 indexed _collateralAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalBorrowAmount,     uint256 _totalReceiveAmount,     uint256 _protocolFee );  event LeverageDecreased(     ISetToken indexed _setToken,     IERC20 indexed _collateralAsset,     IERC20 indexed _repayAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalRedeemAmount,     uint256 _totalRepayAmount,     uint256 _protocolFee );  event CollateralAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  event BorrowAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  event SetTokenStatusUpdated(     ISetToken indexed _setToken,     bool indexed _added );  event AnySetAllowedUpdated(     bool indexed _anySetAllowed );  /* ============ Constants ============ */  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the trade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Mapping of underlying to CToken. If ETH, then map WETH to cETH mapping(IERC20 =&gt; ICErc20) public underlyingToCToken;  // Wrapped Ether address IERC20 internal weth;  // Compound cEther address ICErc20 internal cEther;  // Compound Comptroller contract IComptroller internal comptroller;  // COMP token address IERC20 internal compToken;  // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public collateralCTokenEnabled;  // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public borrowCTokenEnabled;  // Mapping of enabled collateral and borrow cTokens for syncing positions mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;  // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance mapping(ISetToken =&gt; bool) public allowedSetTokens;  // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list bool public anySetAllowed;   /* ============ Constructor ============ */  /**  * Instantiate addresses. Underlying to cToken mapping is created.  *  * @param _controller               Address of controller contract  * @param _compToken                Address of COMP token  * @param _comptroller              Address of Compound Comptroller  * @param _cEther                   Address of cEther contract  * @param _weth                     Address of WETH contract  */ constructor(     IController _controller,     IERC20 _compToken,     IComptroller _comptroller,     ICErc20 _cEther,     IERC20 _weth )     public     ModuleBase(_controller) {     compToken = _compToken;     comptroller = _comptroller;     cEther = _cEther;     weth = _weth;      ICErc20[] memory cTokens = comptroller.getAllMarkets();      for(uint256 i = 0; i &lt; cTokens.length; i++) {         ICErc20 cToken = cTokens[i];         underlyingToCToken[             cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())         ] = cToken;     } }  /* ============ External Functions ============ */  /**  * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.  * Performs a DEX trade, exchanging the borrow asset for collateral asset.  *  * @param _setToken             Instance of the SetToken  * @param _borrowAsset          Address of asset being borrowed for leverage  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _borrowQuantity       Borrow quantity of asset in position units  * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function lever(     ISetToken _setToken,     IERC20 _borrowAsset,     IERC20 _collateralAsset,     uint256 _borrowQuantity,     uint256 _minReceiveQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // For levering up, send quantity is derived from borrow asset and receive quantity is derived from     // collateral asset     ActionInfo memory leverInfo = _createAndValidateActionInfo(         _setToken,         _borrowAsset,         _collateralAsset,         _borrowQuantity,         _minReceiveQuantity,         _tradeAdapterName,         true     );      _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);      uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);      _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);      _updateLeverPositions(leverInfo, _borrowAsset);      emit LeverageIncreased(         _setToken,         _borrowAsset,         _collateralAsset,         leverInfo.exchangeAdapter,         leverInfo.notionalSendQuantity,         postTradeCollateralQuantity,         protocolFee     ); }  /**  * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled  *  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _repayAsset           Address of asset being repaid  * @param _redeemQuantity       Quantity of collateral asset to delever  * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function delever(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantity,     uint256 _minRepayQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from     // repay asset     ActionInfo memory deleverInfo = _createAndValidateActionInfo(         _setToken,         _collateralAsset,         _repayAsset,         _redeemQuantity,         _minRepayQuantity,         _tradeAdapterName,         false     );      _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);      uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);      _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);      _updateLeverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         repayQuantity,         protocolFee     ); }  /**  * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received  * borrow asset is updated as equity. No protocol fee is charged.  *  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)  * @param _redeemQuantity       Quantity of collateral asset to delever  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function deleverToZeroBorrowBalance(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());      require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");     uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));      ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(         _setToken,         _collateralAsset,         _repayAsset,         notionalRedeemQuantity,         notionalRepayQuantity,         _tradeAdapterName,         false     );      _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);      _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly     _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);      // Update default position first to save gas on editing borrow position     _setToken.calculateAndEditDefaultPosition(         address(_repayAsset),         deleverInfo.setTotalSupply,         deleverInfo.preTradeReceiveTokenBalance     );      _updateLeverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         notionalRepayQuantity,         0 // No protocol fee     ); }  /**  * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral  * assets, update cToken default position. For borrow assets, update external borrow position.  * - Collateral assets may come out of sync when a position is liquidated  * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid  *  * @param _setToken               Instance of the SetToken  * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value  */ function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {     uint256 setTotalSupply = _setToken.totalSupply();      // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption     if (setTotalSupply &gt; 0) {         // Loop through collateral assets         address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;         for(uint256 i = 0; i &lt; collateralCTokens.length; i++) {             ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);             uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();             uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (previousPositionUnit != newPositionUnit) {               _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);             }         }          // Loop through borrow assets         address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;         address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;         for(uint256 i = 0; i &lt; borrowCTokens.length; i++) {             ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);             IERC20 borrowAsset = IERC20(borrowAssets[i]);              int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));              int256 newPositionUnit = _getBorrowPosition(                 _setToken,                 borrowCToken,                 setTotalSupply,                 _shouldAccrueInterest             );              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (newPositionUnit != previousPositionUnit) {                 _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);             }         }     } }   /**  * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable  * collateral and borrow assets that don't exist as positions on the SetToken  *  * @param _setToken             Instance of the SetToken to initialize  * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken  * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken  */ function initialize(     ISetToken _setToken,     IERC20[] memory _collateralAssets,     IERC20[] memory _borrowAssets )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     if (!anySetAllowed) {         require(allowedSetTokens[_setToken], "Not allowed SetToken");     }      // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}     }      // Enable collateral and borrow assets on Compound     addCollateralAssets(_setToken, _collateralAssets);      addBorrowAssets(_setToken, _borrowAssets); }  /**  * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled  * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)  */ function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Sync Compound and SetToken positions prior to any removal action     sync(setToken, true);      address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;     for (uint256 i = 0; i &lt; borrowCTokens.length; i++) {         ICErc20 cToken = ICErc20(borrowCTokens[i]);          // Will exit only if token isn't also being used as collateral         if(!collateralCTokenEnabled[setToken][cToken]) {             // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound             setToken.invokeExitMarket(cToken, comptroller);         }          delete borrowCTokenEnabled[setToken][cToken];     }      address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;     for (uint256 i = 0; i &lt; collateralCTokens.length; i++) {         ICErc20 cToken = ICErc20(collateralCTokens[i]);          setToken.invokeExitMarket(cToken, comptroller);          delete collateralCTokenEnabled[setToken][cToken];     }      delete enabledAssets[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken  * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state  * inconsistencies  *  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets  *  * @param _setToken             Instance of the SetToken  * @param _newCollateralAssets  Addresses of new collateral underlying assets  */ function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {     for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];         require(address(cToken) != address(0), "cToken must exist");         require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");          // Note: Will only enter market if cToken is not enabled as a borrow asset as well         if (!borrowCTokenEnabled[_setToken][cToken]) {             _setToken.invokeEnterMarkets(cToken, comptroller);         }          collateralCTokenEnabled[_setToken][cToken] = true;         enabledAssets[_setToken].collateralCTokens.push(address(cToken));     }      emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets); }  /**  * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets  * If there is a borrow balance, collateral asset cannot be removed  *  * @param _setToken             Instance of the SetToken  * @param _collateralAssets     Addresses of collateral underlying assets to remove  */ function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {     // Sync Compound and SetToken positions prior to any removal action     sync(_setToken, true);      for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];         require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");          // Note: Will only exit market if cToken is not enabled as a borrow asset as well         // If there is an existing borrow balance, will revert and market cannot be exited on Compound         if (!borrowCTokenEnabled[_setToken][cToken]) {             _setToken.invokeExitMarket(cToken, comptroller);         }          delete collateralCTokenEnabled[_setToken][cToken];         enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));     }      emit CollateralAssetsUpdated(_setToken, false, _collateralAssets); }  /**  * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets  *  * @param _setToken             Instance of the SetToken  * @param _newBorrowAssets      Addresses of borrow underlying assets to add  */ function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {     for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {         IERC20 newBorrowAsset = _newBorrowAssets[i];         ICErc20 cToken = underlyingToCToken[newBorrowAsset];         require(address(cToken) != address(0), "cToken must exist");         require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");          // Note: Will only enter market if cToken is not enabled as a borrow asset as well         if (!collateralCTokenEnabled[_setToken][cToken]) {             _setToken.invokeEnterMarkets(cToken, comptroller);         }          borrowCTokenEnabled[_setToken][cToken] = true;         enabledAssets[_setToken].borrowCTokens.push(address(cToken));         enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));     }      emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets); }  /**  * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets  * If there is a borrow balance, borrow asset cannot be removed  *  * @param _setToken             Instance of the SetToken  * @param _borrowAssets         Addresses of borrow underlying assets to remove  */ function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {     // Sync Compound and SetToken positions prior to any removal action     sync(_setToken, true);      for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];         require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");          // Note: Will only exit market if cToken is not enabled as a collateral asset as well         // If there is an existing borrow balance, will revert and market cannot be exited on Compound         if (!collateralCTokenEnabled[_setToken][cToken]) {             _setToken.invokeExitMarket(cToken, comptroller);         }          delete borrowCTokenEnabled[_setToken][cToken];         enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));         enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));     }      emit BorrowAssetsUpdated(_setToken, false, _borrowAssets); }  /**  * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.  *  * @param _setToken             Instance of the SetToken  */ function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {     allowedSetTokens[_setToken] = _status;     emit SetTokenStatusUpdated(_setToken, _status); }  /**  * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.  *  * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled  */ function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {     anySetAllowed = _anySetAllowed;     emit AnySetAllowedUpdated(_anySetAllowed); }  /**  * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.  *  * IMPORTANT: Validations are skipped in order to get contract under bytecode limit  *  * @param _cToken                   Address of cToken to add  * @param _underlying               Address of underlying token that maps to cToken  */ function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {     require(address(underlyingToCToken[_underlying]) == address(0), "Already added");     underlyingToCToken[_underlying] = _cToken; }  /**  * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals  *  * IMPORTANT: Validations are skipped in order to get contract under bytecode limit  *  * @param _underlying               Address of underlying token to remove  */ function removeCompoundMarket(IERC20 _underlying) external onlyOwner {     require(address(underlyingToCToken[_underlying]) != address(0), "Not added");     delete underlyingToCToken[_underlying]; }  /**  * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {     sync(_setToken, false); }  /**  * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.  * Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {     sync(_setToken, true); }  /**  * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {     int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));      require(componentDebt &lt; 0, "Component must be negative");      uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);      _borrow(_setToken, underlyingToCToken[_component], notionalDebt); }  /**  * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {     int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));      require(componentDebt &lt; 0, "Component must be negative");      uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);      _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt); }   /* ============ External Getter Functions ============ */  /**  * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an  * array of underlying that are borrow assets.  *  * @return                    Collateral cToken assets that are enabled  * @return                    Underlying borrowed assets that are enabled.  */ function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {     return (         enabledAssets[_setToken].collateralCTokens,         enabledAssets[_setToken].borrowAssets     ); }  /* ============ Internal Functions ============ */  /**  * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be  * unwrapped as it only accepts the underlying ETH.  */ function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {     if (_cToken == cEther) {         _setToken.invokeUnwrapWETH(address(weth), _mintNotional);          _setToken.invokeMintCEther(_cToken, _mintNotional);     } else {         _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);          _setToken.invokeMintCToken(_cToken, _mintNotional);     } }  /**  * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.  */ function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {     _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);      if (_cToken == cEther) {         _setToken.invokeWrapWETH(address(weth), _redeemNotional);     } }  /**  * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.  */ function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {     if (_cToken == cEther) {         _setToken.invokeUnwrapWETH(address(weth), _repayNotional);          _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);     } else {         // Approve to cToken         _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);         _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);     } }  /**  * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.  */ function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {     _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);     if (_cToken == cEther) {         _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);     } }  /**  * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken  *  * @return receiveTokenQuantity The quantity of tokens received post-trade  */ function _executeTrade(     ActionInfo memory _actionInfo,     IERC20 _sendToken,     IERC20 _receiveToken,     bytes memory _data )     internal     returns (uint256) {      ISetToken setToken = _actionInfo.setToken;      uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;       setToken.invokeApprove(         address(_sendToken),         _actionInfo.exchangeAdapter.getSpender(),         notionalSendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _actionInfo.exchangeAdapter.getTradeCalldata(         address(_sendToken),         address(_receiveToken),         address(setToken),         notionalSendQuantity,         _actionInfo.minNotionalReceiveQuantity,         _data     );      setToken.invoke(targetExchange, callValue, methodData);      uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);     require(         receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,         "Slippage too high"     );      return receiveTokenQuantity; }  /**  * Calculates protocol fee on module and pays protocol fee from SetToken  */ function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {     uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);      payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);      return protocolFeeTotal; }  /**  * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)  */ function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {     _updateCollateralPosition(         actionInfo.setToken,         actionInfo.collateralCTokenAsset,         _getCollateralPosition(             actionInfo.setToken,             actionInfo.collateralCTokenAsset,             actionInfo.setTotalSupply         )     );      _updateBorrowPosition(         actionInfo.setToken,         _borrowAsset,         _getBorrowPosition(             actionInfo.setToken,             actionInfo.borrowCTokenAsset,             actionInfo.setTotalSupply,             false // Do not accrue interest         )     ); }  function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {     _setToken.editDefaultPosition(address(_cToken), _newPositionUnit); }  function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {     _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, ""); }  /**  * Construct the ActionInfo struct for lever and delever  */ function _createAndValidateActionInfo(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _sendQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();      return _createAndValidateActionInfoNotional(         _setToken,         _sendToken,         _receiveToken,         _sendQuantityUnits.preciseMul(totalSupply),         _minReceiveQuantityUnits.preciseMul(totalSupply),         _tradeAdapterName,         _isLever     ); }  /**  * Construct the ActionInfo struct for lever and delever accepting notional units  */ function _createAndValidateActionInfoNotional(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _notionalSendQuantity,     uint256 _minNotionalReceiveQuantity,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();     ActionInfo memory actionInfo = ActionInfo ({         exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),         setToken: _setToken,         collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],         borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],         setTotalSupply: totalSupply,         notionalSendQuantity: _notionalSendQuantity,         minNotionalReceiveQuantity: _minNotionalReceiveQuantity,         preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))     });      _validateCommon(actionInfo);      return actionInfo; }    function _validateCommon(ActionInfo memory _actionInfo) internal view {     require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");     require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");     require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");     require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0"); }  function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {     uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));     return collateralNotionalBalance.preciseDiv(_setTotalSupply); }  /**  * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.  * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.  */ function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {     uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));     // Round negative away from 0     int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);      return borrowPositionUnit; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 02:00:24 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { Compound } from "../../integration/lib/Compound.sol";
import { ICErc20 } from "../../../interfaces/external/ICErc20.sol";
import { IComptroller } from "../../../interfaces/external/IComptroller.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title CompoundLeverageModule
 * @author Set Protocol
 *
 * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call
 * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each
 * asset is leveraged when using this module.
 *
 * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 *
 */
contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {
    using Compound for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken
        address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken
        address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset
        ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    /* ============ Events ============ */

    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the trade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping of underlying to CToken. If ETH, then map WETH to cETH
    mapping(IERC20 => ICErc20) public underlyingToCToken;

    // Wrapped Ether address
    IERC20 internal weth;

    // Compound cEther address
    ICErc20 internal cEther;

    // Compound Comptroller contract
    IComptroller internal comptroller;

    // COMP token address
    IERC20 internal compToken;

    // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public collateralCTokenEnabled;

    // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public borrowCTokenEnabled;

    // Mapping of enabled collateral and borrow cTokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list
    bool public anySetAllowed;


    /* ============ Constructor ============ */

    /**
     * Instantiate addresses. Underlying to cToken mapping is created.
     *
     * @param _controller               Address of controller contract
     * @param _compToken                Address of COMP token
     * @param _comptroller              Address of Compound Comptroller
     * @param _cEther                   Address of cEther contract
     * @param _weth                     Address of WETH contract
     */
    constructor(
        IController _controller,
        IERC20 _compToken,
        IComptroller _comptroller,
        ICErc20 _cEther,
        IERC20 _weth
    )
        public
        ModuleBase(_controller)
    {
        compToken = _compToken;
        comptroller = _comptroller;
        cEther = _cEther;
        weth = _weth;

        ICErc20[] memory cTokens = comptroller.getAllMarkets();

        for(uint256 i = 0; i < cTokens.length; i++) {
            ICErc20 cToken = cTokens[i];
            underlyingToCToken[
                cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())
            ] = cToken;
        }
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.
     * Performs a DEX trade, exchanging the borrow asset for collateral asset.
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAsset          Address of asset being borrowed for leverage
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _borrowQuantity       Borrow quantity of asset in position units
     * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantity,
        uint256 _minReceiveQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantity,
            _minReceiveQuantity,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        uint256 _minRepayQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantity,
            _minRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received
     * borrow asset is updated as equity. No protocol fee is charged.
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());

        require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly
        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);

        // Update default position first to save gas on editing borrow position
        _setToken.calculateAndEditDefaultPosition(
            address(_repayAsset),
            deleverInfo.setTotalSupply,
            deleverInfo.preTradeReceiveTokenBalance
        );

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0 // No protocol fee
        );
    }

    /**
     * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral
     * assets, update cToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     *
     * @param _setToken               Instance of the SetToken
     * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value
     */
    function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption
        if (setTotalSupply > 0) {
            // Loop through collateral assets
            address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;
            for(uint256 i = 0; i < collateralCTokens.length; i++) {
                ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);
                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);
                }
            }

            // Loop through borrow assets
            address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;
            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowCTokens.length; i++) {
                ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));

                int256 newPositionUnit = _getBorrowPosition(
                    _setToken,
                    borrowCToken,
                    setTotalSupply,
                    _shouldAccrueInterest
                );

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }


    /**
     * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable
     * collateral and borrow assets that don't exist as positions on the SetToken
     *
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // Enable collateral and borrow assets on Compound
        addCollateralAssets(_setToken, _collateralAssets);

        addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled
     * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Compound and SetToken positions prior to any removal action
        sync(setToken, true);

        address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;
        for (uint256 i = 0; i < borrowCTokens.length; i++) {
            ICErc20 cToken = ICErc20(borrowCTokens[i]);

            // Will exit only if token isn't also being used as collateral
            if(!collateralCTokenEnabled[setToken][cToken]) {
                // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound
                setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[setToken][cToken];
        }

        address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;
        for (uint256 i = 0; i < collateralCTokens.length; i++) {
            ICErc20 cToken = ICErc20(collateralCTokens[i]);

            setToken.invokeExitMarket(cToken, comptroller);

            delete collateralCTokenEnabled[setToken][cToken];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken
     * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];
            require(address(cToken) != address(0), "cToken must exist");
            require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            collateralCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].collateralCTokens.push(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets
     * If there is a borrow balance, collateral asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];
            require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");

            // Note: Will only exit market if cToken is not enabled as a borrow asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete collateralCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 newBorrowAsset = _newBorrowAssets[i];
            ICErc20 cToken = underlyingToCToken[newBorrowAsset];
            require(address(cToken) != address(0), "cToken must exist");
            require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            borrowCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].borrowCTokens.push(address(cToken));
            enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));
        }

        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets
     * If there is a borrow balance, borrow asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];
            require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");

            // Note: Will only exit market if cToken is not enabled as a collateral asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));
            enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));
        }

        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.
     *
     * @param _setToken             Instance of the SetToken
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.
     *
     * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _cToken                   Address of cToken to add
     * @param _underlying               Address of underlying token that maps to cToken
     */
    function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) == address(0), "Already added");
        underlyingToCToken[_underlying] = _cToken;
    }

    /**
     * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _underlying               Address of underlying token to remove
     */
    function removeCompoundMarket(IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) != address(0), "Not added");
        delete underlyingToCToken[_underlying];
    }

    /**
     * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, false);
    }

    /**
     * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.
     * Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, true);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);

        _borrow(_setToken, underlyingToCToken[_component], notionalDebt);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);

        _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt);
    }


    /* ============ External Getter Functions ============ */

    /**
     * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an
     * array of underlying that are borrow assets.
     *
     * @return                    Collateral cToken assets that are enabled
     * @return                    Underlying borrowed assets that are enabled.
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralCTokens,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be
     * unwrapped as it only accepts the underlying ETH.
     */
    function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _mintNotional);

            _setToken.invokeMintCEther(_cToken, _mintNotional);
        } else {
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);

            _setToken.invokeMintCToken(_cToken, _mintNotional);
        }
    }

    /**
     * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.
     */
    function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {
        _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);

        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _redeemNotional);
        }
    }

    /**
     * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.
     */
    function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _repayNotional);

            _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);
        } else {
            // Approve to cToken
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);
            _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);
        }
    }

    /**
     * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.
     */
    function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {
        _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);
        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);
        }
    }

    /**
     * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     *
     * @return receiveTokenQuantity The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
         ISetToken setToken = _actionInfo.setToken;
         uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

         setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * Calculates protocol fee on module and pays protocol fee from SetToken
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)
     */
    function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {
        _updateCollateralPosition(
            actionInfo.setToken,
            actionInfo.collateralCTokenAsset,
            _getCollateralPosition(
                actionInfo.setToken,
                actionInfo.collateralCTokenAsset,
                actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                actionInfo.setToken,
                actionInfo.borrowCTokenAsset,
                actionInfo.setTotalSupply,
                false // Do not accrue interest
            )
        );
    }

    function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_cToken), _newPositionUnit);
    }

    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, "");
    }

    /**
     * Construct the ActionInfo struct for lever and delever
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever
        );
    }

    /**
     * Construct the ActionInfo struct for lever and delever accepting notional units
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            setToken: _setToken,
            collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],
            borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],
            setTotalSupply: totalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }



    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");
        require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");
        require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.
     * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.
     */
    function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {
        uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));
        // Round negative away from 0
        int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);

        return borrowPositionUnit;
    }
}.]

Given the user's task and the brainstorming ideas provided:
Task: "/*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { Compound } from "../../integration/lib/Compound.sol";
import { ICErc20 } from "../../../interfaces/external/ICErc20.sol";
import { IComptroller } from "../../../interfaces/external/IComptroller.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title CompoundLeverageModule
 * @author Set Protocol
 *
 * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call
 * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each
 * asset is leveraged when using this module.
 *
 * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 *
 */
contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {
    using Compound for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken
        address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken
        address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset
        ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    /* ============ Events ============ */

    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the trade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping of underlying to CToken. If ETH, then map WETH to cETH
    mapping(IERC20 => ICErc20) public underlyingToCToken;

    // Wrapped Ether address
    IERC20 internal weth;

    // Compound cEther address
    ICErc20 internal cEther;

    // Compound Comptroller contract
    IComptroller internal comptroller;

    // COMP token address
    IERC20 internal compToken;

    // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public collateralCTokenEnabled;

    // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public borrowCTokenEnabled;

    // Mapping of enabled collateral and borrow cTokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list
    bool public anySetAllowed;


    /* ============ Constructor ============ */

    /**
     * Instantiate addresses. Underlying to cToken mapping is created.
     *
     * @param _controller               Address of controller contract
     * @param _compToken                Address of COMP token
     * @param _comptroller              Address of Compound Comptroller
     * @param _cEther                   Address of cEther contract
     * @param _weth                     Address of WETH contract
     */
    constructor(
        IController _controller,
        IERC20 _compToken,
        IComptroller _comptroller,
        ICErc20 _cEther,
        IERC20 _weth
    )
        public
        ModuleBase(_controller)
    {
        compToken = _compToken;
        comptroller = _comptroller;
        cEther = _cEther;
        weth = _weth;

        ICErc20[] memory cTokens = comptroller.getAllMarkets();

        for(uint256 i = 0; i < cTokens.length; i++) {
            ICErc20 cToken = cTokens[i];
            underlyingToCToken[
                cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())
            ] = cToken;
        }
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.
     * Performs a DEX trade, exchanging the borrow asset for collateral asset.
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAsset          Address of asset being borrowed for leverage
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _borrowQuantity       Borrow quantity of asset in position units
     * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantity,
        uint256 _minReceiveQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantity,
            _minReceiveQuantity,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        uint256 _minRepayQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantity,
            _minRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received
     * borrow asset is updated as equity. No protocol fee is charged.
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());

        require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly
        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);

        // Update default position first to save gas on editing borrow position
        _setToken.calculateAndEditDefaultPosition(
            address(_repayAsset),
            deleverInfo.setTotalSupply,
            deleverInfo.preTradeReceiveTokenBalance
        );

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0 // No protocol fee
        );
    }

    /**
     * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral
     * assets, update cToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     *
     * @param _setToken               Instance of the SetToken
     * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value
     */
    function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption
        if (setTotalSupply > 0) {
            // Loop through collateral assets
            address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;
            for(uint256 i = 0; i < collateralCTokens.length; i++) {
                ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);
                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);
                }
            }

            // Loop through borrow assets
            address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;
            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowCTokens.length; i++) {
                ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));

                int256 newPositionUnit = _getBorrowPosition(
                    _setToken,
                    borrowCToken,
                    setTotalSupply,
                    _shouldAccrueInterest
                );

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }


    /**
     * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable
     * collateral and borrow assets that don't exist as positions on the SetToken
     *
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // Enable collateral and borrow assets on Compound
        addCollateralAssets(_setToken, _collateralAssets);

        addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled
     * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Compound and SetToken positions prior to any removal action
        sync(setToken, true);

        address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;
        for (uint256 i = 0; i < borrowCTokens.length; i++) {
            ICErc20 cToken = ICErc20(borrowCTokens[i]);

            // Will exit only if token isn't also being used as collateral
            if(!collateralCTokenEnabled[setToken][cToken]) {
                // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound
                setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[setToken][cToken];
        }

        address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;
        for (uint256 i = 0; i < collateralCTokens.length; i++) {
            ICErc20 cToken = ICErc20(collateralCTokens[i]);

            setToken.invokeExitMarket(cToken, comptroller);

            delete collateralCTokenEnabled[setToken][cToken];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken
     * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];
            require(address(cToken) != address(0), "cToken must exist");
            require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            collateralCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].collateralCTokens.push(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets
     * If there is a borrow balance, collateral asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];
            require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");

            // Note: Will only exit market if cToken is not enabled as a borrow asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete collateralCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 newBorrowAsset = _newBorrowAssets[i];
            ICErc20 cToken = underlyingToCToken[newBorrowAsset];
            require(address(cToken) != address(0), "cToken must exist");
            require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            borrowCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].borrowCTokens.push(address(cToken));
            enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));
        }

        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets
     * If there is a borrow balance, borrow asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];
            require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");

            // Note: Will only exit market if cToken is not enabled as a collateral asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));
            enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));
        }

        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.
     *
     * @param _setToken             Instance of the SetToken
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.
     *
     * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _cToken                   Address of cToken to add
     * @param _underlying               Address of underlying token that maps to cToken
     */
    function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) == address(0), "Already added");
        underlyingToCToken[_underlying] = _cToken;
    }

    /**
     * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _underlying               Address of underlying token to remove
     */
    function removeCompoundMarket(IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) != address(0), "Not added");
        delete underlyingToCToken[_underlying];
    }

    /**
     * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, false);
    }

    /**
     * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.
     * Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, true);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);

        _borrow(_setToken, underlyingToCToken[_component], notionalDebt);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);

        _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt);
    }


    /* ============ External Getter Functions ============ */

    /**
     * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an
     * array of underlying that are borrow assets.
     *
     * @return                    Collateral cToken assets that are enabled
     * @return                    Underlying borrowed assets that are enabled.
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralCTokens,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be
     * unwrapped as it only accepts the underlying ETH.
     */
    function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _mintNotional);

            _setToken.invokeMintCEther(_cToken, _mintNotional);
        } else {
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);

            _setToken.invokeMintCToken(_cToken, _mintNotional);
        }
    }

    /**
     * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.
     */
    function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {
        _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);

        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _redeemNotional);
        }
    }

    /**
     * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.
     */
    function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _repayNotional);

            _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);
        } else {
            // Approve to cToken
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);
            _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);
        }
    }

    /**
     * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.
     */
    function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {
        _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);
        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);
        }
    }

    /**
     * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     *
     * @return receiveTokenQuantity The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
         ISetToken setToken = _actionInfo.setToken;
         uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

         setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * Calculates protocol fee on module and pays protocol fee from SetToken
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)
     */
    function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {
        _updateCollateralPosition(
            actionInfo.setToken,
            actionInfo.collateralCTokenAsset,
            _getCollateralPosition(
                actionInfo.setToken,
                actionInfo.collateralCTokenAsset,
                actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                actionInfo.setToken,
                actionInfo.borrowCTokenAsset,
                actionInfo.setTotalSupply,
                false // Do not accrue interest
            )
        );
    }

    function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_cToken), _newPositionUnit);
    }

    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, "");
    }

    /**
     * Construct the ActionInfo struct for lever and delever
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever
        );
    }

    /**
     * Construct the ActionInfo struct for lever and delever accepting notional units
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            setToken: _setToken,
            collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],
            borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],
            setTotalSupply: totalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }



    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");
        require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");
        require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.
     * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.
     */
    function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {
        uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));
        // Round negative away from 0
        int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);

        return borrowPositionUnit;
    }
}".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-01-09 02:00:27 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 02:00:27 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 18401
completion_tokens: 1
total_tokens: 18402
cost: $-1.000000


[2024-01-09 02:00:27 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { Compound } from "../../integration/lib/Compound.sol";
import { ICErc20 } from "../../../interfaces/external/ICErc20.sol";
import { IComptroller } from "../../../interfaces/external/IComptroller.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title CompoundLeverageModule
 * @author Set Protocol
 *
 * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call
 * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each
 * asset is leveraged when using this module.
 *
 * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 *
 */
contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {
    using Compound for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken
        address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken
        address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset
        ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    /* ============ Events ============ */

    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the trade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping of underlying to CToken. If ETH, then map WETH to cETH
    mapping(IERC20 => ICErc20) public underlyingToCToken;

    // Wrapped Ether address
    IERC20 internal weth;

    // Compound cEther address
    ICErc20 internal cEther;

    // Compound Comptroller contract
    IComptroller internal comptroller;

    // COMP token address
    IERC20 internal compToken;

    // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public collateralCTokenEnabled;

    // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public borrowCTokenEnabled;

    // Mapping of enabled collateral and borrow cTokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list
    bool public anySetAllowed;


    /* ============ Constructor ============ */

    /**
     * Instantiate addresses. Underlying to cToken mapping is created.
     *
     * @param _controller               Address of controller contract
     * @param _compToken                Address of COMP token
     * @param _comptroller              Address of Compound Comptroller
     * @param _cEther                   Address of cEther contract
     * @param _weth                     Address of WETH contract
     */
    constructor(
        IController _controller,
        IERC20 _compToken,
        IComptroller _comptroller,
        ICErc20 _cEther,
        IERC20 _weth
    )
        public
        ModuleBase(_controller)
    {
        compToken = _compToken;
        comptroller = _comptroller;
        cEther = _cEther;
        weth = _weth;

        ICErc20[] memory cTokens = comptroller.getAllMarkets();

        for(uint256 i = 0; i < cTokens.length; i++) {
            ICErc20 cToken = cTokens[i];
            underlyingToCToken[
                cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())
            ] = cToken;
        }
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.
     * Performs a DEX trade, exchanging the borrow asset for collateral asset.
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAsset          Address of asset being borrowed for leverage
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _borrowQuantity       Borrow quantity of asset in position units
     * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantity,
        uint256 _minReceiveQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantity,
            _minReceiveQuantity,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        uint256 _minRepayQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantity,
            _minRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received
     * borrow asset is updated as equity. No protocol fee is charged.
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());

        require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly
        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);

        // Update default position first to save gas on editing borrow position
        _setToken.calculateAndEditDefaultPosition(
            address(_repayAsset),
            deleverInfo.setTotalSupply,
            deleverInfo.preTradeReceiveTokenBalance
        );

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0 // No protocol fee
        );
    }

    /**
     * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral
     * assets, update cToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     *
     * @param _setToken               Instance of the SetToken
     * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value
     */
    function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption
        if (setTotalSupply > 0) {
            // Loop through collateral assets
            address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;
            for(uint256 i = 0; i < collateralCTokens.length; i++) {
                ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);
                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);
                }
            }

            // Loop through borrow assets
            address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;
            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowCTokens.length; i++) {
                ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));

                int256 newPositionUnit = _getBorrowPosition(
                    _setToken,
                    borrowCToken,
                    setTotalSupply,
                    _shouldAccrueInterest
                );

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }


    /**
     * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable
     * collateral and borrow assets that don't exist as positions on the SetToken
     *
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // Enable collateral and borrow assets on Compound
        addCollateralAssets(_setToken, _collateralAssets);

        addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled
     * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Compound and SetToken positions prior to any removal action
        sync(setToken, true);

        address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;
        for (uint256 i = 0; i < borrowCTokens.length; i++) {
            ICErc20 cToken = ICErc20(borrowCTokens[i]);

            // Will exit only if token isn't also being used as collateral
            if(!collateralCTokenEnabled[setToken][cToken]) {
                // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound
                setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[setToken][cToken];
        }

        address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;
        for (uint256 i = 0; i < collateralCTokens.length; i++) {
            ICErc20 cToken = ICErc20(collateralCTokens[i]);

            setToken.invokeExitMarket(cToken, comptroller);

            delete collateralCTokenEnabled[setToken][cToken];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken
     * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];
            require(address(cToken) != address(0), "cToken must exist");
            require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            collateralCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].collateralCTokens.push(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets
     * If there is a borrow balance, collateral asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];
            require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");

            // Note: Will only exit market if cToken is not enabled as a borrow asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete collateralCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 newBorrowAsset = _newBorrowAssets[i];
            ICErc20 cToken = underlyingToCToken[newBorrowAsset];
            require(address(cToken) != address(0), "cToken must exist");
            require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            borrowCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].borrowCTokens.push(address(cToken));
            enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));
        }

        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets
     * If there is a borrow balance, borrow asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];
            require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");

            // Note: Will only exit market if cToken is not enabled as a collateral asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));
            enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));
        }

        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.
     *
     * @param _setToken             Instance of the SetToken
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.
     *
     * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _cToken                   Address of cToken to add
     * @param _underlying               Address of underlying token that maps to cToken
     */
    function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) == address(0), "Already added");
        underlyingToCToken[_underlying] = _cToken;
    }

    /**
     * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _underlying               Address of underlying token to remove
     */
    function removeCompoundMarket(IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) != address(0), "Not added");
        delete underlyingToCToken[_underlying];
    }

    /**
     * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, false);
    }

    /**
     * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.
     * Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, true);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);

        _borrow(_setToken, underlyingToCToken[_component], notionalDebt);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);

        _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt);
    }


    /* ============ External Getter Functions ============ */

    /**
     * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an
     * array of underlying that are borrow assets.
     *
     * @return                    Collateral cToken assets that are enabled
     * @return                    Underlying borrowed assets that are enabled.
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralCTokens,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be
     * unwrapped as it only accepts the underlying ETH.
     */
    function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _mintNotional);

            _setToken.invokeMintCEther(_cToken, _mintNotional);
        } else {
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);

            _setToken.invokeMintCToken(_cToken, _mintNotional);
        }
    }

    /**
     * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.
     */
    function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {
        _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);

        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _redeemNotional);
        }
    }

    /**
     * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.
     */
    function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _repayNotional);

            _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);
        } else {
            // Approve to cToken
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);
            _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);
        }
    }

    /**
     * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.
     */
    function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {
        _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);
        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);
        }
    }

    /**
     * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     *
     * @return receiveTokenQuantity The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
         ISetToken setToken = _actionInfo.setToken;
         uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

         setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * Calculates protocol fee on module and pays protocol fee from SetToken
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)
     */
    function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {
        _updateCollateralPosition(
            actionInfo.setToken,
            actionInfo.collateralCTokenAsset,
            _getCollateralPosition(
                actionInfo.setToken,
                actionInfo.collateralCTokenAsset,
                actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                actionInfo.setToken,
                actionInfo.borrowCTokenAsset,
                actionInfo.setTotalSupply,
                false // Do not accrue interest
            )
        );
    }

    function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_cToken), _newPositionUnit);
    }

    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, "");
    }

    /**
     * Construct the ActionInfo struct for lever and delever
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever
        );
    }

    /**
     * Construct the ActionInfo struct for lever and delever accepting notional units
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            setToken: _setToken,
            collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],
            borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],
            setTotalSupply: totalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }



    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");
        require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");
        require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.
     * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.
     */
    function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {
        uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));
        // Round negative away from 0
        int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);

        return borrowPositionUnit;
    }
}.]

###

[2024-01-09 02:00:27 INFO] **[Seminar Conclusion]**:

 ###

[2024-01-09 02:00:27 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-01-09 02:00:27 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { Compound } from "../../integration/lib/Compound.sol"; import { ICErc20 } from "../../../interfaces/external/ICErc20.sol"; import { IComptroller } from "../../../interfaces/external/IComptroller.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol"; import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; /*  * @title CompoundLeverageModule  * @author Set Protocol  *  * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call  * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each  * asset is leveraged when using this module.  *  * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of  * debt when borrowed assets are the same.  *  / contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {     using Compound for ISetToken; /* ============ Structs ============ */  struct EnabledAssets {     address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken     address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken     address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets }  struct ActionInfo {     ISetToken setToken;                      // SetToken instance     IExchangeAdapter exchangeAdapter;        // Exchange adapter instance     uint256 setTotalSupply;                  // Total supply of SetToken     uint256 notionalSendQuantity;            // Total notional quantity sent to exchange     uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange     ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset     ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset     uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance }  /* ============ Events ============ */  event LeverageIncreased(     ISetToken indexed _setToken,     IERC20 indexed _borrowAsset,     IERC20 indexed _collateralAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalBorrowAmount,     uint256 _totalReceiveAmount,     uint256 _protocolFee );  event LeverageDecreased(     ISetToken indexed _setToken,     IERC20 indexed _collateralAsset,     IERC20 indexed _repayAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalRedeemAmount,     uint256 _totalRepayAmount,     uint256 _protocolFee );  event CollateralAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  event BorrowAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  event SetTokenStatusUpdated(     ISetToken indexed _setToken,     bool indexed _added );  event AnySetAllowedUpdated(     bool indexed _anySetAllowed );  /* ============ Constants ============ */  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the trade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Mapping of underlying to CToken. If ETH, then map WETH to cETH mapping(IERC20 =&gt; ICErc20) public underlyingToCToken;  // Wrapped Ether address IERC20 internal weth;  // Compound cEther address ICErc20 internal cEther;  // Compound Comptroller contract IComptroller internal comptroller;  // COMP token address IERC20 internal compToken;  // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public collateralCTokenEnabled;  // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public borrowCTokenEnabled;  // Mapping of enabled collateral and borrow cTokens for syncing positions mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;  // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance mapping(ISetToken =&gt; bool) public allowedSetTokens;  // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list bool public anySetAllowed;   /* ============ Constructor ============ */  /**  * Instantiate addresses. Underlying to cToken mapping is created.  *  * @param _controller               Address of controller contract  * @param _compToken                Address of COMP token  * @param _comptroller              Address of Compound Comptroller  * @param _cEther                   Address of cEther contract  * @param _weth                     Address of WETH contract  */ constructor(     IController _controller,     IERC20 _compToken,     IComptroller _comptroller,     ICErc20 _cEther,     IERC20 _weth )     public     ModuleBase(_controller) {     compToken = _compToken;     comptroller = _comptroller;     cEther = _cEther;     weth = _weth;      ICErc20[] memory cTokens = comptroller.getAllMarkets();      for(uint256 i = 0; i &lt; cTokens.length; i++) {         ICErc20 cToken = cTokens[i];         underlyingToCToken[             cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())         ] = cToken;     } }  /* ============ External Functions ============ */  /**  * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.  * Performs a DEX trade, exchanging the borrow asset for collateral asset.  *  * @param _setToken             Instance of the SetToken  * @param _borrowAsset          Address of asset being borrowed for leverage  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _borrowQuantity       Borrow quantity of asset in position units  * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function lever(     ISetToken _setToken,     IERC20 _borrowAsset,     IERC20 _collateralAsset,     uint256 _borrowQuantity,     uint256 _minReceiveQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // For levering up, send quantity is derived from borrow asset and receive quantity is derived from     // collateral asset     ActionInfo memory leverInfo = _createAndValidateActionInfo(         _setToken,         _borrowAsset,         _collateralAsset,         _borrowQuantity,         _minReceiveQuantity,         _tradeAdapterName,         true     );      _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);      uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);      _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);      _updateLeverPositions(leverInfo, _borrowAsset);      emit LeverageIncreased(         _setToken,         _borrowAsset,         _collateralAsset,         leverInfo.exchangeAdapter,         leverInfo.notionalSendQuantity,         postTradeCollateralQuantity,         protocolFee     ); }  /**  * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled  *  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _repayAsset           Address of asset being repaid  * @param _redeemQuantity       Quantity of collateral asset to delever  * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function delever(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantity,     uint256 _minRepayQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from     // repay asset     ActionInfo memory deleverInfo = _createAndValidateActionInfo(         _setToken,         _collateralAsset,         _repayAsset,         _redeemQuantity,         _minRepayQuantity,         _tradeAdapterName,         false     );      _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);      uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);      _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);      _updateLeverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         repayQuantity,         protocolFee     ); }  /**  * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received  * borrow asset is updated as equity. No protocol fee is charged.  *  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)  * @param _redeemQuantity       Quantity of collateral asset to delever  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function deleverToZeroBorrowBalance(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());      require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");     uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));      ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(         _setToken,         _collateralAsset,         _repayAsset,         notionalRedeemQuantity,         notionalRepayQuantity,         _tradeAdapterName,         false     );      _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);      _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly     _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);      // Update default position first to save gas on editing borrow position     _setToken.calculateAndEditDefaultPosition(         address(_repayAsset),         deleverInfo.setTotalSupply,         deleverInfo.preTradeReceiveTokenBalance     );      _updateLeverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         notionalRepayQuantity,         0 // No protocol fee     ); }  /**  * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral  * assets, update cToken default position. For borrow assets, update external borrow position.  * - Collateral assets may come out of sync when a position is liquidated  * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid  *  * @param _setToken               Instance of the SetToken  * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value  */ function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {     uint256 setTotalSupply = _setToken.totalSupply();      // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption     if (setTotalSupply &gt; 0) {         // Loop through collateral assets         address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;         for(uint256 i = 0; i &lt; collateralCTokens.length; i++) {             ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);             uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();             uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (previousPositionUnit != newPositionUnit) {               _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);             }         }          // Loop through borrow assets         address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;         address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;         for(uint256 i = 0; i &lt; borrowCTokens.length; i++) {             ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);             IERC20 borrowAsset = IERC20(borrowAssets[i]);              int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));              int256 newPositionUnit = _getBorrowPosition(                 _setToken,                 borrowCToken,                 setTotalSupply,                 _shouldAccrueInterest             );              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (newPositionUnit != previousPositionUnit) {                 _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);             }         }     } }   /**  * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable  * collateral and borrow assets that don't exist as positions on the SetToken  *  * @param _setToken             Instance of the SetToken to initialize  * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken  * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken  */ function initialize(     ISetToken _setToken,     IERC20[] memory _collateralAssets,     IERC20[] memory _borrowAssets )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     if (!anySetAllowed) {         require(allowedSetTokens[_setToken], "Not allowed SetToken");     }      // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}     }      // Enable collateral and borrow assets on Compound     addCollateralAssets(_setToken, _collateralAssets);      addBorrowAssets(_setToken, _borrowAssets); }  /**  * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled  * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)  */ function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Sync Compound and SetToken positions prior to any removal action     sync(setToken, true);      address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;     for (uint256 i = 0; i &lt; borrowCTokens.length; i++) {         ICErc20 cToken = ICErc20(borrowCTokens[i]);          // Will exit only if token isn't also being used as collateral         if(!collateralCTokenEnabled[setToken][cToken]) {             // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound             setToken.invokeExitMarket(cToken, comptroller);         }          delete borrowCTokenEnabled[setToken][cToken];     }      address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;     for (uint256 i = 0; i &lt; collateralCTokens.length; i++) {         ICErc20 cToken = ICErc20(collateralCTokens[i]);          setToken.invokeExitMarket(cToken, comptroller);          delete collateralCTokenEnabled[setToken][cToken];     }      delete enabledAssets[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken  * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state  * inconsistencies  *  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets  *  * @param _setToken             Instance of the SetToken  * @param _newCollateralAssets  Addresses of new collateral underlying assets  */ function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {     for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];         require(address(cToken) != address(0), "cToken must exist");         require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");          // Note: Will only enter market if cToken is not enabled as a borrow asset as well         if (!borrowCTokenEnabled[_setToken][cToken]) {             _setToken.invokeEnterMarkets(cToken, comptroller);         }          collateralCTokenEnabled[_setToken][cToken] = true;         enabledAssets[_setToken].collateralCTokens.push(address(cToken));     }      emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets); }  /**  * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets  * If there is a borrow balance, collateral asset cannot be removed  *  * @param _setToken             Instance of the SetToken  * @param _collateralAssets     Addresses of collateral underlying assets to remove  */ function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {     // Sync Compound and SetToken positions prior to any removal action     sync(_setToken, true);      for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];         require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");          // Note: Will only exit market if cToken is not enabled as a borrow asset as well         // If there is an existing borrow balance, will revert and market cannot be exited on Compound         if (!borrowCTokenEnabled[_setToken][cToken]) {             _setToken.invokeExitMarket(cToken, comptroller);         }          delete collateralCTokenEnabled[_setToken][cToken];         enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));     }      emit CollateralAssetsUpdated(_setToken, false, _collateralAssets); }  /**  * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets  *  * @param _setToken             Instance of the SetToken  * @param _newBorrowAssets      Addresses of borrow underlying assets to add  */ function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {     for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {         IERC20 newBorrowAsset = _newBorrowAssets[i];         ICErc20 cToken = underlyingToCToken[newBorrowAsset];         require(address(cToken) != address(0), "cToken must exist");         require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");          // Note: Will only enter market if cToken is not enabled as a borrow asset as well         if (!collateralCTokenEnabled[_setToken][cToken]) {             _setToken.invokeEnterMarkets(cToken, comptroller);         }          borrowCTokenEnabled[_setToken][cToken] = true;         enabledAssets[_setToken].borrowCTokens.push(address(cToken));         enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));     }      emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets); }  /**  * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets  * If there is a borrow balance, borrow asset cannot be removed  *  * @param _setToken             Instance of the SetToken  * @param _borrowAssets         Addresses of borrow underlying assets to remove  */ function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {     // Sync Compound and SetToken positions prior to any removal action     sync(_setToken, true);      for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];         require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");          // Note: Will only exit market if cToken is not enabled as a collateral asset as well         // If there is an existing borrow balance, will revert and market cannot be exited on Compound         if (!collateralCTokenEnabled[_setToken][cToken]) {             _setToken.invokeExitMarket(cToken, comptroller);         }          delete borrowCTokenEnabled[_setToken][cToken];         enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));         enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));     }      emit BorrowAssetsUpdated(_setToken, false, _borrowAssets); }  /**  * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.  *  * @param _setToken             Instance of the SetToken  */ function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {     allowedSetTokens[_setToken] = _status;     emit SetTokenStatusUpdated(_setToken, _status); }  /**  * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.  *  * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled  */ function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {     anySetAllowed = _anySetAllowed;     emit AnySetAllowedUpdated(_anySetAllowed); }  /**  * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.  *  * IMPORTANT: Validations are skipped in order to get contract under bytecode limit  *  * @param _cToken                   Address of cToken to add  * @param _underlying               Address of underlying token that maps to cToken  */ function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {     require(address(underlyingToCToken[_underlying]) == address(0), "Already added");     underlyingToCToken[_underlying] = _cToken; }  /**  * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals  *  * IMPORTANT: Validations are skipped in order to get contract under bytecode limit  *  * @param _underlying               Address of underlying token to remove  */ function removeCompoundMarket(IERC20 _underlying) external onlyOwner {     require(address(underlyingToCToken[_underlying]) != address(0), "Not added");     delete underlyingToCToken[_underlying]; }  /**  * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {     sync(_setToken, false); }  /**  * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.  * Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {     sync(_setToken, true); }  /**  * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {     int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));      require(componentDebt &lt; 0, "Component must be negative");      uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);      _borrow(_setToken, underlyingToCToken[_component], notionalDebt); }  /**  * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {     int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));      require(componentDebt &lt; 0, "Component must be negative");      uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);      _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt); }   /* ============ External Getter Functions ============ */  /**  * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an  * array of underlying that are borrow assets.  *  * @return                    Collateral cToken assets that are enabled  * @return                    Underlying borrowed assets that are enabled.  */ function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {     return (         enabledAssets[_setToken].collateralCTokens,         enabledAssets[_setToken].borrowAssets     ); }  /* ============ Internal Functions ============ */  /**  * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be  * unwrapped as it only accepts the underlying ETH.  */ function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {     if (_cToken == cEther) {         _setToken.invokeUnwrapWETH(address(weth), _mintNotional);          _setToken.invokeMintCEther(_cToken, _mintNotional);     } else {         _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);          _setToken.invokeMintCToken(_cToken, _mintNotional);     } }  /**  * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.  */ function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {     _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);      if (_cToken == cEther) {         _setToken.invokeWrapWETH(address(weth), _redeemNotional);     } }  /**  * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.  */ function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {     if (_cToken == cEther) {         _setToken.invokeUnwrapWETH(address(weth), _repayNotional);          _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);     } else {         // Approve to cToken         _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);         _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);     } }  /**  * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.  */ function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {     _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);     if (_cToken == cEther) {         _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);     } }  /**  * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken  *  * @return receiveTokenQuantity The quantity of tokens received post-trade  */ function _executeTrade(     ActionInfo memory _actionInfo,     IERC20 _sendToken,     IERC20 _receiveToken,     bytes memory _data )     internal     returns (uint256) {      ISetToken setToken = _actionInfo.setToken;      uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;       setToken.invokeApprove(         address(_sendToken),         _actionInfo.exchangeAdapter.getSpender(),         notionalSendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _actionInfo.exchangeAdapter.getTradeCalldata(         address(_sendToken),         address(_receiveToken),         address(setToken),         notionalSendQuantity,         _actionInfo.minNotionalReceiveQuantity,         _data     );      setToken.invoke(targetExchange, callValue, methodData);      uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);     require(         receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,         "Slippage too high"     );      return receiveTokenQuantity; }  /**  * Calculates protocol fee on module and pays protocol fee from SetToken  */ function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {     uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);      payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);      return protocolFeeTotal; }  /**  * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)  */ function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {     _updateCollateralPosition(         actionInfo.setToken,         actionInfo.collateralCTokenAsset,         _getCollateralPosition(             actionInfo.setToken,             actionInfo.collateralCTokenAsset,             actionInfo.setTotalSupply         )     );      _updateBorrowPosition(         actionInfo.setToken,         _borrowAsset,         _getBorrowPosition(             actionInfo.setToken,             actionInfo.borrowCTokenAsset,             actionInfo.setTotalSupply,             false // Do not accrue interest         )     ); }  function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {     _setToken.editDefaultPosition(address(_cToken), _newPositionUnit); }  function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {     _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, ""); }  /**  * Construct the ActionInfo struct for lever and delever  */ function _createAndValidateActionInfo(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _sendQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();      return _createAndValidateActionInfoNotional(         _setToken,         _sendToken,         _receiveToken,         _sendQuantityUnits.preciseMul(totalSupply),         _minReceiveQuantityUnits.preciseMul(totalSupply),         _tradeAdapterName,         _isLever     ); }  /**  * Construct the ActionInfo struct for lever and delever accepting notional units  */ function _createAndValidateActionInfoNotional(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _notionalSendQuantity,     uint256 _minNotionalReceiveQuantity,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();     ActionInfo memory actionInfo = ActionInfo ({         exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),         setToken: _setToken,         collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],         borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],         setTotalSupply: totalSupply,         notionalSendQuantity: _notionalSendQuantity,         minNotionalReceiveQuantity: _minNotionalReceiveQuantity,         preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))     });      _validateCommon(actionInfo);      return actionInfo; }    function _validateCommon(ActionInfo memory _actionInfo) internal view {     require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");     require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");     require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");     require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0"); }  function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {     uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));     return collateralNotionalBalance.preciseDiv(_setTotalSupply); }  /**  * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.  * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.  */ function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {     uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));     // Round negative away from 0     int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);      return borrowPositionUnit; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 02:00:27 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { Compound } from "../../integration/lib/Compound.sol"; import { ICErc20 } from "../../../interfaces/external/ICErc20.sol"; import { IComptroller } from "../../../interfaces/external/IComptroller.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol"; import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; /*  * @title CompoundLeverageModule  * @author Set Protocol  *  * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call  * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each  * asset is leveraged when using this module.  *  * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of  * debt when borrowed assets are the same.  *  / contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {     using Compound for ISetToken; /* ============ Structs ============ */  struct EnabledAssets {     address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken     address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken     address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets }  struct ActionInfo {     ISetToken setToken;                      // SetToken instance     IExchangeAdapter exchangeAdapter;        // Exchange adapter instance     uint256 setTotalSupply;                  // Total supply of SetToken     uint256 notionalSendQuantity;            // Total notional quantity sent to exchange     uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange     ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset     ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset     uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance }  /* ============ Events ============ */  event LeverageIncreased(     ISetToken indexed _setToken,     IERC20 indexed _borrowAsset,     IERC20 indexed _collateralAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalBorrowAmount,     uint256 _totalReceiveAmount,     uint256 _protocolFee );  event LeverageDecreased(     ISetToken indexed _setToken,     IERC20 indexed _collateralAsset,     IERC20 indexed _repayAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalRedeemAmount,     uint256 _totalRepayAmount,     uint256 _protocolFee );  event CollateralAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  event BorrowAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  event SetTokenStatusUpdated(     ISetToken indexed _setToken,     bool indexed _added );  event AnySetAllowedUpdated(     bool indexed _anySetAllowed );  /* ============ Constants ============ */  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the trade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Mapping of underlying to CToken. If ETH, then map WETH to cETH mapping(IERC20 =&gt; ICErc20) public underlyingToCToken;  // Wrapped Ether address IERC20 internal weth;  // Compound cEther address ICErc20 internal cEther;  // Compound Comptroller contract IComptroller internal comptroller;  // COMP token address IERC20 internal compToken;  // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public collateralCTokenEnabled;  // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public borrowCTokenEnabled;  // Mapping of enabled collateral and borrow cTokens for syncing positions mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;  // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance mapping(ISetToken =&gt; bool) public allowedSetTokens;  // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list bool public anySetAllowed;   /* ============ Constructor ============ */  /**  * Instantiate addresses. Underlying to cToken mapping is created.  *  * @param _controller               Address of controller contract  * @param _compToken                Address of COMP token  * @param _comptroller              Address of Compound Comptroller  * @param _cEther                   Address of cEther contract  * @param _weth                     Address of WETH contract  */ constructor(     IController _controller,     IERC20 _compToken,     IComptroller _comptroller,     ICErc20 _cEther,     IERC20 _weth )     public     ModuleBase(_controller) {     compToken = _compToken;     comptroller = _comptroller;     cEther = _cEther;     weth = _weth;      ICErc20[] memory cTokens = comptroller.getAllMarkets();      for(uint256 i = 0; i &lt; cTokens.length; i++) {         ICErc20 cToken = cTokens[i];         underlyingToCToken[             cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())         ] = cToken;     } }  /* ============ External Functions ============ */  /**  * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.  * Performs a DEX trade, exchanging the borrow asset for collateral asset.  *  * @param _setToken             Instance of the SetToken  * @param _borrowAsset          Address of asset being borrowed for leverage  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _borrowQuantity       Borrow quantity of asset in position units  * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function lever(     ISetToken _setToken,     IERC20 _borrowAsset,     IERC20 _collateralAsset,     uint256 _borrowQuantity,     uint256 _minReceiveQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // For levering up, send quantity is derived from borrow asset and receive quantity is derived from     // collateral asset     ActionInfo memory leverInfo = _createAndValidateActionInfo(         _setToken,         _borrowAsset,         _collateralAsset,         _borrowQuantity,         _minReceiveQuantity,         _tradeAdapterName,         true     );      _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);      uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);      _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);      _updateLeverPositions(leverInfo, _borrowAsset);      emit LeverageIncreased(         _setToken,         _borrowAsset,         _collateralAsset,         leverInfo.exchangeAdapter,         leverInfo.notionalSendQuantity,         postTradeCollateralQuantity,         protocolFee     ); }  /**  * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled  *  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _repayAsset           Address of asset being repaid  * @param _redeemQuantity       Quantity of collateral asset to delever  * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function delever(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantity,     uint256 _minRepayQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from     // repay asset     ActionInfo memory deleverInfo = _createAndValidateActionInfo(         _setToken,         _collateralAsset,         _repayAsset,         _redeemQuantity,         _minRepayQuantity,         _tradeAdapterName,         false     );      _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);      uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);      _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);      _updateLeverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         repayQuantity,         protocolFee     ); }  /**  * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received  * borrow asset is updated as equity. No protocol fee is charged.  *  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)  * @param _redeemQuantity       Quantity of collateral asset to delever  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function deleverToZeroBorrowBalance(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());      require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");     uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));      ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(         _setToken,         _collateralAsset,         _repayAsset,         notionalRedeemQuantity,         notionalRepayQuantity,         _tradeAdapterName,         false     );      _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);      _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly     _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);      // Update default position first to save gas on editing borrow position     _setToken.calculateAndEditDefaultPosition(         address(_repayAsset),         deleverInfo.setTotalSupply,         deleverInfo.preTradeReceiveTokenBalance     );      _updateLeverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         notionalRepayQuantity,         0 // No protocol fee     ); }  /**  * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral  * assets, update cToken default position. For borrow assets, update external borrow position.  * - Collateral assets may come out of sync when a position is liquidated  * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid  *  * @param _setToken               Instance of the SetToken  * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value  */ function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {     uint256 setTotalSupply = _setToken.totalSupply();      // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption     if (setTotalSupply &gt; 0) {         // Loop through collateral assets         address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;         for(uint256 i = 0; i &lt; collateralCTokens.length; i++) {             ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);             uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();             uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (previousPositionUnit != newPositionUnit) {               _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);             }         }          // Loop through borrow assets         address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;         address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;         for(uint256 i = 0; i &lt; borrowCTokens.length; i++) {             ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);             IERC20 borrowAsset = IERC20(borrowAssets[i]);              int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));              int256 newPositionUnit = _getBorrowPosition(                 _setToken,                 borrowCToken,                 setTotalSupply,                 _shouldAccrueInterest             );              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (newPositionUnit != previousPositionUnit) {                 _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);             }         }     } }   /**  * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable  * collateral and borrow assets that don't exist as positions on the SetToken  *  * @param _setToken             Instance of the SetToken to initialize  * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken  * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken  */ function initialize(     ISetToken _setToken,     IERC20[] memory _collateralAssets,     IERC20[] memory _borrowAssets )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     if (!anySetAllowed) {         require(allowedSetTokens[_setToken], "Not allowed SetToken");     }      // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}     }      // Enable collateral and borrow assets on Compound     addCollateralAssets(_setToken, _collateralAssets);      addBorrowAssets(_setToken, _borrowAssets); }  /**  * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled  * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)  */ function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Sync Compound and SetToken positions prior to any removal action     sync(setToken, true);      address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;     for (uint256 i = 0; i &lt; borrowCTokens.length; i++) {         ICErc20 cToken = ICErc20(borrowCTokens[i]);          // Will exit only if token isn't also being used as collateral         if(!collateralCTokenEnabled[setToken][cToken]) {             // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound             setToken.invokeExitMarket(cToken, comptroller);         }          delete borrowCTokenEnabled[setToken][cToken];     }      address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;     for (uint256 i = 0; i &lt; collateralCTokens.length; i++) {         ICErc20 cToken = ICErc20(collateralCTokens[i]);          setToken.invokeExitMarket(cToken, comptroller);          delete collateralCTokenEnabled[setToken][cToken];     }      delete enabledAssets[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken  * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state  * inconsistencies  *  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets  *  * @param _setToken             Instance of the SetToken  * @param _newCollateralAssets  Addresses of new collateral underlying assets  */ function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {     for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];         require(address(cToken) != address(0), "cToken must exist");         require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");          // Note: Will only enter market if cToken is not enabled as a borrow asset as well         if (!borrowCTokenEnabled[_setToken][cToken]) {             _setToken.invokeEnterMarkets(cToken, comptroller);         }          collateralCTokenEnabled[_setToken][cToken] = true;         enabledAssets[_setToken].collateralCTokens.push(address(cToken));     }      emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets); }  /**  * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets  * If there is a borrow balance, collateral asset cannot be removed  *  * @param _setToken             Instance of the SetToken  * @param _collateralAssets     Addresses of collateral underlying assets to remove  */ function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {     // Sync Compound and SetToken positions prior to any removal action     sync(_setToken, true);      for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];         require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");          // Note: Will only exit market if cToken is not enabled as a borrow asset as well         // If there is an existing borrow balance, will revert and market cannot be exited on Compound         if (!borrowCTokenEnabled[_setToken][cToken]) {             _setToken.invokeExitMarket(cToken, comptroller);         }          delete collateralCTokenEnabled[_setToken][cToken];         enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));     }      emit CollateralAssetsUpdated(_setToken, false, _collateralAssets); }  /**  * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets  *  * @param _setToken             Instance of the SetToken  * @param _newBorrowAssets      Addresses of borrow underlying assets to add  */ function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {     for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {         IERC20 newBorrowAsset = _newBorrowAssets[i];         ICErc20 cToken = underlyingToCToken[newBorrowAsset];         require(address(cToken) != address(0), "cToken must exist");         require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");          // Note: Will only enter market if cToken is not enabled as a borrow asset as well         if (!collateralCTokenEnabled[_setToken][cToken]) {             _setToken.invokeEnterMarkets(cToken, comptroller);         }          borrowCTokenEnabled[_setToken][cToken] = true;         enabledAssets[_setToken].borrowCTokens.push(address(cToken));         enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));     }      emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets); }  /**  * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets  * If there is a borrow balance, borrow asset cannot be removed  *  * @param _setToken             Instance of the SetToken  * @param _borrowAssets         Addresses of borrow underlying assets to remove  */ function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {     // Sync Compound and SetToken positions prior to any removal action     sync(_setToken, true);      for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];         require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");          // Note: Will only exit market if cToken is not enabled as a collateral asset as well         // If there is an existing borrow balance, will revert and market cannot be exited on Compound         if (!collateralCTokenEnabled[_setToken][cToken]) {             _setToken.invokeExitMarket(cToken, comptroller);         }          delete borrowCTokenEnabled[_setToken][cToken];         enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));         enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));     }      emit BorrowAssetsUpdated(_setToken, false, _borrowAssets); }  /**  * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.  *  * @param _setToken             Instance of the SetToken  */ function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {     allowedSetTokens[_setToken] = _status;     emit SetTokenStatusUpdated(_setToken, _status); }  /**  * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.  *  * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled  */ function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {     anySetAllowed = _anySetAllowed;     emit AnySetAllowedUpdated(_anySetAllowed); }  /**  * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.  *  * IMPORTANT: Validations are skipped in order to get contract under bytecode limit  *  * @param _cToken                   Address of cToken to add  * @param _underlying               Address of underlying token that maps to cToken  */ function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {     require(address(underlyingToCToken[_underlying]) == address(0), "Already added");     underlyingToCToken[_underlying] = _cToken; }  /**  * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals  *  * IMPORTANT: Validations are skipped in order to get contract under bytecode limit  *  * @param _underlying               Address of underlying token to remove  */ function removeCompoundMarket(IERC20 _underlying) external onlyOwner {     require(address(underlyingToCToken[_underlying]) != address(0), "Not added");     delete underlyingToCToken[_underlying]; }  /**  * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {     sync(_setToken, false); }  /**  * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.  * Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {     sync(_setToken, true); }  /**  * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {     int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));      require(componentDebt &lt; 0, "Component must be negative");      uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);      _borrow(_setToken, underlyingToCToken[_component], notionalDebt); }  /**  * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {     int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));      require(componentDebt &lt; 0, "Component must be negative");      uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);      _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt); }   /* ============ External Getter Functions ============ */  /**  * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an  * array of underlying that are borrow assets.  *  * @return                    Collateral cToken assets that are enabled  * @return                    Underlying borrowed assets that are enabled.  */ function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {     return (         enabledAssets[_setToken].collateralCTokens,         enabledAssets[_setToken].borrowAssets     ); }  /* ============ Internal Functions ============ */  /**  * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be  * unwrapped as it only accepts the underlying ETH.  */ function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {     if (_cToken == cEther) {         _setToken.invokeUnwrapWETH(address(weth), _mintNotional);          _setToken.invokeMintCEther(_cToken, _mintNotional);     } else {         _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);          _setToken.invokeMintCToken(_cToken, _mintNotional);     } }  /**  * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.  */ function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {     _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);      if (_cToken == cEther) {         _setToken.invokeWrapWETH(address(weth), _redeemNotional);     } }  /**  * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.  */ function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {     if (_cToken == cEther) {         _setToken.invokeUnwrapWETH(address(weth), _repayNotional);          _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);     } else {         // Approve to cToken         _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);         _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);     } }  /**  * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.  */ function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {     _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);     if (_cToken == cEther) {         _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);     } }  /**  * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken  *  * @return receiveTokenQuantity The quantity of tokens received post-trade  */ function _executeTrade(     ActionInfo memory _actionInfo,     IERC20 _sendToken,     IERC20 _receiveToken,     bytes memory _data )     internal     returns (uint256) {      ISetToken setToken = _actionInfo.setToken;      uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;       setToken.invokeApprove(         address(_sendToken),         _actionInfo.exchangeAdapter.getSpender(),         notionalSendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _actionInfo.exchangeAdapter.getTradeCalldata(         address(_sendToken),         address(_receiveToken),         address(setToken),         notionalSendQuantity,         _actionInfo.minNotionalReceiveQuantity,         _data     );      setToken.invoke(targetExchange, callValue, methodData);      uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);     require(         receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,         "Slippage too high"     );      return receiveTokenQuantity; }  /**  * Calculates protocol fee on module and pays protocol fee from SetToken  */ function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {     uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);      payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);      return protocolFeeTotal; }  /**  * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)  */ function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {     _updateCollateralPosition(         actionInfo.setToken,         actionInfo.collateralCTokenAsset,         _getCollateralPosition(             actionInfo.setToken,             actionInfo.collateralCTokenAsset,             actionInfo.setTotalSupply         )     );      _updateBorrowPosition(         actionInfo.setToken,         _borrowAsset,         _getBorrowPosition(             actionInfo.setToken,             actionInfo.borrowCTokenAsset,             actionInfo.setTotalSupply,             false // Do not accrue interest         )     ); }  function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {     _setToken.editDefaultPosition(address(_cToken), _newPositionUnit); }  function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {     _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, ""); }  /**  * Construct the ActionInfo struct for lever and delever  */ function _createAndValidateActionInfo(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _sendQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();      return _createAndValidateActionInfoNotional(         _setToken,         _sendToken,         _receiveToken,         _sendQuantityUnits.preciseMul(totalSupply),         _minReceiveQuantityUnits.preciseMul(totalSupply),         _tradeAdapterName,         _isLever     ); }  /**  * Construct the ActionInfo struct for lever and delever accepting notional units  */ function _createAndValidateActionInfoNotional(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _notionalSendQuantity,     uint256 _minNotionalReceiveQuantity,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();     ActionInfo memory actionInfo = ActionInfo ({         exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),         setToken: _setToken,         collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],         borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],         setTotalSupply: totalSupply,         notionalSendQuantity: _notionalSendQuantity,         minNotionalReceiveQuantity: _minNotionalReceiveQuantity,         preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))     });      _validateCommon(actionInfo);      return actionInfo; }    function _validateCommon(ActionInfo memory _actionInfo) internal view {     require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");     require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");     require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");     require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0"); }  function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {     uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));     return collateralNotionalBalance.preciseDiv(_setTotalSupply); }  /**  * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.  * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.  */ function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {     uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));     // Round negative away from 0     int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);      return borrowPositionUnit; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 02:00:27 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { Compound } from "../../integration/lib/Compound.sol";
import { ICErc20 } from "../../../interfaces/external/ICErc20.sol";
import { IComptroller } from "../../../interfaces/external/IComptroller.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title CompoundLeverageModule
 * @author Set Protocol
 *
 * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call
 * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each
 * asset is leveraged when using this module.
 *
 * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 *
 */
contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {
    using Compound for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken
        address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken
        address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset
        ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    /* ============ Events ============ */

    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the trade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping of underlying to CToken. If ETH, then map WETH to cETH
    mapping(IERC20 => ICErc20) public underlyingToCToken;

    // Wrapped Ether address
    IERC20 internal weth;

    // Compound cEther address
    ICErc20 internal cEther;

    // Compound Comptroller contract
    IComptroller internal comptroller;

    // COMP token address
    IERC20 internal compToken;

    // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public collateralCTokenEnabled;

    // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public borrowCTokenEnabled;

    // Mapping of enabled collateral and borrow cTokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list
    bool public anySetAllowed;


    /* ============ Constructor ============ */

    /**
     * Instantiate addresses. Underlying to cToken mapping is created.
     *
     * @param _controller               Address of controller contract
     * @param _compToken                Address of COMP token
     * @param _comptroller              Address of Compound Comptroller
     * @param _cEther                   Address of cEther contract
     * @param _weth                     Address of WETH contract
     */
    constructor(
        IController _controller,
        IERC20 _compToken,
        IComptroller _comptroller,
        ICErc20 _cEther,
        IERC20 _weth
    )
        public
        ModuleBase(_controller)
    {
        compToken = _compToken;
        comptroller = _comptroller;
        cEther = _cEther;
        weth = _weth;

        ICErc20[] memory cTokens = comptroller.getAllMarkets();

        for(uint256 i = 0; i < cTokens.length; i++) {
            ICErc20 cToken = cTokens[i];
            underlyingToCToken[
                cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())
            ] = cToken;
        }
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.
     * Performs a DEX trade, exchanging the borrow asset for collateral asset.
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAsset          Address of asset being borrowed for leverage
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _borrowQuantity       Borrow quantity of asset in position units
     * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantity,
        uint256 _minReceiveQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantity,
            _minReceiveQuantity,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        uint256 _minRepayQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantity,
            _minRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received
     * borrow asset is updated as equity. No protocol fee is charged.
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());

        require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly
        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);

        // Update default position first to save gas on editing borrow position
        _setToken.calculateAndEditDefaultPosition(
            address(_repayAsset),
            deleverInfo.setTotalSupply,
            deleverInfo.preTradeReceiveTokenBalance
        );

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0 // No protocol fee
        );
    }

    /**
     * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral
     * assets, update cToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     *
     * @param _setToken               Instance of the SetToken
     * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value
     */
    function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption
        if (setTotalSupply > 0) {
            // Loop through collateral assets
            address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;
            for(uint256 i = 0; i < collateralCTokens.length; i++) {
                ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);
                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);
                }
            }

            // Loop through borrow assets
            address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;
            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowCTokens.length; i++) {
                ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));

                int256 newPositionUnit = _getBorrowPosition(
                    _setToken,
                    borrowCToken,
                    setTotalSupply,
                    _shouldAccrueInterest
                );

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }


    /**
     * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable
     * collateral and borrow assets that don't exist as positions on the SetToken
     *
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // Enable collateral and borrow assets on Compound
        addCollateralAssets(_setToken, _collateralAssets);

        addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled
     * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Compound and SetToken positions prior to any removal action
        sync(setToken, true);

        address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;
        for (uint256 i = 0; i < borrowCTokens.length; i++) {
            ICErc20 cToken = ICErc20(borrowCTokens[i]);

            // Will exit only if token isn't also being used as collateral
            if(!collateralCTokenEnabled[setToken][cToken]) {
                // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound
                setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[setToken][cToken];
        }

        address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;
        for (uint256 i = 0; i < collateralCTokens.length; i++) {
            ICErc20 cToken = ICErc20(collateralCTokens[i]);

            setToken.invokeExitMarket(cToken, comptroller);

            delete collateralCTokenEnabled[setToken][cToken];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken
     * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];
            require(address(cToken) != address(0), "cToken must exist");
            require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            collateralCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].collateralCTokens.push(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets
     * If there is a borrow balance, collateral asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];
            require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");

            // Note: Will only exit market if cToken is not enabled as a borrow asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete collateralCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 newBorrowAsset = _newBorrowAssets[i];
            ICErc20 cToken = underlyingToCToken[newBorrowAsset];
            require(address(cToken) != address(0), "cToken must exist");
            require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            borrowCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].borrowCTokens.push(address(cToken));
            enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));
        }

        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets
     * If there is a borrow balance, borrow asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];
            require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");

            // Note: Will only exit market if cToken is not enabled as a collateral asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));
            enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));
        }

        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.
     *
     * @param _setToken             Instance of the SetToken
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.
     *
     * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _cToken                   Address of cToken to add
     * @param _underlying               Address of underlying token that maps to cToken
     */
    function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) == address(0), "Already added");
        underlyingToCToken[_underlying] = _cToken;
    }

    /**
     * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _underlying               Address of underlying token to remove
     */
    function removeCompoundMarket(IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) != address(0), "Not added");
        delete underlyingToCToken[_underlying];
    }

    /**
     * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, false);
    }

    /**
     * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.
     * Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, true);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);

        _borrow(_setToken, underlyingToCToken[_component], notionalDebt);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);

        _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt);
    }


    /* ============ External Getter Functions ============ */

    /**
     * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an
     * array of underlying that are borrow assets.
     *
     * @return                    Collateral cToken assets that are enabled
     * @return                    Underlying borrowed assets that are enabled.
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralCTokens,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be
     * unwrapped as it only accepts the underlying ETH.
     */
    function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _mintNotional);

            _setToken.invokeMintCEther(_cToken, _mintNotional);
        } else {
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);

            _setToken.invokeMintCToken(_cToken, _mintNotional);
        }
    }

    /**
     * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.
     */
    function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {
        _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);

        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _redeemNotional);
        }
    }

    /**
     * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.
     */
    function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _repayNotional);

            _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);
        } else {
            // Approve to cToken
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);
            _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);
        }
    }

    /**
     * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.
     */
    function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {
        _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);
        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);
        }
    }

    /**
     * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     *
     * @return receiveTokenQuantity The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
         ISetToken setToken = _actionInfo.setToken;
         uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

         setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * Calculates protocol fee on module and pays protocol fee from SetToken
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)
     */
    function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {
        _updateCollateralPosition(
            actionInfo.setToken,
            actionInfo.collateralCTokenAsset,
            _getCollateralPosition(
                actionInfo.setToken,
                actionInfo.collateralCTokenAsset,
                actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                actionInfo.setToken,
                actionInfo.borrowCTokenAsset,
                actionInfo.setTotalSupply,
                false // Do not accrue interest
            )
        );
    }

    function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_cToken), _newPositionUnit);
    }

    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, "");
    }

    /**
     * Construct the ActionInfo struct for lever and delever
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever
        );
    }

    /**
     * Construct the ActionInfo struct for lever and delever accepting notional units
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            setToken: _setToken,
            collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],
            borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],
            setTotalSupply: totalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }



    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");
        require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");
        require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.
     * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.
     */
    function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {
        uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));
        // Round negative away from 0
        int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);

        return borrowPositionUnit;
    }
}.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-01-09 02:00:38 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 02:00:38 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 9259
completion_tokens: 888
total_tokens: 10147
cost: $-1.000000


[2024-01-09 02:00:38 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { Compound } from "../../integration/lib/Compound.sol";
import { ICErc20 } from "../../../interfaces/external/ICErc20.sol";
import { IComptroller } from "../../../interfaces/external/IComptroller.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title CompoundLeverageModule
 * @author Set Protocol
 *
 * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call
 * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each
 * asset is leveraged when using this module.
 *
 * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 *
 */
contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {
    using Compound for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken
        address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken
        address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset
        ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    /* ============ Events ============ */

    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the trade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping of underlying to CToken. If ETH, then map WETH to cETH
    mapping(IERC20 => ICErc20) public underlyingToCToken;

    // Wrapped Ether address
    IERC20 internal weth;

    // Compound cEther address
    ICErc20 internal cEther;

    // Compound Comptroller contract
    IComptroller internal comptroller;

    // COMP token address
    IERC20 internal compToken;

    // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public collateralCTokenEnabled;

    // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public borrowCTokenEnabled;

    // Mapping of enabled collateral and borrow cTokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list
    bool public anySetAllowed;


    /* ============ Constructor ============ */

    /**
     * Instantiate addresses. Underlying to cToken mapping is created.
     *
     * @param _controller               Address of controller contract
     * @param _compToken                Address of COMP token
     * @param _comptroller              Address of Compound Comptroller
     * @param _cEther                   Address of cEther contract
     * @param _weth                     Address of WETH contract
     */
    constructor(
        IController _controller,
        IERC20 _compToken,
        IComptroller _comptroller,
        ICErc20 _cEther,
        IERC20 _weth
    )
        public
        ModuleBase(_controller)
    {
        compToken = _compToken;
        comptroller = _comptroller;
        cEther = _cEther;
        weth = _weth;

        ICErc20[] memory cTokens = comptroller.getAllMarkets();

        for(uint256 i = 0; i < cTokens.length; i++) {
            ICErc20 cToken = cTokens[i];
            underlyingToCToken[
                cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())
            ] = cToken;
        }
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.
     * Performs a DEX trade, exchanging the borrow asset for collateral asset.
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAsset          Address of asset being borrowed for leverage
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _borrowQuantity       Borrow quantity of asset in position units
     * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantity,
        uint256 _minReceiveQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantity,
            _minReceiveQuantity,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        uint256 _minRepayQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantity,
            _minRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received
     * borrow asset is updated as equity. No protocol fee is charged.
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());

        require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly
        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);

        // Update default position first to save gas on editing borrow position
        _setToken.calculateAndEditDefaultPosition(
            address(_repayAsset),
            deleverInfo.setTotalSupply,
            deleverInfo.preTradeReceiveTokenBalance
        );

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0 // No protocol fee
        );
    }

    /**
     * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral
     * assets, update cToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     *
     * @param _setToken               Instance of the SetToken
     * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value
     */
    function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption
        if (setTotalSupply > 0) {
            // Loop through collateral assets
            address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;
            for(uint256 i = 0; i < collateralCTokens.length; i++) {
                ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);
                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);
                }
            }

            // Loop through borrow assets
            address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;
            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowCTokens.length; i++) {
                ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));

                int256 newPositionUnit = _getBorrowPosition(
                    _setToken,
                    borrowCToken,
                    setTotalSupply,
                    _shouldAccrueInterest
                );

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }


    /**
     * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable
     * collateral and borrow assets that don't exist as positions on the SetToken
     *
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // Enable collateral and borrow assets on Compound
        addCollateralAssets(_setToken, _collateralAssets);

        addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled
     * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Compound and SetToken positions prior to any removal action
        sync(setToken, true);

        address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;
        for (uint256 i = 0; i < borrowCTokens.length; i++) {
            ICErc20 cToken = ICErc20(borrowCTokens[i]);

            // Will exit only if token isn't also being used as collateral
            if(!collateralCTokenEnabled[setToken][cToken]) {
                // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound
                setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[setToken][cToken];
        }

        address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;
        for (uint256 i = 0; i < collateralCTokens.length; i++) {
            ICErc20 cToken = ICErc20(collateralCTokens[i]);

            setToken.invokeExitMarket(cToken, comptroller);

            delete collateralCTokenEnabled[setToken][cToken];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken
     * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];
            require(address(cToken) != address(0), "cToken must exist");
            require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            collateralCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].collateralCTokens.push(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets
     * If there is a borrow balance, collateral asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];
            require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");

            // Note: Will only exit market if cToken is not enabled as a borrow asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete collateralCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 newBorrowAsset = _newBorrowAssets[i];
            ICErc20 cToken = underlyingToCToken[newBorrowAsset];
            require(address(cToken) != address(0), "cToken must exist");
            require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            borrowCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].borrowCTokens.push(address(cToken));
            enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));
        }

        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets
     * If there is a borrow balance, borrow asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];
            require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");

            // Note: Will only exit market if cToken is not enabled as a collateral asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));
            enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));
        }

        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.
     *
     * @param _setToken             Instance of the SetToken
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.
     *
     * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _cToken                   Address of cToken to add
     * @param _underlying               Address of underlying token that maps to cToken
     */
    function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) == address(0), "Already added");
        underlyingToCToken[_underlying] = _cToken;
    }

    /**
     * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _underlying               Address of underlying token to remove
     */
    function removeCompoundMarket(IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) != address(0), "Not added");
        delete underlyingToCToken[_underlying];
    }

    /**
     * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, false);
    }

    /**
     * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.
     * Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, true);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);

        _borrow(_setToken, underlyingToCToken[_component], notionalDebt);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);

        _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt);
    }


    /* ============ External Getter Functions ============ */

    /**
     * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an
     * array of underlying that are borrow assets.
     *
     * @return                    Collateral cToken assets that are enabled
     * @return                    Underlying borrowed assets that are enabled.
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralCTokens,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be
     * unwrapped as it only accepts the underlying ETH.
     */
    function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _mintNotional);

            _setToken.invokeMintCEther(_cToken, _mintNotional);
        } else {
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);

            _setToken.invokeMintCToken(_cToken, _mintNotional);
        }
    }

    /**
     * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.
     */
    function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {
        _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);

        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _redeemNotional);
        }
    }

    /**
     * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.
     */
    function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _repayNotional);

            _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);
        } else {
            // Approve to cToken
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);
            _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);
        }
    }

    /**
     * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.
     */
    function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {
        _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);
        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);
        }
    }

    /**
     * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     *
     * @return receiveTokenQuantity The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
         ISetToken setToken = _actionInfo.setToken;
         uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

         setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * Calculates protocol fee on module and pays protocol fee from SetToken
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)
     */
    function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {
        _updateCollateralPosition(
            actionInfo.setToken,
            actionInfo.collateralCTokenAsset,
            _getCollateralPosition(
                actionInfo.setToken,
                actionInfo.collateralCTokenAsset,
                actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                actionInfo.setToken,
                actionInfo.borrowCTokenAsset,
                actionInfo.setTotalSupply,
                false // Do not accrue interest
            )
        );
    }

    function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_cToken), _newPositionUnit);
    }

    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, "");
    }

    /**
     * Construct the ActionInfo struct for lever and delever
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever
        );
    }

    /**
     * Construct the ActionInfo struct for lever and delever accepting notional units
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            setToken: _setToken,
            collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],
            borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],
            setTotalSupply: totalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }



    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");
        require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");
        require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.
     * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.
     */
    function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {
        uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));
        // Round negative away from 0
        int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);

        return borrowPositionUnit;
    }
}.]

Based on the provided Solidity smart contract code for the `CompoundLeverageModule`, here is a summary of potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**:
   - Although the contract inherits from `ReentrancyGuard`, which provides protection against reentrancy attacks, it is crucial to ensure that all external calls (e.g., to other contracts) are properly managed to avoid reentrancy issues, especially in functions like `lever`, `delever`, and `_executeTrade`.

2. **Lack of Input Validation**:
   - Functions such as `lever` and `delever` do not have sufficient checks on the parameters being passed. For example, validating that the `_borrowQuantity` and `_redeemQuantity` are greater than zero is essential to prevent unintended behavior.

3. **Potential for Integer Overflow/Underflow**:
   - While Solidity 0.6.10 has built-in overflow/underflow checks, it is still important to ensure that arithmetic operations (e.g., in `_accrueProtocolFee`, `_updateLeverPositions`) do not lead to unexpected results due to incorrect assumptions about input values.

4. **Improper Access Control**:
   - The contract relies on the `onlyManagerAndValidSet` modifier for critical functions, but it is important to ensure that the manager's address is securely managed and cannot be changed to an unauthorized address.

5. **Gas Limit Issues**:
   - Functions that involve loops (e.g., `sync`, `addCollateralAssets`, `removeCollateralAssets`) may run into gas limit issues if the number of assets is large. This could lead to failed transactions.

6. **Lack of Fallback Function**:
   - The contract does not implement a fallback function, which could lead to issues if Ether is sent directly to the contract. This could result in loss of funds.

7. **Potential for Front-Running**:
   - The contract's reliance on external price feeds and trade execution could expose it to front-running attacks, where a malicious actor could exploit the timing of transactions to gain an advantage.

8. **Unrestricted Access to Governance Functions**:
   - Functions that modify critical parameters (e.g., `updateAllowedSetToken`, `updateAnySetAllowed`) are only restricted to the owner. If the owner's private key is compromised, an attacker could manipulate these settings.

### Comprehensive Analysis Report

The `CompoundLeverageModule` contract is designed to facilitate leverage trading using the Compound protocol. While it incorporates several best practices, such as using OpenZeppelin's libraries for access control and reentrancy protection, there are notable security vulnerabilities that need to be addressed to ensure the contract's robustness.

1. **Reentrancy Protection**: The use of `ReentrancyGuard` is a positive aspect, but developers must remain vigilant about external calls that could lead to reentrancy attacks.

2. **Input Validation**: Comprehensive input validation is necessary to ensure that all parameters passed to functions are within acceptable ranges. This will help prevent unexpected behavior and potential exploits.

3. **Arithmetic Safety**: Although Solidity 0.6.10 mitigates overflow/underflow risks, developers should still be cautious with arithmetic operations and consider using SafeMath for clarity.

4. **Access Control**: The contract's reliance on the manager's address for critical functions necessitates a secure management process. Additionally, governance functions should be carefully controlled to prevent unauthorized access.

5. **Gas Limit Considerations**: Functions that involve loops should be optimized to avoid gas limit issues, especially in scenarios where the number of assets could be substantial.

6. **Fallback Function**: Implementing a fallback function would prevent potential loss of Ether sent directly to the contract.

7. **Front-Running Risks**: The design should consider mechanisms to mitigate front-running risks, such as time-locks or commit-reveal schemes for sensitive operations.

8. **Governance Security**: The governance model should be robust, with multi-signature wallets or time-locks to protect against single points of failure.

In conclusion, while the `CompoundLeverageModule` contract has a solid foundation, addressing the identified vulnerabilities is crucial for ensuring the security and reliability of the contract in a live environment. A thorough audit and testing phase should be conducted before deployment to mitigate these risks effectively.

[2024-01-09 02:00:38 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code for the `CompoundLeverageModule`, here is a summary of potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**:
   - Although the contract inherits from `ReentrancyGuard`, which provides protection against reentrancy attacks, it is crucial to ensure that all external calls (e.g., to other contracts) are properly managed to avoid reentrancy issues, especially in functions like `lever`, `delever`, and `_executeTrade`.

2. **Lack of Input Validation**:
   - Functions such as `lever` and `delever` do not have sufficient checks on the parameters being passed. For example, validating that the `_borrowQuantity` and `_redeemQuantity` are greater than zero is essential to prevent unintended behavior.

3. **Potential for Integer Overflow/Underflow**:
   - While Solidity 0.6.10 has built-in overflow/underflow checks, it is still important to ensure that arithmetic operations (e.g., in `_accrueProtocolFee`, `_updateLeverPositions`) do not lead to unexpected results due to incorrect assumptions about input values.

4. **Improper Access Control**:
   - The contract relies on the `onlyManagerAndValidSet` modifier for critical functions, but it is important to ensure that the manager's address is securely managed and cannot be changed to an unauthorized address.

5. **Gas Limit Issues**:
   - Functions that involve loops (e.g., `sync`, `addCollateralAssets`, `removeCollateralAssets`) may run into gas limit issues if the number of assets is large. This could lead to failed transactions.

6. **Lack of Fallback Function**:
   - The contract does not implement a fallback function, which could lead to issues if Ether is sent directly to the contract. This could result in loss of funds.

7. **Potential for Front-Running**:
   - The contract's reliance on external price feeds and trade execution could expose it to front-running attacks, where a malicious actor could exploit the timing of transactions to gain an advantage.

8. **Unrestricted Access to Governance Functions**:
   - Functions that modify critical parameters (e.g., `updateAllowedSetToken`, `updateAnySetAllowed`) are only restricted to the owner. If the owner's private key is compromised, an attacker could manipulate these settings.

### Comprehensive Analysis Report

The `CompoundLeverageModule` contract is designed to facilitate leverage trading using the Compound protocol. While it incorporates several best practices, such as using OpenZeppelin's libraries for access control and reentrancy protection, there are notable security vulnerabilities that need to be addressed to ensure the contract's robustness.

1. **Reentrancy Protection**: The use of `ReentrancyGuard` is a positive aspect, but developers must remain vigilant about external calls that could lead to reentrancy attacks.

2. **Input Validation**: Comprehensive input validation is necessary to ensure that all parameters passed to functions are within acceptable ranges. This will help prevent unexpected behavior and potential exploits.

3. **Arithmetic Safety**: Although Solidity 0.6.10 mitigates overflow/underflow risks, developers should still be cautious with arithmetic operations and consider using SafeMath for clarity.

4. **Access Control**: The contract's reliance on the manager's address for critical functions necessitates a secure management process. Additionally, governance functions should be carefully controlled to prevent unauthorized access.

5. **Gas Limit Considerations**: Functions that involve loops should be optimized to avoid gas limit issues, especially in scenarios where the number of assets could be substantial.

6. **Fallback Function**: Implementing a fallback function would prevent potential loss of Ether sent directly to the contract.

7. **Front-Running Risks**: The design should consider mechanisms to mitigate front-running risks, such as time-locks or commit-reveal schemes for sensitive operations.

8. **Governance Security**: The governance model should be robust, with multi-signature wallets or time-locks to protect against single points of failure.

In conclusion, while the `CompoundLeverageModule` contract has a solid foundation, addressing the identified vulnerabilities is crucial for ensuring the security and reliability of the contract in a live environment. A thorough audit and testing phase should be conducted before deployment to mitigate these risks effectively.

[2024-01-09 02:00:38 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-01-09 02:00:39 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { Compound } from "../../integration/lib/Compound.sol"; import { ICErc20 } from "../../../interfaces/external/ICErc20.sol"; import { IComptroller } from "../../../interfaces/external/IComptroller.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol"; import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; /*  * @title CompoundLeverageModule  * @author Set Protocol  *  * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call  * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each  * asset is leveraged when using this module.  *  * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of  * debt when borrowed assets are the same.  *  / contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {     using Compound for ISetToken; /* ============ Structs ============ */  struct EnabledAssets {     address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken     address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken     address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets }  struct ActionInfo {     ISetToken setToken;                      // SetToken instance     IExchangeAdapter exchangeAdapter;        // Exchange adapter instance     uint256 setTotalSupply;                  // Total supply of SetToken     uint256 notionalSendQuantity;            // Total notional quantity sent to exchange     uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange     ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset     ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset     uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance }  /* ============ Events ============ */  event LeverageIncreased(     ISetToken indexed _setToken,     IERC20 indexed _borrowAsset,     IERC20 indexed _collateralAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalBorrowAmount,     uint256 _totalReceiveAmount,     uint256 _protocolFee );  event LeverageDecreased(     ISetToken indexed _setToken,     IERC20 indexed _collateralAsset,     IERC20 indexed _repayAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalRedeemAmount,     uint256 _totalRepayAmount,     uint256 _protocolFee );  event CollateralAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  event BorrowAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  event SetTokenStatusUpdated(     ISetToken indexed _setToken,     bool indexed _added );  event AnySetAllowedUpdated(     bool indexed _anySetAllowed );  /* ============ Constants ============ */  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the trade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Mapping of underlying to CToken. If ETH, then map WETH to cETH mapping(IERC20 =&gt; ICErc20) public underlyingToCToken;  // Wrapped Ether address IERC20 internal weth;  // Compound cEther address ICErc20 internal cEther;  // Compound Comptroller contract IComptroller internal comptroller;  // COMP token address IERC20 internal compToken;  // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public collateralCTokenEnabled;  // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public borrowCTokenEnabled;  // Mapping of enabled collateral and borrow cTokens for syncing positions mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;  // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance mapping(ISetToken =&gt; bool) public allowedSetTokens;  // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list bool public anySetAllowed;   /* ============ Constructor ============ */  /**  * Instantiate addresses. Underlying to cToken mapping is created.  *  * @param _controller               Address of controller contract  * @param _compToken                Address of COMP token  * @param _comptroller              Address of Compound Comptroller  * @param _cEther                   Address of cEther contract  * @param _weth                     Address of WETH contract  */ constructor(     IController _controller,     IERC20 _compToken,     IComptroller _comptroller,     ICErc20 _cEther,     IERC20 _weth )     public     ModuleBase(_controller) {     compToken = _compToken;     comptroller = _comptroller;     cEther = _cEther;     weth = _weth;      ICErc20[] memory cTokens = comptroller.getAllMarkets();      for(uint256 i = 0; i &lt; cTokens.length; i++) {         ICErc20 cToken = cTokens[i];         underlyingToCToken[             cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())         ] = cToken;     } }  /* ============ External Functions ============ */  /**  * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.  * Performs a DEX trade, exchanging the borrow asset for collateral asset.  *  * @param _setToken             Instance of the SetToken  * @param _borrowAsset          Address of asset being borrowed for leverage  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _borrowQuantity       Borrow quantity of asset in position units  * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function lever(     ISetToken _setToken,     IERC20 _borrowAsset,     IERC20 _collateralAsset,     uint256 _borrowQuantity,     uint256 _minReceiveQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // For levering up, send quantity is derived from borrow asset and receive quantity is derived from     // collateral asset     ActionInfo memory leverInfo = _createAndValidateActionInfo(         _setToken,         _borrowAsset,         _collateralAsset,         _borrowQuantity,         _minReceiveQuantity,         _tradeAdapterName,         true     );      _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);      uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);      _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);      _updateLeverPositions(leverInfo, _borrowAsset);      emit LeverageIncreased(         _setToken,         _borrowAsset,         _collateralAsset,         leverInfo.exchangeAdapter,         leverInfo.notionalSendQuantity,         postTradeCollateralQuantity,         protocolFee     ); }  /**  * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled  *  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _repayAsset           Address of asset being repaid  * @param _redeemQuantity       Quantity of collateral asset to delever  * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function delever(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantity,     uint256 _minRepayQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from     // repay asset     ActionInfo memory deleverInfo = _createAndValidateActionInfo(         _setToken,         _collateralAsset,         _repayAsset,         _redeemQuantity,         _minRepayQuantity,         _tradeAdapterName,         false     );      _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);      uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);      _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);      _updateLeverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         repayQuantity,         protocolFee     ); }  /**  * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received  * borrow asset is updated as equity. No protocol fee is charged.  *  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)  * @param _redeemQuantity       Quantity of collateral asset to delever  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function deleverToZeroBorrowBalance(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());      require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");     uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));      ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(         _setToken,         _collateralAsset,         _repayAsset,         notionalRedeemQuantity,         notionalRepayQuantity,         _tradeAdapterName,         false     );      _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);      _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly     _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);      // Update default position first to save gas on editing borrow position     _setToken.calculateAndEditDefaultPosition(         address(_repayAsset),         deleverInfo.setTotalSupply,         deleverInfo.preTradeReceiveTokenBalance     );      _updateLeverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         notionalRepayQuantity,         0 // No protocol fee     ); }  /**  * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral  * assets, update cToken default position. For borrow assets, update external borrow position.  * - Collateral assets may come out of sync when a position is liquidated  * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid  *  * @param _setToken               Instance of the SetToken  * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value  */ function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {     uint256 setTotalSupply = _setToken.totalSupply();      // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption     if (setTotalSupply &gt; 0) {         // Loop through collateral assets         address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;         for(uint256 i = 0; i &lt; collateralCTokens.length; i++) {             ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);             uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();             uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (previousPositionUnit != newPositionUnit) {               _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);             }         }          // Loop through borrow assets         address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;         address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;         for(uint256 i = 0; i &lt; borrowCTokens.length; i++) {             ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);             IERC20 borrowAsset = IERC20(borrowAssets[i]);              int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));              int256 newPositionUnit = _getBorrowPosition(                 _setToken,                 borrowCToken,                 setTotalSupply,                 _shouldAccrueInterest             );              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (newPositionUnit != previousPositionUnit) {                 _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);             }         }     } }   /**  * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable  * collateral and borrow assets that don't exist as positions on the SetToken  *  * @param _setToken             Instance of the SetToken to initialize  * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken  * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken  */ function initialize(     ISetToken _setToken,     IERC20[] memory _collateralAssets,     IERC20[] memory _borrowAssets )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     if (!anySetAllowed) {         require(allowedSetTokens[_setToken], "Not allowed SetToken");     }      // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}     }      // Enable collateral and borrow assets on Compound     addCollateralAssets(_setToken, _collateralAssets);      addBorrowAssets(_setToken, _borrowAssets); }  /**  * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled  * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)  */ function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Sync Compound and SetToken positions prior to any removal action     sync(setToken, true);      address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;     for (uint256 i = 0; i &lt; borrowCTokens.length; i++) {         ICErc20 cToken = ICErc20(borrowCTokens[i]);          // Will exit only if token isn't also being used as collateral         if(!collateralCTokenEnabled[setToken][cToken]) {             // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound             setToken.invokeExitMarket(cToken, comptroller);         }          delete borrowCTokenEnabled[setToken][cToken];     }      address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;     for (uint256 i = 0; i &lt; collateralCTokens.length; i++) {         ICErc20 cToken = ICErc20(collateralCTokens[i]);          setToken.invokeExitMarket(cToken, comptroller);          delete collateralCTokenEnabled[setToken][cToken];     }      delete enabledAssets[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken  * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state  * inconsistencies  *  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets  *  * @param _setToken             Instance of the SetToken  * @param _newCollateralAssets  Addresses of new collateral underlying assets  */ function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {     for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];         require(address(cToken) != address(0), "cToken must exist");         require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");          // Note: Will only enter market if cToken is not enabled as a borrow asset as well         if (!borrowCTokenEnabled[_setToken][cToken]) {             _setToken.invokeEnterMarkets(cToken, comptroller);         }          collateralCTokenEnabled[_setToken][cToken] = true;         enabledAssets[_setToken].collateralCTokens.push(address(cToken));     }      emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets); }  /**  * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets  * If there is a borrow balance, collateral asset cannot be removed  *  * @param _setToken             Instance of the SetToken  * @param _collateralAssets     Addresses of collateral underlying assets to remove  */ function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {     // Sync Compound and SetToken positions prior to any removal action     sync(_setToken, true);      for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];         require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");          // Note: Will only exit market if cToken is not enabled as a borrow asset as well         // If there is an existing borrow balance, will revert and market cannot be exited on Compound         if (!borrowCTokenEnabled[_setToken][cToken]) {             _setToken.invokeExitMarket(cToken, comptroller);         }          delete collateralCTokenEnabled[_setToken][cToken];         enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));     }      emit CollateralAssetsUpdated(_setToken, false, _collateralAssets); }  /**  * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets  *  * @param _setToken             Instance of the SetToken  * @param _newBorrowAssets      Addresses of borrow underlying assets to add  */ function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {     for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {         IERC20 newBorrowAsset = _newBorrowAssets[i];         ICErc20 cToken = underlyingToCToken[newBorrowAsset];         require(address(cToken) != address(0), "cToken must exist");         require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");          // Note: Will only enter market if cToken is not enabled as a borrow asset as well         if (!collateralCTokenEnabled[_setToken][cToken]) {             _setToken.invokeEnterMarkets(cToken, comptroller);         }          borrowCTokenEnabled[_setToken][cToken] = true;         enabledAssets[_setToken].borrowCTokens.push(address(cToken));         enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));     }      emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets); }  /**  * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets  * If there is a borrow balance, borrow asset cannot be removed  *  * @param _setToken             Instance of the SetToken  * @param _borrowAssets         Addresses of borrow underlying assets to remove  */ function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {     // Sync Compound and SetToken positions prior to any removal action     sync(_setToken, true);      for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];         require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");          // Note: Will only exit market if cToken is not enabled as a collateral asset as well         // If there is an existing borrow balance, will revert and market cannot be exited on Compound         if (!collateralCTokenEnabled[_setToken][cToken]) {             _setToken.invokeExitMarket(cToken, comptroller);         }          delete borrowCTokenEnabled[_setToken][cToken];         enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));         enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));     }      emit BorrowAssetsUpdated(_setToken, false, _borrowAssets); }  /**  * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.  *  * @param _setToken             Instance of the SetToken  */ function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {     allowedSetTokens[_setToken] = _status;     emit SetTokenStatusUpdated(_setToken, _status); }  /**  * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.  *  * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled  */ function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {     anySetAllowed = _anySetAllowed;     emit AnySetAllowedUpdated(_anySetAllowed); }  /**  * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.  *  * IMPORTANT: Validations are skipped in order to get contract under bytecode limit  *  * @param _cToken                   Address of cToken to add  * @param _underlying               Address of underlying token that maps to cToken  */ function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {     require(address(underlyingToCToken[_underlying]) == address(0), "Already added");     underlyingToCToken[_underlying] = _cToken; }  /**  * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals  *  * IMPORTANT: Validations are skipped in order to get contract under bytecode limit  *  * @param _underlying               Address of underlying token to remove  */ function removeCompoundMarket(IERC20 _underlying) external onlyOwner {     require(address(underlyingToCToken[_underlying]) != address(0), "Not added");     delete underlyingToCToken[_underlying]; }  /**  * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {     sync(_setToken, false); }  /**  * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.  * Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {     sync(_setToken, true); }  /**  * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {     int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));      require(componentDebt &lt; 0, "Component must be negative");      uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);      _borrow(_setToken, underlyingToCToken[_component], notionalDebt); }  /**  * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {     int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));      require(componentDebt &lt; 0, "Component must be negative");      uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);      _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt); }   /* ============ External Getter Functions ============ */  /**  * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an  * array of underlying that are borrow assets.  *  * @return                    Collateral cToken assets that are enabled  * @return                    Underlying borrowed assets that are enabled.  */ function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {     return (         enabledAssets[_setToken].collateralCTokens,         enabledAssets[_setToken].borrowAssets     ); }  /* ============ Internal Functions ============ */  /**  * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be  * unwrapped as it only accepts the underlying ETH.  */ function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {     if (_cToken == cEther) {         _setToken.invokeUnwrapWETH(address(weth), _mintNotional);          _setToken.invokeMintCEther(_cToken, _mintNotional);     } else {         _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);          _setToken.invokeMintCToken(_cToken, _mintNotional);     } }  /**  * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.  */ function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {     _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);      if (_cToken == cEther) {         _setToken.invokeWrapWETH(address(weth), _redeemNotional);     } }  /**  * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.  */ function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {     if (_cToken == cEther) {         _setToken.invokeUnwrapWETH(address(weth), _repayNotional);          _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);     } else {         // Approve to cToken         _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);         _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);     } }  /**  * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.  */ function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {     _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);     if (_cToken == cEther) {         _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);     } }  /**  * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken  *  * @return receiveTokenQuantity The quantity of tokens received post-trade  */ function _executeTrade(     ActionInfo memory _actionInfo,     IERC20 _sendToken,     IERC20 _receiveToken,     bytes memory _data )     internal     returns (uint256) {      ISetToken setToken = _actionInfo.setToken;      uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;       setToken.invokeApprove(         address(_sendToken),         _actionInfo.exchangeAdapter.getSpender(),         notionalSendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _actionInfo.exchangeAdapter.getTradeCalldata(         address(_sendToken),         address(_receiveToken),         address(setToken),         notionalSendQuantity,         _actionInfo.minNotionalReceiveQuantity,         _data     );      setToken.invoke(targetExchange, callValue, methodData);      uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);     require(         receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,         "Slippage too high"     );      return receiveTokenQuantity; }  /**  * Calculates protocol fee on module and pays protocol fee from SetToken  */ function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {     uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);      payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);      return protocolFeeTotal; }  /**  * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)  */ function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {     _updateCollateralPosition(         actionInfo.setToken,         actionInfo.collateralCTokenAsset,         _getCollateralPosition(             actionInfo.setToken,             actionInfo.collateralCTokenAsset,             actionInfo.setTotalSupply         )     );      _updateBorrowPosition(         actionInfo.setToken,         _borrowAsset,         _getBorrowPosition(             actionInfo.setToken,             actionInfo.borrowCTokenAsset,             actionInfo.setTotalSupply,             false // Do not accrue interest         )     ); }  function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {     _setToken.editDefaultPosition(address(_cToken), _newPositionUnit); }  function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {     _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, ""); }  /**  * Construct the ActionInfo struct for lever and delever  */ function _createAndValidateActionInfo(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _sendQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();      return _createAndValidateActionInfoNotional(         _setToken,         _sendToken,         _receiveToken,         _sendQuantityUnits.preciseMul(totalSupply),         _minReceiveQuantityUnits.preciseMul(totalSupply),         _tradeAdapterName,         _isLever     ); }  /**  * Construct the ActionInfo struct for lever and delever accepting notional units  */ function _createAndValidateActionInfoNotional(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _notionalSendQuantity,     uint256 _minNotionalReceiveQuantity,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();     ActionInfo memory actionInfo = ActionInfo ({         exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),         setToken: _setToken,         collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],         borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],         setTotalSupply: totalSupply,         notionalSendQuantity: _notionalSendQuantity,         minNotionalReceiveQuantity: _minNotionalReceiveQuantity,         preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))     });      _validateCommon(actionInfo);      return actionInfo; }    function _validateCommon(ActionInfo memory _actionInfo) internal view {     require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");     require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");     require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");     require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0"); }  function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {     uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));     return collateralNotionalBalance.preciseDiv(_setTotalSupply); }  /**  * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.  * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.  */ function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {     uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));     // Round negative away from 0     int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);      return borrowPositionUnit; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '/\n    Copyright 2021 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n/\n\npragma solidity 0.6.10;\npragma experimental "ABIEncoderV2";\n\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";\nimport { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\n\nimport { Compound } from "../../integration/lib/Compound.sol";\nimport { ICErc20 } from "../../../interfaces/external/ICErc20.sol";\nimport { IComptroller } from "../../../interfaces/external/IComptroller.sol";\nimport { IController } from "../../../interfaces/IController.sol";\nimport { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";\nimport { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";\nimport { ISetToken } from "../../../interfaces/ISetToken.sol";\nimport { ModuleBase } from "../../lib/ModuleBase.sol";\n\n/\n * @title CompoundLeverageModule\n * @author Set Protocol\n \n * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call\n * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each\n * asset is leveraged when using this module.\n \n * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of\n * debt when borrowed assets are the same.\n \n /\ncontract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {\n    using Compound for ISetToken;\n\n    / ============ Structs ============ /\n\n    struct EnabledAssets {\n        address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken\n        address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken\n        address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets\n    }\n\n    struct ActionInfo {\n        ISetToken setToken;                      // SetToken instance\n        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance\n        uint256 setTotalSupply;                  // Total supply of SetToken\n        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange\n        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange\n        ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset\n        ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset\n        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance\n    }\n\n    / ============ Events ============ /\n\n    event LeverageIncreased(\n        ISetToken indexed _setToken,\n        IERC20 indexed _borrowAsset,\n        IERC20 indexed _collateralAsset,\n        IExchangeAdapter _exchangeAdapter,\n        uint256 _totalBorrowAmount,\n        uint256 _totalReceiveAmount,\n        uint256 _protocolFee\n    );\n\n    event LeverageDecreased(\n        ISetToken indexed _setToken,\n        IERC20 indexed _collateralAsset,\n        IERC20 indexed _repayAsset,\n        IExchangeAdapter _exchangeAdapter,\n        uint256 _totalRedeemAmount,\n        uint256 _totalRepayAmount,\n        uint256 _protocolFee\n    );\n\n    event CollateralAssetsUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added,\n        IERC20[] _assets\n    );\n\n    event BorrowAssetsUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added,\n        IERC20[] _assets\n    );\n\n    event SetTokenStatusUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added\n    );\n\n    event AnySetAllowedUpdated(\n        bool indexed _anySetAllowed\n    );\n\n    / ============ Constants ============ /\n\n    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as\n    // the string as the integration name\n    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";\n\n    // 0 index stores protocol fee % on the controller, charged in the trade function\n    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;\n\n    / ============ State Variables ============ /\n\n    // Mapping of underlying to CToken. If ETH, then map WETH to cETH\n    mapping(IERC20 =&gt; ICErc20) public underlyingToCToken;\n\n    // Wrapped Ether address\n    IERC20 internal weth;\n\n    // Compound cEther address\n    ICErc20 internal cEther;\n\n    // Compound Comptroller contract\n    IComptroller internal comptroller;\n\n    // COMP token address\n    IERC20 internal compToken;\n\n    // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken\n    mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public collateralCTokenEnabled;\n\n    // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken\n    mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public borrowCTokenEnabled;\n\n    // Mapping of enabled collateral and borrow cTokens for syncing positions\n    mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;\n\n    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance\n    mapping(ISetToken =&gt; bool) public allowedSetTokens;\n\n    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list\n    bool public anySetAllowed;\n\n\n    / ============ Constructor ============ /\n\n    /\n     * Instantiate addresses. Underlying to cToken mapping is created.\n     \n     * @param _controller               Address of controller contract\n     * @param _compToken                Address of COMP token\n     * @param _comptroller              Address of Compound Comptroller\n     * @param _cEther                   Address of cEther contract\n     * @param _weth                     Address of WETH contract\n     /\n    constructor(\n        IController _controller,\n        IERC20 _compToken,\n        IComptroller _comptroller,\n        ICErc20 _cEther,\n        IERC20 _weth\n    )\n        public\n        ModuleBase(_controller)\n    {\n        compToken = _compToken;\n        comptroller = _comptroller;\n        cEther = _cEther;\n        weth = _weth;\n\n        ICErc20[] memory cTokens = comptroller.getAllMarkets();\n\n        for(uint256 i = 0; i &lt; cTokens.length; i++) {\n            ICErc20 cToken = cTokens[i];\n            underlyingToCToken[\n                cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())\n            ] = cToken;\n        }\n    }\n\n    / ============ External Functions ============ /\n\n    /\n     * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.\n     * Performs a DEX trade, exchanging the borrow asset for collateral asset.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _borrowAsset          Address of asset being borrowed for leverage\n     * @param _collateralAsset      Address of collateral asset (underlying of cToken)\n     * @param _borrowQuantity       Borrow quantity of asset in position units\n     * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units\n     * @param _tradeAdapterName     Name of trade adapter\n     * @param _tradeData            Arbitrary data for trade\n     /\n    function lever(\n        ISetToken _setToken,\n        IERC20 _borrowAsset,\n        IERC20 _collateralAsset,\n        uint256 _borrowQuantity,\n        uint256 _minReceiveQuantity,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from\n        // collateral asset\n        ActionInfo memory leverInfo = _createAndValidateActionInfo(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            _borrowQuantity,\n            _minReceiveQuantity,\n            _tradeAdapterName,\n            true\n        );\n\n        _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);\n\n        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);\n\n        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n        _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);\n\n        _updateLeverPositions(leverInfo, _borrowAsset);\n\n        emit LeverageIncreased(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            leverInfo.exchangeAdapter,\n            leverInfo.notionalSendQuantity,\n            postTradeCollateralQuantity,\n            protocolFee\n        );\n    }\n\n    /\n     * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _collateralAsset      Address of collateral asset (underlying of cToken)\n     * @param _repayAsset           Address of asset being repaid\n     * @param _redeemQuantity       Quantity of collateral asset to delever\n     * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade\n     * @param _tradeAdapterName     Name of trade adapter\n     * @param _tradeData            Arbitrary data for trade\n     /\n    function delever(\n        ISetToken _setToken,\n        IERC20 _collateralAsset,\n        IERC20 _repayAsset,\n        uint256 _redeemQuantity,\n        uint256 _minRepayQuantity,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from\n        // repay asset\n        ActionInfo memory deleverInfo = _createAndValidateActionInfo(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            _redeemQuantity,\n            _minRepayQuantity,\n            _tradeAdapterName,\n            false\n        );\n\n        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);\n\n        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);\n\n        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);\n\n        _updateLeverPositions(deleverInfo, _repayAsset);\n\n        emit LeverageDecreased(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            deleverInfo.exchangeAdapter,\n            deleverInfo.notionalSendQuantity,\n            repayQuantity,\n            protocolFee\n        );\n    }\n\n    /\n     * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received\n     * borrow asset is updated as equity. No protocol fee is charged.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _collateralAsset      Address of collateral asset (underlying of cToken)\n     * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)\n     * @param _redeemQuantity       Quantity of collateral asset to delever\n     * @param _tradeAdapterName     Name of trade adapter\n     * @param _tradeData            Arbitrary data for trade\n     /\n    function deleverToZeroBorrowBalance(\n        ISetToken _setToken,\n        IERC20 _collateralAsset,\n        IERC20 _repayAsset,\n        uint256 _redeemQuantity,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());\n\n        require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");\n        uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));\n\n        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            notionalRedeemQuantity,\n            notionalRepayQuantity,\n            _tradeAdapterName,\n            false\n        );\n\n        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);\n\n        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n\n        // We use notionalRepayQuantity vs. Compound\'s max value uint256(-1) to handle WETH properly\n        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);\n\n        // Update default position first to save gas on editing borrow position\n        _setToken.calculateAndEditDefaultPosition(\n            address(_repayAsset),\n            deleverInfo.setTotalSupply,\n            deleverInfo.preTradeReceiveTokenBalance\n        );\n\n        _updateLeverPositions(deleverInfo, _repayAsset);\n\n        emit LeverageDecreased(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            deleverInfo.exchangeAdapter,\n            deleverInfo.notionalSendQuantity,\n            notionalRepayQuantity,\n            0 // No protocol fee\n        );\n    }\n\n    /\n     * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral\n     * assets, update cToken default position. For borrow assets, update external borrow position.\n     * - Collateral assets may come out of sync when a position is liquidated\n     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid\n     \n     * @param _setToken               Instance of the SetToken\n     * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value\n     /\n    function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {\n        uint256 setTotalSupply = _setToken.totalSupply();\n\n        // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption\n        if (setTotalSupply &gt; 0) {\n            // Loop through collateral assets\n            address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;\n            for(uint256 i = 0; i &lt; collateralCTokens.length; i++) {\n                ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);\n                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();\n                uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);\n\n                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets\n                if (previousPositionUnit != newPositionUnit) {\n                  _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);\n                }\n            }\n\n            // Loop through borrow assets\n            address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;\n            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;\n            for(uint256 i = 0; i &lt; borrowCTokens.length; i++) {\n                ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);\n                IERC20 borrowAsset = IERC20(borrowAssets[i]);\n\n                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));\n\n                int256 newPositionUnit = _getBorrowPosition(\n                    _setToken,\n                    borrowCToken,\n                    setTotalSupply,\n                    _shouldAccrueInterest\n                );\n\n                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets\n                if (newPositionUnit != previousPositionUnit) {\n                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);\n                }\n            }\n        }\n    }\n\n\n    /\n     * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken\'s manager. Note: managers can enable\n     * collateral and borrow assets that don\'t exist as positions on the SetToken\n     \n     * @param _setToken             Instance of the SetToken to initialize\n     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken\n     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken\n     /\n    function initialize(\n        ISetToken _setToken,\n        IERC20[] memory _collateralAssets,\n        IERC20[] memory _borrowAssets\n    )\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        if (!anySetAllowed) {\n            require(allowedSetTokens[_setToken], "Not allowed SetToken");\n        }\n\n        // Initialize module before trying register\n        _setToken.initializeModule();\n\n        // Get debt issuance module registered to this module and require that it is initialized\n        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");\n\n        // Try if register exists on any of the modules including the debt issuance module\n        address[] memory modules = _setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}\n        }\n\n        // Enable collateral and borrow assets on Compound\n        addCollateralAssets(_setToken, _collateralAssets);\n\n        addBorrowAssets(_setToken, _borrowAssets);\n    }\n\n    /\n     * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled\n     * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)\n     /\n    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {\n        ISetToken setToken = ISetToken(msg.sender);\n\n        // Sync Compound and SetToken positions prior to any removal action\n        sync(setToken, true);\n\n        address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;\n        for (uint256 i = 0; i &lt; borrowCTokens.length; i++) {\n            ICErc20 cToken = ICErc20(borrowCTokens[i]);\n\n            // Will exit only if token isn\'t also being used as collateral\n            if(!collateralCTokenEnabled[setToken][cToken]) {\n                // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound\n                setToken.invokeExitMarket(cToken, comptroller);\n            }\n\n            delete borrowCTokenEnabled[setToken][cToken];\n        }\n\n        address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;\n        for (uint256 i = 0; i &lt; collateralCTokens.length; i++) {\n            ICErc20 cToken = ICErc20(collateralCTokens[i]);\n\n            setToken.invokeExitMarket(cToken, comptroller);\n\n            delete collateralCTokenEnabled[setToken][cToken];\n        }\n\n        delete enabledAssets[setToken];\n\n        // Try if unregister exists on any of the modules\n        address[] memory modules = setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}\n        }\n    }\n\n    /\n     * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken\n     * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state\n     * inconsistencies\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _debtIssuanceModule   Debt issuance module address to register\n     /\n    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {\n        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");\n\n        _debtIssuanceModule.registerToIssuanceModule(_setToken);\n    }\n\n    /\n     * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _newCollateralAssets  Addresses of new collateral underlying assets\n     /\n    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {\n        for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {\n            ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];\n            require(address(cToken) != address(0), "cToken must exist");\n            require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");\n\n            // Note: Will only enter market if cToken is not enabled as a borrow asset as well\n            if (!borrowCTokenEnabled[_setToken][cToken]) {\n                _setToken.invokeEnterMarkets(cToken, comptroller);\n            }\n\n            collateralCTokenEnabled[_setToken][cToken] = true;\n            enabledAssets[_setToken].collateralCTokens.push(address(cToken));\n        }\n\n        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);\n    }\n\n    /\n     * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets\n     * If there is a borrow balance, collateral asset cannot be removed\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _collateralAssets     Addresses of collateral underlying assets to remove\n     /\n    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {\n        // Sync Compound and SetToken positions prior to any removal action\n        sync(_setToken, true);\n\n        for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {\n            ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];\n            require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");\n\n            // Note: Will only exit market if cToken is not enabled as a borrow asset as well\n            // If there is an existing borrow balance, will revert and market cannot be exited on Compound\n            if (!borrowCTokenEnabled[_setToken][cToken]) {\n                _setToken.invokeExitMarket(cToken, comptroller);\n            }\n\n            delete collateralCTokenEnabled[_setToken][cToken];\n            enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));\n        }\n\n        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);\n    }\n\n    /\n     * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _newBorrowAssets      Addresses of borrow underlying assets to add\n     /\n    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {\n        for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {\n            IERC20 newBorrowAsset = _newBorrowAssets[i];\n            ICErc20 cToken = underlyingToCToken[newBorrowAsset];\n            require(address(cToken) != address(0), "cToken must exist");\n            require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");\n\n            // Note: Will only enter market if cToken is not enabled as a borrow asset as well\n            if (!collateralCTokenEnabled[_setToken][cToken]) {\n                _setToken.invokeEnterMarkets(cToken, comptroller);\n            }\n\n            borrowCTokenEnabled[_setToken][cToken] = true;\n            enabledAssets[_setToken].borrowCTokens.push(address(cToken));\n            enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));\n        }\n\n        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);\n    }\n\n    /\n     * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets\n     * If there is a borrow balance, borrow asset cannot be removed\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _borrowAssets         Addresses of borrow underlying assets to remove\n     /\n    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {\n        // Sync Compound and SetToken positions prior to any removal action\n        sync(_setToken, true);\n\n        for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {\n            ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];\n            require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");\n\n            // Note: Will only exit market if cToken is not enabled as a collateral asset as well\n            // If there is an existing borrow balance, will revert and market cannot be exited on Compound\n            if (!collateralCTokenEnabled[_setToken][cToken]) {\n                _setToken.invokeExitMarket(cToken, comptroller);\n            }\n\n            delete borrowCTokenEnabled[_setToken][cToken];\n            enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));\n            enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));\n        }\n\n        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);\n    }\n\n    /\n     * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.\n     \n     * @param _setToken             Instance of the SetToken\n     /\n    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {\n        allowedSetTokens[_setToken] = _status;\n        emit SetTokenStatusUpdated(_setToken, _status);\n    }\n\n    /\n     * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.\n     \n     * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled\n     /\n    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {\n        anySetAllowed = _anySetAllowed;\n        emit AnySetAllowedUpdated(_anySetAllowed);\n    }\n\n    /\n     * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.\n     \n     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit\n     \n     * @param _cToken                   Address of cToken to add\n     * @param _underlying               Address of underlying token that maps to cToken\n     /\n    function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {\n        require(address(underlyingToCToken[_underlying]) == address(0), "Already added");\n        underlyingToCToken[_underlying] = _cToken;\n    }\n\n    /\n     * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals\n     \n     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit\n     \n     * @param _underlying               Address of underlying token to remove\n     */\n    function removeCompoundMarket(IERC20 _underlying) external onlyOwner {\n        require(address(underlyingToCToken[_underlying]) != address(0), "Not added");\n        delete underlyingToCToken[_underlying];\n    }\n\n    /\n     * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.\n     \n     * @param _setToken             Instance of the SetToken\n     /\n    function moduleIssueHook(ISetToken _setToken, uint256 / _setTokenQuantity /) external onlyModule(_setToken) {\n        sync(_setToken, false);\n    }\n\n    /\n     * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.\n     * Only callable by valid module.\n     \n     * @param _setToken             Instance of the SetToken\n     /\n    function moduleRedeemHook(ISetToken _setToken, uint256 / _setTokenQuantity /) external onlyModule(_setToken) {\n        sync(_setToken, true);\n    }\n\n    /\n     * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken\n     * @param _component            Address of component\n     /\n    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool / _isEquity /) external onlyModule(_setToken) {\n        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n\n        require(componentDebt &lt; 0, "Component must be negative");\n\n        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);\n\n        _borrow(_setToken, underlyingToCToken[_component], notionalDebt);\n    }\n\n    /\n     * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken\n     * @param _component            Address of component\n     /\n    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool / _isEquity /) external onlyModule(_setToken) {\n        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n\n        require(componentDebt &lt; 0, "Component must be negative");\n\n        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);\n\n        _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt);\n    }\n\n\n    / ============ External Getter Functions ============ /\n\n    /\n     * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an\n     * array of underlying that are borrow assets.\n     \n     * @return                    Collateral cToken assets that are enabled\n     * @return                    Underlying borrowed assets that are enabled.\n     /\n    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {\n        return (\n            enabledAssets[_setToken].collateralCTokens,\n            enabledAssets[_setToken].borrowAssets\n        );\n    }\n\n    / ============ Internal Functions ============ /\n\n    /\n     * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be\n     * unwrapped as it only accepts the underlying ETH.\n     */\n    function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {\n        if (_cToken == cEther) {\n            _setToken.invokeUnwrapWETH(address(weth), _mintNotional);\n\n            _setToken.invokeMintCEther(_cToken, _mintNotional);\n        } else {\n            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);\n\n            _setToken.invokeMintCToken(_cToken, _mintNotional);\n        }\n    }\n\n    /\n     * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.\n     /\n    function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {\n        _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);\n\n        if (_cToken == cEther) {\n            _setToken.invokeWrapWETH(address(weth), _redeemNotional);\n        }\n    }\n\n    /\n     * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.\n     /\n    function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {\n        if (_cToken == cEther) {\n            _setToken.invokeUnwrapWETH(address(weth), _repayNotional);\n\n            _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);\n        } else {\n            // Approve to cToken\n            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);\n            _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);\n        }\n    }\n\n    /\n     * Invoke the SetToken to interact with the specified cToken to borrow the cToken\'s underlying of the specified borrowQuantity.\n     */\n    function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {\n        _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);\n        if (_cToken == cEther) {\n            _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);\n        }\n    }\n\n    /\n     * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken\n     \n     * @return receiveTokenQuantity The quantity of tokens received post-trade\n     /\n    function _executeTrade(\n        ActionInfo memory _actionInfo,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        bytes memory _data\n    )\n        internal\n        returns (uint256)\n    {\n         ISetToken setToken = _actionInfo.setToken;\n         uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;\n\n         setToken.invokeApprove(\n            address(_sendToken),\n            _actionInfo.exchangeAdapter.getSpender(),\n            notionalSendQuantity\n        );\n\n        (\n            address targetExchange,\n            uint256 callValue,\n            bytes memory methodData\n        ) = _actionInfo.exchangeAdapter.getTradeCalldata(\n            address(_sendToken),\n            address(_receiveToken),\n            address(setToken),\n            notionalSendQuantity,\n            _actionInfo.minNotionalReceiveQuantity,\n            _data\n        );\n\n        setToken.invoke(targetExchange, callValue, methodData);\n\n        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);\n        require(\n            receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,\n            "Slippage too high"\n        );\n\n        return receiveTokenQuantity;\n    }\n\n    /\n     * Calculates protocol fee on module and pays protocol fee from SetToken\n     */\n    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {\n        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);\n\n        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);\n\n        return protocolFeeTotal;\n    }\n\n    /\n     * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)\n     /\n    function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {\n        _updateCollateralPosition(\n            actionInfo.setToken,\n            actionInfo.collateralCTokenAsset,\n            _getCollateralPosition(\n                actionInfo.setToken,\n                actionInfo.collateralCTokenAsset,\n                actionInfo.setTotalSupply\n            )\n        );\n\n        _updateBorrowPosition(\n            actionInfo.setToken,\n            _borrowAsset,\n            _getBorrowPosition(\n                actionInfo.setToken,\n                actionInfo.borrowCTokenAsset,\n                actionInfo.setTotalSupply,\n                false // Do not accrue interest\n            )\n        );\n    }\n\n    function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {\n        _setToken.editDefaultPosition(address(_cToken), _newPositionUnit);\n    }\n\n    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {\n        _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, "");\n    }\n\n    /\n     * Construct the ActionInfo struct for lever and delever\n     /\n    function _createAndValidateActionInfo(\n        ISetToken _setToken,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        uint256 _sendQuantityUnits,\n        uint256 _minReceiveQuantityUnits,\n        string memory _tradeAdapterName,\n        bool _isLever\n    )\n        internal\n        view\n        returns(ActionInfo memory)\n    {\n        uint256 totalSupply = _setToken.totalSupply();\n\n        return _createAndValidateActionInfoNotional(\n            _setToken,\n            _sendToken,\n            _receiveToken,\n            _sendQuantityUnits.preciseMul(totalSupply),\n            _minReceiveQuantityUnits.preciseMul(totalSupply),\n            _tradeAdapterName,\n            _isLever\n        );\n    }\n\n    /\n     * Construct the ActionInfo struct for lever and delever accepting notional units\n     */\n    function _createAndValidateActionInfoNotional(\n        ISetToken _setToken,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        uint256 _notionalSendQuantity,\n        uint256 _minNotionalReceiveQuantity,\n        string memory _tradeAdapterName,\n        bool _isLever\n    )\n        internal\n        view\n        returns(ActionInfo memory)\n    {\n        uint256 totalSupply = _setToken.totalSupply();\n        ActionInfo memory actionInfo = ActionInfo ({\n            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),\n            setToken: _setToken,\n            collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],\n            borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],\n            setTotalSupply: totalSupply,\n            notionalSendQuantity: _notionalSendQuantity,\n            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,\n            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))\n        });\n\n        _validateCommon(actionInfo);\n\n        return actionInfo;\n    }\n\n\n\n    function _validateCommon(ActionInfo memory _actionInfo) internal view {\n        require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");\n        require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");\n        require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");\n        require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0");\n    }\n\n    function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {\n        uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));\n        return collateralNotionalBalance.preciseDiv(_setTotalSupply);\n    }\n\n    /\n     * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.\n     * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.\n     */\n    function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {\n        uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));\n        // Round negative away from 0\n        int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);\n\n        return borrowPositionUnit;\n    }\n}', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 02:00:39 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { Compound } from "../../integration/lib/Compound.sol"; import { ICErc20 } from "../../../interfaces/external/ICErc20.sol"; import { IComptroller } from "../../../interfaces/external/IComptroller.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol"; import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; /*  * @title CompoundLeverageModule  * @author Set Protocol  *  * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call  * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each  * asset is leveraged when using this module.  *  * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of  * debt when borrowed assets are the same.  *  / contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {     using Compound for ISetToken; /* ============ Structs ============ */  struct EnabledAssets {     address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken     address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken     address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets }  struct ActionInfo {     ISetToken setToken;                      // SetToken instance     IExchangeAdapter exchangeAdapter;        // Exchange adapter instance     uint256 setTotalSupply;                  // Total supply of SetToken     uint256 notionalSendQuantity;            // Total notional quantity sent to exchange     uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange     ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset     ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset     uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance }  /* ============ Events ============ */  event LeverageIncreased(     ISetToken indexed _setToken,     IERC20 indexed _borrowAsset,     IERC20 indexed _collateralAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalBorrowAmount,     uint256 _totalReceiveAmount,     uint256 _protocolFee );  event LeverageDecreased(     ISetToken indexed _setToken,     IERC20 indexed _collateralAsset,     IERC20 indexed _repayAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalRedeemAmount,     uint256 _totalRepayAmount,     uint256 _protocolFee );  event CollateralAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  event BorrowAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  event SetTokenStatusUpdated(     ISetToken indexed _setToken,     bool indexed _added );  event AnySetAllowedUpdated(     bool indexed _anySetAllowed );  /* ============ Constants ============ */  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the trade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Mapping of underlying to CToken. If ETH, then map WETH to cETH mapping(IERC20 =&gt; ICErc20) public underlyingToCToken;  // Wrapped Ether address IERC20 internal weth;  // Compound cEther address ICErc20 internal cEther;  // Compound Comptroller contract IComptroller internal comptroller;  // COMP token address IERC20 internal compToken;  // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public collateralCTokenEnabled;  // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public borrowCTokenEnabled;  // Mapping of enabled collateral and borrow cTokens for syncing positions mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;  // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance mapping(ISetToken =&gt; bool) public allowedSetTokens;  // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list bool public anySetAllowed;   /* ============ Constructor ============ */  /**  * Instantiate addresses. Underlying to cToken mapping is created.  *  * @param _controller               Address of controller contract  * @param _compToken                Address of COMP token  * @param _comptroller              Address of Compound Comptroller  * @param _cEther                   Address of cEther contract  * @param _weth                     Address of WETH contract  */ constructor(     IController _controller,     IERC20 _compToken,     IComptroller _comptroller,     ICErc20 _cEther,     IERC20 _weth )     public     ModuleBase(_controller) {     compToken = _compToken;     comptroller = _comptroller;     cEther = _cEther;     weth = _weth;      ICErc20[] memory cTokens = comptroller.getAllMarkets();      for(uint256 i = 0; i &lt; cTokens.length; i++) {         ICErc20 cToken = cTokens[i];         underlyingToCToken[             cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())         ] = cToken;     } }  /* ============ External Functions ============ */  /**  * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.  * Performs a DEX trade, exchanging the borrow asset for collateral asset.  *  * @param _setToken             Instance of the SetToken  * @param _borrowAsset          Address of asset being borrowed for leverage  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _borrowQuantity       Borrow quantity of asset in position units  * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function lever(     ISetToken _setToken,     IERC20 _borrowAsset,     IERC20 _collateralAsset,     uint256 _borrowQuantity,     uint256 _minReceiveQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // For levering up, send quantity is derived from borrow asset and receive quantity is derived from     // collateral asset     ActionInfo memory leverInfo = _createAndValidateActionInfo(         _setToken,         _borrowAsset,         _collateralAsset,         _borrowQuantity,         _minReceiveQuantity,         _tradeAdapterName,         true     );      _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);      uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);      _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);      _updateLeverPositions(leverInfo, _borrowAsset);      emit LeverageIncreased(         _setToken,         _borrowAsset,         _collateralAsset,         leverInfo.exchangeAdapter,         leverInfo.notionalSendQuantity,         postTradeCollateralQuantity,         protocolFee     ); }  /**  * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled  *  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _repayAsset           Address of asset being repaid  * @param _redeemQuantity       Quantity of collateral asset to delever  * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function delever(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantity,     uint256 _minRepayQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from     // repay asset     ActionInfo memory deleverInfo = _createAndValidateActionInfo(         _setToken,         _collateralAsset,         _repayAsset,         _redeemQuantity,         _minRepayQuantity,         _tradeAdapterName,         false     );      _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);      uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);      _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);      _updateLeverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         repayQuantity,         protocolFee     ); }  /**  * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received  * borrow asset is updated as equity. No protocol fee is charged.  *  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)  * @param _redeemQuantity       Quantity of collateral asset to delever  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function deleverToZeroBorrowBalance(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());      require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");     uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));      ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(         _setToken,         _collateralAsset,         _repayAsset,         notionalRedeemQuantity,         notionalRepayQuantity,         _tradeAdapterName,         false     );      _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);      _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly     _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);      // Update default position first to save gas on editing borrow position     _setToken.calculateAndEditDefaultPosition(         address(_repayAsset),         deleverInfo.setTotalSupply,         deleverInfo.preTradeReceiveTokenBalance     );      _updateLeverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         notionalRepayQuantity,         0 // No protocol fee     ); }  /**  * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral  * assets, update cToken default position. For borrow assets, update external borrow position.  * - Collateral assets may come out of sync when a position is liquidated  * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid  *  * @param _setToken               Instance of the SetToken  * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value  */ function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {     uint256 setTotalSupply = _setToken.totalSupply();      // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption     if (setTotalSupply &gt; 0) {         // Loop through collateral assets         address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;         for(uint256 i = 0; i &lt; collateralCTokens.length; i++) {             ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);             uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();             uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (previousPositionUnit != newPositionUnit) {               _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);             }         }          // Loop through borrow assets         address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;         address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;         for(uint256 i = 0; i &lt; borrowCTokens.length; i++) {             ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);             IERC20 borrowAsset = IERC20(borrowAssets[i]);              int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));              int256 newPositionUnit = _getBorrowPosition(                 _setToken,                 borrowCToken,                 setTotalSupply,                 _shouldAccrueInterest             );              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (newPositionUnit != previousPositionUnit) {                 _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);             }         }     } }   /**  * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable  * collateral and borrow assets that don't exist as positions on the SetToken  *  * @param _setToken             Instance of the SetToken to initialize  * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken  * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken  */ function initialize(     ISetToken _setToken,     IERC20[] memory _collateralAssets,     IERC20[] memory _borrowAssets )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     if (!anySetAllowed) {         require(allowedSetTokens[_setToken], "Not allowed SetToken");     }      // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}     }      // Enable collateral and borrow assets on Compound     addCollateralAssets(_setToken, _collateralAssets);      addBorrowAssets(_setToken, _borrowAssets); }  /**  * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled  * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)  */ function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Sync Compound and SetToken positions prior to any removal action     sync(setToken, true);      address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;     for (uint256 i = 0; i &lt; borrowCTokens.length; i++) {         ICErc20 cToken = ICErc20(borrowCTokens[i]);          // Will exit only if token isn't also being used as collateral         if(!collateralCTokenEnabled[setToken][cToken]) {             // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound             setToken.invokeExitMarket(cToken, comptroller);         }          delete borrowCTokenEnabled[setToken][cToken];     }      address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;     for (uint256 i = 0; i &lt; collateralCTokens.length; i++) {         ICErc20 cToken = ICErc20(collateralCTokens[i]);          setToken.invokeExitMarket(cToken, comptroller);          delete collateralCTokenEnabled[setToken][cToken];     }      delete enabledAssets[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken  * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state  * inconsistencies  *  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets  *  * @param _setToken             Instance of the SetToken  * @param _newCollateralAssets  Addresses of new collateral underlying assets  */ function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {     for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];         require(address(cToken) != address(0), "cToken must exist");         require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");          // Note: Will only enter market if cToken is not enabled as a borrow asset as well         if (!borrowCTokenEnabled[_setToken][cToken]) {             _setToken.invokeEnterMarkets(cToken, comptroller);         }          collateralCTokenEnabled[_setToken][cToken] = true;         enabledAssets[_setToken].collateralCTokens.push(address(cToken));     }      emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets); }  /**  * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets  * If there is a borrow balance, collateral asset cannot be removed  *  * @param _setToken             Instance of the SetToken  * @param _collateralAssets     Addresses of collateral underlying assets to remove  */ function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {     // Sync Compound and SetToken positions prior to any removal action     sync(_setToken, true);      for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];         require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");          // Note: Will only exit market if cToken is not enabled as a borrow asset as well         // If there is an existing borrow balance, will revert and market cannot be exited on Compound         if (!borrowCTokenEnabled[_setToken][cToken]) {             _setToken.invokeExitMarket(cToken, comptroller);         }          delete collateralCTokenEnabled[_setToken][cToken];         enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));     }      emit CollateralAssetsUpdated(_setToken, false, _collateralAssets); }  /**  * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets  *  * @param _setToken             Instance of the SetToken  * @param _newBorrowAssets      Addresses of borrow underlying assets to add  */ function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {     for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {         IERC20 newBorrowAsset = _newBorrowAssets[i];         ICErc20 cToken = underlyingToCToken[newBorrowAsset];         require(address(cToken) != address(0), "cToken must exist");         require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");          // Note: Will only enter market if cToken is not enabled as a borrow asset as well         if (!collateralCTokenEnabled[_setToken][cToken]) {             _setToken.invokeEnterMarkets(cToken, comptroller);         }          borrowCTokenEnabled[_setToken][cToken] = true;         enabledAssets[_setToken].borrowCTokens.push(address(cToken));         enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));     }      emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets); }  /**  * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets  * If there is a borrow balance, borrow asset cannot be removed  *  * @param _setToken             Instance of the SetToken  * @param _borrowAssets         Addresses of borrow underlying assets to remove  */ function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {     // Sync Compound and SetToken positions prior to any removal action     sync(_setToken, true);      for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];         require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");          // Note: Will only exit market if cToken is not enabled as a collateral asset as well         // If there is an existing borrow balance, will revert and market cannot be exited on Compound         if (!collateralCTokenEnabled[_setToken][cToken]) {             _setToken.invokeExitMarket(cToken, comptroller);         }          delete borrowCTokenEnabled[_setToken][cToken];         enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));         enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));     }      emit BorrowAssetsUpdated(_setToken, false, _borrowAssets); }  /**  * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.  *  * @param _setToken             Instance of the SetToken  */ function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {     allowedSetTokens[_setToken] = _status;     emit SetTokenStatusUpdated(_setToken, _status); }  /**  * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.  *  * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled  */ function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {     anySetAllowed = _anySetAllowed;     emit AnySetAllowedUpdated(_anySetAllowed); }  /**  * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.  *  * IMPORTANT: Validations are skipped in order to get contract under bytecode limit  *  * @param _cToken                   Address of cToken to add  * @param _underlying               Address of underlying token that maps to cToken  */ function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {     require(address(underlyingToCToken[_underlying]) == address(0), "Already added");     underlyingToCToken[_underlying] = _cToken; }  /**  * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals  *  * IMPORTANT: Validations are skipped in order to get contract under bytecode limit  *  * @param _underlying               Address of underlying token to remove  */ function removeCompoundMarket(IERC20 _underlying) external onlyOwner {     require(address(underlyingToCToken[_underlying]) != address(0), "Not added");     delete underlyingToCToken[_underlying]; }  /**  * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {     sync(_setToken, false); }  /**  * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.  * Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {     sync(_setToken, true); }  /**  * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {     int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));      require(componentDebt &lt; 0, "Component must be negative");      uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);      _borrow(_setToken, underlyingToCToken[_component], notionalDebt); }  /**  * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {     int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));      require(componentDebt &lt; 0, "Component must be negative");      uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);      _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt); }   /* ============ External Getter Functions ============ */  /**  * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an  * array of underlying that are borrow assets.  *  * @return                    Collateral cToken assets that are enabled  * @return                    Underlying borrowed assets that are enabled.  */ function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {     return (         enabledAssets[_setToken].collateralCTokens,         enabledAssets[_setToken].borrowAssets     ); }  /* ============ Internal Functions ============ */  /**  * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be  * unwrapped as it only accepts the underlying ETH.  */ function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {     if (_cToken == cEther) {         _setToken.invokeUnwrapWETH(address(weth), _mintNotional);          _setToken.invokeMintCEther(_cToken, _mintNotional);     } else {         _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);          _setToken.invokeMintCToken(_cToken, _mintNotional);     } }  /**  * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.  */ function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {     _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);      if (_cToken == cEther) {         _setToken.invokeWrapWETH(address(weth), _redeemNotional);     } }  /**  * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.  */ function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {     if (_cToken == cEther) {         _setToken.invokeUnwrapWETH(address(weth), _repayNotional);          _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);     } else {         // Approve to cToken         _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);         _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);     } }  /**  * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.  */ function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {     _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);     if (_cToken == cEther) {         _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);     } }  /**  * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken  *  * @return receiveTokenQuantity The quantity of tokens received post-trade  */ function _executeTrade(     ActionInfo memory _actionInfo,     IERC20 _sendToken,     IERC20 _receiveToken,     bytes memory _data )     internal     returns (uint256) {      ISetToken setToken = _actionInfo.setToken;      uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;       setToken.invokeApprove(         address(_sendToken),         _actionInfo.exchangeAdapter.getSpender(),         notionalSendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _actionInfo.exchangeAdapter.getTradeCalldata(         address(_sendToken),         address(_receiveToken),         address(setToken),         notionalSendQuantity,         _actionInfo.minNotionalReceiveQuantity,         _data     );      setToken.invoke(targetExchange, callValue, methodData);      uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);     require(         receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,         "Slippage too high"     );      return receiveTokenQuantity; }  /**  * Calculates protocol fee on module and pays protocol fee from SetToken  */ function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {     uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);      payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);      return protocolFeeTotal; }  /**  * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)  */ function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {     _updateCollateralPosition(         actionInfo.setToken,         actionInfo.collateralCTokenAsset,         _getCollateralPosition(             actionInfo.setToken,             actionInfo.collateralCTokenAsset,             actionInfo.setTotalSupply         )     );      _updateBorrowPosition(         actionInfo.setToken,         _borrowAsset,         _getBorrowPosition(             actionInfo.setToken,             actionInfo.borrowCTokenAsset,             actionInfo.setTotalSupply,             false // Do not accrue interest         )     ); }  function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {     _setToken.editDefaultPosition(address(_cToken), _newPositionUnit); }  function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {     _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, ""); }  /**  * Construct the ActionInfo struct for lever and delever  */ function _createAndValidateActionInfo(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _sendQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();      return _createAndValidateActionInfoNotional(         _setToken,         _sendToken,         _receiveToken,         _sendQuantityUnits.preciseMul(totalSupply),         _minReceiveQuantityUnits.preciseMul(totalSupply),         _tradeAdapterName,         _isLever     ); }  /**  * Construct the ActionInfo struct for lever and delever accepting notional units  */ function _createAndValidateActionInfoNotional(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _notionalSendQuantity,     uint256 _minNotionalReceiveQuantity,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();     ActionInfo memory actionInfo = ActionInfo ({         exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),         setToken: _setToken,         collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],         borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],         setTotalSupply: totalSupply,         notionalSendQuantity: _notionalSendQuantity,         minNotionalReceiveQuantity: _minNotionalReceiveQuantity,         preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))     });      _validateCommon(actionInfo);      return actionInfo; }    function _validateCommon(ActionInfo memory _actionInfo) internal view {     require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");     require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");     require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");     require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0"); }  function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {     uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));     return collateralNotionalBalance.preciseDiv(_setTotalSupply); }  /**  * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.  * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.  */ function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {     uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));     // Round negative away from 0     int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);      return borrowPositionUnit; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 02:00:39 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { Compound } from "../../integration/lib/Compound.sol";
import { ICErc20 } from "../../../interfaces/external/ICErc20.sol";
import { IComptroller } from "../../../interfaces/external/IComptroller.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title CompoundLeverageModule
 * @author Set Protocol
 *
 * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call
 * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each
 * asset is leveraged when using this module.
 *
 * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 *
 */
contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {
    using Compound for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken
        address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken
        address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset
        ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    /* ============ Events ============ */

    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the trade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping of underlying to CToken. If ETH, then map WETH to cETH
    mapping(IERC20 => ICErc20) public underlyingToCToken;

    // Wrapped Ether address
    IERC20 internal weth;

    // Compound cEther address
    ICErc20 internal cEther;

    // Compound Comptroller contract
    IComptroller internal comptroller;

    // COMP token address
    IERC20 internal compToken;

    // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public collateralCTokenEnabled;

    // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public borrowCTokenEnabled;

    // Mapping of enabled collateral and borrow cTokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list
    bool public anySetAllowed;


    /* ============ Constructor ============ */

    /**
     * Instantiate addresses. Underlying to cToken mapping is created.
     *
     * @param _controller               Address of controller contract
     * @param _compToken                Address of COMP token
     * @param _comptroller              Address of Compound Comptroller
     * @param _cEther                   Address of cEther contract
     * @param _weth                     Address of WETH contract
     */
    constructor(
        IController _controller,
        IERC20 _compToken,
        IComptroller _comptroller,
        ICErc20 _cEther,
        IERC20 _weth
    )
        public
        ModuleBase(_controller)
    {
        compToken = _compToken;
        comptroller = _comptroller;
        cEther = _cEther;
        weth = _weth;

        ICErc20[] memory cTokens = comptroller.getAllMarkets();

        for(uint256 i = 0; i < cTokens.length; i++) {
            ICErc20 cToken = cTokens[i];
            underlyingToCToken[
                cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())
            ] = cToken;
        }
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.
     * Performs a DEX trade, exchanging the borrow asset for collateral asset.
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAsset          Address of asset being borrowed for leverage
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _borrowQuantity       Borrow quantity of asset in position units
     * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantity,
        uint256 _minReceiveQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantity,
            _minReceiveQuantity,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        uint256 _minRepayQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantity,
            _minRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received
     * borrow asset is updated as equity. No protocol fee is charged.
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());

        require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly
        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);

        // Update default position first to save gas on editing borrow position
        _setToken.calculateAndEditDefaultPosition(
            address(_repayAsset),
            deleverInfo.setTotalSupply,
            deleverInfo.preTradeReceiveTokenBalance
        );

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0 // No protocol fee
        );
    }

    /**
     * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral
     * assets, update cToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     *
     * @param _setToken               Instance of the SetToken
     * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value
     */
    function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption
        if (setTotalSupply > 0) {
            // Loop through collateral assets
            address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;
            for(uint256 i = 0; i < collateralCTokens.length; i++) {
                ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);
                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);
                }
            }

            // Loop through borrow assets
            address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;
            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowCTokens.length; i++) {
                ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));

                int256 newPositionUnit = _getBorrowPosition(
                    _setToken,
                    borrowCToken,
                    setTotalSupply,
                    _shouldAccrueInterest
                );

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }


    /**
     * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable
     * collateral and borrow assets that don't exist as positions on the SetToken
     *
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // Enable collateral and borrow assets on Compound
        addCollateralAssets(_setToken, _collateralAssets);

        addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled
     * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Compound and SetToken positions prior to any removal action
        sync(setToken, true);

        address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;
        for (uint256 i = 0; i < borrowCTokens.length; i++) {
            ICErc20 cToken = ICErc20(borrowCTokens[i]);

            // Will exit only if token isn't also being used as collateral
            if(!collateralCTokenEnabled[setToken][cToken]) {
                // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound
                setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[setToken][cToken];
        }

        address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;
        for (uint256 i = 0; i < collateralCTokens.length; i++) {
            ICErc20 cToken = ICErc20(collateralCTokens[i]);

            setToken.invokeExitMarket(cToken, comptroller);

            delete collateralCTokenEnabled[setToken][cToken];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken
     * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];
            require(address(cToken) != address(0), "cToken must exist");
            require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            collateralCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].collateralCTokens.push(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets
     * If there is a borrow balance, collateral asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];
            require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");

            // Note: Will only exit market if cToken is not enabled as a borrow asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete collateralCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 newBorrowAsset = _newBorrowAssets[i];
            ICErc20 cToken = underlyingToCToken[newBorrowAsset];
            require(address(cToken) != address(0), "cToken must exist");
            require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            borrowCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].borrowCTokens.push(address(cToken));
            enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));
        }

        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets
     * If there is a borrow balance, borrow asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];
            require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");

            // Note: Will only exit market if cToken is not enabled as a collateral asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));
            enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));
        }

        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.
     *
     * @param _setToken             Instance of the SetToken
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.
     *
     * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _cToken                   Address of cToken to add
     * @param _underlying               Address of underlying token that maps to cToken
     */
    function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) == address(0), "Already added");
        underlyingToCToken[_underlying] = _cToken;
    }

    /**
     * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _underlying               Address of underlying token to remove
     */
    function removeCompoundMarket(IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) != address(0), "Not added");
        delete underlyingToCToken[_underlying];
    }

    /**
     * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, false);
    }

    /**
     * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.
     * Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, true);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);

        _borrow(_setToken, underlyingToCToken[_component], notionalDebt);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);

        _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt);
    }


    /* ============ External Getter Functions ============ */

    /**
     * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an
     * array of underlying that are borrow assets.
     *
     * @return                    Collateral cToken assets that are enabled
     * @return                    Underlying borrowed assets that are enabled.
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralCTokens,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be
     * unwrapped as it only accepts the underlying ETH.
     */
    function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _mintNotional);

            _setToken.invokeMintCEther(_cToken, _mintNotional);
        } else {
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);

            _setToken.invokeMintCToken(_cToken, _mintNotional);
        }
    }

    /**
     * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.
     */
    function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {
        _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);

        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _redeemNotional);
        }
    }

    /**
     * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.
     */
    function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _repayNotional);

            _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);
        } else {
            // Approve to cToken
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);
            _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);
        }
    }

    /**
     * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.
     */
    function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {
        _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);
        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);
        }
    }

    /**
     * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     *
     * @return receiveTokenQuantity The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
         ISetToken setToken = _actionInfo.setToken;
         uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

         setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * Calculates protocol fee on module and pays protocol fee from SetToken
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)
     */
    function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {
        _updateCollateralPosition(
            actionInfo.setToken,
            actionInfo.collateralCTokenAsset,
            _getCollateralPosition(
                actionInfo.setToken,
                actionInfo.collateralCTokenAsset,
                actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                actionInfo.setToken,
                actionInfo.borrowCTokenAsset,
                actionInfo.setTotalSupply,
                false // Do not accrue interest
            )
        );
    }

    function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_cToken), _newPositionUnit);
    }

    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, "");
    }

    /**
     * Construct the ActionInfo struct for lever and delever
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever
        );
    }

    /**
     * Construct the ActionInfo struct for lever and delever accepting notional units
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            setToken: _setToken,
            collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],
            borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],
            setTotalSupply: totalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }



    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");
        require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");
        require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.
     * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.
     */
    function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {
        uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));
        // Round negative away from 0
        int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);

        return borrowPositionUnit;
    }
}.]

Given the user's task and the brainstorming ideas provided:
Task: "/*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { Compound } from "../../integration/lib/Compound.sol";
import { ICErc20 } from "../../../interfaces/external/ICErc20.sol";
import { IComptroller } from "../../../interfaces/external/IComptroller.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title CompoundLeverageModule
 * @author Set Protocol
 *
 * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call
 * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each
 * asset is leveraged when using this module.
 *
 * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 *
 */
contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {
    using Compound for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken
        address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken
        address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset
        ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    /* ============ Events ============ */

    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the trade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping of underlying to CToken. If ETH, then map WETH to cETH
    mapping(IERC20 => ICErc20) public underlyingToCToken;

    // Wrapped Ether address
    IERC20 internal weth;

    // Compound cEther address
    ICErc20 internal cEther;

    // Compound Comptroller contract
    IComptroller internal comptroller;

    // COMP token address
    IERC20 internal compToken;

    // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public collateralCTokenEnabled;

    // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public borrowCTokenEnabled;

    // Mapping of enabled collateral and borrow cTokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list
    bool public anySetAllowed;


    /* ============ Constructor ============ */

    /**
     * Instantiate addresses. Underlying to cToken mapping is created.
     *
     * @param _controller               Address of controller contract
     * @param _compToken                Address of COMP token
     * @param _comptroller              Address of Compound Comptroller
     * @param _cEther                   Address of cEther contract
     * @param _weth                     Address of WETH contract
     */
    constructor(
        IController _controller,
        IERC20 _compToken,
        IComptroller _comptroller,
        ICErc20 _cEther,
        IERC20 _weth
    )
        public
        ModuleBase(_controller)
    {
        compToken = _compToken;
        comptroller = _comptroller;
        cEther = _cEther;
        weth = _weth;

        ICErc20[] memory cTokens = comptroller.getAllMarkets();

        for(uint256 i = 0; i < cTokens.length; i++) {
            ICErc20 cToken = cTokens[i];
            underlyingToCToken[
                cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())
            ] = cToken;
        }
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.
     * Performs a DEX trade, exchanging the borrow asset for collateral asset.
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAsset          Address of asset being borrowed for leverage
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _borrowQuantity       Borrow quantity of asset in position units
     * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantity,
        uint256 _minReceiveQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantity,
            _minReceiveQuantity,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        uint256 _minRepayQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantity,
            _minRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received
     * borrow asset is updated as equity. No protocol fee is charged.
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());

        require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly
        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);

        // Update default position first to save gas on editing borrow position
        _setToken.calculateAndEditDefaultPosition(
            address(_repayAsset),
            deleverInfo.setTotalSupply,
            deleverInfo.preTradeReceiveTokenBalance
        );

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0 // No protocol fee
        );
    }

    /**
     * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral
     * assets, update cToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     *
     * @param _setToken               Instance of the SetToken
     * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value
     */
    function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption
        if (setTotalSupply > 0) {
            // Loop through collateral assets
            address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;
            for(uint256 i = 0; i < collateralCTokens.length; i++) {
                ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);
                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);
                }
            }

            // Loop through borrow assets
            address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;
            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowCTokens.length; i++) {
                ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));

                int256 newPositionUnit = _getBorrowPosition(
                    _setToken,
                    borrowCToken,
                    setTotalSupply,
                    _shouldAccrueInterest
                );

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }


    /**
     * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable
     * collateral and borrow assets that don't exist as positions on the SetToken
     *
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // Enable collateral and borrow assets on Compound
        addCollateralAssets(_setToken, _collateralAssets);

        addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled
     * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Compound and SetToken positions prior to any removal action
        sync(setToken, true);

        address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;
        for (uint256 i = 0; i < borrowCTokens.length; i++) {
            ICErc20 cToken = ICErc20(borrowCTokens[i]);

            // Will exit only if token isn't also being used as collateral
            if(!collateralCTokenEnabled[setToken][cToken]) {
                // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound
                setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[setToken][cToken];
        }

        address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;
        for (uint256 i = 0; i < collateralCTokens.length; i++) {
            ICErc20 cToken = ICErc20(collateralCTokens[i]);

            setToken.invokeExitMarket(cToken, comptroller);

            delete collateralCTokenEnabled[setToken][cToken];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken
     * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];
            require(address(cToken) != address(0), "cToken must exist");
            require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            collateralCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].collateralCTokens.push(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets
     * If there is a borrow balance, collateral asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];
            require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");

            // Note: Will only exit market if cToken is not enabled as a borrow asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete collateralCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 newBorrowAsset = _newBorrowAssets[i];
            ICErc20 cToken = underlyingToCToken[newBorrowAsset];
            require(address(cToken) != address(0), "cToken must exist");
            require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            borrowCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].borrowCTokens.push(address(cToken));
            enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));
        }

        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets
     * If there is a borrow balance, borrow asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];
            require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");

            // Note: Will only exit market if cToken is not enabled as a collateral asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));
            enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));
        }

        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.
     *
     * @param _setToken             Instance of the SetToken
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.
     *
     * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _cToken                   Address of cToken to add
     * @param _underlying               Address of underlying token that maps to cToken
     */
    function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) == address(0), "Already added");
        underlyingToCToken[_underlying] = _cToken;
    }

    /**
     * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _underlying               Address of underlying token to remove
     */
    function removeCompoundMarket(IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) != address(0), "Not added");
        delete underlyingToCToken[_underlying];
    }

    /**
     * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, false);
    }

    /**
     * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.
     * Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, true);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);

        _borrow(_setToken, underlyingToCToken[_component], notionalDebt);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);

        _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt);
    }


    /* ============ External Getter Functions ============ */

    /**
     * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an
     * array of underlying that are borrow assets.
     *
     * @return                    Collateral cToken assets that are enabled
     * @return                    Underlying borrowed assets that are enabled.
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralCTokens,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be
     * unwrapped as it only accepts the underlying ETH.
     */
    function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _mintNotional);

            _setToken.invokeMintCEther(_cToken, _mintNotional);
        } else {
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);

            _setToken.invokeMintCToken(_cToken, _mintNotional);
        }
    }

    /**
     * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.
     */
    function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {
        _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);

        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _redeemNotional);
        }
    }

    /**
     * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.
     */
    function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _repayNotional);

            _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);
        } else {
            // Approve to cToken
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);
            _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);
        }
    }

    /**
     * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.
     */
    function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {
        _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);
        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);
        }
    }

    /**
     * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     *
     * @return receiveTokenQuantity The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
         ISetToken setToken = _actionInfo.setToken;
         uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

         setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * Calculates protocol fee on module and pays protocol fee from SetToken
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)
     */
    function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {
        _updateCollateralPosition(
            actionInfo.setToken,
            actionInfo.collateralCTokenAsset,
            _getCollateralPosition(
                actionInfo.setToken,
                actionInfo.collateralCTokenAsset,
                actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                actionInfo.setToken,
                actionInfo.borrowCTokenAsset,
                actionInfo.setTotalSupply,
                false // Do not accrue interest
            )
        );
    }

    function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_cToken), _newPositionUnit);
    }

    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, "");
    }

    /**
     * Construct the ActionInfo struct for lever and delever
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever
        );
    }

    /**
     * Construct the ActionInfo struct for lever and delever accepting notional units
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            setToken: _setToken,
            collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],
            borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],
            setTotalSupply: totalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }



    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");
        require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");
        require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.
     * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.
     */
    function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {
        uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));
        // Round negative away from 0
        int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);

        return borrowPositionUnit;
    }
}".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-01-09 02:00:42 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 02:00:42 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 18401
completion_tokens: 1
total_tokens: 18402
cost: $-1.000000


[2024-01-09 02:00:42 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { Compound } from "../../integration/lib/Compound.sol";
import { ICErc20 } from "../../../interfaces/external/ICErc20.sol";
import { IComptroller } from "../../../interfaces/external/IComptroller.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title CompoundLeverageModule
 * @author Set Protocol
 *
 * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call
 * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each
 * asset is leveraged when using this module.
 *
 * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 *
 */
contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {
    using Compound for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken
        address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken
        address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset
        ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    /* ============ Events ============ */

    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the trade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping of underlying to CToken. If ETH, then map WETH to cETH
    mapping(IERC20 => ICErc20) public underlyingToCToken;

    // Wrapped Ether address
    IERC20 internal weth;

    // Compound cEther address
    ICErc20 internal cEther;

    // Compound Comptroller contract
    IComptroller internal comptroller;

    // COMP token address
    IERC20 internal compToken;

    // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public collateralCTokenEnabled;

    // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public borrowCTokenEnabled;

    // Mapping of enabled collateral and borrow cTokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list
    bool public anySetAllowed;


    /* ============ Constructor ============ */

    /**
     * Instantiate addresses. Underlying to cToken mapping is created.
     *
     * @param _controller               Address of controller contract
     * @param _compToken                Address of COMP token
     * @param _comptroller              Address of Compound Comptroller
     * @param _cEther                   Address of cEther contract
     * @param _weth                     Address of WETH contract
     */
    constructor(
        IController _controller,
        IERC20 _compToken,
        IComptroller _comptroller,
        ICErc20 _cEther,
        IERC20 _weth
    )
        public
        ModuleBase(_controller)
    {
        compToken = _compToken;
        comptroller = _comptroller;
        cEther = _cEther;
        weth = _weth;

        ICErc20[] memory cTokens = comptroller.getAllMarkets();

        for(uint256 i = 0; i < cTokens.length; i++) {
            ICErc20 cToken = cTokens[i];
            underlyingToCToken[
                cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())
            ] = cToken;
        }
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.
     * Performs a DEX trade, exchanging the borrow asset for collateral asset.
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAsset          Address of asset being borrowed for leverage
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _borrowQuantity       Borrow quantity of asset in position units
     * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantity,
        uint256 _minReceiveQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantity,
            _minReceiveQuantity,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        uint256 _minRepayQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantity,
            _minRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received
     * borrow asset is updated as equity. No protocol fee is charged.
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());

        require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly
        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);

        // Update default position first to save gas on editing borrow position
        _setToken.calculateAndEditDefaultPosition(
            address(_repayAsset),
            deleverInfo.setTotalSupply,
            deleverInfo.preTradeReceiveTokenBalance
        );

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0 // No protocol fee
        );
    }

    /**
     * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral
     * assets, update cToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     *
     * @param _setToken               Instance of the SetToken
     * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value
     */
    function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption
        if (setTotalSupply > 0) {
            // Loop through collateral assets
            address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;
            for(uint256 i = 0; i < collateralCTokens.length; i++) {
                ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);
                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);
                }
            }

            // Loop through borrow assets
            address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;
            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowCTokens.length; i++) {
                ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));

                int256 newPositionUnit = _getBorrowPosition(
                    _setToken,
                    borrowCToken,
                    setTotalSupply,
                    _shouldAccrueInterest
                );

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }


    /**
     * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable
     * collateral and borrow assets that don't exist as positions on the SetToken
     *
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // Enable collateral and borrow assets on Compound
        addCollateralAssets(_setToken, _collateralAssets);

        addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled
     * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Compound and SetToken positions prior to any removal action
        sync(setToken, true);

        address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;
        for (uint256 i = 0; i < borrowCTokens.length; i++) {
            ICErc20 cToken = ICErc20(borrowCTokens[i]);

            // Will exit only if token isn't also being used as collateral
            if(!collateralCTokenEnabled[setToken][cToken]) {
                // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound
                setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[setToken][cToken];
        }

        address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;
        for (uint256 i = 0; i < collateralCTokens.length; i++) {
            ICErc20 cToken = ICErc20(collateralCTokens[i]);

            setToken.invokeExitMarket(cToken, comptroller);

            delete collateralCTokenEnabled[setToken][cToken];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken
     * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];
            require(address(cToken) != address(0), "cToken must exist");
            require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            collateralCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].collateralCTokens.push(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets
     * If there is a borrow balance, collateral asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];
            require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");

            // Note: Will only exit market if cToken is not enabled as a borrow asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete collateralCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 newBorrowAsset = _newBorrowAssets[i];
            ICErc20 cToken = underlyingToCToken[newBorrowAsset];
            require(address(cToken) != address(0), "cToken must exist");
            require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            borrowCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].borrowCTokens.push(address(cToken));
            enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));
        }

        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets
     * If there is a borrow balance, borrow asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];
            require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");

            // Note: Will only exit market if cToken is not enabled as a collateral asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));
            enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));
        }

        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.
     *
     * @param _setToken             Instance of the SetToken
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.
     *
     * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _cToken                   Address of cToken to add
     * @param _underlying               Address of underlying token that maps to cToken
     */
    function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) == address(0), "Already added");
        underlyingToCToken[_underlying] = _cToken;
    }

    /**
     * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _underlying               Address of underlying token to remove
     */
    function removeCompoundMarket(IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) != address(0), "Not added");
        delete underlyingToCToken[_underlying];
    }

    /**
     * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, false);
    }

    /**
     * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.
     * Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, true);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);

        _borrow(_setToken, underlyingToCToken[_component], notionalDebt);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);

        _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt);
    }


    /* ============ External Getter Functions ============ */

    /**
     * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an
     * array of underlying that are borrow assets.
     *
     * @return                    Collateral cToken assets that are enabled
     * @return                    Underlying borrowed assets that are enabled.
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralCTokens,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be
     * unwrapped as it only accepts the underlying ETH.
     */
    function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _mintNotional);

            _setToken.invokeMintCEther(_cToken, _mintNotional);
        } else {
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);

            _setToken.invokeMintCToken(_cToken, _mintNotional);
        }
    }

    /**
     * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.
     */
    function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {
        _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);

        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _redeemNotional);
        }
    }

    /**
     * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.
     */
    function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _repayNotional);

            _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);
        } else {
            // Approve to cToken
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);
            _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);
        }
    }

    /**
     * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.
     */
    function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {
        _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);
        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);
        }
    }

    /**
     * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     *
     * @return receiveTokenQuantity The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
         ISetToken setToken = _actionInfo.setToken;
         uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

         setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * Calculates protocol fee on module and pays protocol fee from SetToken
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)
     */
    function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {
        _updateCollateralPosition(
            actionInfo.setToken,
            actionInfo.collateralCTokenAsset,
            _getCollateralPosition(
                actionInfo.setToken,
                actionInfo.collateralCTokenAsset,
                actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                actionInfo.setToken,
                actionInfo.borrowCTokenAsset,
                actionInfo.setTotalSupply,
                false // Do not accrue interest
            )
        );
    }

    function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_cToken), _newPositionUnit);
    }

    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, "");
    }

    /**
     * Construct the ActionInfo struct for lever and delever
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever
        );
    }

    /**
     * Construct the ActionInfo struct for lever and delever accepting notional units
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            setToken: _setToken,
            collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],
            borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],
            setTotalSupply: totalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }



    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");
        require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");
        require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.
     * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.
     */
    function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {
        uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));
        // Round negative away from 0
        int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);

        return borrowPositionUnit;
    }
}.]

###

[2024-01-09 02:00:42 INFO] **[Seminar Conclusion]**:

 ###

[2024-01-09 02:00:42 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-01-09 02:00:42 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { Compound } from "../../integration/lib/Compound.sol"; import { ICErc20 } from "../../../interfaces/external/ICErc20.sol"; import { IComptroller } from "../../../interfaces/external/IComptroller.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol"; import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; /*  * @title CompoundLeverageModule  * @author Set Protocol  *  * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call  * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each  * asset is leveraged when using this module.  *  * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of  * debt when borrowed assets are the same.  *  / contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {     using Compound for ISetToken; /* ============ Structs ============ */  struct EnabledAssets {     address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken     address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken     address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets }  struct ActionInfo {     ISetToken setToken;                      // SetToken instance     IExchangeAdapter exchangeAdapter;        // Exchange adapter instance     uint256 setTotalSupply;                  // Total supply of SetToken     uint256 notionalSendQuantity;            // Total notional quantity sent to exchange     uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange     ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset     ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset     uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance }  /* ============ Events ============ */  event LeverageIncreased(     ISetToken indexed _setToken,     IERC20 indexed _borrowAsset,     IERC20 indexed _collateralAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalBorrowAmount,     uint256 _totalReceiveAmount,     uint256 _protocolFee );  event LeverageDecreased(     ISetToken indexed _setToken,     IERC20 indexed _collateralAsset,     IERC20 indexed _repayAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalRedeemAmount,     uint256 _totalRepayAmount,     uint256 _protocolFee );  event CollateralAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  event BorrowAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  event SetTokenStatusUpdated(     ISetToken indexed _setToken,     bool indexed _added );  event AnySetAllowedUpdated(     bool indexed _anySetAllowed );  /* ============ Constants ============ */  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the trade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Mapping of underlying to CToken. If ETH, then map WETH to cETH mapping(IERC20 =&gt; ICErc20) public underlyingToCToken;  // Wrapped Ether address IERC20 internal weth;  // Compound cEther address ICErc20 internal cEther;  // Compound Comptroller contract IComptroller internal comptroller;  // COMP token address IERC20 internal compToken;  // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public collateralCTokenEnabled;  // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public borrowCTokenEnabled;  // Mapping of enabled collateral and borrow cTokens for syncing positions mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;  // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance mapping(ISetToken =&gt; bool) public allowedSetTokens;  // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list bool public anySetAllowed;   /* ============ Constructor ============ */  /**  * Instantiate addresses. Underlying to cToken mapping is created.  *  * @param _controller               Address of controller contract  * @param _compToken                Address of COMP token  * @param _comptroller              Address of Compound Comptroller  * @param _cEther                   Address of cEther contract  * @param _weth                     Address of WETH contract  */ constructor(     IController _controller,     IERC20 _compToken,     IComptroller _comptroller,     ICErc20 _cEther,     IERC20 _weth )     public     ModuleBase(_controller) {     compToken = _compToken;     comptroller = _comptroller;     cEther = _cEther;     weth = _weth;      ICErc20[] memory cTokens = comptroller.getAllMarkets();      for(uint256 i = 0; i &lt; cTokens.length; i++) {         ICErc20 cToken = cTokens[i];         underlyingToCToken[             cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())         ] = cToken;     } }  /* ============ External Functions ============ */  /**  * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.  * Performs a DEX trade, exchanging the borrow asset for collateral asset.  *  * @param _setToken             Instance of the SetToken  * @param _borrowAsset          Address of asset being borrowed for leverage  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _borrowQuantity       Borrow quantity of asset in position units  * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function lever(     ISetToken _setToken,     IERC20 _borrowAsset,     IERC20 _collateralAsset,     uint256 _borrowQuantity,     uint256 _minReceiveQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // For levering up, send quantity is derived from borrow asset and receive quantity is derived from     // collateral asset     ActionInfo memory leverInfo = _createAndValidateActionInfo(         _setToken,         _borrowAsset,         _collateralAsset,         _borrowQuantity,         _minReceiveQuantity,         _tradeAdapterName,         true     );      _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);      uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);      _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);      _updateLeverPositions(leverInfo, _borrowAsset);      emit LeverageIncreased(         _setToken,         _borrowAsset,         _collateralAsset,         leverInfo.exchangeAdapter,         leverInfo.notionalSendQuantity,         postTradeCollateralQuantity,         protocolFee     ); }  /**  * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled  *  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _repayAsset           Address of asset being repaid  * @param _redeemQuantity       Quantity of collateral asset to delever  * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function delever(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantity,     uint256 _minRepayQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from     // repay asset     ActionInfo memory deleverInfo = _createAndValidateActionInfo(         _setToken,         _collateralAsset,         _repayAsset,         _redeemQuantity,         _minRepayQuantity,         _tradeAdapterName,         false     );      _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);      uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);      _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);      _updateLeverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         repayQuantity,         protocolFee     ); }  /**  * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received  * borrow asset is updated as equity. No protocol fee is charged.  *  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)  * @param _redeemQuantity       Quantity of collateral asset to delever  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function deleverToZeroBorrowBalance(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());      require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");     uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));      ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(         _setToken,         _collateralAsset,         _repayAsset,         notionalRedeemQuantity,         notionalRepayQuantity,         _tradeAdapterName,         false     );      _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);      _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly     _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);      // Update default position first to save gas on editing borrow position     _setToken.calculateAndEditDefaultPosition(         address(_repayAsset),         deleverInfo.setTotalSupply,         deleverInfo.preTradeReceiveTokenBalance     );      _updateLeverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         notionalRepayQuantity,         0 // No protocol fee     ); }  /**  * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral  * assets, update cToken default position. For borrow assets, update external borrow position.  * - Collateral assets may come out of sync when a position is liquidated  * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid  *  * @param _setToken               Instance of the SetToken  * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value  */ function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {     uint256 setTotalSupply = _setToken.totalSupply();      // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption     if (setTotalSupply &gt; 0) {         // Loop through collateral assets         address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;         for(uint256 i = 0; i &lt; collateralCTokens.length; i++) {             ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);             uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();             uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (previousPositionUnit != newPositionUnit) {               _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);             }         }          // Loop through borrow assets         address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;         address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;         for(uint256 i = 0; i &lt; borrowCTokens.length; i++) {             ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);             IERC20 borrowAsset = IERC20(borrowAssets[i]);              int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));              int256 newPositionUnit = _getBorrowPosition(                 _setToken,                 borrowCToken,                 setTotalSupply,                 _shouldAccrueInterest             );              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (newPositionUnit != previousPositionUnit) {                 _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);             }         }     } }   /**  * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable  * collateral and borrow assets that don't exist as positions on the SetToken  *  * @param _setToken             Instance of the SetToken to initialize  * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken  * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken  */ function initialize(     ISetToken _setToken,     IERC20[] memory _collateralAssets,     IERC20[] memory _borrowAssets )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     if (!anySetAllowed) {         require(allowedSetTokens[_setToken], "Not allowed SetToken");     }      // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}     }      // Enable collateral and borrow assets on Compound     addCollateralAssets(_setToken, _collateralAssets);      addBorrowAssets(_setToken, _borrowAssets); }  /**  * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled  * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)  */ function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Sync Compound and SetToken positions prior to any removal action     sync(setToken, true);      address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;     for (uint256 i = 0; i &lt; borrowCTokens.length; i++) {         ICErc20 cToken = ICErc20(borrowCTokens[i]);          // Will exit only if token isn't also being used as collateral         if(!collateralCTokenEnabled[setToken][cToken]) {             // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound             setToken.invokeExitMarket(cToken, comptroller);         }          delete borrowCTokenEnabled[setToken][cToken];     }      address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;     for (uint256 i = 0; i &lt; collateralCTokens.length; i++) {         ICErc20 cToken = ICErc20(collateralCTokens[i]);          setToken.invokeExitMarket(cToken, comptroller);          delete collateralCTokenEnabled[setToken][cToken];     }      delete enabledAssets[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken  * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state  * inconsistencies  *  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets  *  * @param _setToken             Instance of the SetToken  * @param _newCollateralAssets  Addresses of new collateral underlying assets  */ function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {     for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];         require(address(cToken) != address(0), "cToken must exist");         require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");          // Note: Will only enter market if cToken is not enabled as a borrow asset as well         if (!borrowCTokenEnabled[_setToken][cToken]) {             _setToken.invokeEnterMarkets(cToken, comptroller);         }          collateralCTokenEnabled[_setToken][cToken] = true;         enabledAssets[_setToken].collateralCTokens.push(address(cToken));     }      emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets); }  /**  * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets  * If there is a borrow balance, collateral asset cannot be removed  *  * @param _setToken             Instance of the SetToken  * @param _collateralAssets     Addresses of collateral underlying assets to remove  */ function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {     // Sync Compound and SetToken positions prior to any removal action     sync(_setToken, true);      for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];         require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");          // Note: Will only exit market if cToken is not enabled as a borrow asset as well         // If there is an existing borrow balance, will revert and market cannot be exited on Compound         if (!borrowCTokenEnabled[_setToken][cToken]) {             _setToken.invokeExitMarket(cToken, comptroller);         }          delete collateralCTokenEnabled[_setToken][cToken];         enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));     }      emit CollateralAssetsUpdated(_setToken, false, _collateralAssets); }  /**  * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets  *  * @param _setToken             Instance of the SetToken  * @param _newBorrowAssets      Addresses of borrow underlying assets to add  */ function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {     for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {         IERC20 newBorrowAsset = _newBorrowAssets[i];         ICErc20 cToken = underlyingToCToken[newBorrowAsset];         require(address(cToken) != address(0), "cToken must exist");         require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");          // Note: Will only enter market if cToken is not enabled as a borrow asset as well         if (!collateralCTokenEnabled[_setToken][cToken]) {             _setToken.invokeEnterMarkets(cToken, comptroller);         }          borrowCTokenEnabled[_setToken][cToken] = true;         enabledAssets[_setToken].borrowCTokens.push(address(cToken));         enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));     }      emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets); }  /**  * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets  * If there is a borrow balance, borrow asset cannot be removed  *  * @param _setToken             Instance of the SetToken  * @param _borrowAssets         Addresses of borrow underlying assets to remove  */ function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {     // Sync Compound and SetToken positions prior to any removal action     sync(_setToken, true);      for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];         require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");          // Note: Will only exit market if cToken is not enabled as a collateral asset as well         // If there is an existing borrow balance, will revert and market cannot be exited on Compound         if (!collateralCTokenEnabled[_setToken][cToken]) {             _setToken.invokeExitMarket(cToken, comptroller);         }          delete borrowCTokenEnabled[_setToken][cToken];         enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));         enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));     }      emit BorrowAssetsUpdated(_setToken, false, _borrowAssets); }  /**  * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.  *  * @param _setToken             Instance of the SetToken  */ function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {     allowedSetTokens[_setToken] = _status;     emit SetTokenStatusUpdated(_setToken, _status); }  /**  * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.  *  * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled  */ function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {     anySetAllowed = _anySetAllowed;     emit AnySetAllowedUpdated(_anySetAllowed); }  /**  * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.  *  * IMPORTANT: Validations are skipped in order to get contract under bytecode limit  *  * @param _cToken                   Address of cToken to add  * @param _underlying               Address of underlying token that maps to cToken  */ function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {     require(address(underlyingToCToken[_underlying]) == address(0), "Already added");     underlyingToCToken[_underlying] = _cToken; }  /**  * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals  *  * IMPORTANT: Validations are skipped in order to get contract under bytecode limit  *  * @param _underlying               Address of underlying token to remove  */ function removeCompoundMarket(IERC20 _underlying) external onlyOwner {     require(address(underlyingToCToken[_underlying]) != address(0), "Not added");     delete underlyingToCToken[_underlying]; }  /**  * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {     sync(_setToken, false); }  /**  * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.  * Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {     sync(_setToken, true); }  /**  * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {     int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));      require(componentDebt &lt; 0, "Component must be negative");      uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);      _borrow(_setToken, underlyingToCToken[_component], notionalDebt); }  /**  * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {     int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));      require(componentDebt &lt; 0, "Component must be negative");      uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);      _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt); }   /* ============ External Getter Functions ============ */  /**  * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an  * array of underlying that are borrow assets.  *  * @return                    Collateral cToken assets that are enabled  * @return                    Underlying borrowed assets that are enabled.  */ function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {     return (         enabledAssets[_setToken].collateralCTokens,         enabledAssets[_setToken].borrowAssets     ); }  /* ============ Internal Functions ============ */  /**  * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be  * unwrapped as it only accepts the underlying ETH.  */ function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {     if (_cToken == cEther) {         _setToken.invokeUnwrapWETH(address(weth), _mintNotional);          _setToken.invokeMintCEther(_cToken, _mintNotional);     } else {         _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);          _setToken.invokeMintCToken(_cToken, _mintNotional);     } }  /**  * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.  */ function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {     _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);      if (_cToken == cEther) {         _setToken.invokeWrapWETH(address(weth), _redeemNotional);     } }  /**  * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.  */ function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {     if (_cToken == cEther) {         _setToken.invokeUnwrapWETH(address(weth), _repayNotional);          _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);     } else {         // Approve to cToken         _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);         _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);     } }  /**  * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.  */ function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {     _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);     if (_cToken == cEther) {         _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);     } }  /**  * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken  *  * @return receiveTokenQuantity The quantity of tokens received post-trade  */ function _executeTrade(     ActionInfo memory _actionInfo,     IERC20 _sendToken,     IERC20 _receiveToken,     bytes memory _data )     internal     returns (uint256) {      ISetToken setToken = _actionInfo.setToken;      uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;       setToken.invokeApprove(         address(_sendToken),         _actionInfo.exchangeAdapter.getSpender(),         notionalSendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _actionInfo.exchangeAdapter.getTradeCalldata(         address(_sendToken),         address(_receiveToken),         address(setToken),         notionalSendQuantity,         _actionInfo.minNotionalReceiveQuantity,         _data     );      setToken.invoke(targetExchange, callValue, methodData);      uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);     require(         receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,         "Slippage too high"     );      return receiveTokenQuantity; }  /**  * Calculates protocol fee on module and pays protocol fee from SetToken  */ function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {     uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);      payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);      return protocolFeeTotal; }  /**  * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)  */ function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {     _updateCollateralPosition(         actionInfo.setToken,         actionInfo.collateralCTokenAsset,         _getCollateralPosition(             actionInfo.setToken,             actionInfo.collateralCTokenAsset,             actionInfo.setTotalSupply         )     );      _updateBorrowPosition(         actionInfo.setToken,         _borrowAsset,         _getBorrowPosition(             actionInfo.setToken,             actionInfo.borrowCTokenAsset,             actionInfo.setTotalSupply,             false // Do not accrue interest         )     ); }  function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {     _setToken.editDefaultPosition(address(_cToken), _newPositionUnit); }  function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {     _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, ""); }  /**  * Construct the ActionInfo struct for lever and delever  */ function _createAndValidateActionInfo(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _sendQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();      return _createAndValidateActionInfoNotional(         _setToken,         _sendToken,         _receiveToken,         _sendQuantityUnits.preciseMul(totalSupply),         _minReceiveQuantityUnits.preciseMul(totalSupply),         _tradeAdapterName,         _isLever     ); }  /**  * Construct the ActionInfo struct for lever and delever accepting notional units  */ function _createAndValidateActionInfoNotional(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _notionalSendQuantity,     uint256 _minNotionalReceiveQuantity,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();     ActionInfo memory actionInfo = ActionInfo ({         exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),         setToken: _setToken,         collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],         borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],         setTotalSupply: totalSupply,         notionalSendQuantity: _notionalSendQuantity,         minNotionalReceiveQuantity: _minNotionalReceiveQuantity,         preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))     });      _validateCommon(actionInfo);      return actionInfo; }    function _validateCommon(ActionInfo memory _actionInfo) internal view {     require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");     require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");     require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");     require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0"); }  function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {     uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));     return collateralNotionalBalance.preciseDiv(_setTotalSupply); }  /**  * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.  * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.  */ function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {     uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));     // Round negative away from 0     int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);      return borrowPositionUnit; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 02:00:42 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { Compound } from "../../integration/lib/Compound.sol"; import { ICErc20 } from "../../../interfaces/external/ICErc20.sol"; import { IComptroller } from "../../../interfaces/external/IComptroller.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol"; import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; /*  * @title CompoundLeverageModule  * @author Set Protocol  *  * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call  * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each  * asset is leveraged when using this module.  *  * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of  * debt when borrowed assets are the same.  *  / contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {     using Compound for ISetToken; /* ============ Structs ============ */  struct EnabledAssets {     address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken     address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken     address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets }  struct ActionInfo {     ISetToken setToken;                      // SetToken instance     IExchangeAdapter exchangeAdapter;        // Exchange adapter instance     uint256 setTotalSupply;                  // Total supply of SetToken     uint256 notionalSendQuantity;            // Total notional quantity sent to exchange     uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange     ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset     ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset     uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance }  /* ============ Events ============ */  event LeverageIncreased(     ISetToken indexed _setToken,     IERC20 indexed _borrowAsset,     IERC20 indexed _collateralAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalBorrowAmount,     uint256 _totalReceiveAmount,     uint256 _protocolFee );  event LeverageDecreased(     ISetToken indexed _setToken,     IERC20 indexed _collateralAsset,     IERC20 indexed _repayAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalRedeemAmount,     uint256 _totalRepayAmount,     uint256 _protocolFee );  event CollateralAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  event BorrowAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  event SetTokenStatusUpdated(     ISetToken indexed _setToken,     bool indexed _added );  event AnySetAllowedUpdated(     bool indexed _anySetAllowed );  /* ============ Constants ============ */  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the trade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Mapping of underlying to CToken. If ETH, then map WETH to cETH mapping(IERC20 =&gt; ICErc20) public underlyingToCToken;  // Wrapped Ether address IERC20 internal weth;  // Compound cEther address ICErc20 internal cEther;  // Compound Comptroller contract IComptroller internal comptroller;  // COMP token address IERC20 internal compToken;  // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public collateralCTokenEnabled;  // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public borrowCTokenEnabled;  // Mapping of enabled collateral and borrow cTokens for syncing positions mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;  // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance mapping(ISetToken =&gt; bool) public allowedSetTokens;  // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list bool public anySetAllowed;   /* ============ Constructor ============ */  /**  * Instantiate addresses. Underlying to cToken mapping is created.  *  * @param _controller               Address of controller contract  * @param _compToken                Address of COMP token  * @param _comptroller              Address of Compound Comptroller  * @param _cEther                   Address of cEther contract  * @param _weth                     Address of WETH contract  */ constructor(     IController _controller,     IERC20 _compToken,     IComptroller _comptroller,     ICErc20 _cEther,     IERC20 _weth )     public     ModuleBase(_controller) {     compToken = _compToken;     comptroller = _comptroller;     cEther = _cEther;     weth = _weth;      ICErc20[] memory cTokens = comptroller.getAllMarkets();      for(uint256 i = 0; i &lt; cTokens.length; i++) {         ICErc20 cToken = cTokens[i];         underlyingToCToken[             cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())         ] = cToken;     } }  /* ============ External Functions ============ */  /**  * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.  * Performs a DEX trade, exchanging the borrow asset for collateral asset.  *  * @param _setToken             Instance of the SetToken  * @param _borrowAsset          Address of asset being borrowed for leverage  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _borrowQuantity       Borrow quantity of asset in position units  * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function lever(     ISetToken _setToken,     IERC20 _borrowAsset,     IERC20 _collateralAsset,     uint256 _borrowQuantity,     uint256 _minReceiveQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // For levering up, send quantity is derived from borrow asset and receive quantity is derived from     // collateral asset     ActionInfo memory leverInfo = _createAndValidateActionInfo(         _setToken,         _borrowAsset,         _collateralAsset,         _borrowQuantity,         _minReceiveQuantity,         _tradeAdapterName,         true     );      _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);      uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);      _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);      _updateLeverPositions(leverInfo, _borrowAsset);      emit LeverageIncreased(         _setToken,         _borrowAsset,         _collateralAsset,         leverInfo.exchangeAdapter,         leverInfo.notionalSendQuantity,         postTradeCollateralQuantity,         protocolFee     ); }  /**  * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled  *  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _repayAsset           Address of asset being repaid  * @param _redeemQuantity       Quantity of collateral asset to delever  * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function delever(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantity,     uint256 _minRepayQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from     // repay asset     ActionInfo memory deleverInfo = _createAndValidateActionInfo(         _setToken,         _collateralAsset,         _repayAsset,         _redeemQuantity,         _minRepayQuantity,         _tradeAdapterName,         false     );      _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);      uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);      _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);      _updateLeverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         repayQuantity,         protocolFee     ); }  /**  * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received  * borrow asset is updated as equity. No protocol fee is charged.  *  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)  * @param _redeemQuantity       Quantity of collateral asset to delever  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function deleverToZeroBorrowBalance(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());      require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");     uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));      ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(         _setToken,         _collateralAsset,         _repayAsset,         notionalRedeemQuantity,         notionalRepayQuantity,         _tradeAdapterName,         false     );      _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);      _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly     _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);      // Update default position first to save gas on editing borrow position     _setToken.calculateAndEditDefaultPosition(         address(_repayAsset),         deleverInfo.setTotalSupply,         deleverInfo.preTradeReceiveTokenBalance     );      _updateLeverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         notionalRepayQuantity,         0 // No protocol fee     ); }  /**  * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral  * assets, update cToken default position. For borrow assets, update external borrow position.  * - Collateral assets may come out of sync when a position is liquidated  * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid  *  * @param _setToken               Instance of the SetToken  * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value  */ function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {     uint256 setTotalSupply = _setToken.totalSupply();      // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption     if (setTotalSupply &gt; 0) {         // Loop through collateral assets         address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;         for(uint256 i = 0; i &lt; collateralCTokens.length; i++) {             ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);             uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();             uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (previousPositionUnit != newPositionUnit) {               _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);             }         }          // Loop through borrow assets         address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;         address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;         for(uint256 i = 0; i &lt; borrowCTokens.length; i++) {             ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);             IERC20 borrowAsset = IERC20(borrowAssets[i]);              int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));              int256 newPositionUnit = _getBorrowPosition(                 _setToken,                 borrowCToken,                 setTotalSupply,                 _shouldAccrueInterest             );              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (newPositionUnit != previousPositionUnit) {                 _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);             }         }     } }   /**  * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable  * collateral and borrow assets that don't exist as positions on the SetToken  *  * @param _setToken             Instance of the SetToken to initialize  * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken  * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken  */ function initialize(     ISetToken _setToken,     IERC20[] memory _collateralAssets,     IERC20[] memory _borrowAssets )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     if (!anySetAllowed) {         require(allowedSetTokens[_setToken], "Not allowed SetToken");     }      // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}     }      // Enable collateral and borrow assets on Compound     addCollateralAssets(_setToken, _collateralAssets);      addBorrowAssets(_setToken, _borrowAssets); }  /**  * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled  * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)  */ function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Sync Compound and SetToken positions prior to any removal action     sync(setToken, true);      address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;     for (uint256 i = 0; i &lt; borrowCTokens.length; i++) {         ICErc20 cToken = ICErc20(borrowCTokens[i]);          // Will exit only if token isn't also being used as collateral         if(!collateralCTokenEnabled[setToken][cToken]) {             // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound             setToken.invokeExitMarket(cToken, comptroller);         }          delete borrowCTokenEnabled[setToken][cToken];     }      address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;     for (uint256 i = 0; i &lt; collateralCTokens.length; i++) {         ICErc20 cToken = ICErc20(collateralCTokens[i]);          setToken.invokeExitMarket(cToken, comptroller);          delete collateralCTokenEnabled[setToken][cToken];     }      delete enabledAssets[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken  * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state  * inconsistencies  *  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets  *  * @param _setToken             Instance of the SetToken  * @param _newCollateralAssets  Addresses of new collateral underlying assets  */ function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {     for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];         require(address(cToken) != address(0), "cToken must exist");         require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");          // Note: Will only enter market if cToken is not enabled as a borrow asset as well         if (!borrowCTokenEnabled[_setToken][cToken]) {             _setToken.invokeEnterMarkets(cToken, comptroller);         }          collateralCTokenEnabled[_setToken][cToken] = true;         enabledAssets[_setToken].collateralCTokens.push(address(cToken));     }      emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets); }  /**  * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets  * If there is a borrow balance, collateral asset cannot be removed  *  * @param _setToken             Instance of the SetToken  * @param _collateralAssets     Addresses of collateral underlying assets to remove  */ function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {     // Sync Compound and SetToken positions prior to any removal action     sync(_setToken, true);      for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];         require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");          // Note: Will only exit market if cToken is not enabled as a borrow asset as well         // If there is an existing borrow balance, will revert and market cannot be exited on Compound         if (!borrowCTokenEnabled[_setToken][cToken]) {             _setToken.invokeExitMarket(cToken, comptroller);         }          delete collateralCTokenEnabled[_setToken][cToken];         enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));     }      emit CollateralAssetsUpdated(_setToken, false, _collateralAssets); }  /**  * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets  *  * @param _setToken             Instance of the SetToken  * @param _newBorrowAssets      Addresses of borrow underlying assets to add  */ function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {     for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {         IERC20 newBorrowAsset = _newBorrowAssets[i];         ICErc20 cToken = underlyingToCToken[newBorrowAsset];         require(address(cToken) != address(0), "cToken must exist");         require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");          // Note: Will only enter market if cToken is not enabled as a borrow asset as well         if (!collateralCTokenEnabled[_setToken][cToken]) {             _setToken.invokeEnterMarkets(cToken, comptroller);         }          borrowCTokenEnabled[_setToken][cToken] = true;         enabledAssets[_setToken].borrowCTokens.push(address(cToken));         enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));     }      emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets); }  /**  * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets  * If there is a borrow balance, borrow asset cannot be removed  *  * @param _setToken             Instance of the SetToken  * @param _borrowAssets         Addresses of borrow underlying assets to remove  */ function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {     // Sync Compound and SetToken positions prior to any removal action     sync(_setToken, true);      for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];         require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");          // Note: Will only exit market if cToken is not enabled as a collateral asset as well         // If there is an existing borrow balance, will revert and market cannot be exited on Compound         if (!collateralCTokenEnabled[_setToken][cToken]) {             _setToken.invokeExitMarket(cToken, comptroller);         }          delete borrowCTokenEnabled[_setToken][cToken];         enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));         enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));     }      emit BorrowAssetsUpdated(_setToken, false, _borrowAssets); }  /**  * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.  *  * @param _setToken             Instance of the SetToken  */ function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {     allowedSetTokens[_setToken] = _status;     emit SetTokenStatusUpdated(_setToken, _status); }  /**  * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.  *  * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled  */ function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {     anySetAllowed = _anySetAllowed;     emit AnySetAllowedUpdated(_anySetAllowed); }  /**  * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.  *  * IMPORTANT: Validations are skipped in order to get contract under bytecode limit  *  * @param _cToken                   Address of cToken to add  * @param _underlying               Address of underlying token that maps to cToken  */ function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {     require(address(underlyingToCToken[_underlying]) == address(0), "Already added");     underlyingToCToken[_underlying] = _cToken; }  /**  * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals  *  * IMPORTANT: Validations are skipped in order to get contract under bytecode limit  *  * @param _underlying               Address of underlying token to remove  */ function removeCompoundMarket(IERC20 _underlying) external onlyOwner {     require(address(underlyingToCToken[_underlying]) != address(0), "Not added");     delete underlyingToCToken[_underlying]; }  /**  * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {     sync(_setToken, false); }  /**  * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.  * Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {     sync(_setToken, true); }  /**  * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {     int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));      require(componentDebt &lt; 0, "Component must be negative");      uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);      _borrow(_setToken, underlyingToCToken[_component], notionalDebt); }  /**  * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {     int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));      require(componentDebt &lt; 0, "Component must be negative");      uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);      _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt); }   /* ============ External Getter Functions ============ */  /**  * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an  * array of underlying that are borrow assets.  *  * @return                    Collateral cToken assets that are enabled  * @return                    Underlying borrowed assets that are enabled.  */ function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {     return (         enabledAssets[_setToken].collateralCTokens,         enabledAssets[_setToken].borrowAssets     ); }  /* ============ Internal Functions ============ */  /**  * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be  * unwrapped as it only accepts the underlying ETH.  */ function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {     if (_cToken == cEther) {         _setToken.invokeUnwrapWETH(address(weth), _mintNotional);          _setToken.invokeMintCEther(_cToken, _mintNotional);     } else {         _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);          _setToken.invokeMintCToken(_cToken, _mintNotional);     } }  /**  * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.  */ function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {     _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);      if (_cToken == cEther) {         _setToken.invokeWrapWETH(address(weth), _redeemNotional);     } }  /**  * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.  */ function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {     if (_cToken == cEther) {         _setToken.invokeUnwrapWETH(address(weth), _repayNotional);          _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);     } else {         // Approve to cToken         _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);         _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);     } }  /**  * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.  */ function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {     _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);     if (_cToken == cEther) {         _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);     } }  /**  * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken  *  * @return receiveTokenQuantity The quantity of tokens received post-trade  */ function _executeTrade(     ActionInfo memory _actionInfo,     IERC20 _sendToken,     IERC20 _receiveToken,     bytes memory _data )     internal     returns (uint256) {      ISetToken setToken = _actionInfo.setToken;      uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;       setToken.invokeApprove(         address(_sendToken),         _actionInfo.exchangeAdapter.getSpender(),         notionalSendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _actionInfo.exchangeAdapter.getTradeCalldata(         address(_sendToken),         address(_receiveToken),         address(setToken),         notionalSendQuantity,         _actionInfo.minNotionalReceiveQuantity,         _data     );      setToken.invoke(targetExchange, callValue, methodData);      uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);     require(         receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,         "Slippage too high"     );      return receiveTokenQuantity; }  /**  * Calculates protocol fee on module and pays protocol fee from SetToken  */ function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {     uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);      payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);      return protocolFeeTotal; }  /**  * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)  */ function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {     _updateCollateralPosition(         actionInfo.setToken,         actionInfo.collateralCTokenAsset,         _getCollateralPosition(             actionInfo.setToken,             actionInfo.collateralCTokenAsset,             actionInfo.setTotalSupply         )     );      _updateBorrowPosition(         actionInfo.setToken,         _borrowAsset,         _getBorrowPosition(             actionInfo.setToken,             actionInfo.borrowCTokenAsset,             actionInfo.setTotalSupply,             false // Do not accrue interest         )     ); }  function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {     _setToken.editDefaultPosition(address(_cToken), _newPositionUnit); }  function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {     _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, ""); }  /**  * Construct the ActionInfo struct for lever and delever  */ function _createAndValidateActionInfo(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _sendQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();      return _createAndValidateActionInfoNotional(         _setToken,         _sendToken,         _receiveToken,         _sendQuantityUnits.preciseMul(totalSupply),         _minReceiveQuantityUnits.preciseMul(totalSupply),         _tradeAdapterName,         _isLever     ); }  /**  * Construct the ActionInfo struct for lever and delever accepting notional units  */ function _createAndValidateActionInfoNotional(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _notionalSendQuantity,     uint256 _minNotionalReceiveQuantity,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();     ActionInfo memory actionInfo = ActionInfo ({         exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),         setToken: _setToken,         collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],         borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],         setTotalSupply: totalSupply,         notionalSendQuantity: _notionalSendQuantity,         minNotionalReceiveQuantity: _minNotionalReceiveQuantity,         preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))     });      _validateCommon(actionInfo);      return actionInfo; }    function _validateCommon(ActionInfo memory _actionInfo) internal view {     require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");     require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");     require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");     require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0"); }  function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {     uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));     return collateralNotionalBalance.preciseDiv(_setTotalSupply); }  /**  * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.  * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.  */ function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {     uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));     // Round negative away from 0     int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);      return borrowPositionUnit; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 02:00:42 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { Compound } from "../../integration/lib/Compound.sol";
import { ICErc20 } from "../../../interfaces/external/ICErc20.sol";
import { IComptroller } from "../../../interfaces/external/IComptroller.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title CompoundLeverageModule
 * @author Set Protocol
 *
 * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call
 * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each
 * asset is leveraged when using this module.
 *
 * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 *
 */
contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {
    using Compound for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken
        address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken
        address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset
        ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    /* ============ Events ============ */

    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the trade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping of underlying to CToken. If ETH, then map WETH to cETH
    mapping(IERC20 => ICErc20) public underlyingToCToken;

    // Wrapped Ether address
    IERC20 internal weth;

    // Compound cEther address
    ICErc20 internal cEther;

    // Compound Comptroller contract
    IComptroller internal comptroller;

    // COMP token address
    IERC20 internal compToken;

    // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public collateralCTokenEnabled;

    // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public borrowCTokenEnabled;

    // Mapping of enabled collateral and borrow cTokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list
    bool public anySetAllowed;


    /* ============ Constructor ============ */

    /**
     * Instantiate addresses. Underlying to cToken mapping is created.
     *
     * @param _controller               Address of controller contract
     * @param _compToken                Address of COMP token
     * @param _comptroller              Address of Compound Comptroller
     * @param _cEther                   Address of cEther contract
     * @param _weth                     Address of WETH contract
     */
    constructor(
        IController _controller,
        IERC20 _compToken,
        IComptroller _comptroller,
        ICErc20 _cEther,
        IERC20 _weth
    )
        public
        ModuleBase(_controller)
    {
        compToken = _compToken;
        comptroller = _comptroller;
        cEther = _cEther;
        weth = _weth;

        ICErc20[] memory cTokens = comptroller.getAllMarkets();

        for(uint256 i = 0; i < cTokens.length; i++) {
            ICErc20 cToken = cTokens[i];
            underlyingToCToken[
                cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())
            ] = cToken;
        }
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.
     * Performs a DEX trade, exchanging the borrow asset for collateral asset.
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAsset          Address of asset being borrowed for leverage
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _borrowQuantity       Borrow quantity of asset in position units
     * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantity,
        uint256 _minReceiveQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantity,
            _minReceiveQuantity,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        uint256 _minRepayQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantity,
            _minRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received
     * borrow asset is updated as equity. No protocol fee is charged.
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());

        require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly
        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);

        // Update default position first to save gas on editing borrow position
        _setToken.calculateAndEditDefaultPosition(
            address(_repayAsset),
            deleverInfo.setTotalSupply,
            deleverInfo.preTradeReceiveTokenBalance
        );

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0 // No protocol fee
        );
    }

    /**
     * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral
     * assets, update cToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     *
     * @param _setToken               Instance of the SetToken
     * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value
     */
    function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption
        if (setTotalSupply > 0) {
            // Loop through collateral assets
            address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;
            for(uint256 i = 0; i < collateralCTokens.length; i++) {
                ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);
                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);
                }
            }

            // Loop through borrow assets
            address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;
            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowCTokens.length; i++) {
                ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));

                int256 newPositionUnit = _getBorrowPosition(
                    _setToken,
                    borrowCToken,
                    setTotalSupply,
                    _shouldAccrueInterest
                );

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }


    /**
     * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable
     * collateral and borrow assets that don't exist as positions on the SetToken
     *
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // Enable collateral and borrow assets on Compound
        addCollateralAssets(_setToken, _collateralAssets);

        addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled
     * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Compound and SetToken positions prior to any removal action
        sync(setToken, true);

        address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;
        for (uint256 i = 0; i < borrowCTokens.length; i++) {
            ICErc20 cToken = ICErc20(borrowCTokens[i]);

            // Will exit only if token isn't also being used as collateral
            if(!collateralCTokenEnabled[setToken][cToken]) {
                // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound
                setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[setToken][cToken];
        }

        address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;
        for (uint256 i = 0; i < collateralCTokens.length; i++) {
            ICErc20 cToken = ICErc20(collateralCTokens[i]);

            setToken.invokeExitMarket(cToken, comptroller);

            delete collateralCTokenEnabled[setToken][cToken];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken
     * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];
            require(address(cToken) != address(0), "cToken must exist");
            require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            collateralCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].collateralCTokens.push(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets
     * If there is a borrow balance, collateral asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];
            require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");

            // Note: Will only exit market if cToken is not enabled as a borrow asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete collateralCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 newBorrowAsset = _newBorrowAssets[i];
            ICErc20 cToken = underlyingToCToken[newBorrowAsset];
            require(address(cToken) != address(0), "cToken must exist");
            require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            borrowCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].borrowCTokens.push(address(cToken));
            enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));
        }

        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets
     * If there is a borrow balance, borrow asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];
            require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");

            // Note: Will only exit market if cToken is not enabled as a collateral asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));
            enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));
        }

        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.
     *
     * @param _setToken             Instance of the SetToken
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.
     *
     * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _cToken                   Address of cToken to add
     * @param _underlying               Address of underlying token that maps to cToken
     */
    function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) == address(0), "Already added");
        underlyingToCToken[_underlying] = _cToken;
    }

    /**
     * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _underlying               Address of underlying token to remove
     */
    function removeCompoundMarket(IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) != address(0), "Not added");
        delete underlyingToCToken[_underlying];
    }

    /**
     * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, false);
    }

    /**
     * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.
     * Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, true);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);

        _borrow(_setToken, underlyingToCToken[_component], notionalDebt);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);

        _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt);
    }


    /* ============ External Getter Functions ============ */

    /**
     * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an
     * array of underlying that are borrow assets.
     *
     * @return                    Collateral cToken assets that are enabled
     * @return                    Underlying borrowed assets that are enabled.
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralCTokens,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be
     * unwrapped as it only accepts the underlying ETH.
     */
    function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _mintNotional);

            _setToken.invokeMintCEther(_cToken, _mintNotional);
        } else {
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);

            _setToken.invokeMintCToken(_cToken, _mintNotional);
        }
    }

    /**
     * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.
     */
    function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {
        _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);

        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _redeemNotional);
        }
    }

    /**
     * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.
     */
    function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _repayNotional);

            _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);
        } else {
            // Approve to cToken
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);
            _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);
        }
    }

    /**
     * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.
     */
    function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {
        _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);
        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);
        }
    }

    /**
     * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     *
     * @return receiveTokenQuantity The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
         ISetToken setToken = _actionInfo.setToken;
         uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

         setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * Calculates protocol fee on module and pays protocol fee from SetToken
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)
     */
    function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {
        _updateCollateralPosition(
            actionInfo.setToken,
            actionInfo.collateralCTokenAsset,
            _getCollateralPosition(
                actionInfo.setToken,
                actionInfo.collateralCTokenAsset,
                actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                actionInfo.setToken,
                actionInfo.borrowCTokenAsset,
                actionInfo.setTotalSupply,
                false // Do not accrue interest
            )
        );
    }

    function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_cToken), _newPositionUnit);
    }

    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, "");
    }

    /**
     * Construct the ActionInfo struct for lever and delever
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever
        );
    }

    /**
     * Construct the ActionInfo struct for lever and delever accepting notional units
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            setToken: _setToken,
            collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],
            borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],
            setTotalSupply: totalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }



    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");
        require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");
        require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.
     * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.
     */
    function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {
        uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));
        // Round negative away from 0
        int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);

        return borrowPositionUnit;
    }
}.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-01-09 02:00:55 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 02:00:55 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 9259
completion_tokens: 888
total_tokens: 10147
cost: $-1.000000


[2024-01-09 02:00:55 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { Compound } from "../../integration/lib/Compound.sol";
import { ICErc20 } from "../../../interfaces/external/ICErc20.sol";
import { IComptroller } from "../../../interfaces/external/IComptroller.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title CompoundLeverageModule
 * @author Set Protocol
 *
 * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call
 * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each
 * asset is leveraged when using this module.
 *
 * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 *
 */
contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {
    using Compound for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken
        address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken
        address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset
        ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    /* ============ Events ============ */

    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the trade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping of underlying to CToken. If ETH, then map WETH to cETH
    mapping(IERC20 => ICErc20) public underlyingToCToken;

    // Wrapped Ether address
    IERC20 internal weth;

    // Compound cEther address
    ICErc20 internal cEther;

    // Compound Comptroller contract
    IComptroller internal comptroller;

    // COMP token address
    IERC20 internal compToken;

    // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public collateralCTokenEnabled;

    // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public borrowCTokenEnabled;

    // Mapping of enabled collateral and borrow cTokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list
    bool public anySetAllowed;


    /* ============ Constructor ============ */

    /**
     * Instantiate addresses. Underlying to cToken mapping is created.
     *
     * @param _controller               Address of controller contract
     * @param _compToken                Address of COMP token
     * @param _comptroller              Address of Compound Comptroller
     * @param _cEther                   Address of cEther contract
     * @param _weth                     Address of WETH contract
     */
    constructor(
        IController _controller,
        IERC20 _compToken,
        IComptroller _comptroller,
        ICErc20 _cEther,
        IERC20 _weth
    )
        public
        ModuleBase(_controller)
    {
        compToken = _compToken;
        comptroller = _comptroller;
        cEther = _cEther;
        weth = _weth;

        ICErc20[] memory cTokens = comptroller.getAllMarkets();

        for(uint256 i = 0; i < cTokens.length; i++) {
            ICErc20 cToken = cTokens[i];
            underlyingToCToken[
                cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())
            ] = cToken;
        }
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.
     * Performs a DEX trade, exchanging the borrow asset for collateral asset.
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAsset          Address of asset being borrowed for leverage
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _borrowQuantity       Borrow quantity of asset in position units
     * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantity,
        uint256 _minReceiveQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantity,
            _minReceiveQuantity,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        uint256 _minRepayQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantity,
            _minRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received
     * borrow asset is updated as equity. No protocol fee is charged.
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());

        require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly
        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);

        // Update default position first to save gas on editing borrow position
        _setToken.calculateAndEditDefaultPosition(
            address(_repayAsset),
            deleverInfo.setTotalSupply,
            deleverInfo.preTradeReceiveTokenBalance
        );

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0 // No protocol fee
        );
    }

    /**
     * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral
     * assets, update cToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     *
     * @param _setToken               Instance of the SetToken
     * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value
     */
    function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption
        if (setTotalSupply > 0) {
            // Loop through collateral assets
            address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;
            for(uint256 i = 0; i < collateralCTokens.length; i++) {
                ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);
                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);
                }
            }

            // Loop through borrow assets
            address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;
            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowCTokens.length; i++) {
                ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));

                int256 newPositionUnit = _getBorrowPosition(
                    _setToken,
                    borrowCToken,
                    setTotalSupply,
                    _shouldAccrueInterest
                );

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }


    /**
     * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable
     * collateral and borrow assets that don't exist as positions on the SetToken
     *
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // Enable collateral and borrow assets on Compound
        addCollateralAssets(_setToken, _collateralAssets);

        addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled
     * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Compound and SetToken positions prior to any removal action
        sync(setToken, true);

        address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;
        for (uint256 i = 0; i < borrowCTokens.length; i++) {
            ICErc20 cToken = ICErc20(borrowCTokens[i]);

            // Will exit only if token isn't also being used as collateral
            if(!collateralCTokenEnabled[setToken][cToken]) {
                // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound
                setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[setToken][cToken];
        }

        address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;
        for (uint256 i = 0; i < collateralCTokens.length; i++) {
            ICErc20 cToken = ICErc20(collateralCTokens[i]);

            setToken.invokeExitMarket(cToken, comptroller);

            delete collateralCTokenEnabled[setToken][cToken];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken
     * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];
            require(address(cToken) != address(0), "cToken must exist");
            require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            collateralCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].collateralCTokens.push(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets
     * If there is a borrow balance, collateral asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];
            require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");

            // Note: Will only exit market if cToken is not enabled as a borrow asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete collateralCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 newBorrowAsset = _newBorrowAssets[i];
            ICErc20 cToken = underlyingToCToken[newBorrowAsset];
            require(address(cToken) != address(0), "cToken must exist");
            require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            borrowCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].borrowCTokens.push(address(cToken));
            enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));
        }

        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets
     * If there is a borrow balance, borrow asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];
            require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");

            // Note: Will only exit market if cToken is not enabled as a collateral asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));
            enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));
        }

        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.
     *
     * @param _setToken             Instance of the SetToken
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.
     *
     * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _cToken                   Address of cToken to add
     * @param _underlying               Address of underlying token that maps to cToken
     */
    function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) == address(0), "Already added");
        underlyingToCToken[_underlying] = _cToken;
    }

    /**
     * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _underlying               Address of underlying token to remove
     */
    function removeCompoundMarket(IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) != address(0), "Not added");
        delete underlyingToCToken[_underlying];
    }

    /**
     * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, false);
    }

    /**
     * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.
     * Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, true);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);

        _borrow(_setToken, underlyingToCToken[_component], notionalDebt);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);

        _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt);
    }


    /* ============ External Getter Functions ============ */

    /**
     * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an
     * array of underlying that are borrow assets.
     *
     * @return                    Collateral cToken assets that are enabled
     * @return                    Underlying borrowed assets that are enabled.
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralCTokens,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be
     * unwrapped as it only accepts the underlying ETH.
     */
    function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _mintNotional);

            _setToken.invokeMintCEther(_cToken, _mintNotional);
        } else {
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);

            _setToken.invokeMintCToken(_cToken, _mintNotional);
        }
    }

    /**
     * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.
     */
    function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {
        _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);

        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _redeemNotional);
        }
    }

    /**
     * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.
     */
    function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _repayNotional);

            _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);
        } else {
            // Approve to cToken
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);
            _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);
        }
    }

    /**
     * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.
     */
    function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {
        _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);
        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);
        }
    }

    /**
     * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     *
     * @return receiveTokenQuantity The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
         ISetToken setToken = _actionInfo.setToken;
         uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

         setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * Calculates protocol fee on module and pays protocol fee from SetToken
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)
     */
    function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {
        _updateCollateralPosition(
            actionInfo.setToken,
            actionInfo.collateralCTokenAsset,
            _getCollateralPosition(
                actionInfo.setToken,
                actionInfo.collateralCTokenAsset,
                actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                actionInfo.setToken,
                actionInfo.borrowCTokenAsset,
                actionInfo.setTotalSupply,
                false // Do not accrue interest
            )
        );
    }

    function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_cToken), _newPositionUnit);
    }

    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, "");
    }

    /**
     * Construct the ActionInfo struct for lever and delever
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever
        );
    }

    /**
     * Construct the ActionInfo struct for lever and delever accepting notional units
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            setToken: _setToken,
            collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],
            borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],
            setTotalSupply: totalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }



    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");
        require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");
        require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.
     * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.
     */
    function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {
        uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));
        // Round negative away from 0
        int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);

        return borrowPositionUnit;
    }
}.]

Based on the provided Solidity smart contract code for the `CompoundLeverageModule`, here is a succinct summary of the security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities:

1. **Reentrancy Risk**:
   - Although the contract uses `ReentrancyGuard`, there are multiple external calls (e.g., `_executeTrade`, `_borrow`, `_repayBorrow`) that could potentially be exploited if not properly managed. The use of `nonReentrant` modifier is crucial, but additional care must be taken to ensure that no state changes occur after external calls that could lead to reentrancy attacks.

2. **Slippage Vulnerability**:
   - The contract allows for trades to be executed with a minimum receive quantity. If the market conditions change drastically, the trade could still execute, leading to significant slippage. The requirement for `receiveTokenQuantity` to meet the `minNotionalReceiveQuantity` is a safeguard, but it does not eliminate the risk entirely.

3. **Access Control Issues**:
   - Functions such as `addCollateralAssets`, `addBorrowAssets`, and `initialize` rely on the `onlyManagerAndValidSet` modifier. If the manager's address is compromised, it could lead to unauthorized access to critical functions. The governance mechanisms should be robust to prevent unauthorized changes.

4. **Gas Limit Issues**:
   - The contract contains loops (e.g., in `sync` and asset management functions) that could potentially exceed the gas limit if a large number of assets are involved. This could lead to failed transactions and denial of service.

5. **Lack of Input Validation**:
   - Functions that accept arrays of addresses (e.g., `addCollateralAssets`, `addBorrowAssets`) do not validate the input for duplicates or zero addresses, which could lead to unexpected behavior or state inconsistencies.

6. **Potential for Integer Overflow/Underflow**:
   - Although Solidity 0.6.10 has built-in overflow/underflow checks, any arithmetic operations that are not explicitly checked could still lead to unexpected results. Care should be taken to ensure that all arithmetic operations are safe.

7. **Protocol Fee Calculation**:
   - The protocol fee calculation relies on the `getModuleFee` function, which should be audited to ensure that it does not introduce vulnerabilities or unexpected behavior in fee calculations.

8. **Market Exit Risks**:
   - The `removeModule` function attempts to exit markets on Compound. If there are existing borrow balances, the function will revert, which could leave the contract in an inconsistent state if not handled properly.

### Comprehensive Analysis Report:

The `CompoundLeverageModule` contract is designed to facilitate leveraged trading using the Compound protocol. While it incorporates several best practices, such as the use of `ReentrancyGuard` and structured access control, there are notable vulnerabilities that need to be addressed to ensure the security and reliability of the contract.

1. **Reentrancy**: The use of external calls in critical functions poses a risk of reentrancy attacks. It is essential to ensure that state changes are made before any external calls and to maintain a clear order of operations.

2. **Slippage and Trade Execution**: The potential for slippage during trades could lead to significant losses for users. Implementing stricter checks or limits on trade execution could mitigate this risk.

3. **Access Control**: The reliance on the manager's address for critical functions necessitates robust governance mechanisms to prevent unauthorized access. Regular audits and monitoring of the manager's activities are recommended.

4. **Gas Limit and Input Validation**: The contract should include checks to prevent excessive gas consumption and validate inputs to avoid unexpected behavior. This includes ensuring that no duplicate or zero addresses are processed.

5. **Arithmetic Safety**: While Solidity 0.6.10 provides some protections against overflow/underflow, developers should remain vigilant and implement additional checks where necessary.

6. **Protocol Fee and Market Management**: The fee calculation and market exit strategies should be thoroughly audited to prevent inconsistencies and ensure that the contract behaves as expected under various conditions.

In conclusion, while the `CompoundLeverageModule` contract demonstrates a solid foundation for leveraging Compound's capabilities, addressing the identified vulnerabilities is crucial for enhancing its security posture. A comprehensive audit and ongoing monitoring will be essential to maintain the integrity of the contract and protect user assets.

[2024-01-09 02:00:55 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code for the `CompoundLeverageModule`, here is a succinct summary of the security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities:

1. **Reentrancy Risk**:
   - Although the contract uses `ReentrancyGuard`, there are multiple external calls (e.g., `_executeTrade`, `_borrow`, `_repayBorrow`) that could potentially be exploited if not properly managed. The use of `nonReentrant` modifier is crucial, but additional care must be taken to ensure that no state changes occur after external calls that could lead to reentrancy attacks.

2. **Slippage Vulnerability**:
   - The contract allows for trades to be executed with a minimum receive quantity. If the market conditions change drastically, the trade could still execute, leading to significant slippage. The requirement for `receiveTokenQuantity` to meet the `minNotionalReceiveQuantity` is a safeguard, but it does not eliminate the risk entirely.

3. **Access Control Issues**:
   - Functions such as `addCollateralAssets`, `addBorrowAssets`, and `initialize` rely on the `onlyManagerAndValidSet` modifier. If the manager's address is compromised, it could lead to unauthorized access to critical functions. The governance mechanisms should be robust to prevent unauthorized changes.

4. **Gas Limit Issues**:
   - The contract contains loops (e.g., in `sync` and asset management functions) that could potentially exceed the gas limit if a large number of assets are involved. This could lead to failed transactions and denial of service.

5. **Lack of Input Validation**:
   - Functions that accept arrays of addresses (e.g., `addCollateralAssets`, `addBorrowAssets`) do not validate the input for duplicates or zero addresses, which could lead to unexpected behavior or state inconsistencies.

6. **Potential for Integer Overflow/Underflow**:
   - Although Solidity 0.6.10 has built-in overflow/underflow checks, any arithmetic operations that are not explicitly checked could still lead to unexpected results. Care should be taken to ensure that all arithmetic operations are safe.

7. **Protocol Fee Calculation**:
   - The protocol fee calculation relies on the `getModuleFee` function, which should be audited to ensure that it does not introduce vulnerabilities or unexpected behavior in fee calculations.

8. **Market Exit Risks**:
   - The `removeModule` function attempts to exit markets on Compound. If there are existing borrow balances, the function will revert, which could leave the contract in an inconsistent state if not handled properly.

### Comprehensive Analysis Report:

The `CompoundLeverageModule` contract is designed to facilitate leveraged trading using the Compound protocol. While it incorporates several best practices, such as the use of `ReentrancyGuard` and structured access control, there are notable vulnerabilities that need to be addressed to ensure the security and reliability of the contract.

1. **Reentrancy**: The use of external calls in critical functions poses a risk of reentrancy attacks. It is essential to ensure that state changes are made before any external calls and to maintain a clear order of operations.

2. **Slippage and Trade Execution**: The potential for slippage during trades could lead to significant losses for users. Implementing stricter checks or limits on trade execution could mitigate this risk.

3. **Access Control**: The reliance on the manager's address for critical functions necessitates robust governance mechanisms to prevent unauthorized access. Regular audits and monitoring of the manager's activities are recommended.

4. **Gas Limit and Input Validation**: The contract should include checks to prevent excessive gas consumption and validate inputs to avoid unexpected behavior. This includes ensuring that no duplicate or zero addresses are processed.

5. **Arithmetic Safety**: While Solidity 0.6.10 provides some protections against overflow/underflow, developers should remain vigilant and implement additional checks where necessary.

6. **Protocol Fee and Market Management**: The fee calculation and market exit strategies should be thoroughly audited to prevent inconsistencies and ensure that the contract behaves as expected under various conditions.

In conclusion, while the `CompoundLeverageModule` contract demonstrates a solid foundation for leveraging Compound's capabilities, addressing the identified vulnerabilities is crucial for enhancing its security posture. A comprehensive audit and ongoing monitoring will be essential to maintain the integrity of the contract and protect user assets.

[2024-01-09 02:00:58 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { Compound } from "../../integration/lib/Compound.sol"; import { ICErc20 } from "../../../interfaces/external/ICErc20.sol"; import { IComptroller } from "../../../interfaces/external/IComptroller.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol"; import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; /*  * @title CompoundLeverageModule  * @author Set Protocol  *  * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call  * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each  * asset is leveraged when using this module.  *  * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of  * debt when borrowed assets are the same.  *  / contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {     using Compound for ISetToken; /* ============ Structs ============ */  struct EnabledAssets {     address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken     address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken     address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets }  struct ActionInfo {     ISetToken setToken;                      // SetToken instance     IExchangeAdapter exchangeAdapter;        // Exchange adapter instance     uint256 setTotalSupply;                  // Total supply of SetToken     uint256 notionalSendQuantity;            // Total notional quantity sent to exchange     uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange     ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset     ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset     uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance }  /* ============ Events ============ */  event LeverageIncreased(     ISetToken indexed _setToken,     IERC20 indexed _borrowAsset,     IERC20 indexed _collateralAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalBorrowAmount,     uint256 _totalReceiveAmount,     uint256 _protocolFee );  event LeverageDecreased(     ISetToken indexed _setToken,     IERC20 indexed _collateralAsset,     IERC20 indexed _repayAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalRedeemAmount,     uint256 _totalRepayAmount,     uint256 _protocolFee );  event CollateralAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  event BorrowAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  event SetTokenStatusUpdated(     ISetToken indexed _setToken,     bool indexed _added );  event AnySetAllowedUpdated(     bool indexed _anySetAllowed );  /* ============ Constants ============ */  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the trade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Mapping of underlying to CToken. If ETH, then map WETH to cETH mapping(IERC20 =&gt; ICErc20) public underlyingToCToken;  // Wrapped Ether address IERC20 internal weth;  // Compound cEther address ICErc20 internal cEther;  // Compound Comptroller contract IComptroller internal comptroller;  // COMP token address IERC20 internal compToken;  // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public collateralCTokenEnabled;  // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public borrowCTokenEnabled;  // Mapping of enabled collateral and borrow cTokens for syncing positions mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;  // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance mapping(ISetToken =&gt; bool) public allowedSetTokens;  // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list bool public anySetAllowed;   /* ============ Constructor ============ */  /**  * Instantiate addresses. Underlying to cToken mapping is created.  *  * @param _controller               Address of controller contract  * @param _compToken                Address of COMP token  * @param _comptroller              Address of Compound Comptroller  * @param _cEther                   Address of cEther contract  * @param _weth                     Address of WETH contract  */ constructor(     IController _controller,     IERC20 _compToken,     IComptroller _comptroller,     ICErc20 _cEther,     IERC20 _weth )     public     ModuleBase(_controller) {     compToken = _compToken;     comptroller = _comptroller;     cEther = _cEther;     weth = _weth;      ICErc20[] memory cTokens = comptroller.getAllMarkets();      for(uint256 i = 0; i &lt; cTokens.length; i++) {         ICErc20 cToken = cTokens[i];         underlyingToCToken[             cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())         ] = cToken;     } }  /* ============ External Functions ============ */  /**  * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.  * Performs a DEX trade, exchanging the borrow asset for collateral asset.  *  * @param _setToken             Instance of the SetToken  * @param _borrowAsset          Address of asset being borrowed for leverage  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _borrowQuantity       Borrow quantity of asset in position units  * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function lever(     ISetToken _setToken,     IERC20 _borrowAsset,     IERC20 _collateralAsset,     uint256 _borrowQuantity,     uint256 _minReceiveQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // For levering up, send quantity is derived from borrow asset and receive quantity is derived from     // collateral asset     ActionInfo memory leverInfo = _createAndValidateActionInfo(         _setToken,         _borrowAsset,         _collateralAsset,         _borrowQuantity,         _minReceiveQuantity,         _tradeAdapterName,         true     );      _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);      uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);      _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);      _updateLeverPositions(leverInfo, _borrowAsset);      emit LeverageIncreased(         _setToken,         _borrowAsset,         _collateralAsset,         leverInfo.exchangeAdapter,         leverInfo.notionalSendQuantity,         postTradeCollateralQuantity,         protocolFee     ); }  /**  * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled  *  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _repayAsset           Address of asset being repaid  * @param _redeemQuantity       Quantity of collateral asset to delever  * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function delever(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantity,     uint256 _minRepayQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from     // repay asset     ActionInfo memory deleverInfo = _createAndValidateActionInfo(         _setToken,         _collateralAsset,         _repayAsset,         _redeemQuantity,         _minRepayQuantity,         _tradeAdapterName,         false     );      _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);      uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);      _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);      _updateLeverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         repayQuantity,         protocolFee     ); }  /**  * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received  * borrow asset is updated as equity. No protocol fee is charged.  *  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)  * @param _redeemQuantity       Quantity of collateral asset to delever  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function deleverToZeroBorrowBalance(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());      require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");     uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));      ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(         _setToken,         _collateralAsset,         _repayAsset,         notionalRedeemQuantity,         notionalRepayQuantity,         _tradeAdapterName,         false     );      _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);      _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly     _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);      // Update default position first to save gas on editing borrow position     _setToken.calculateAndEditDefaultPosition(         address(_repayAsset),         deleverInfo.setTotalSupply,         deleverInfo.preTradeReceiveTokenBalance     );      _updateLeverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         notionalRepayQuantity,         0 // No protocol fee     ); }  /**  * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral  * assets, update cToken default position. For borrow assets, update external borrow position.  * - Collateral assets may come out of sync when a position is liquidated  * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid  *  * @param _setToken               Instance of the SetToken  * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value  */ function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {     uint256 setTotalSupply = _setToken.totalSupply();      // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption     if (setTotalSupply &gt; 0) {         // Loop through collateral assets         address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;         for(uint256 i = 0; i &lt; collateralCTokens.length; i++) {             ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);             uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();             uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (previousPositionUnit != newPositionUnit) {               _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);             }         }          // Loop through borrow assets         address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;         address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;         for(uint256 i = 0; i &lt; borrowCTokens.length; i++) {             ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);             IERC20 borrowAsset = IERC20(borrowAssets[i]);              int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));              int256 newPositionUnit = _getBorrowPosition(                 _setToken,                 borrowCToken,                 setTotalSupply,                 _shouldAccrueInterest             );              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (newPositionUnit != previousPositionUnit) {                 _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);             }         }     } }   /**  * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable  * collateral and borrow assets that don't exist as positions on the SetToken  *  * @param _setToken             Instance of the SetToken to initialize  * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken  * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken  */ function initialize(     ISetToken _setToken,     IERC20[] memory _collateralAssets,     IERC20[] memory _borrowAssets )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     if (!anySetAllowed) {         require(allowedSetTokens[_setToken], "Not allowed SetToken");     }      // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}     }      // Enable collateral and borrow assets on Compound     addCollateralAssets(_setToken, _collateralAssets);      addBorrowAssets(_setToken, _borrowAssets); }  /**  * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled  * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)  */ function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Sync Compound and SetToken positions prior to any removal action     sync(setToken, true);      address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;     for (uint256 i = 0; i &lt; borrowCTokens.length; i++) {         ICErc20 cToken = ICErc20(borrowCTokens[i]);          // Will exit only if token isn't also being used as collateral         if(!collateralCTokenEnabled[setToken][cToken]) {             // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound             setToken.invokeExitMarket(cToken, comptroller);         }          delete borrowCTokenEnabled[setToken][cToken];     }      address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;     for (uint256 i = 0; i &lt; collateralCTokens.length; i++) {         ICErc20 cToken = ICErc20(collateralCTokens[i]);          setToken.invokeExitMarket(cToken, comptroller);          delete collateralCTokenEnabled[setToken][cToken];     }      delete enabledAssets[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken  * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state  * inconsistencies  *  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets  *  * @param _setToken             Instance of the SetToken  * @param _newCollateralAssets  Addresses of new collateral underlying assets  */ function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {     for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];         require(address(cToken) != address(0), "cToken must exist");         require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");          // Note: Will only enter market if cToken is not enabled as a borrow asset as well         if (!borrowCTokenEnabled[_setToken][cToken]) {             _setToken.invokeEnterMarkets(cToken, comptroller);         }          collateralCTokenEnabled[_setToken][cToken] = true;         enabledAssets[_setToken].collateralCTokens.push(address(cToken));     }      emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets); }  /**  * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets  * If there is a borrow balance, collateral asset cannot be removed  *  * @param _setToken             Instance of the SetToken  * @param _collateralAssets     Addresses of collateral underlying assets to remove  */ function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {     // Sync Compound and SetToken positions prior to any removal action     sync(_setToken, true);      for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];         require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");          // Note: Will only exit market if cToken is not enabled as a borrow asset as well         // If there is an existing borrow balance, will revert and market cannot be exited on Compound         if (!borrowCTokenEnabled[_setToken][cToken]) {             _setToken.invokeExitMarket(cToken, comptroller);         }          delete collateralCTokenEnabled[_setToken][cToken];         enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));     }      emit CollateralAssetsUpdated(_setToken, false, _collateralAssets); }  /**  * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets  *  * @param _setToken             Instance of the SetToken  * @param _newBorrowAssets      Addresses of borrow underlying assets to add  */ function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {     for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {         IERC20 newBorrowAsset = _newBorrowAssets[i];         ICErc20 cToken = underlyingToCToken[newBorrowAsset];         require(address(cToken) != address(0), "cToken must exist");         require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");          // Note: Will only enter market if cToken is not enabled as a borrow asset as well         if (!collateralCTokenEnabled[_setToken][cToken]) {             _setToken.invokeEnterMarkets(cToken, comptroller);         }          borrowCTokenEnabled[_setToken][cToken] = true;         enabledAssets[_setToken].borrowCTokens.push(address(cToken));         enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));     }      emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets); }  /**  * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets  * If there is a borrow balance, borrow asset cannot be removed  *  * @param _setToken             Instance of the SetToken  * @param _borrowAssets         Addresses of borrow underlying assets to remove  */ function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {     // Sync Compound and SetToken positions prior to any removal action     sync(_setToken, true);      for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];         require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");          // Note: Will only exit market if cToken is not enabled as a collateral asset as well         // If there is an existing borrow balance, will revert and market cannot be exited on Compound         if (!collateralCTokenEnabled[_setToken][cToken]) {             _setToken.invokeExitMarket(cToken, comptroller);         }          delete borrowCTokenEnabled[_setToken][cToken];         enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));         enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));     }      emit BorrowAssetsUpdated(_setToken, false, _borrowAssets); }  /**  * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.  *  * @param _setToken             Instance of the SetToken  */ function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {     allowedSetTokens[_setToken] = _status;     emit SetTokenStatusUpdated(_setToken, _status); }  /**  * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.  *  * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled  */ function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {     anySetAllowed = _anySetAllowed;     emit AnySetAllowedUpdated(_anySetAllowed); }  /**  * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.  *  * IMPORTANT: Validations are skipped in order to get contract under bytecode limit  *  * @param _cToken                   Address of cToken to add  * @param _underlying               Address of underlying token that maps to cToken  */ function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {     require(address(underlyingToCToken[_underlying]) == address(0), "Already added");     underlyingToCToken[_underlying] = _cToken; }  /**  * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals  *  * IMPORTANT: Validations are skipped in order to get contract under bytecode limit  *  * @param _underlying               Address of underlying token to remove  */ function removeCompoundMarket(IERC20 _underlying) external onlyOwner {     require(address(underlyingToCToken[_underlying]) != address(0), "Not added");     delete underlyingToCToken[_underlying]; }  /**  * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {     sync(_setToken, false); }  /**  * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.  * Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {     sync(_setToken, true); }  /**  * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {     int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));      require(componentDebt &lt; 0, "Component must be negative");      uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);      _borrow(_setToken, underlyingToCToken[_component], notionalDebt); }  /**  * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {     int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));      require(componentDebt &lt; 0, "Component must be negative");      uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);      _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt); }   /* ============ External Getter Functions ============ */  /**  * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an  * array of underlying that are borrow assets.  *  * @return                    Collateral cToken assets that are enabled  * @return                    Underlying borrowed assets that are enabled.  */ function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {     return (         enabledAssets[_setToken].collateralCTokens,         enabledAssets[_setToken].borrowAssets     ); }  /* ============ Internal Functions ============ */  /**  * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be  * unwrapped as it only accepts the underlying ETH.  */ function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {     if (_cToken == cEther) {         _setToken.invokeUnwrapWETH(address(weth), _mintNotional);          _setToken.invokeMintCEther(_cToken, _mintNotional);     } else {         _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);          _setToken.invokeMintCToken(_cToken, _mintNotional);     } }  /**  * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.  */ function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {     _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);      if (_cToken == cEther) {         _setToken.invokeWrapWETH(address(weth), _redeemNotional);     } }  /**  * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.  */ function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {     if (_cToken == cEther) {         _setToken.invokeUnwrapWETH(address(weth), _repayNotional);          _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);     } else {         // Approve to cToken         _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);         _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);     } }  /**  * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.  */ function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {     _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);     if (_cToken == cEther) {         _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);     } }  /**  * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken  *  * @return receiveTokenQuantity The quantity of tokens received post-trade  */ function _executeTrade(     ActionInfo memory _actionInfo,     IERC20 _sendToken,     IERC20 _receiveToken,     bytes memory _data )     internal     returns (uint256) {      ISetToken setToken = _actionInfo.setToken;      uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;       setToken.invokeApprove(         address(_sendToken),         _actionInfo.exchangeAdapter.getSpender(),         notionalSendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _actionInfo.exchangeAdapter.getTradeCalldata(         address(_sendToken),         address(_receiveToken),         address(setToken),         notionalSendQuantity,         _actionInfo.minNotionalReceiveQuantity,         _data     );      setToken.invoke(targetExchange, callValue, methodData);      uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);     require(         receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,         "Slippage too high"     );      return receiveTokenQuantity; }  /**  * Calculates protocol fee on module and pays protocol fee from SetToken  */ function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {     uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);      payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);      return protocolFeeTotal; }  /**  * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)  */ function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {     _updateCollateralPosition(         actionInfo.setToken,         actionInfo.collateralCTokenAsset,         _getCollateralPosition(             actionInfo.setToken,             actionInfo.collateralCTokenAsset,             actionInfo.setTotalSupply         )     );      _updateBorrowPosition(         actionInfo.setToken,         _borrowAsset,         _getBorrowPosition(             actionInfo.setToken,             actionInfo.borrowCTokenAsset,             actionInfo.setTotalSupply,             false // Do not accrue interest         )     ); }  function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {     _setToken.editDefaultPosition(address(_cToken), _newPositionUnit); }  function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {     _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, ""); }  /**  * Construct the ActionInfo struct for lever and delever  */ function _createAndValidateActionInfo(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _sendQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();      return _createAndValidateActionInfoNotional(         _setToken,         _sendToken,         _receiveToken,         _sendQuantityUnits.preciseMul(totalSupply),         _minReceiveQuantityUnits.preciseMul(totalSupply),         _tradeAdapterName,         _isLever     ); }  /**  * Construct the ActionInfo struct for lever and delever accepting notional units  */ function _createAndValidateActionInfoNotional(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _notionalSendQuantity,     uint256 _minNotionalReceiveQuantity,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();     ActionInfo memory actionInfo = ActionInfo ({         exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),         setToken: _setToken,         collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],         borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],         setTotalSupply: totalSupply,         notionalSendQuantity: _notionalSendQuantity,         minNotionalReceiveQuantity: _minNotionalReceiveQuantity,         preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))     });      _validateCommon(actionInfo);      return actionInfo; }    function _validateCommon(ActionInfo memory _actionInfo) internal view {     require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");     require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");     require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");     require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0"); }  function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {     uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));     return collateralNotionalBalance.preciseDiv(_setTotalSupply); }  /**  * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.  * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.  */ function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {     uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));     // Round negative away from 0     int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);      return borrowPositionUnit; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '/\n    Copyright 2021 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n/\n\npragma solidity 0.6.10;\npragma experimental "ABIEncoderV2";\n\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";\nimport { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\n\nimport { Compound } from "../../integration/lib/Compound.sol";\nimport { ICErc20 } from "../../../interfaces/external/ICErc20.sol";\nimport { IComptroller } from "../../../interfaces/external/IComptroller.sol";\nimport { IController } from "../../../interfaces/IController.sol";\nimport { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";\nimport { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";\nimport { ISetToken } from "../../../interfaces/ISetToken.sol";\nimport { ModuleBase } from "../../lib/ModuleBase.sol";\n\n/\n * @title CompoundLeverageModule\n * @author Set Protocol\n \n * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call\n * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each\n * asset is leveraged when using this module.\n \n * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of\n * debt when borrowed assets are the same.\n \n /\ncontract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {\n    using Compound for ISetToken;\n\n    / ============ Structs ============ /\n\n    struct EnabledAssets {\n        address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken\n        address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken\n        address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets\n    }\n\n    struct ActionInfo {\n        ISetToken setToken;                      // SetToken instance\n        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance\n        uint256 setTotalSupply;                  // Total supply of SetToken\n        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange\n        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange\n        ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset\n        ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset\n        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance\n    }\n\n    / ============ Events ============ /\n\n    event LeverageIncreased(\n        ISetToken indexed _setToken,\n        IERC20 indexed _borrowAsset,\n        IERC20 indexed _collateralAsset,\n        IExchangeAdapter _exchangeAdapter,\n        uint256 _totalBorrowAmount,\n        uint256 _totalReceiveAmount,\n        uint256 _protocolFee\n    );\n\n    event LeverageDecreased(\n        ISetToken indexed _setToken,\n        IERC20 indexed _collateralAsset,\n        IERC20 indexed _repayAsset,\n        IExchangeAdapter _exchangeAdapter,\n        uint256 _totalRedeemAmount,\n        uint256 _totalRepayAmount,\n        uint256 _protocolFee\n    );\n\n    event CollateralAssetsUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added,\n        IERC20[] _assets\n    );\n\n    event BorrowAssetsUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added,\n        IERC20[] _assets\n    );\n\n    event SetTokenStatusUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added\n    );\n\n    event AnySetAllowedUpdated(\n        bool indexed _anySetAllowed\n    );\n\n    / ============ Constants ============ /\n\n    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as\n    // the string as the integration name\n    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";\n\n    // 0 index stores protocol fee % on the controller, charged in the trade function\n    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;\n\n    / ============ State Variables ============ /\n\n    // Mapping of underlying to CToken. If ETH, then map WETH to cETH\n    mapping(IERC20 =&gt; ICErc20) public underlyingToCToken;\n\n    // Wrapped Ether address\n    IERC20 internal weth;\n\n    // Compound cEther address\n    ICErc20 internal cEther;\n\n    // Compound Comptroller contract\n    IComptroller internal comptroller;\n\n    // COMP token address\n    IERC20 internal compToken;\n\n    // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken\n    mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public collateralCTokenEnabled;\n\n    // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken\n    mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public borrowCTokenEnabled;\n\n    // Mapping of enabled collateral and borrow cTokens for syncing positions\n    mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;\n\n    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance\n    mapping(ISetToken =&gt; bool) public allowedSetTokens;\n\n    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list\n    bool public anySetAllowed;\n\n\n    / ============ Constructor ============ /\n\n    /\n     * Instantiate addresses. Underlying to cToken mapping is created.\n     \n     * @param _controller               Address of controller contract\n     * @param _compToken                Address of COMP token\n     * @param _comptroller              Address of Compound Comptroller\n     * @param _cEther                   Address of cEther contract\n     * @param _weth                     Address of WETH contract\n     /\n    constructor(\n        IController _controller,\n        IERC20 _compToken,\n        IComptroller _comptroller,\n        ICErc20 _cEther,\n        IERC20 _weth\n    )\n        public\n        ModuleBase(_controller)\n    {\n        compToken = _compToken;\n        comptroller = _comptroller;\n        cEther = _cEther;\n        weth = _weth;\n\n        ICErc20[] memory cTokens = comptroller.getAllMarkets();\n\n        for(uint256 i = 0; i &lt; cTokens.length; i++) {\n            ICErc20 cToken = cTokens[i];\n            underlyingToCToken[\n                cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())\n            ] = cToken;\n        }\n    }\n\n    / ============ External Functions ============ /\n\n    /\n     * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.\n     * Performs a DEX trade, exchanging the borrow asset for collateral asset.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _borrowAsset          Address of asset being borrowed for leverage\n     * @param _collateralAsset      Address of collateral asset (underlying of cToken)\n     * @param _borrowQuantity       Borrow quantity of asset in position units\n     * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units\n     * @param _tradeAdapterName     Name of trade adapter\n     * @param _tradeData            Arbitrary data for trade\n     /\n    function lever(\n        ISetToken _setToken,\n        IERC20 _borrowAsset,\n        IERC20 _collateralAsset,\n        uint256 _borrowQuantity,\n        uint256 _minReceiveQuantity,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from\n        // collateral asset\n        ActionInfo memory leverInfo = _createAndValidateActionInfo(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            _borrowQuantity,\n            _minReceiveQuantity,\n            _tradeAdapterName,\n            true\n        );\n\n        _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);\n\n        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);\n\n        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n        _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);\n\n        _updateLeverPositions(leverInfo, _borrowAsset);\n\n        emit LeverageIncreased(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            leverInfo.exchangeAdapter,\n            leverInfo.notionalSendQuantity,\n            postTradeCollateralQuantity,\n            protocolFee\n        );\n    }\n\n    /\n     * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _collateralAsset      Address of collateral asset (underlying of cToken)\n     * @param _repayAsset           Address of asset being repaid\n     * @param _redeemQuantity       Quantity of collateral asset to delever\n     * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade\n     * @param _tradeAdapterName     Name of trade adapter\n     * @param _tradeData            Arbitrary data for trade\n     /\n    function delever(\n        ISetToken _setToken,\n        IERC20 _collateralAsset,\n        IERC20 _repayAsset,\n        uint256 _redeemQuantity,\n        uint256 _minRepayQuantity,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from\n        // repay asset\n        ActionInfo memory deleverInfo = _createAndValidateActionInfo(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            _redeemQuantity,\n            _minRepayQuantity,\n            _tradeAdapterName,\n            false\n        );\n\n        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);\n\n        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);\n\n        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);\n\n        _updateLeverPositions(deleverInfo, _repayAsset);\n\n        emit LeverageDecreased(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            deleverInfo.exchangeAdapter,\n            deleverInfo.notionalSendQuantity,\n            repayQuantity,\n            protocolFee\n        );\n    }\n\n    /\n     * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received\n     * borrow asset is updated as equity. No protocol fee is charged.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _collateralAsset      Address of collateral asset (underlying of cToken)\n     * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)\n     * @param _redeemQuantity       Quantity of collateral asset to delever\n     * @param _tradeAdapterName     Name of trade adapter\n     * @param _tradeData            Arbitrary data for trade\n     /\n    function deleverToZeroBorrowBalance(\n        ISetToken _setToken,\n        IERC20 _collateralAsset,\n        IERC20 _repayAsset,\n        uint256 _redeemQuantity,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());\n\n        require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");\n        uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));\n\n        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            notionalRedeemQuantity,\n            notionalRepayQuantity,\n            _tradeAdapterName,\n            false\n        );\n\n        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);\n\n        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n\n        // We use notionalRepayQuantity vs. Compound\'s max value uint256(-1) to handle WETH properly\n        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);\n\n        // Update default position first to save gas on editing borrow position\n        _setToken.calculateAndEditDefaultPosition(\n            address(_repayAsset),\n            deleverInfo.setTotalSupply,\n            deleverInfo.preTradeReceiveTokenBalance\n        );\n\n        _updateLeverPositions(deleverInfo, _repayAsset);\n\n        emit LeverageDecreased(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            deleverInfo.exchangeAdapter,\n            deleverInfo.notionalSendQuantity,\n            notionalRepayQuantity,\n            0 // No protocol fee\n        );\n    }\n\n    /\n     * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral\n     * assets, update cToken default position. For borrow assets, update external borrow position.\n     * - Collateral assets may come out of sync when a position is liquidated\n     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid\n     \n     * @param _setToken               Instance of the SetToken\n     * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value\n     /\n    function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {\n        uint256 setTotalSupply = _setToken.totalSupply();\n\n        // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption\n        if (setTotalSupply &gt; 0) {\n            // Loop through collateral assets\n            address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;\n            for(uint256 i = 0; i &lt; collateralCTokens.length; i++) {\n                ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);\n                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();\n                uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);\n\n                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets\n                if (previousPositionUnit != newPositionUnit) {\n                  _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);\n                }\n            }\n\n            // Loop through borrow assets\n            address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;\n            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;\n            for(uint256 i = 0; i &lt; borrowCTokens.length; i++) {\n                ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);\n                IERC20 borrowAsset = IERC20(borrowAssets[i]);\n\n                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));\n\n                int256 newPositionUnit = _getBorrowPosition(\n                    _setToken,\n                    borrowCToken,\n                    setTotalSupply,\n                    _shouldAccrueInterest\n                );\n\n                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets\n                if (newPositionUnit != previousPositionUnit) {\n                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);\n                }\n            }\n        }\n    }\n\n\n    /\n     * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken\'s manager. Note: managers can enable\n     * collateral and borrow assets that don\'t exist as positions on the SetToken\n     \n     * @param _setToken             Instance of the SetToken to initialize\n     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken\n     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken\n     /\n    function initialize(\n        ISetToken _setToken,\n        IERC20[] memory _collateralAssets,\n        IERC20[] memory _borrowAssets\n    )\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        if (!anySetAllowed) {\n            require(allowedSetTokens[_setToken], "Not allowed SetToken");\n        }\n\n        // Initialize module before trying register\n        _setToken.initializeModule();\n\n        // Get debt issuance module registered to this module and require that it is initialized\n        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");\n\n        // Try if register exists on any of the modules including the debt issuance module\n        address[] memory modules = _setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}\n        }\n\n        // Enable collateral and borrow assets on Compound\n        addCollateralAssets(_setToken, _collateralAssets);\n\n        addBorrowAssets(_setToken, _borrowAssets);\n    }\n\n    /\n     * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled\n     * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)\n     /\n    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {\n        ISetToken setToken = ISetToken(msg.sender);\n\n        // Sync Compound and SetToken positions prior to any removal action\n        sync(setToken, true);\n\n        address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;\n        for (uint256 i = 0; i &lt; borrowCTokens.length; i++) {\n            ICErc20 cToken = ICErc20(borrowCTokens[i]);\n\n            // Will exit only if token isn\'t also being used as collateral\n            if(!collateralCTokenEnabled[setToken][cToken]) {\n                // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound\n                setToken.invokeExitMarket(cToken, comptroller);\n            }\n\n            delete borrowCTokenEnabled[setToken][cToken];\n        }\n\n        address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;\n        for (uint256 i = 0; i &lt; collateralCTokens.length; i++) {\n            ICErc20 cToken = ICErc20(collateralCTokens[i]);\n\n            setToken.invokeExitMarket(cToken, comptroller);\n\n            delete collateralCTokenEnabled[setToken][cToken];\n        }\n\n        delete enabledAssets[setToken];\n\n        // Try if unregister exists on any of the modules\n        address[] memory modules = setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}\n        }\n    }\n\n    /\n     * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken\n     * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state\n     * inconsistencies\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _debtIssuanceModule   Debt issuance module address to register\n     /\n    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {\n        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");\n\n        _debtIssuanceModule.registerToIssuanceModule(_setToken);\n    }\n\n    /\n     * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _newCollateralAssets  Addresses of new collateral underlying assets\n     /\n    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {\n        for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {\n            ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];\n            require(address(cToken) != address(0), "cToken must exist");\n            require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");\n\n            // Note: Will only enter market if cToken is not enabled as a borrow asset as well\n            if (!borrowCTokenEnabled[_setToken][cToken]) {\n                _setToken.invokeEnterMarkets(cToken, comptroller);\n            }\n\n            collateralCTokenEnabled[_setToken][cToken] = true;\n            enabledAssets[_setToken].collateralCTokens.push(address(cToken));\n        }\n\n        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);\n    }\n\n    /\n     * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets\n     * If there is a borrow balance, collateral asset cannot be removed\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _collateralAssets     Addresses of collateral underlying assets to remove\n     /\n    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {\n        // Sync Compound and SetToken positions prior to any removal action\n        sync(_setToken, true);\n\n        for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {\n            ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];\n            require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");\n\n            // Note: Will only exit market if cToken is not enabled as a borrow asset as well\n            // If there is an existing borrow balance, will revert and market cannot be exited on Compound\n            if (!borrowCTokenEnabled[_setToken][cToken]) {\n                _setToken.invokeExitMarket(cToken, comptroller);\n            }\n\n            delete collateralCTokenEnabled[_setToken][cToken];\n            enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));\n        }\n\n        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);\n    }\n\n    /\n     * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _newBorrowAssets      Addresses of borrow underlying assets to add\n     /\n    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {\n        for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {\n            IERC20 newBorrowAsset = _newBorrowAssets[i];\n            ICErc20 cToken = underlyingToCToken[newBorrowAsset];\n            require(address(cToken) != address(0), "cToken must exist");\n            require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");\n\n            // Note: Will only enter market if cToken is not enabled as a borrow asset as well\n            if (!collateralCTokenEnabled[_setToken][cToken]) {\n                _setToken.invokeEnterMarkets(cToken, comptroller);\n            }\n\n            borrowCTokenEnabled[_setToken][cToken] = true;\n            enabledAssets[_setToken].borrowCTokens.push(address(cToken));\n            enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));\n        }\n\n        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);\n    }\n\n    /\n     * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets\n     * If there is a borrow balance, borrow asset cannot be removed\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _borrowAssets         Addresses of borrow underlying assets to remove\n     /\n    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {\n        // Sync Compound and SetToken positions prior to any removal action\n        sync(_setToken, true);\n\n        for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {\n            ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];\n            require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");\n\n            // Note: Will only exit market if cToken is not enabled as a collateral asset as well\n            // If there is an existing borrow balance, will revert and market cannot be exited on Compound\n            if (!collateralCTokenEnabled[_setToken][cToken]) {\n                _setToken.invokeExitMarket(cToken, comptroller);\n            }\n\n            delete borrowCTokenEnabled[_setToken][cToken];\n            enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));\n            enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));\n        }\n\n        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);\n    }\n\n    /\n     * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.\n     \n     * @param _setToken             Instance of the SetToken\n     /\n    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {\n        allowedSetTokens[_setToken] = _status;\n        emit SetTokenStatusUpdated(_setToken, _status);\n    }\n\n    /\n     * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.\n     \n     * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled\n     /\n    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {\n        anySetAllowed = _anySetAllowed;\n        emit AnySetAllowedUpdated(_anySetAllowed);\n    }\n\n    /\n     * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.\n     \n     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit\n     \n     * @param _cToken                   Address of cToken to add\n     * @param _underlying               Address of underlying token that maps to cToken\n     /\n    function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {\n        require(address(underlyingToCToken[_underlying]) == address(0), "Already added");\n        underlyingToCToken[_underlying] = _cToken;\n    }\n\n    /\n     * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals\n     \n     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit\n     \n     * @param _underlying               Address of underlying token to remove\n     */\n    function removeCompoundMarket(IERC20 _underlying) external onlyOwner {\n        require(address(underlyingToCToken[_underlying]) != address(0), "Not added");\n        delete underlyingToCToken[_underlying];\n    }\n\n    /\n     * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.\n     \n     * @param _setToken             Instance of the SetToken\n     /\n    function moduleIssueHook(ISetToken _setToken, uint256 / _setTokenQuantity /) external onlyModule(_setToken) {\n        sync(_setToken, false);\n    }\n\n    /\n     * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.\n     * Only callable by valid module.\n     \n     * @param _setToken             Instance of the SetToken\n     /\n    function moduleRedeemHook(ISetToken _setToken, uint256 / _setTokenQuantity /) external onlyModule(_setToken) {\n        sync(_setToken, true);\n    }\n\n    /\n     * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken\n     * @param _component            Address of component\n     /\n    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool / _isEquity /) external onlyModule(_setToken) {\n        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n\n        require(componentDebt &lt; 0, "Component must be negative");\n\n        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);\n\n        _borrow(_setToken, underlyingToCToken[_component], notionalDebt);\n    }\n\n    /\n     * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken\n     * @param _component            Address of component\n     /\n    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool / _isEquity /) external onlyModule(_setToken) {\n        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n\n        require(componentDebt &lt; 0, "Component must be negative");\n\n        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);\n\n        _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt);\n    }\n\n\n    / ============ External Getter Functions ============ /\n\n    /\n     * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an\n     * array of underlying that are borrow assets.\n     \n     * @return                    Collateral cToken assets that are enabled\n     * @return                    Underlying borrowed assets that are enabled.\n     /\n    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {\n        return (\n            enabledAssets[_setToken].collateralCTokens,\n            enabledAssets[_setToken].borrowAssets\n        );\n    }\n\n    / ============ Internal Functions ============ /\n\n    /\n     * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be\n     * unwrapped as it only accepts the underlying ETH.\n     */\n    function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {\n        if (_cToken == cEther) {\n            _setToken.invokeUnwrapWETH(address(weth), _mintNotional);\n\n            _setToken.invokeMintCEther(_cToken, _mintNotional);\n        } else {\n            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);\n\n            _setToken.invokeMintCToken(_cToken, _mintNotional);\n        }\n    }\n\n    /\n     * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.\n     /\n    function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {\n        _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);\n\n        if (_cToken == cEther) {\n            _setToken.invokeWrapWETH(address(weth), _redeemNotional);\n        }\n    }\n\n    /\n     * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.\n     /\n    function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {\n        if (_cToken == cEther) {\n            _setToken.invokeUnwrapWETH(address(weth), _repayNotional);\n\n            _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);\n        } else {\n            // Approve to cToken\n            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);\n            _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);\n        }\n    }\n\n    /\n     * Invoke the SetToken to interact with the specified cToken to borrow the cToken\'s underlying of the specified borrowQuantity.\n     */\n    function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {\n        _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);\n        if (_cToken == cEther) {\n            _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);\n        }\n    }\n\n    /\n     * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken\n     \n     * @return receiveTokenQuantity The quantity of tokens received post-trade\n     /\n    function _executeTrade(\n        ActionInfo memory _actionInfo,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        bytes memory _data\n    )\n        internal\n        returns (uint256)\n    {\n         ISetToken setToken = _actionInfo.setToken;\n         uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;\n\n         setToken.invokeApprove(\n            address(_sendToken),\n            _actionInfo.exchangeAdapter.getSpender(),\n            notionalSendQuantity\n        );\n\n        (\n            address targetExchange,\n            uint256 callValue,\n            bytes memory methodData\n        ) = _actionInfo.exchangeAdapter.getTradeCalldata(\n            address(_sendToken),\n            address(_receiveToken),\n            address(setToken),\n            notionalSendQuantity,\n            _actionInfo.minNotionalReceiveQuantity,\n            _data\n        );\n\n        setToken.invoke(targetExchange, callValue, methodData);\n\n        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);\n        require(\n            receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,\n            "Slippage too high"\n        );\n\n        return receiveTokenQuantity;\n    }\n\n    /\n     * Calculates protocol fee on module and pays protocol fee from SetToken\n     */\n    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {\n        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);\n\n        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);\n\n        return protocolFeeTotal;\n    }\n\n    /\n     * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)\n     /\n    function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {\n        _updateCollateralPosition(\n            actionInfo.setToken,\n            actionInfo.collateralCTokenAsset,\n            _getCollateralPosition(\n                actionInfo.setToken,\n                actionInfo.collateralCTokenAsset,\n                actionInfo.setTotalSupply\n            )\n        );\n\n        _updateBorrowPosition(\n            actionInfo.setToken,\n            _borrowAsset,\n            _getBorrowPosition(\n                actionInfo.setToken,\n                actionInfo.borrowCTokenAsset,\n                actionInfo.setTotalSupply,\n                false // Do not accrue interest\n            )\n        );\n    }\n\n    function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {\n        _setToken.editDefaultPosition(address(_cToken), _newPositionUnit);\n    }\n\n    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {\n        _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, "");\n    }\n\n    /\n     * Construct the ActionInfo struct for lever and delever\n     /\n    function _createAndValidateActionInfo(\n        ISetToken _setToken,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        uint256 _sendQuantityUnits,\n        uint256 _minReceiveQuantityUnits,\n        string memory _tradeAdapterName,\n        bool _isLever\n    )\n        internal\n        view\n        returns(ActionInfo memory)\n    {\n        uint256 totalSupply = _setToken.totalSupply();\n\n        return _createAndValidateActionInfoNotional(\n            _setToken,\n            _sendToken,\n            _receiveToken,\n            _sendQuantityUnits.preciseMul(totalSupply),\n            _minReceiveQuantityUnits.preciseMul(totalSupply),\n            _tradeAdapterName,\n            _isLever\n        );\n    }\n\n    /\n     * Construct the ActionInfo struct for lever and delever accepting notional units\n     */\n    function _createAndValidateActionInfoNotional(\n        ISetToken _setToken,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        uint256 _notionalSendQuantity,\n        uint256 _minNotionalReceiveQuantity,\n        string memory _tradeAdapterName,\n        bool _isLever\n    )\n        internal\n        view\n        returns(ActionInfo memory)\n    {\n        uint256 totalSupply = _setToken.totalSupply();\n        ActionInfo memory actionInfo = ActionInfo ({\n            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),\n            setToken: _setToken,\n            collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],\n            borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],\n            setTotalSupply: totalSupply,\n            notionalSendQuantity: _notionalSendQuantity,\n            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,\n            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))\n        });\n\n        _validateCommon(actionInfo);\n\n        return actionInfo;\n    }\n\n\n\n    function _validateCommon(ActionInfo memory _actionInfo) internal view {\n        require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");\n        require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");\n        require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");\n        require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0");\n    }\n\n    function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {\n        uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));\n        return collateralNotionalBalance.preciseDiv(_setTotalSupply);\n    }\n\n    /\n     * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.\n     * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.\n     */\n    function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {\n        uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));\n        // Round negative away from 0\n        int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);\n\n        return borrowPositionUnit;\n    }\n}', 'ideas': ' Security', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-01-09 02:00:58 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { Compound } from "../../integration/lib/Compound.sol"; import { ICErc20 } from "../../../interfaces/external/ICErc20.sol"; import { IComptroller } from "../../../interfaces/external/IComptroller.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol"; import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; /*  * @title CompoundLeverageModule  * @author Set Protocol  *  * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call  * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each  * asset is leveraged when using this module.  *  * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of  * debt when borrowed assets are the same.  *  / contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {     using Compound for ISetToken; /* ============ Structs ============ */  struct EnabledAssets {     address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken     address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken     address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets }  struct ActionInfo {     ISetToken setToken;                      // SetToken instance     IExchangeAdapter exchangeAdapter;        // Exchange adapter instance     uint256 setTotalSupply;                  // Total supply of SetToken     uint256 notionalSendQuantity;            // Total notional quantity sent to exchange     uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange     ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset     ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset     uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance }  /* ============ Events ============ */  event LeverageIncreased(     ISetToken indexed _setToken,     IERC20 indexed _borrowAsset,     IERC20 indexed _collateralAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalBorrowAmount,     uint256 _totalReceiveAmount,     uint256 _protocolFee );  event LeverageDecreased(     ISetToken indexed _setToken,     IERC20 indexed _collateralAsset,     IERC20 indexed _repayAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalRedeemAmount,     uint256 _totalRepayAmount,     uint256 _protocolFee );  event CollateralAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  event BorrowAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  event SetTokenStatusUpdated(     ISetToken indexed _setToken,     bool indexed _added );  event AnySetAllowedUpdated(     bool indexed _anySetAllowed );  /* ============ Constants ============ */  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the trade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Mapping of underlying to CToken. If ETH, then map WETH to cETH mapping(IERC20 =&gt; ICErc20) public underlyingToCToken;  // Wrapped Ether address IERC20 internal weth;  // Compound cEther address ICErc20 internal cEther;  // Compound Comptroller contract IComptroller internal comptroller;  // COMP token address IERC20 internal compToken;  // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public collateralCTokenEnabled;  // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken mapping(ISetToken =&gt; mapping(ICErc20 =&gt; bool)) public borrowCTokenEnabled;  // Mapping of enabled collateral and borrow cTokens for syncing positions mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;  // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance mapping(ISetToken =&gt; bool) public allowedSetTokens;  // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list bool public anySetAllowed;   /* ============ Constructor ============ */  /**  * Instantiate addresses. Underlying to cToken mapping is created.  *  * @param _controller               Address of controller contract  * @param _compToken                Address of COMP token  * @param _comptroller              Address of Compound Comptroller  * @param _cEther                   Address of cEther contract  * @param _weth                     Address of WETH contract  */ constructor(     IController _controller,     IERC20 _compToken,     IComptroller _comptroller,     ICErc20 _cEther,     IERC20 _weth )     public     ModuleBase(_controller) {     compToken = _compToken;     comptroller = _comptroller;     cEther = _cEther;     weth = _weth;      ICErc20[] memory cTokens = comptroller.getAllMarkets();      for(uint256 i = 0; i &lt; cTokens.length; i++) {         ICErc20 cToken = cTokens[i];         underlyingToCToken[             cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())         ] = cToken;     } }  /* ============ External Functions ============ */  /**  * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.  * Performs a DEX trade, exchanging the borrow asset for collateral asset.  *  * @param _setToken             Instance of the SetToken  * @param _borrowAsset          Address of asset being borrowed for leverage  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _borrowQuantity       Borrow quantity of asset in position units  * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function lever(     ISetToken _setToken,     IERC20 _borrowAsset,     IERC20 _collateralAsset,     uint256 _borrowQuantity,     uint256 _minReceiveQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // For levering up, send quantity is derived from borrow asset and receive quantity is derived from     // collateral asset     ActionInfo memory leverInfo = _createAndValidateActionInfo(         _setToken,         _borrowAsset,         _collateralAsset,         _borrowQuantity,         _minReceiveQuantity,         _tradeAdapterName,         true     );      _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);      uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);      _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);      _updateLeverPositions(leverInfo, _borrowAsset);      emit LeverageIncreased(         _setToken,         _borrowAsset,         _collateralAsset,         leverInfo.exchangeAdapter,         leverInfo.notionalSendQuantity,         postTradeCollateralQuantity,         protocolFee     ); }  /**  * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled  *  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _repayAsset           Address of asset being repaid  * @param _redeemQuantity       Quantity of collateral asset to delever  * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function delever(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantity,     uint256 _minRepayQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from     // repay asset     ActionInfo memory deleverInfo = _createAndValidateActionInfo(         _setToken,         _collateralAsset,         _repayAsset,         _redeemQuantity,         _minRepayQuantity,         _tradeAdapterName,         false     );      _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);      uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);      _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);      _updateLeverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         repayQuantity,         protocolFee     ); }  /**  * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received  * borrow asset is updated as equity. No protocol fee is charged.  *  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of collateral asset (underlying of cToken)  * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)  * @param _redeemQuantity       Quantity of collateral asset to delever  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  */ function deleverToZeroBorrowBalance(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantity,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());      require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");     uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));      ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(         _setToken,         _collateralAsset,         _repayAsset,         notionalRedeemQuantity,         notionalRepayQuantity,         _tradeAdapterName,         false     );      _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);      _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly     _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);      // Update default position first to save gas on editing borrow position     _setToken.calculateAndEditDefaultPosition(         address(_repayAsset),         deleverInfo.setTotalSupply,         deleverInfo.preTradeReceiveTokenBalance     );      _updateLeverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         notionalRepayQuantity,         0 // No protocol fee     ); }  /**  * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral  * assets, update cToken default position. For borrow assets, update external borrow position.  * - Collateral assets may come out of sync when a position is liquidated  * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid  *  * @param _setToken               Instance of the SetToken  * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value  */ function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {     uint256 setTotalSupply = _setToken.totalSupply();      // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption     if (setTotalSupply &gt; 0) {         // Loop through collateral assets         address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;         for(uint256 i = 0; i &lt; collateralCTokens.length; i++) {             ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);             uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();             uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (previousPositionUnit != newPositionUnit) {               _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);             }         }          // Loop through borrow assets         address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;         address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;         for(uint256 i = 0; i &lt; borrowCTokens.length; i++) {             ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);             IERC20 borrowAsset = IERC20(borrowAssets[i]);              int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));              int256 newPositionUnit = _getBorrowPosition(                 _setToken,                 borrowCToken,                 setTotalSupply,                 _shouldAccrueInterest             );              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (newPositionUnit != previousPositionUnit) {                 _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);             }         }     } }   /**  * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable  * collateral and borrow assets that don't exist as positions on the SetToken  *  * @param _setToken             Instance of the SetToken to initialize  * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken  * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken  */ function initialize(     ISetToken _setToken,     IERC20[] memory _collateralAssets,     IERC20[] memory _borrowAssets )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     if (!anySetAllowed) {         require(allowedSetTokens[_setToken], "Not allowed SetToken");     }      // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}     }      // Enable collateral and borrow assets on Compound     addCollateralAssets(_setToken, _collateralAssets);      addBorrowAssets(_setToken, _borrowAssets); }  /**  * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled  * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)  */ function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Sync Compound and SetToken positions prior to any removal action     sync(setToken, true);      address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;     for (uint256 i = 0; i &lt; borrowCTokens.length; i++) {         ICErc20 cToken = ICErc20(borrowCTokens[i]);          // Will exit only if token isn't also being used as collateral         if(!collateralCTokenEnabled[setToken][cToken]) {             // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound             setToken.invokeExitMarket(cToken, comptroller);         }          delete borrowCTokenEnabled[setToken][cToken];     }      address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;     for (uint256 i = 0; i &lt; collateralCTokens.length; i++) {         ICErc20 cToken = ICErc20(collateralCTokens[i]);          setToken.invokeExitMarket(cToken, comptroller);          delete collateralCTokenEnabled[setToken][cToken];     }      delete enabledAssets[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken  * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state  * inconsistencies  *  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets  *  * @param _setToken             Instance of the SetToken  * @param _newCollateralAssets  Addresses of new collateral underlying assets  */ function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {     for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];         require(address(cToken) != address(0), "cToken must exist");         require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");          // Note: Will only enter market if cToken is not enabled as a borrow asset as well         if (!borrowCTokenEnabled[_setToken][cToken]) {             _setToken.invokeEnterMarkets(cToken, comptroller);         }          collateralCTokenEnabled[_setToken][cToken] = true;         enabledAssets[_setToken].collateralCTokens.push(address(cToken));     }      emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets); }  /**  * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets  * If there is a borrow balance, collateral asset cannot be removed  *  * @param _setToken             Instance of the SetToken  * @param _collateralAssets     Addresses of collateral underlying assets to remove  */ function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {     // Sync Compound and SetToken positions prior to any removal action     sync(_setToken, true);      for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];         require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");          // Note: Will only exit market if cToken is not enabled as a borrow asset as well         // If there is an existing borrow balance, will revert and market cannot be exited on Compound         if (!borrowCTokenEnabled[_setToken][cToken]) {             _setToken.invokeExitMarket(cToken, comptroller);         }          delete collateralCTokenEnabled[_setToken][cToken];         enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));     }      emit CollateralAssetsUpdated(_setToken, false, _collateralAssets); }  /**  * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets  *  * @param _setToken             Instance of the SetToken  * @param _newBorrowAssets      Addresses of borrow underlying assets to add  */ function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {     for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {         IERC20 newBorrowAsset = _newBorrowAssets[i];         ICErc20 cToken = underlyingToCToken[newBorrowAsset];         require(address(cToken) != address(0), "cToken must exist");         require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");          // Note: Will only enter market if cToken is not enabled as a borrow asset as well         if (!collateralCTokenEnabled[_setToken][cToken]) {             _setToken.invokeEnterMarkets(cToken, comptroller);         }          borrowCTokenEnabled[_setToken][cToken] = true;         enabledAssets[_setToken].borrowCTokens.push(address(cToken));         enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));     }      emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets); }  /**  * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets  * If there is a borrow balance, borrow asset cannot be removed  *  * @param _setToken             Instance of the SetToken  * @param _borrowAssets         Addresses of borrow underlying assets to remove  */ function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {     // Sync Compound and SetToken positions prior to any removal action     sync(_setToken, true);      for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {         ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];         require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");          // Note: Will only exit market if cToken is not enabled as a collateral asset as well         // If there is an existing borrow balance, will revert and market cannot be exited on Compound         if (!collateralCTokenEnabled[_setToken][cToken]) {             _setToken.invokeExitMarket(cToken, comptroller);         }          delete borrowCTokenEnabled[_setToken][cToken];         enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));         enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));     }      emit BorrowAssetsUpdated(_setToken, false, _borrowAssets); }  /**  * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.  *  * @param _setToken             Instance of the SetToken  */ function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {     allowedSetTokens[_setToken] = _status;     emit SetTokenStatusUpdated(_setToken, _status); }  /**  * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.  *  * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled  */ function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {     anySetAllowed = _anySetAllowed;     emit AnySetAllowedUpdated(_anySetAllowed); }  /**  * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.  *  * IMPORTANT: Validations are skipped in order to get contract under bytecode limit  *  * @param _cToken                   Address of cToken to add  * @param _underlying               Address of underlying token that maps to cToken  */ function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {     require(address(underlyingToCToken[_underlying]) == address(0), "Already added");     underlyingToCToken[_underlying] = _cToken; }  /**  * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals  *  * IMPORTANT: Validations are skipped in order to get contract under bytecode limit  *  * @param _underlying               Address of underlying token to remove  */ function removeCompoundMarket(IERC20 _underlying) external onlyOwner {     require(address(underlyingToCToken[_underlying]) != address(0), "Not added");     delete underlyingToCToken[_underlying]; }  /**  * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {     sync(_setToken, false); }  /**  * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.  * Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {     sync(_setToken, true); }  /**  * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {     int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));      require(componentDebt &lt; 0, "Component must be negative");      uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);      _borrow(_setToken, underlyingToCToken[_component], notionalDebt); }  /**  * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {     int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));      require(componentDebt &lt; 0, "Component must be negative");      uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);      _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt); }   /* ============ External Getter Functions ============ */  /**  * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an  * array of underlying that are borrow assets.  *  * @return                    Collateral cToken assets that are enabled  * @return                    Underlying borrowed assets that are enabled.  */ function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {     return (         enabledAssets[_setToken].collateralCTokens,         enabledAssets[_setToken].borrowAssets     ); }  /* ============ Internal Functions ============ */  /**  * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be  * unwrapped as it only accepts the underlying ETH.  */ function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {     if (_cToken == cEther) {         _setToken.invokeUnwrapWETH(address(weth), _mintNotional);          _setToken.invokeMintCEther(_cToken, _mintNotional);     } else {         _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);          _setToken.invokeMintCToken(_cToken, _mintNotional);     } }  /**  * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.  */ function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {     _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);      if (_cToken == cEther) {         _setToken.invokeWrapWETH(address(weth), _redeemNotional);     } }  /**  * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.  */ function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {     if (_cToken == cEther) {         _setToken.invokeUnwrapWETH(address(weth), _repayNotional);          _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);     } else {         // Approve to cToken         _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);         _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);     } }  /**  * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.  */ function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {     _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);     if (_cToken == cEther) {         _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);     } }  /**  * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken  *  * @return receiveTokenQuantity The quantity of tokens received post-trade  */ function _executeTrade(     ActionInfo memory _actionInfo,     IERC20 _sendToken,     IERC20 _receiveToken,     bytes memory _data )     internal     returns (uint256) {      ISetToken setToken = _actionInfo.setToken;      uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;       setToken.invokeApprove(         address(_sendToken),         _actionInfo.exchangeAdapter.getSpender(),         notionalSendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _actionInfo.exchangeAdapter.getTradeCalldata(         address(_sendToken),         address(_receiveToken),         address(setToken),         notionalSendQuantity,         _actionInfo.minNotionalReceiveQuantity,         _data     );      setToken.invoke(targetExchange, callValue, methodData);      uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);     require(         receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,         "Slippage too high"     );      return receiveTokenQuantity; }  /**  * Calculates protocol fee on module and pays protocol fee from SetToken  */ function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {     uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);      payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);      return protocolFeeTotal; }  /**  * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)  */ function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {     _updateCollateralPosition(         actionInfo.setToken,         actionInfo.collateralCTokenAsset,         _getCollateralPosition(             actionInfo.setToken,             actionInfo.collateralCTokenAsset,             actionInfo.setTotalSupply         )     );      _updateBorrowPosition(         actionInfo.setToken,         _borrowAsset,         _getBorrowPosition(             actionInfo.setToken,             actionInfo.borrowCTokenAsset,             actionInfo.setTotalSupply,             false // Do not accrue interest         )     ); }  function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {     _setToken.editDefaultPosition(address(_cToken), _newPositionUnit); }  function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {     _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, ""); }  /**  * Construct the ActionInfo struct for lever and delever  */ function _createAndValidateActionInfo(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _sendQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();      return _createAndValidateActionInfoNotional(         _setToken,         _sendToken,         _receiveToken,         _sendQuantityUnits.preciseMul(totalSupply),         _minReceiveQuantityUnits.preciseMul(totalSupply),         _tradeAdapterName,         _isLever     ); }  /**  * Construct the ActionInfo struct for lever and delever accepting notional units  */ function _createAndValidateActionInfoNotional(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _notionalSendQuantity,     uint256 _minNotionalReceiveQuantity,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();     ActionInfo memory actionInfo = ActionInfo ({         exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),         setToken: _setToken,         collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],         borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],         setTotalSupply: totalSupply,         notionalSendQuantity: _notionalSendQuantity,         minNotionalReceiveQuantity: _minNotionalReceiveQuantity,         preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))     });      _validateCommon(actionInfo);      return actionInfo; }    function _validateCommon(ActionInfo memory _actionInfo) internal view {     require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");     require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");     require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");     require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0"); }  function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {     uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));     return collateralNotionalBalance.preciseDiv(_setTotalSupply); }  /**  * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.  * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.  */ function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {     uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));     // Round negative away from 0     int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);      return borrowPositionUnit; }  } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 02:00:58 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { Compound } from "../../integration/lib/Compound.sol";
import { ICErc20 } from "../../../interfaces/external/ICErc20.sol";
import { IComptroller } from "../../../interfaces/external/IComptroller.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title CompoundLeverageModule
 * @author Set Protocol
 *
 * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call
 * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each
 * asset is leveraged when using this module.
 *
 * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 *
 */
contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {
    using Compound for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken
        address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken
        address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset
        ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    /* ============ Events ============ */

    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the trade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping of underlying to CToken. If ETH, then map WETH to cETH
    mapping(IERC20 => ICErc20) public underlyingToCToken;

    // Wrapped Ether address
    IERC20 internal weth;

    // Compound cEther address
    ICErc20 internal cEther;

    // Compound Comptroller contract
    IComptroller internal comptroller;

    // COMP token address
    IERC20 internal compToken;

    // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public collateralCTokenEnabled;

    // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public borrowCTokenEnabled;

    // Mapping of enabled collateral and borrow cTokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list
    bool public anySetAllowed;


    /* ============ Constructor ============ */

    /**
     * Instantiate addresses. Underlying to cToken mapping is created.
     *
     * @param _controller               Address of controller contract
     * @param _compToken                Address of COMP token
     * @param _comptroller              Address of Compound Comptroller
     * @param _cEther                   Address of cEther contract
     * @param _weth                     Address of WETH contract
     */
    constructor(
        IController _controller,
        IERC20 _compToken,
        IComptroller _comptroller,
        ICErc20 _cEther,
        IERC20 _weth
    )
        public
        ModuleBase(_controller)
    {
        compToken = _compToken;
        comptroller = _comptroller;
        cEther = _cEther;
        weth = _weth;

        ICErc20[] memory cTokens = comptroller.getAllMarkets();

        for(uint256 i = 0; i < cTokens.length; i++) {
            ICErc20 cToken = cTokens[i];
            underlyingToCToken[
                cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())
            ] = cToken;
        }
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.
     * Performs a DEX trade, exchanging the borrow asset for collateral asset.
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAsset          Address of asset being borrowed for leverage
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _borrowQuantity       Borrow quantity of asset in position units
     * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantity,
        uint256 _minReceiveQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantity,
            _minReceiveQuantity,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        uint256 _minRepayQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantity,
            _minRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received
     * borrow asset is updated as equity. No protocol fee is charged.
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());

        require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly
        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);

        // Update default position first to save gas on editing borrow position
        _setToken.calculateAndEditDefaultPosition(
            address(_repayAsset),
            deleverInfo.setTotalSupply,
            deleverInfo.preTradeReceiveTokenBalance
        );

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0 // No protocol fee
        );
    }

    /**
     * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral
     * assets, update cToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     *
     * @param _setToken               Instance of the SetToken
     * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value
     */
    function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption
        if (setTotalSupply > 0) {
            // Loop through collateral assets
            address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;
            for(uint256 i = 0; i < collateralCTokens.length; i++) {
                ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);
                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);
                }
            }

            // Loop through borrow assets
            address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;
            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowCTokens.length; i++) {
                ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));

                int256 newPositionUnit = _getBorrowPosition(
                    _setToken,
                    borrowCToken,
                    setTotalSupply,
                    _shouldAccrueInterest
                );

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }


    /**
     * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable
     * collateral and borrow assets that don't exist as positions on the SetToken
     *
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // Enable collateral and borrow assets on Compound
        addCollateralAssets(_setToken, _collateralAssets);

        addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled
     * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Compound and SetToken positions prior to any removal action
        sync(setToken, true);

        address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;
        for (uint256 i = 0; i < borrowCTokens.length; i++) {
            ICErc20 cToken = ICErc20(borrowCTokens[i]);

            // Will exit only if token isn't also being used as collateral
            if(!collateralCTokenEnabled[setToken][cToken]) {
                // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound
                setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[setToken][cToken];
        }

        address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;
        for (uint256 i = 0; i < collateralCTokens.length; i++) {
            ICErc20 cToken = ICErc20(collateralCTokens[i]);

            setToken.invokeExitMarket(cToken, comptroller);

            delete collateralCTokenEnabled[setToken][cToken];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken
     * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];
            require(address(cToken) != address(0), "cToken must exist");
            require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            collateralCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].collateralCTokens.push(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets
     * If there is a borrow balance, collateral asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];
            require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");

            // Note: Will only exit market if cToken is not enabled as a borrow asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete collateralCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 newBorrowAsset = _newBorrowAssets[i];
            ICErc20 cToken = underlyingToCToken[newBorrowAsset];
            require(address(cToken) != address(0), "cToken must exist");
            require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            borrowCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].borrowCTokens.push(address(cToken));
            enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));
        }

        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets
     * If there is a borrow balance, borrow asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];
            require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");

            // Note: Will only exit market if cToken is not enabled as a collateral asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));
            enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));
        }

        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.
     *
     * @param _setToken             Instance of the SetToken
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.
     *
     * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _cToken                   Address of cToken to add
     * @param _underlying               Address of underlying token that maps to cToken
     */
    function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) == address(0), "Already added");
        underlyingToCToken[_underlying] = _cToken;
    }

    /**
     * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _underlying               Address of underlying token to remove
     */
    function removeCompoundMarket(IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) != address(0), "Not added");
        delete underlyingToCToken[_underlying];
    }

    /**
     * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, false);
    }

    /**
     * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.
     * Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, true);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);

        _borrow(_setToken, underlyingToCToken[_component], notionalDebt);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);

        _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt);
    }


    /* ============ External Getter Functions ============ */

    /**
     * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an
     * array of underlying that are borrow assets.
     *
     * @return                    Collateral cToken assets that are enabled
     * @return                    Underlying borrowed assets that are enabled.
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralCTokens,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be
     * unwrapped as it only accepts the underlying ETH.
     */
    function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _mintNotional);

            _setToken.invokeMintCEther(_cToken, _mintNotional);
        } else {
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);

            _setToken.invokeMintCToken(_cToken, _mintNotional);
        }
    }

    /**
     * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.
     */
    function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {
        _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);

        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _redeemNotional);
        }
    }

    /**
     * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.
     */
    function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _repayNotional);

            _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);
        } else {
            // Approve to cToken
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);
            _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);
        }
    }

    /**
     * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.
     */
    function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {
        _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);
        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);
        }
    }

    /**
     * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     *
     * @return receiveTokenQuantity The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
         ISetToken setToken = _actionInfo.setToken;
         uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

         setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * Calculates protocol fee on module and pays protocol fee from SetToken
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)
     */
    function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {
        _updateCollateralPosition(
            actionInfo.setToken,
            actionInfo.collateralCTokenAsset,
            _getCollateralPosition(
                actionInfo.setToken,
                actionInfo.collateralCTokenAsset,
                actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                actionInfo.setToken,
                actionInfo.borrowCTokenAsset,
                actionInfo.setTotalSupply,
                false // Do not accrue interest
            )
        );
    }

    function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_cToken), _newPositionUnit);
    }

    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, "");
    }

    /**
     * Construct the ActionInfo struct for lever and delever
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever
        );
    }

    /**
     * Construct the ActionInfo struct for lever and delever accepting notional units
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            setToken: _setToken,
            collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],
            borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],
            setTotalSupply: totalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }



    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");
        require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");
        require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.
     * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.
     */
    function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {
        uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));
        // Round negative away from 0
        int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);

        return borrowPositionUnit;
    }
}.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "/*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { Compound } from "../../integration/lib/Compound.sol";
import { ICErc20 } from "../../../interfaces/external/ICErc20.sol";
import { IComptroller } from "../../../interfaces/external/IComptroller.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title CompoundLeverageModule
 * @author Set Protocol
 *
 * Smart contract that enables leverage trading using Compound as the lending protocol. This module is paired with a debt issuance module that will call
 * functions on this module to keep interest accrual and liquidation state updated. This does not allow borrowing of assets from Compound alone. Each
 * asset is leveraged when using this module.
 *
 * Note: Do not use this module in conjunction with other debt modules that allow Compound debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 *
 */
contract CompoundLeverageModule is ModuleBase, ReentrancyGuard, Ownable {
    using Compound for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralCTokens;             // Array of enabled cToken collateral assets for a SetToken
        address[] borrowCTokens;                 // Array of enabled cToken borrow assets for a SetToken
        address[] borrowAssets;                  // Array of underlying borrow assets that map to the array of enabled cToken borrow assets
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        ICErc20 collateralCTokenAsset;           // Address of cToken collateral asset
        ICErc20 borrowCTokenAsset;               // Address of cToken borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    /* ============ Events ============ */

    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the trade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping of underlying to CToken. If ETH, then map WETH to cETH
    mapping(IERC20 => ICErc20) public underlyingToCToken;

    // Wrapped Ether address
    IERC20 internal weth;

    // Compound cEther address
    ICErc20 internal cEther;

    // Compound Comptroller contract
    IComptroller internal comptroller;

    // COMP token address
    IERC20 internal compToken;

    // Mapping to efficiently check if cToken market for collateral asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public collateralCTokenEnabled;

    // Mapping to efficiently check if cToken market for borrow asset is valid in SetToken
    mapping(ISetToken => mapping(ICErc20 => bool)) public borrowCTokenEnabled;

    // Mapping of enabled collateral and borrow cTokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list
    bool public anySetAllowed;


    /* ============ Constructor ============ */

    /**
     * Instantiate addresses. Underlying to cToken mapping is created.
     *
     * @param _controller               Address of controller contract
     * @param _compToken                Address of COMP token
     * @param _comptroller              Address of Compound Comptroller
     * @param _cEther                   Address of cEther contract
     * @param _weth                     Address of WETH contract
     */
    constructor(
        IController _controller,
        IERC20 _compToken,
        IComptroller _comptroller,
        ICErc20 _cEther,
        IERC20 _weth
    )
        public
        ModuleBase(_controller)
    {
        compToken = _compToken;
        comptroller = _comptroller;
        cEther = _cEther;
        weth = _weth;

        ICErc20[] memory cTokens = comptroller.getAllMarkets();

        for(uint256 i = 0; i < cTokens.length; i++) {
            ICErc20 cToken = cTokens[i];
            underlyingToCToken[
                cToken == _cEther ? _weth : IERC20(cTokens[i].underlying())
            ] = cToken;
        }
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset that is enabled.
     * Performs a DEX trade, exchanging the borrow asset for collateral asset.
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAsset          Address of asset being borrowed for leverage
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _borrowQuantity       Borrow quantity of asset in position units
     * @param _minReceiveQuantity   Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantity,
        uint256 _minReceiveQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantity,
            _minReceiveQuantity,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset that is enabled
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _minRepayQuantity     Minimum amount of repay asset to receive post trade
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        uint256 _minRepayQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantity,
            _minRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /**
     * MANAGER ONLY: Pays down the borrow asset to 0 selling off a given collateral asset. Any extra received
     * borrow asset is updated as equity. No protocol fee is charged.
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of collateral asset (underlying of cToken)
     * @param _repayAsset           Address of asset being repaid (underlying asset e.g. DAI)
     * @param _redeemQuantity       Quantity of collateral asset to delever
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantity,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());

        require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false
        );

        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly
        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);

        // Update default position first to save gas on editing borrow position
        _setToken.calculateAndEditDefaultPosition(
            address(_repayAsset),
            deleverInfo.setTotalSupply,
            deleverInfo.preTradeReceiveTokenBalance
        );

        _updateLeverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0 // No protocol fee
        );
    }

    /**
     * CALLABLE BY ANYBODY: Sync Set positions with enabled Compound collateral and borrow positions. For collateral
     * assets, update cToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     *
     * @param _setToken               Instance of the SetToken
     * @param _shouldAccrueInterest   Boolean indicating whether use current block interest rate value or stored value
     */
    function sync(ISetToken _setToken, bool _shouldAccrueInterest) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. This preserves debt and collateral positions on issuance / redemption
        if (setTotalSupply > 0) {
            // Loop through collateral assets
            address[] memory collateralCTokens = enabledAssets[_setToken].collateralCTokens;
            for(uint256 i = 0; i < collateralCTokens.length; i++) {
                ICErc20 collateralCToken = ICErc20(collateralCTokens[i]);
                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(collateralCToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, collateralCToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, collateralCToken, newPositionUnit);
                }
            }

            // Loop through borrow assets
            address[] memory borrowCTokens = enabledAssets[_setToken].borrowCTokens;
            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowCTokens.length; i++) {
                ICErc20 borrowCToken = ICErc20(borrowCTokens[i]);
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));

                int256 newPositionUnit = _getBorrowPosition(
                    _setToken,
                    borrowCToken,
                    setTotalSupply,
                    _shouldAccrueInterest
                );

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }


    /**
     * MANAGER ONLY: Initializes this module to the SetToken. Only callable by the SetToken's manager. Note: managers can enable
     * collateral and borrow assets that don't exist as positions on the SetToken
     *
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // Enable collateral and borrow assets on Compound
        addCollateralAssets(_setToken, _collateralAssets);

        addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Compound Settings and manager enabled
     * cTokens are deleted. Markets are exited on Comptroller (only valid if borrow balances are zero)
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Compound and SetToken positions prior to any removal action
        sync(setToken, true);

        address[] memory borrowCTokens = enabledAssets[setToken].borrowCTokens;
        for (uint256 i = 0; i < borrowCTokens.length; i++) {
            ICErc20 cToken = ICErc20(borrowCTokens[i]);

            // Will exit only if token isn't also being used as collateral
            if(!collateralCTokenEnabled[setToken][cToken]) {
                // Note: if there is an existing borrow balance, will revert and market cannot be exited on Compound
                setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[setToken][cToken];
        }

        address[] memory collateralCTokens = enabledAssets[setToken].collateralCTokens;
        for (uint256 i = 0; i < collateralCTokens.length; i++) {
            ICErc20 cToken = ICErc20(collateralCTokens[i]);

            setToken.invokeExitMarket(cToken, comptroller);

            delete collateralCTokenEnabled[setToken][cToken];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * MANAGER ONLY: Add registration of this module on debt issuance module for the SetToken. Note: if the debt issuance module is not added to SetToken
     * before this module is initialized, then this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * MANAGER ONLY: Add enabled collateral assets. Collateral assets are tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_newCollateralAssets[i]];
            require(address(cToken) != address(0), "cToken must exist");
            require(!collateralCTokenEnabled[_setToken][cToken], "Collateral enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            collateralCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].collateralCTokens.push(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * MANAGER ONLY: Remove collateral asset. Collateral asset exited in Compound markets
     * If there is a borrow balance, collateral asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];
            require(collateralCTokenEnabled[_setToken][cToken], "Collateral not enabled");

            // Note: Will only exit market if cToken is not enabled as a borrow asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!borrowCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete collateralCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));
        }

        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * MANAGER ONLY: Add borrow asset. Borrow asset is tracked for syncing positions and entered in Compound markets
     *
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) public onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 newBorrowAsset = _newBorrowAssets[i];
            ICErc20 cToken = underlyingToCToken[newBorrowAsset];
            require(address(cToken) != address(0), "cToken must exist");
            require(!borrowCTokenEnabled[_setToken][cToken], "Borrow enabled");

            // Note: Will only enter market if cToken is not enabled as a borrow asset as well
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeEnterMarkets(cToken, comptroller);
            }

            borrowCTokenEnabled[_setToken][cToken] = true;
            enabledAssets[_setToken].borrowCTokens.push(address(cToken));
            enabledAssets[_setToken].borrowAssets.push(address(newBorrowAsset));
        }

        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * MANAGER ONLY: Remove borrow asset. Borrow asset is exited in Compound markets
     * If there is a borrow balance, borrow asset cannot be removed
     *
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {
        // Sync Compound and SetToken positions prior to any removal action
        sync(_setToken, true);

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];
            require(borrowCTokenEnabled[_setToken][cToken], "Borrow not enabled");

            // Note: Will only exit market if cToken is not enabled as a collateral asset as well
            // If there is an existing borrow balance, will revert and market cannot be exited on Compound
            if (!collateralCTokenEnabled[_setToken][cToken]) {
                _setToken.invokeExitMarket(cToken, comptroller);
            }

            delete borrowCTokenEnabled[_setToken][cToken];
            enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));
            enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));
        }

        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * GOVERNANCE ONLY: Add or remove allowed SetToken to initialize this module. Only callable by governance.
     *
     * @param _setToken             Instance of the SetToken
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * GOVERNANCE ONLY: Toggle whether any SetToken is allowed to initialize this module. Only callable by governance.
     *
     * @param _anySetAllowed             Bool indicating whether allowedSetTokens is enabled
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * GOVERNANCE ONLY: Add Compound market to module with stored underlying to cToken mapping in case of market additions to Compound.
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _cToken                   Address of cToken to add
     * @param _underlying               Address of underlying token that maps to cToken
     */
    function addCompoundMarket(ICErc20 _cToken, IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) == address(0), "Already added");
        underlyingToCToken[_underlying] = _cToken;
    }

    /**
     * GOVERNANCE ONLY: Remove Compound market on stored underlying to cToken mapping in case of market removals
     *
     * IMPORTANT: Validations are skipped in order to get contract under bytecode limit
     *
     * @param _underlying               Address of underlying token to remove
     */
    function removeCompoundMarket(IERC20 _underlying) external onlyOwner {
        require(address(underlyingToCToken[_underlying]) != address(0), "Not added");
        delete underlyingToCToken[_underlying];
    }

    /**
     * MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, false);
    }

    /**
     * MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed balance after interest accrual.
     * Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external onlyModule(_setToken) {
        sync(_setToken, true);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for module to return debt to issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);

        _borrow(_setToken, underlyingToCToken[_component], notionalDebt);
    }

    /**
     * MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after issuance module transfers debt from issuer. Only callable by valid module.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool /* _isEquity */) external onlyModule(_setToken) {
        int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

        require(componentDebt < 0, "Component must be negative");

        uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);

        _repayBorrow(_setToken, underlyingToCToken[_component], _component, notionalDebt);
    }


    /* ============ External Getter Functions ============ */

    /**
     * Get enabled assets for SetToken. Returns an array of enabled cTokens that are collateral assets and an
     * array of underlying that are borrow assets.
     *
     * @return                    Collateral cToken assets that are enabled
     * @return                    Underlying borrowed assets that are enabled.
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralCTokens,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * Mints the specified cToken from the underlying of the specified notional quantity. If cEther, the WETH must be
     * unwrapped as it only accepts the underlying ETH.
     */
    function _mintCToken(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _mintNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _mintNotional);

            _setToken.invokeMintCEther(_cToken, _mintNotional);
        } else {
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _mintNotional);

            _setToken.invokeMintCToken(_cToken, _mintNotional);
        }
    }

    /**
     * Invoke redeem from SetToken. If cEther, then also wrap ETH into WETH.
     */
    function _redeemUnderlying(ISetToken _setToken, ICErc20 _cToken, uint256 _redeemNotional) internal {
        _setToken.invokeRedeemUnderlying(_cToken, _redeemNotional);

        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _redeemNotional);
        }
    }

    /**
     * Invoke repay from SetToken. If cEther then unwrap WETH into ETH.
     */
    function _repayBorrow(ISetToken _setToken, ICErc20 _cToken, IERC20 _underlyingToken, uint256 _repayNotional) internal {
        if (_cToken == cEther) {
            _setToken.invokeUnwrapWETH(address(weth), _repayNotional);

            _setToken.invokeRepayBorrowCEther(_cToken, _repayNotional);
        } else {
            // Approve to cToken
            _setToken.invokeApprove(address(_underlyingToken), address(_cToken), _repayNotional);
            _setToken.invokeRepayBorrowCToken(_cToken, _repayNotional);
        }
    }

    /**
     * Invoke the SetToken to interact with the specified cToken to borrow the cToken's underlying of the specified borrowQuantity.
     */
    function _borrow(ISetToken _setToken, ICErc20 _cToken, uint256 _notionalBorrowQuantity) internal {
        _setToken.invokeBorrow(_cToken, _notionalBorrowQuantity);
        if (_cToken == cEther) {
            _setToken.invokeWrapWETH(address(weth), _notionalBorrowQuantity);
        }
    }

    /**
     * Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     *
     * @return receiveTokenQuantity The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
         ISetToken setToken = _actionInfo.setToken;
         uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

         setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * Calculates protocol fee on module and pays protocol fee from SetToken
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * Updates the collateral (cToken held) and borrow position (underlying owed on Compound)
     */
    function _updateLeverPositions(ActionInfo memory actionInfo, IERC20 _borrowAsset) internal {
        _updateCollateralPosition(
            actionInfo.setToken,
            actionInfo.collateralCTokenAsset,
            _getCollateralPosition(
                actionInfo.setToken,
                actionInfo.collateralCTokenAsset,
                actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                actionInfo.setToken,
                actionInfo.borrowCTokenAsset,
                actionInfo.setTotalSupply,
                false // Do not accrue interest
            )
        );
    }

    function _updateCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_cToken), _newPositionUnit);
    }

    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingToken, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingToken), address(this), _newPositionUnit, "");
    }

    /**
     * Construct the ActionInfo struct for lever and delever
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever
        );
    }

    /**
     * Construct the ActionInfo struct for lever and delever accepting notional units
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            setToken: _setToken,
            collateralCTokenAsset: _isLever ? underlyingToCToken[_receiveToken] : underlyingToCToken[_sendToken],
            borrowCTokenAsset: _isLever ? underlyingToCToken[_sendToken] : underlyingToCToken[_receiveToken],
            setTotalSupply: totalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }



    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralCTokenEnabled[_actionInfo.setToken][_actionInfo.collateralCTokenAsset], "Collateral not enabled");
        require(borrowCTokenEnabled[_actionInfo.setToken][_actionInfo.borrowCTokenAsset], "Borrow not enabled");
        require(_actionInfo.collateralCTokenAsset != _actionInfo.borrowCTokenAsset, "Must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    function _getCollateralPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _cToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * Get borrow position. If should accrue interest is true, then accrue interest on Compound and use current borrow balance, else use the stored value to save gas.
     * Use the current value for debt redemption, when we need to calculate the exact units of debt that needs to be repaid.
     */
    function _getBorrowPosition(ISetToken _setToken, ICErc20 _cToken, uint256 _setTotalSupply, bool _shouldAccrueInterest) internal returns (int256) {
        uint256 borrowNotionalBalance = _shouldAccrueInterest ? _cToken.borrowBalanceCurrent(address(_setToken)) : _cToken.borrowBalanceStored(address(_setToken));
        // Round negative away from 0
        int256 borrowPositionUnit = borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);

        return borrowPositionUnit;
    }
}".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

