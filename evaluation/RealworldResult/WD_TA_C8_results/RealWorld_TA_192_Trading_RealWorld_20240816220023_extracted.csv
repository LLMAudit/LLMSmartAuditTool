Integer Overflow/Underflow Identified,Reentrancy Identified,Unchecked External Calls Identified,Unchecked Low-level Calls Identified,Transactions Order Dependence Identified,Timestamp Manipulation Identified,Predictable Randomness Identified,Unsafe `tx.origin` Identified,Unsafe Suicide Identified,Gas Limit Identified,Price Manipulation Identified,Assumption of Fixed-Length Array Identified,Lack of Withdrawal Function Identified,Lack of Authorization Identified,Potential Data Inconsistency Identified,Hash Collision Identified,Uninitialized Return Variable Identified,Misdeclared Constructor Identified,Missing 'onlyOwner' Modifier Identified,Misuse of `msg.value` within a Loop Identified,Precision Loss Identified,Redundant Conditional Check Identified,External Oracle Dependency Identified,Ownership Hijacking Identified,Centralization Risk Identified,Incorrect Funding Rate Calculation Identified,Flash Loan Fee Manipulation Identified,Misuse of Mapping Getter Identified,Lack of Getter Function Implementation Identified,Unnecessary Comparison Identified,Inconsistent Initialization Identified,Potential Inconsistency in Yield Source Swapping Identified,Incorrect Signer Verification Identified,Order of Inheritance Initialization Identified,Impracticality of Exact Match Identified,Inconsistent Base Tokens Identified,Handling Partial Withdrawals Identified,Fallback Function Identified,Unlimited Token Approval Identified,Lack of Input Validation Identified,DoS Vulnerability Identified
"<INFO> Integer Overflow/Underflow Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Reentrancy Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unchecked External Calls Identified."".
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unchecked Low-level Calls Identified."".
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Transactions Order Dependence Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades
'''
```
If you don't find any Transactions Order Dependence vulnerabilities, respond only with: ""","<INFO> Timestamp Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Predictable Randomness Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unsafe `tx.origin` Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unsafe Suicide Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Lack of Restriction on `selfdestruct` is found, respond only with: ""","<INFO> Gas Limit Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Price Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Assumption of Fixed-Length Array Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Withdrawal Function Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If a secure withdrawal function is found and no issues are identified, respond only with: ""","<INFO> Lack of Authorization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Lack of Authorization vulnerabilities are found, respond only with: ""","<INFO> Potential Data Inconsistency Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Potential Data Inconsistency vulnerabilities are found, respond only with: ""","<INFO> Hash Collision Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Hash Collision vulnerabilities are found, respond only with: ""","<INFO> Uninitialized Return Variable Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Uninitialized Return Variable vulnerabilities are found, respond only with: ""","<INFO> Misdeclared Constructor Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Misdeclared Constructor vulnerabilities are found, respond only with: ""","<INFO> Missing 'onlyOwner' Modifier Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Misuse of `msg.value` within a Loop Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Precision Loss Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Redundant Conditional Check Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> External Oracle Dependency Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: """,,"<INFO> Centralization Risk Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Incorrect Funding Rate Calculation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Flash Loan Fee Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Misuse of Mapping Getter Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Getter Function Implementation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unnecessary Comparison Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Inconsistent Initialization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Potential Inconsistency in Yield Source Swapping Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Incorrect Signer Verification Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Order of Inheritance Initialization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Impracticality of Exact Match Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Inconsistent Base Tokens Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Handling Partial Withdrawals Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Fallback Function Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unlimited Token Approval Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Input Validation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> DoS Vulnerability Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades.
'''
```
If you don't find any vulnerabilities, respond only with: """
,,,"<INFO> Unchecked Low-level Calls Identified.

```
UNCHECKED LOW-LEVEL CALL
'''
In the function `_handleDeposit`, the contract performs a low-level call to `IERC20(_marginAsset).transferFrom(...)` without checking if the call was successful. If the transfer fails (for example, due to insufficient balance or allowance), the contract will continue executing without reverting, potentially leading to unexpected states or loss of funds.

Recommended Mitigation/Fix:
Add a require statement to check the success of the transfer operation:
```solidity
bool success = IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);
require(success, ""Transfer failed"");
```
'''
```

```
UNCHECKED LOW-LEVEL CALL
'''
In the function `_handleWithdraw`, the contract calls `IStableVault(_stableVault).withdraw(...)` without checking if the withdrawal was successful. If the withdrawal fails, the contract will not revert, which could lead to inconsistencies in the state of the contract and potential loss of funds.

Recommended Mitigation/Fix:
Add a require statement to check the success of the withdrawal operation:
```solidity
bool success = IStableVault(_stableVault).withdraw(_outputToken, _toMint);
require(success, ""Withdrawal failed"");
```
'''
```

```
UNCHECKED LOW-LEVEL CALL
'''
In the function `_handleOpenFees`, the contract calls `IStable(_tigAsset).mintFor(...)` without checking if the minting operation was successful. If the minting fails, the contract will not revert, which could lead to incorrect fee distributions and loss of funds.

Recommended Mitigation/Fix:
Add a require statement to check the success of the minting operation:
```solidity
bool success = IStable(_tigAsset).mintFor(_referrer, _positionSize * _fees.referralFees / DIVISION_CONSTANT);
require(success, ""Minting failed"");
```
'''
```

```
UNCHECKED LOW-LEVEL CALL
'''
In the function `_handleCloseFees`, the contract calls `IStable(_tigAsset).mintFor(...)` without checking if the minting operation was successful. If the minting fails, the contract will not revert, which could lead to incorrect fee distributions and loss of funds.

Recommended Mitigation/Fix:
Add a require statement to check the success of the minting operation:
```solidity
bool success = IStable(_tigAsset).mintFor(_referrer, _referralFeesPaid);
require(success, ""Minting failed"");
```
'''
```

```
UNCHECKED LOW-LEVEL CALL
'''
In the function `approveProxy`, the contract transfers Ether to the proxy address using `payable(_proxy).transfer(msg.value);` without checking if the transfer was successful. If the transfer fails, the contract will not revert, which could lead to unexpected states.

Recommended Mitigation/Fix:
Use the `call` method instead of `transfer` and check for success:
```solidity
(bool success, ) = _proxy.call{value: msg.value}("""");
require(success, ""Transfer to proxy failed"");
```
'''
```

[2024-16-08 22:00:54 INFO] **[Seminar Conclusion]**:

 ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,"<INFO> Unchecked Low-level Calls Identified.

```
UNCHECKED LOW-LEVEL CALL
'''
In the function `_handleDeposit`, the contract performs a low-level call to `IERC20(_marginAsset).transferFrom(...)` without checking if the call was successful. If the transfer fails (for example, due to insufficient balance or allowance), the contract will continue executing without reverting, potentially leading to unexpected states or loss of funds.

Recommended Mitigation/Fix:
Add a require statement to check the success of the transfer operation:
```solidity
bool success = IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);
require(success, ""Transfer failed"");
```
'''
```

```
UNCHECKED LOW-LEVEL CALL
'''
In the function `_handleWithdraw`, the contract calls `IStableVault(_stableVault).withdraw(...)` without checking if the withdrawal was successful. If the withdrawal fails, the contract will not revert, which could lead to inconsistencies in the state of the contract and potential loss of funds.

Recommended Mitigation/Fix:
Add a require statement to check the success of the withdrawal operation:
```solidity
bool success = IStableVault(_stableVault).withdraw(_outputToken, _toMint);
require(success, ""Withdrawal failed"");
```
'''
```

```
UNCHECKED LOW-LEVEL CALL
'''
In the function `_handleOpenFees`, the contract calls `IStable(_tigAsset).mintFor(...)` without checking if the minting operation was successful. If the minting fails, the contract will not revert, which could lead to incorrect fee distributions and loss of funds.

Recommended Mitigation/Fix:
Add a require statement to check the success of the minting operation:
```solidity
bool success = IStable(_tigAsset).mintFor(_referrer, _positionSize * _fees.referralFees / DIVISION_CONSTANT);
require(success, ""Minting failed"");
```
'''
```

```
UNCHECKED LOW-LEVEL CALL
'''
In the function `_handleCloseFees`, the contract calls `IStable(_tigAsset).mintFor(...)` without checking if the minting operation was successful. If the minting fails, the contract will not revert, which could lead to incorrect fee distributions and loss of funds.

Recommended Mitigation/Fix:
Add a require statement to check the success of the minting operation:
```solidity
bool success = IStable(_tigAsset).mintFor(_referrer, _referralFeesPaid);
require(success, ""Minting failed"");
```
'''
```

```
UNCHECKED LOW-LEVEL CALL
'''
In the function `approveProxy`, the contract transfers Ether to the proxy address using `payable(_proxy).transfer(msg.value);` without checking if the transfer was successful. If the transfer fails, the contract will not revert, which could lead to unexpected states.

Recommended Mitigation/Fix:
Use the `call` method instead of `transfer` and check for success:
```solidity
(bool success, ) = _proxy.call{value: msg.value}("""");
require(success, ""Transfer to proxy failed"");
```
'''
```

[2024-16-08 22:00:54 INFO] **[Execute Detail]**

execute SimplePhase:[TODDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-16-08 22:00:55 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | //SPDX-License-Identifier: Unlicense pragma solidity ^0.8.0; import ""./utils/MetaContext.sol""; import ""./interfaces/ITrading.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""./interfaces/IPairsContract.sol""; import ""./interfaces/IReferrals.sol""; import ""./interfaces/IPosition.sol""; import ""./interfaces/IGovNFT.sol""; import ""./interfaces/IStableVault.sol""; import ""./utils/TradingLibrary.sol""; interface ITradingExtension {     function getVerifiedPrice(         uint _asset,         PriceData calldata _priceData,         bytes calldata _signature,         uint _withSpreadIsLong     ) external returns(uint256 _price, uint256 _spread);     function getRef(         address _trader     ) external pure returns(address);     function _setReferral(         bytes32 _referral,         address _trader     ) external;     function validateTrade(uint _asset, address _tigAsset, uint _margin, uint _leverage) external view;     function isPaused() external view returns(bool);     function minPos(address) external view returns(uint);     function modifyLongOi(         uint _asset,         address _tigAsset,         bool _onOpen,         uint _size     ) external;     function modifyShortOi(         uint _asset,         address _tigAsset,         bool _onOpen,         uint _size     ) external;     function paused() external returns(bool);     function _limitClose(         uint _id,         bool _tp,         PriceData calldata _priceData,         bytes calldata _signature     ) external returns(uint _limitPrice, address _tigAsset);     function _checkGas() external view;     function _closePosition(         uint _id,         uint _price,         uint _percent     ) external returns (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout); } interface IStable is IERC20 {     function burnFrom(address account, uint amount) external;     function mintFor(address account, uint amount) external; } interface ExtendedIERC20 is IERC20 {     function decimals() external view returns (uint); } interface ERC20Permit is IERC20 {     function permit(         address owner,         address spender,         uint256 value,         uint256 deadline,         uint8 v,         bytes32 r,         bytes32 s     ) external; } contract Trading is MetaContext, ITrading { error LimitNotSet(); //7 error NotLiquidatable(); error TradingPaused(); error BadDeposit(); error BadWithdraw(); error ValueNotEqualToMargin(); error BadLeverage(); error NotMargin(); error NotAllowedPair(); error BelowMinPositionSize(); error BadClosePercent(); error NoPrice(); error LiqThreshold();  uint constant private DIVISION_CONSTANT = 1e10; // 100% uint private constant liqPercent = 9e9; // 90%  struct Fees {     uint daoFees;     uint burnFees;     uint referralFees;     uint botFees; } Fees public openFees = Fees(     0,     0,     0,     0 ); Fees public closeFees = Fees(     0,     0,     0,     0 ); uint public limitOrderPriceRange = 1e8; // 1%  uint public maxWinPercent; uint public vaultFundingPercent;  IPairsContract private pairsContract; IPosition private position; IGovNFT private gov; ITradingExtension private tradingExtension;  struct Delay {     uint delay; // Block number where delay ends     bool actionType; // True for open, False for close } mapping(uint =&gt; Delay) public blockDelayPassed; // id =&gt; Delay uint public blockDelay; mapping(uint =&gt; uint) public limitDelay; // id =&gt; block.timestamp  mapping(address =&gt; bool) public allowedVault;  struct Proxy {     address proxy;     uint256 time; }  mapping(address =&gt; Proxy) public proxyApprovals;  constructor(     address _position,     address _gov,     address _pairsContract ) {     position = IPosition(_position);     gov = IGovNFT(_gov);     pairsContract = IPairsContract(_pairsContract); }  // ===== END-USER FUNCTIONS =====  /**  * @param _tradeInfo Trade info  * @param _priceData verifiable off-chain price data  * @param _signature node signature  * @param _permitData data and signature needed for token approval  * @param _trader address the trade is initiated for  */ function initiateMarketOrder(     TradeInfo calldata _tradeInfo,     PriceData calldata _priceData,     bytes calldata _signature,     ERC20PermitData calldata _permitData,     address _trader )     external {     _validateProxy(_trader);     _checkDelay(position.getCount(), true);     _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);     address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();     tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);     tradingExtension._setReferral(_tradeInfo.referral, _trader);     uint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false);     uint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;     _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);     uint256 _isLong = _tradeInfo.direction ? 1 : 2;     (uint256 _price,) = tradingExtension.getVerifiedPrice(_tradeInfo.asset, _priceData, _signature, _isLong);     IPosition.MintTrade memory _mintTrade = IPosition.MintTrade(         _trader,         _marginAfterFees,         _tradeInfo.leverage,         _tradeInfo.asset,         _tradeInfo.direction,         _price,         _tradeInfo.tpPrice,         _tradeInfo.slPrice,         0,         _tigAsset     );     _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);     unchecked {         if (_tradeInfo.direction) {             tradingExtension.modifyLongOi(_tradeInfo.asset, _tigAsset, true, _positionSize);         } else {             tradingExtension.modifyShortOi(_tradeInfo.asset, _tigAsset, true, _positionSize);         }     }     _updateFunding(_tradeInfo.asset, _tigAsset);     position.mint(         _mintTrade     );     unchecked {         emit PositionOpened(_tradeInfo, 0, _price, position.getCount()-1, _trader, _marginAfterFees);     }    }  /**  * @dev initiate closing position  * @param _id id of the position NFT  * @param _percent percent of the position being closed in BP  * @param _priceData verifiable off-chain price data  * @param _signature node signature  * @param _stableVault StableVault address  * @param _outputToken Token received upon closing trade  * @param _trader address the trade is initiated for  */ function initiateCloseOrder(     uint _id,     uint _percent,     PriceData calldata _priceData,     bytes calldata _signature,     address _stableVault,     address _outputToken,     address _trader )     external {     _validateProxy(_trader);     _checkDelay(_id, false);     _checkOwner(_id, _trader);     _checkVault(_stableVault, _outputToken);     IPosition.Trade memory _trade = position.trades(_id);     if (_trade.orderType != 0) revert(""4""); //IsLimit             (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);      if (_percent &gt; DIVISION_CONSTANT || _percent == 0) revert BadClosePercent();     _closePosition(_id, _percent, _price, _stableVault, _outputToken, false);  }  /**  * @param _id position id  * @param _addMargin margin amount used to add to the position  * @param _priceData verifiable off-chain price data  * @param _signature node signature  * @param _stableVault StableVault address  * @param _marginAsset Token being used to add to the position  * @param _permitData data and signature needed for token approval  * @param _trader address the trade is initiated for  */ function addToPosition(     uint _id,     uint _addMargin,     PriceData calldata _priceData,     bytes calldata _signature,     address _stableVault,     address _marginAsset,     ERC20PermitData calldata _permitData,     address _trader )     external {     _validateProxy(_trader);     _checkOwner(_id, _trader);     _checkDelay(_id, true);     IPosition.Trade memory _trade = position.trades(_id);     tradingExtension.validateTrade(_trade.asset, _trade.tigAsset, _trade.margin + _addMargin, _trade.leverage);     _checkVault(_stableVault, _marginAsset);     if (_trade.orderType != 0) revert(""4""); //IsLimit     uint _fee = _handleOpenFees(_trade.asset, _addMargin*_trade.leverage/1e18, _trader, _trade.tigAsset, false);     _handleDeposit(         _trade.tigAsset,         _marginAsset,         _addMargin - _fee,         _stableVault,         _permitData,         _trader     );     position.setAccInterest(_id);     unchecked {         (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, _trade.direction ? 1 : 2);         uint _positionSize = (_addMargin - _fee) * _trade.leverage / 1e18;         if (_trade.direction) {             tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, true, _positionSize);         } else {             tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, true, _positionSize);              }         _updateFunding(_trade.asset, _trade.tigAsset);         _addMargin -= _fee;         uint _newMargin = _trade.margin + _addMargin;         uint _newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin;          position.addToPosition(             _trade.id,             _newMargin,             _newPrice         );          emit AddToPosition(_trade.id, _newMargin, _newPrice, _trade.trader);     } }  /**  * @param _tradeInfo Trade info  * @param _orderType type of limit order used to open the position  * @param _price limit price  * @param _permitData data and signature needed for token approval  * @param _trader address the trade is initiated for  */ function initiateLimitOrder(     TradeInfo calldata _tradeInfo,     uint256 _orderType, // 1 limit, 2 stop     uint256 _price,     ERC20PermitData calldata _permitData,     address _trader )     external {     _validateProxy(_trader);     address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();     tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);     _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);     if (_orderType == 0) revert(""5"");     if (_price == 0) revert NoPrice();     tradingExtension._setReferral(_tradeInfo.referral, _trader);     _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);     _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);     uint256 _id = position.getCount();     position.mint(         IPosition.MintTrade(             _trader,             _tradeInfo.margin,             _tradeInfo.leverage,             _tradeInfo.asset,             _tradeInfo.direction,             _price,             _tradeInfo.tpPrice,             _tradeInfo.slPrice,             _orderType,             _tigAsset         )     );     limitDelay[_id] = block.timestamp + 4;     emit PositionOpened(_tradeInfo, _orderType, _price, _id, _trader, _tradeInfo.margin); }  /**  * @param _id position ID  * @param _trader address the trade is initiated for  */ function cancelLimitOrder(     uint256 _id,     address _trader )     external {     _validateProxy(_trader);     _checkOwner(_id, _trader);     IPosition.Trade memory _trade = position.trades(_id);     if (_trade.orderType == 0) revert();     IStable(_trade.tigAsset).mintFor(_trader, _trade.margin);     position.burn(_id);     emit LimitCancelled(_id, _trader); }  /**  * @param _id position id  * @param _marginAsset Token being used to add to the position  * @param _stableVault StableVault address  * @param _addMargin margin amount being added to the position  * @param _permitData data and signature needed for token approval  * @param _trader address the trade is initiated for  */ function addMargin(     uint256 _id,     address _marginAsset,     address _stableVault,     uint256 _addMargin,     ERC20PermitData calldata _permitData,     address _trader )     external {     _validateProxy(_trader);     _checkOwner(_id, _trader);     _checkVault(_stableVault, _marginAsset);     IPosition.Trade memory _trade = position.trades(_id);     if (_trade.orderType != 0) revert(); //IsLimit     IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);     _handleDeposit(_trade.tigAsset, _marginAsset, _addMargin, _stableVault, _permitData, _trader);     unchecked {         uint256 _newMargin = _trade.margin + _addMargin;         uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;         if (_newLeverage &lt; asset.minLeverage) revert(""!lev"");         position.modifyMargin(_id, _newMargin, _newLeverage);         emit MarginModified(_id, _newMargin, _newLeverage, true, _trader);     } }  /**  * @param _id position id  * @param _stableVault StableVault address  * @param _outputToken token the trader will receive  * @param _removeMargin margin amount being removed from the position  * @param _priceData verifiable off-chain price data  * @param _signature node signature  * @param _trader address the trade is initiated for  */ function removeMargin(     uint256 _id,     address _stableVault,     address _outputToken,     uint256 _removeMargin,     PriceData calldata _priceData,     bytes calldata _signature,     address _trader )     external {     _validateProxy(_trader);     _checkOwner(_id, _trader);     _checkVault(_stableVault, _outputToken);     IPosition.Trade memory _trade = position.trades(_id);     if (_trade.orderType != 0) revert(); //IsLimit     IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);     uint256 _newMargin = _trade.margin - _removeMargin;     uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;     if (_newLeverage &gt; asset.maxLeverage) revert(""!lev"");     (uint _assetPrice,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);     (,int256 _payout) = TradingLibrary.pnl(_trade.direction, _assetPrice, _trade.price, _newMargin, _newLeverage, _trade.accInterest);     unchecked {         if (_payout &lt;= int256(_newMargin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert LiqThreshold();     }     position.modifyMargin(_trade.id, _newMargin, _newLeverage);     _handleWithdraw(_trade, _stableVault, _outputToken, _removeMargin);     emit MarginModified(_trade.id, _newMargin, _newLeverage, false, _trader); }  /**  * @param _type true for TP, false for SL  * @param _id position id  * @param _limitPrice TP/SL trigger price  * @param _priceData verifiable off-chain price data  * @param _signature node signature  * @param _trader address the trade is initiated for  */ function updateTpSl(     bool _type,     uint _id,     uint _limitPrice,     PriceData calldata _priceData,     bytes calldata _signature,     address _trader )     external {     _validateProxy(_trader);     _checkOwner(_id, _trader);     IPosition.Trade memory _trade = position.trades(_id);     if (_trade.orderType != 0) revert(""4""); //IsLimit     if (_type) {         position.modifyTp(_id, _limitPrice);     } else {         (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);         _checkSl(_limitPrice, _trade.direction, _price);         position.modifySl(_id, _limitPrice);     }     emit UpdateTPSL(_id, _type, _limitPrice, _trader); }  /**  * @param _id position id  * @param _priceData verifiable off-chain price data  * @param _signature node signature  */ function executeLimitOrder(     uint _id,      PriceData calldata _priceData,     bytes calldata _signature )      external {     unchecked {         _checkDelay(_id, true);         tradingExtension._checkGas();         if (tradingExtension.paused()) revert TradingPaused();         require(block.timestamp &gt;= limitDelay[_id]);         IPosition.Trade memory trade = position.trades(_id);         uint _fee = _handleOpenFees(trade.asset, trade.margin*trade.leverage/1e18, trade.trader, trade.tigAsset, true);         (uint256 _price, uint256 _spread) = tradingExtension.getVerifiedPrice(trade.asset, _priceData, _signature, 0);         if (trade.orderType == 0) revert(""5"");         if (_price &gt; trade.price+trade.price*limitOrderPriceRange/DIVISION_CONSTANT || _price &lt; trade.price-trade.price*limitOrderPriceRange/DIVISION_CONSTANT) revert(""6""); //LimitNotMet         if (trade.direction &amp;&amp; trade.orderType == 1) {             if (trade.price &lt; _price) revert(""6""); //LimitNotMet         } else if (!trade.direction &amp;&amp; trade.orderType == 1) {             if (trade.price &gt; _price) revert(""6""); //LimitNotMet         } else if (!trade.direction &amp;&amp; trade.orderType == 2) {             if (trade.price &lt; _price) revert(""6""); //LimitNotMet             trade.price = _price;         } else {             if (trade.price &gt; _price) revert(""6""); //LimitNotMet             trade.price = _price;         }          if(trade.direction) {             trade.price += trade.price * _spread / DIVISION_CONSTANT;         } else {             trade.price -= trade.price * _spread / DIVISION_CONSTANT;         }         if (trade.direction) {             tradingExtension.modifyLongOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);         } else {             tradingExtension.modifyShortOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);         }         _updateFunding(trade.asset, trade.tigAsset);         position.executeLimitOrder(_id, trade.price, trade.margin - _fee);         emit LimitOrderExecuted(trade.asset, trade.direction, trade.price, trade.leverage, trade.margin - _fee, _id, trade.trader, _msgSender());     } }  /**  * @notice liquidate position  * @param _id id of the position NFT  * @param _priceData verifiable off-chain data  * @param _signature node signature  */ function liquidatePosition(     uint _id,     PriceData calldata _priceData,     bytes calldata _signature )     external {     unchecked {         tradingExtension._checkGas();         IPosition.Trade memory _trade = position.trades(_id);         if (_trade.orderType != 0) revert(""4""); //IsLimit          (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);         (uint256 _positionSizeAfterPrice, int256 _payout) = TradingLibrary.pnl(_trade.direction, _price, _trade.price, _trade.margin, _trade.leverage, _trade.accInterest);         uint256 _positionSize = _trade.margin*_trade.leverage/1e18;         if (_payout &gt; int256(_trade.margin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert NotLiquidatable();         if (_trade.direction) {             tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, false, _positionSize);         } else {             tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, false, _positionSize);         }         _updateFunding(_trade.asset, _trade.tigAsset);         _handleCloseFees(_trade.asset, type(uint).max, _trade.tigAsset, _positionSizeAfterPrice, _trade.trader, true);         position.burn(_id);         emit PositionLiquidated(_id, _trade.trader, _msgSender());     } }  /**  * @dev close position at a pre-set price  * @param _id id of the position NFT  * @param _tp true if take profit  * @param _priceData verifiable off-chain price data  * @param _signature node signature  */ function limitClose(     uint _id,     bool _tp,     PriceData calldata _priceData,     bytes calldata _signature )     external {     _checkDelay(_id, false);     (uint _limitPrice, address _tigAsset) = tradingExtension._limitClose(_id, _tp, _priceData, _signature);     _closePosition(_id, DIVISION_CONSTANT, _limitPrice, address(0), _tigAsset, true); }  /**  * @notice Trader can approve a proxy wallet address for it to trade on its behalf. Can also provide proxy wallet with gas.  * @param _proxy proxy wallet address  * @param _timestamp end timestamp of approval period  */ function approveProxy(address _proxy, uint256 _timestamp) external payable {     proxyApprovals[_msgSender()] = Proxy(         _proxy,         _timestamp     );     payable(_proxy).transfer(msg.value); }  // ===== INTERNAL FUNCTIONS =====  /**  * @dev close the initiated position.  * @param _id id of the position NFT  * @param _percent percent of the position being closed  * @param _price pair price  * @param _stableVault StableVault address  * @param _outputToken Token that trader will receive  * @param _isBot false if closed via market order  */ function _closePosition(     uint _id,     uint _percent,     uint _price,     address _stableVault,     address _outputToken,     bool _isBot )     internal {     (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout) = tradingExtension._closePosition(_id, _price, _percent);     position.setAccInterest(_id);     _updateFunding(_trade.asset, _trade.tigAsset);     if (_percent &lt; DIVISION_CONSTANT) {         if ((_trade.margin*_trade.leverage*(DIVISION_CONSTANT-_percent)/DIVISION_CONSTANT)/1e18 &lt; tradingExtension.minPos(_trade.tigAsset)) revert(""!size"");         position.reducePosition(_id, _percent);     } else {         position.burn(_id);     }     uint256 _toMint;     if (_payout &gt; 0) {         unchecked {             _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);             if (maxWinPercent &gt; 0 &amp;&amp; _toMint &gt; _trade.margin*maxWinPercent/DIVISION_CONSTANT) {                 _toMint = _trade.margin*maxWinPercent/DIVISION_CONSTANT;             }         }         _handleWithdraw(_trade, _stableVault, _outputToken, _toMint);     }     emit PositionClosed(_id, _price, _percent, _toMint, _trade.trader, _isBot ? _msgSender() : _trade.trader); }  /**  * @dev handle stablevault deposits for different trading functions  * @param _tigAsset tigAsset token address  * @param _marginAsset token being deposited into stablevault  * @param _margin amount being deposited  * @param _stableVault StableVault address  * @param _permitData Data for approval via permit  * @param _trader Trader address to take tokens from  */ function _handleDeposit(address _tigAsset, address _marginAsset, uint256 _margin, address _stableVault, ERC20PermitData calldata _permitData, address _trader) internal {     IStable tigAsset = IStable(_tigAsset);     if (_tigAsset != _marginAsset) {         if (_permitData.usePermit) {             ERC20Permit(_marginAsset).permit(_trader, address(this), _permitData.amount, _permitData.deadline, _permitData.v, _permitData.r, _permitData.s);         }         uint256 _balBefore = tigAsset.balanceOf(address(this));         uint _marginDecMultiplier = 10**(18-ExtendedIERC20(_marginAsset).decimals());         IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);         IERC20(_marginAsset).approve(_stableVault, type(uint).max);         IStableVault(_stableVault).deposit(_marginAsset, _margin/_marginDecMultiplier);         if (tigAsset.balanceOf(address(this)) != _balBefore + _margin) revert BadDeposit();         tigAsset.burnFrom(address(this), tigAsset.balanceOf(address(this)));     } else {         tigAsset.burnFrom(_trader, _margin);     }         }  /**  * @dev handle stablevault withdrawals for different trading functions  * @param _trade Position info  * @param _stableVault StableVault address  * @param _outputToken Output token address  * @param _toMint Amount of tigAsset minted to be used for withdrawal  */ function _handleWithdraw(IPosition.Trade memory _trade, address _stableVault, address _outputToken, uint _toMint) internal {     IStable(_trade.tigAsset).mintFor(address(this), _toMint);     if (_outputToken == _trade.tigAsset) {         IERC20(_outputToken).transfer(_trade.trader, _toMint);     } else {         uint256 _balBefore = IERC20(_outputToken).balanceOf(address(this));         IStableVault(_stableVault).withdraw(_outputToken, _toMint);         if (IERC20(_outputToken).balanceOf(address(this)) != _balBefore + _toMint/(10**(18-ExtendedIERC20(_outputToken).decimals()))) revert BadWithdraw();         IERC20(_outputToken).transfer(_trade.trader, IERC20(_outputToken).balanceOf(address(this)) - _balBefore);     }         }  /**  * @dev handle fees distribution for opening  * @param _asset asset id  * @param _positionSize position size  * @param _trader trader address  * @param _tigAsset tigAsset address  * @param _isBot false if opened via market order  * @return _feePaid total fees paid during opening  */ function _handleOpenFees(     uint _asset,     uint _positionSize,     address _trader,     address _tigAsset,     bool _isBot )     internal     returns (uint _feePaid) {     IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);     Fees memory _fees = openFees;     unchecked {         _fees.daoFees = _fees.daoFees * asset.feeMultiplier / DIVISION_CONSTANT;         _fees.burnFees = _fees.burnFees * asset.feeMultiplier / DIVISION_CONSTANT;         _fees.referralFees = _fees.referralFees * asset.feeMultiplier / DIVISION_CONSTANT;         _fees.botFees = _fees.botFees * asset.feeMultiplier / DIVISION_CONSTANT;     }     address _referrer = tradingExtension.getRef(_trader); //referrals.getReferral(referrals.getReferred(_trader));     if (_referrer != address(0)) {         unchecked {             IStable(_tigAsset).mintFor(                 _referrer,                 _positionSize                 * _fees.referralFees // get referral fee%                 / DIVISION_CONSTANT // divide by 100%             );         }         _fees.daoFees = _fees.daoFees - _fees.referralFees*2;     }     if (_isBot) {         unchecked {             IStable(_tigAsset).mintFor(                 _msgSender(),                 _positionSize                 * _fees.botFees // get bot fee%                 / DIVISION_CONSTANT // divide by 100%             );         }         _fees.daoFees = _fees.daoFees - _fees.botFees;     } else {         _fees.botFees = 0;     }     unchecked {         uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT;         _feePaid =             _positionSize             * (_fees.burnFees + _fees.botFees) // get total fee%             / DIVISION_CONSTANT // divide by 100%             + _daoFeesPaid;         emit FeesDistributed(             _tigAsset,             _daoFeesPaid,             _positionSize * _fees.burnFees / DIVISION_CONSTANT,             _referrer != address(0) ? _positionSize * _fees.referralFees / DIVISION_CONSTANT : 0,             _positionSize * _fees.botFees / DIVISION_CONSTANT,             _referrer         );         IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);     }     gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this))); }  /**  * @dev handle fees distribution for closing  * @param _asset asset id  * @param _payout payout to trader before fees  * @param _tigAsset margin asset  * @param _positionSize position size  * @param _trader trader address  * @param _isBot false if closed via market order  * @return payout_ payout to trader after fees  */ function _handleCloseFees(     uint _asset,     uint _payout,     address _tigAsset,     uint _positionSize,     address _trader,     bool _isBot )     internal     returns (uint payout_) {     IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);     Fees memory _fees = closeFees;     uint _daoFeesPaid;     uint _burnFeesPaid;     uint _referralFeesPaid;     unchecked {         _daoFeesPaid = (_positionSize*_fees.daoFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;         _burnFeesPaid = (_positionSize*_fees.burnFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;     }     uint _botFeesPaid;     address _referrer = tradingExtension.getRef(_trader);//referrals.getReferral(referrals.getReferred(_trader));     if (_referrer != address(0)) {         unchecked {             _referralFeesPaid = (_positionSize*_fees.referralFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;         }         IStable(_tigAsset).mintFor(             _referrer,             _referralFeesPaid         );          _daoFeesPaid = _daoFeesPaid-_referralFeesPaid*2;     }     if (_isBot) {         unchecked {             _botFeesPaid = (_positionSize*_fees.botFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;             IStable(_tigAsset).mintFor(                 _msgSender(),                 _botFeesPaid             );         }         _daoFeesPaid = _daoFeesPaid - _botFeesPaid;     }     emit FeesDistributed(_tigAsset, _daoFeesPaid, _burnFeesPaid, _referralFeesPaid, _botFeesPaid, _referrer);     payout_ = _payout - _daoFeesPaid - _burnFeesPaid - _botFeesPaid;     IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);     IStable(_tigAsset).approve(address(gov), type(uint).max);     gov.distribute(_tigAsset, _daoFeesPaid);     return payout_; }  /**  * @dev update funding rates after open interest changes  * @param _asset asset id  * @param _tigAsset tigAsset used for OI  */ function _updateFunding(uint256 _asset, address _tigAsset) internal {     position.updateFunding(         _asset,         _tigAsset,         pairsContract.idToOi(_asset, _tigAsset).longOi,         pairsContract.idToOi(_asset, _tigAsset).shortOi,         pairsContract.idToAsset(_asset).baseFundingRate,         vaultFundingPercent     ); }  /**  * @dev check that SL price is valid compared to market price  * @param _sl SL price  * @param _direction long/short  * @param _price market price  */ function _checkSl(uint _sl, bool _direction, uint _price) internal pure {     if (_direction) {         if (_sl &gt; _price) revert(""3""); //BadStopLoss     } else {         if (_sl &lt; _price &amp;&amp; _sl != 0) revert(""3""); //BadStopLoss     } }  /**  * @dev check that trader address owns the position  * @param _id position id  * @param _trader trader address  */ function _checkOwner(uint _id, address _trader) internal view {     if (position.ownerOf(_id) != _trader) revert(""2""); //NotPositionOwner    }  /**  * @notice Check that sufficient time has passed between opening and closing  * @dev This is to prevent profitable opening and closing in the same tx with two different prices in the ""valid signature pool"".  * @param _id position id  * @param _type true for opening, false for closing  */ function _checkDelay(uint _id, bool _type) internal {     unchecked {         Delay memory _delay = blockDelayPassed[_id];         if (_delay.actionType == _type) {             blockDelayPassed[_id].delay = block.number + blockDelay;         } else {             if (block.number &lt; _delay.delay) revert(""0""); //Wait             blockDelayPassed[_id].delay = block.number + blockDelay;             blockDelayPassed[_id].actionType = _type;         }     } }  /**  * @dev Check that the stablevault input is whitelisted and the margin asset is whitelisted in the vault  * @param _stableVault StableVault address  * @param _token Margin asset token address  */ function _checkVault(address _stableVault, address _token) internal view {     require(allowedVault[_stableVault], ""Unapproved stablevault"");     require(_token == IStableVault(_stableVault).stable() || IStableVault(_stableVault).allowed(_token), ""Token not approved in vault""); }  /**  * @dev Check that the trader has approved the proxy address to trade for it  * @param _trader Trader address  */ function _validateProxy(address _trader) internal view {     if (_trader != _msgSender()) {         Proxy memory _proxy = proxyApprovals[_trader];         require(_proxy.proxy == _msgSender() &amp;&amp; _proxy.time &gt;= block.timestamp, ""Proxy not approved"");     } }  // ===== GOVERNANCE-ONLY =====  /**  * @dev Sets block delay between opening and closing  * @notice In blocks not seconds  * @param _blockDelay delay amount  */ function setBlockDelay(     uint _blockDelay )     external     onlyOwner {     blockDelay = _blockDelay; }  /**  * @dev Whitelists a stablevault contract address  * @param _stableVault StableVault address  * @param _bool true if allowed  */ function setAllowedVault(     address _stableVault,     bool _bool )     external     onlyOwner {     allowedVault[_stableVault] = _bool; }  /**  * @dev Sets max payout % compared to margin  * @param _maxWinPercent payout %  */ function setMaxWinPercent(     uint _maxWinPercent )     external     onlyOwner {     maxWinPercent = _maxWinPercent; }  /**  * @dev Sets executable price range for limit orders  * @param _range price range in %  */ function setLimitOrderPriceRange(uint _range) external onlyOwner {     limitOrderPriceRange = _range; }  /**  * @dev Sets the fees for the trading protocol  * @param _open True if open fees are being set  * @param _daoFees Fees distributed to the DAO  * @param _burnFees Fees which get burned  * @param _referralFees Fees given to referrers  * @param _botFees Fees given to bots that execute limit orders  * @param _percent Percent of earned funding fees going to StableVault  */ function setFees(bool _open, uint _daoFees, uint _burnFees, uint _referralFees, uint _botFees, uint _percent) external onlyOwner {     unchecked {         require(_daoFees &gt;= _botFees+_referralFees*2);         if (_open) {             openFees.daoFees = _daoFees;             openFees.burnFees = _burnFees;             openFees.referralFees = _referralFees;             openFees.botFees = _botFees;         } else {             closeFees.daoFees = _daoFees;             closeFees.burnFees = _burnFees;             closeFees.referralFees = _referralFees;             closeFees.botFees = _botFees;                         }         require(_percent &lt;= DIVISION_CONSTANT);         vaultFundingPercent = _percent;     } }  /**  * @dev Sets the extension contract address for trading  * @param _ext extension contract address  */ function setTradingExtension(     address _ext ) external onlyOwner() {     tradingExtension = ITradingExtension(_ext); }  // ===== EVENTS =====  event PositionOpened(     TradeInfo _tradeInfo,     uint _orderType,     uint _price,     uint _id,     address _trader,     uint _marginAfterFees );  event PositionClosed(     uint _id,     uint _closePrice,     uint _percent,     uint _payout,     address _trader,     address _executor );  event PositionLiquidated(     uint _id,     address _trader,     address _executor );  event LimitOrderExecuted(     uint _asset,     bool _direction,     uint _openPrice,     uint _lev,     uint _margin,     uint _id,     address _trader,     address _executor );  event UpdateTPSL(     uint _id,     bool _isTp,     uint _price,     address _trader );  event LimitCancelled(     uint _id,     address _trader );  event MarginModified(     uint _id,     uint _newMargin,     uint _newLeverage,     bool _isMarginAdded,     address _trader );  event AddToPosition(     uint _id,     uint _newMargin,     uint _newPrice,     address _trader );  event FeesDistributed(     address _tigAsset,     uint _daoFees,     uint _burnFees,     uint _refFees,     uint _botFees,     address _referrer );  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Transactions Order Dependence. Transactions Order Dependence vulnerabilities can result in unintended consequences and create opportunities for malicious actors to exploit transaction sequencing. Please conduct a thorough analysis, considering the following information: 1. Review the contract's code logic to identify any potential areas where the order of transaction execution might have an impact on the contract's behavior.   Examine critical functions, particularly those involving fund transfers or resource allocation, to ensure they are not susceptible to Transactions Order Dependence.   Investigate scenarios in which gas prices can be manipulated to change the order of transaction execution.   If you identify Transactions Order Dependence, respond with: "" Transactions Order Dependence Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades ''' If you don't find any Transactions Order Dependence vulnerabilities, respond only with: "" NO Transactions Order Dependence."" |
| **phase_name** | TODDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport ""./utils/MetaContext.sol"";\nimport ""./interfaces/ITrading.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport ""./interfaces/IPairsContract.sol"";\nimport ""./interfaces/IReferrals.sol"";\nimport ""./interfaces/IPosition.sol"";\nimport ""./interfaces/IGovNFT.sol"";\nimport ""./interfaces/IStableVault.sol"";\nimport ""./utils/TradingLibrary.sol"";\n\ninterface ITradingExtension {\n    function getVerifiedPrice(\n        uint asset,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        uint _withSpreadIsLong\n    ) external returns(uint256 _price, uint256 _spread);\n    function getRef(\n        address _trader\n    ) external pure returns(address);\n    function _setReferral(\n        bytes32 _referral,\n        address _trader\n    ) external;\n    function validateTrade(uint _asset, address _tigAsset, uint _margin, uint _leverage) external view;\n    function isPaused() external view returns(bool);\n    function minPos(address) external view returns(uint);\n    function modifyLongOi(\n        uint _asset,\n        address _tigAsset,\n        bool _onOpen,\n        uint _size\n    ) external;\n    function modifyShortOi(\n        uint _asset,\n        address _tigAsset,\n        bool _onOpen,\n        uint _size\n    ) external;\n    function paused() external returns(bool);\n    function _limitClose(\n        uint _id,\n        bool _tp,\n        PriceData calldata _priceData,\n        bytes calldata _signature\n    ) external returns(uint _limitPrice, address _tigAsset);\n    function _checkGas() external view;\n    function _closePosition(\n        uint _id,\n        uint _price,\n        uint _percent\n    ) external returns (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout);\n}\n\ninterface IStable is IERC20 {\n    function burnFrom(address account, uint amount) external;\n    function mintFor(address account, uint amount) external;\n}\n\ninterface ExtendedIERC20 is IERC20 {\n    function decimals() external view returns (uint);\n}\n\ninterface ERC20Permit is IERC20 {\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\ncontract Trading is MetaContext, ITrading {\n\n    error LimitNotSet(); //7\n    error NotLiquidatable();\n    error TradingPaused();\n    error BadDeposit();\n    error BadWithdraw();\n    error ValueNotEqualToMargin();\n    error BadLeverage();\n    error NotMargin();\n    error NotAllowedPair();\n    error BelowMinPositionSize();\n    error BadClosePercent();\n    error NoPrice();\n    error LiqThreshold();\n\n    uint constant private DIVISION_CONSTANT = 1e10; // 100%\n    uint private constant liqPercent = 9e9; // 90%\n\n    struct Fees {\n        uint daoFees;\n        uint burnFees;\n        uint referralFees;\n        uint botFees;\n    }\n    Fees public openFees = Fees(\n        0,\n        0,\n        0,\n        0\n    );\n    Fees public closeFees = Fees(\n        0,\n        0,\n        0,\n        0\n    );\n    uint public limitOrderPriceRange = 1e8; // 1%\n\n    uint public maxWinPercent;\n    uint public vaultFundingPercent;\n\n    IPairsContract private pairsContract;\n    IPosition private position;\n    IGovNFT private gov;\n    ITradingExtension private tradingExtension;\n\n    struct Delay {\n        uint delay; // Block number where delay ends\n        bool actionType; // True for open, False for close\n    }\n    mapping(uint =&gt; Delay) public blockDelayPassed; // id =&gt; Delay\n    uint public blockDelay;\n    mapping(uint =&gt; uint) public limitDelay; // id =&gt; block.timestamp\n\n    mapping(address =&gt; bool) public allowedVault;\n\n    struct Proxy {\n        address proxy;\n        uint256 time;\n    }\n\n    mapping(address =&gt; Proxy) public proxyApprovals;\n\n    constructor(\n        address _position,\n        address _gov,\n        address _pairsContract\n    )\n    {\n        position = IPosition(_position);\n        gov = IGovNFT(_gov);\n        pairsContract = IPairsContract(_pairsContract);\n    }\n\n    // ===== END-USER FUNCTIONS =====\n\n    /\n     * @param _tradeInfo Trade info\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _permitData data and signature needed for token approval\n     * @param _trader address the trade is initiated for\n     /\n    function initiateMarketOrder(\n        TradeInfo calldata _tradeInfo,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        ERC20PermitData calldata _permitData,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkDelay(position.getCount(), true);\n        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);\n        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();\n        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);\n        tradingExtension._setReferral(_tradeInfo.referral, _trader);\n        uint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin_tradeInfo.leverage/1e18, _trader, _tigAsset, false);\n        uint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;\n        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);\n        uint256 _isLong = _tradeInfo.direction ? 1 : 2;\n        (uint256 _price,) = tradingExtension.getVerifiedPrice(_tradeInfo.asset, _priceData, _signature, _isLong);\n        IPosition.MintTrade memory _mintTrade = IPosition.MintTrade(\n            _trader,\n            _marginAfterFees,\n            _tradeInfo.leverage,\n            _tradeInfo.asset,\n            _tradeInfo.direction,\n            _price,\n            _tradeInfo.tpPrice,\n            _tradeInfo.slPrice,\n            0,\n            _tigAsset\n        );\n        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);\n        unchecked {\n            if (_tradeInfo.direction) {\n                tradingExtension.modifyLongOi(_tradeInfo.asset, _tigAsset, true, _positionSize);\n            } else {\n                tradingExtension.modifyShortOi(_tradeInfo.asset, _tigAsset, true, _positionSize);\n            }\n        }\n        _updateFunding(_tradeInfo.asset, _tigAsset);\n        position.mint(\n            _mintTrade\n        );\n        unchecked {\n            emit PositionOpened(_tradeInfo, 0, _price, position.getCount()-1, _trader, _marginAfterFees);\n        }   \n    }\n\n    /\n     * @dev initiate closing position\n     * @param _id id of the position NFT\n     * @param _percent percent of the position being closed in BP\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _stableVault StableVault address\n     * @param _outputToken Token received upon closing trade\n     * @param _trader address the trade is initiated for\n     /\n    function initiateCloseOrder(\n        uint _id,\n        uint _percent,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        address _stableVault,\n        address _outputToken,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkDelay(_id, false);\n        _checkOwner(_id, _trader);\n        _checkVault(_stableVault, _outputToken);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType != 0) revert(""4""); //IsLimit        \n        (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);\n\n        if (_percent &gt; DIVISION_CONSTANT || _percent == 0) revert BadClosePercent();\n        _closePosition(_id, _percent, _price, _stableVault, _outputToken, false); \n    }\n\n    /\n     * @param _id position id\n     * @param _addMargin margin amount used to add to the position\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _stableVault StableVault address\n     * @param _marginAsset Token being used to add to the position\n     * @param _permitData data and signature needed for token approval\n     * @param _trader address the trade is initiated for\n     /\n    function addToPosition(\n        uint _id,\n        uint _addMargin,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        address _stableVault,\n        address _marginAsset,\n        ERC20PermitData calldata _permitData,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        _checkDelay(_id, true);\n        IPosition.Trade memory _trade = position.trades(_id);\n        tradingExtension.validateTrade(_trade.asset, _trade.tigAsset, _trade.margin + _addMargin, _trade.leverage);\n        _checkVault(_stableVault, _marginAsset);\n        if (_trade.orderType != 0) revert(""4""); //IsLimit\n        uint _fee = _handleOpenFees(_trade.asset, _addMargin_trade.leverage/1e18, _trader, _trade.tigAsset, false);\n        _handleDeposit(\n            _trade.tigAsset,\n            _marginAsset,\n            _addMargin - _fee,\n            _stableVault,\n            _permitData,\n            _trader\n        );\n        position.setAccInterest(_id);\n        unchecked {\n            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, _trade.direction ? 1 : 2);\n            uint _positionSize = (_addMargin - _fee) * _trade.leverage / 1e18;\n            if (_trade.direction) {\n                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, true, _positionSize);\n            } else {\n                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, true, _positionSize);     \n            }\n            _updateFunding(_trade.asset, _trade.tigAsset);\n            _addMargin -= _fee;\n            uint _newMargin = _trade.margin + _addMargin;\n            uint _newPrice = _trade.price_trade.margin/_newMargin + _price_addMargin/_newMargin;\n\n            position.addToPosition(\n                _trade.id,\n                _newMargin,\n                _newPrice\n            );\n            \n            emit AddToPosition(_trade.id, _newMargin, _newPrice, _trade.trader);\n        }\n    }\n\n    /\n     * @param _tradeInfo Trade info\n     * @param _orderType type of limit order used to open the position\n     * @param _price limit price\n     * @param _permitData data and signature needed for token approval\n     * @param _trader address the trade is initiated for\n     /\n    function initiateLimitOrder(\n        TradeInfo calldata _tradeInfo,\n        uint256 _orderType, // 1 limit, 2 stop\n        uint256 _price,\n        ERC20PermitData calldata _permitData,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();\n        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);\n        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);\n        if (_orderType == 0) revert(""5"");\n        if (_price == 0) revert NoPrice();\n        tradingExtension._setReferral(_tradeInfo.referral, _trader);\n        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);\n        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);\n        uint256 _id = position.getCount();\n        position.mint(\n            IPosition.MintTrade(\n                _trader,\n                _tradeInfo.margin,\n                _tradeInfo.leverage,\n                _tradeInfo.asset,\n                _tradeInfo.direction,\n                _price,\n                _tradeInfo.tpPrice,\n                _tradeInfo.slPrice,\n                _orderType,\n                _tigAsset\n            )\n        );\n        limitDelay[_id] = block.timestamp + 4;\n        emit PositionOpened(_tradeInfo, _orderType, _price, _id, _trader, _tradeInfo.margin);\n    }\n\n    /\n     * @param _id position ID\n     * @param _trader address the trade is initiated for\n     */\n    function cancelLimitOrder(\n        uint256 _id,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType == 0) revert();\n        IStable(_trade.tigAsset).mintFor(_trader, _trade.margin);\n        position.burn(_id);\n        emit LimitCancelled(_id, _trader);\n    }\n\n    /\n     * @param _id position id\n     * @param _marginAsset Token being used to add to the position\n     * @param _stableVault StableVault address\n     * @param _addMargin margin amount being added to the position\n     * @param _permitData data and signature needed for token approval\n     * @param _trader address the trade is initiated for\n     /\n    function addMargin(\n        uint256 _id,\n        address _marginAsset,\n        address _stableVault,\n        uint256 _addMargin,\n        ERC20PermitData calldata _permitData,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        _checkVault(_stableVault, _marginAsset);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType != 0) revert(); //IsLimit\n        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);\n        _handleDeposit(_trade.tigAsset, _marginAsset, _addMargin, _stableVault, _permitData, _trader);\n        unchecked {\n            uint256 _newMargin = _trade.margin + _addMargin;\n            uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;\n            if (_newLeverage &lt; asset.minLeverage) revert(""!lev"");\n            position.modifyMargin(_id, _newMargin, _newLeverage);\n            emit MarginModified(_id, _newMargin, _newLeverage, true, _trader);\n        }\n    }\n\n    /\n     * @param _id position id\n     * @param _stableVault StableVault address\n     * @param _outputToken token the trader will receive\n     * @param _removeMargin margin amount being removed from the position\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _trader address the trade is initiated for\n     /\n    function removeMargin(\n        uint256 _id,\n        address _stableVault,\n        address _outputToken,\n        uint256 _removeMargin,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        _checkVault(_stableVault, _outputToken);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType != 0) revert(); //IsLimit\n        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);\n        uint256 _newMargin = _trade.margin - _removeMargin;\n        uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;\n        if (_newLeverage &gt; asset.maxLeverage) revert(""!lev"");\n        (uint _assetPrice,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);\n        (,int256 _payout) = TradingLibrary.pnl(_trade.direction, _assetPrice, _trade.price, _newMargin, _newLeverage, _trade.accInterest);\n        unchecked {\n            if (_payout &lt;= int256(_newMargin(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert LiqThreshold();\n        }\n        position.modifyMargin(_trade.id, _newMargin, _newLeverage);\n        _handleWithdraw(_trade, _stableVault, _outputToken, _removeMargin);\n        emit MarginModified(_trade.id, _newMargin, _newLeverage, false, _trader);\n    }\n\n    /\n     * @param _type true for TP, false for SL\n     * @param _id position id\n     * @param _limitPrice TP/SL trigger price\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _trader address the trade is initiated for\n     /\n    function updateTpSl(\n        bool _type,\n        uint _id,\n        uint _limitPrice,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType != 0) revert(""4""); //IsLimit\n        if (_type) {\n            position.modifyTp(_id, _limitPrice);\n        } else {\n            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);\n            _checkSl(_limitPrice, _trade.direction, _price);\n            position.modifySl(_id, _limitPrice);\n        }\n        emit UpdateTPSL(_id, _type, _limitPrice, _trader);\n    }\n\n    /\n     * @param _id position id\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     /\n    function executeLimitOrder(\n        uint _id, \n        PriceData calldata _priceData,\n        bytes calldata _signature\n    ) \n        external\n    {\n        unchecked {\n            _checkDelay(_id, true);\n            tradingExtension._checkGas();\n            if (tradingExtension.paused()) revert TradingPaused();\n            require(block.timestamp &gt;= limitDelay[_id]);\n            IPosition.Trade memory trade = position.trades(_id);\n            uint _fee = _handleOpenFees(trade.asset, trade.margintrade.leverage/1e18, trade.trader, trade.tigAsset, true);\n            (uint256 _price, uint256 _spread) = tradingExtension.getVerifiedPrice(trade.asset, _priceData, _signature, 0);\n            if (trade.orderType == 0) revert(""5"");\n            if (_price &gt; trade.price+trade.pricelimitOrderPriceRange/DIVISION_CONSTANT || _price &lt; trade.price-trade.pricelimitOrderPriceRange/DIVISION_CONSTANT) revert(""6""); //LimitNotMet\n            if (trade.direction &amp;&amp; trade.orderType == 1) {\n                if (trade.price &lt; _price) revert(""6""); //LimitNotMet\n            } else if (!trade.direction &amp;&amp; trade.orderType == 1) {\n                if (trade.price &gt; _price) revert(""6""); //LimitNotMet\n            } else if (!trade.direction &amp;&amp; trade.orderType == 2) {\n                if (trade.price &lt; _price) revert(""6""); //LimitNotMet\n                trade.price = _price;\n            } else {\n                if (trade.price &gt; _price) revert(""6""); //LimitNotMet\n                trade.price = _price;\n            } \n            if(trade.direction) {\n                trade.price += trade.price * _spread / DIVISION_CONSTANT;\n            } else {\n                trade.price -= trade.price * _spread / DIVISION_CONSTANT;\n            }\n            if (trade.direction) {\n                tradingExtension.modifyLongOi(trade.asset, trade.tigAsset, true, trade.margintrade.leverage/1e18);\n            } else {\n                tradingExtension.modifyShortOi(trade.asset, trade.tigAsset, true, trade.margintrade.leverage/1e18);\n            }\n            _updateFunding(trade.asset, trade.tigAsset);\n            position.executeLimitOrder(_id, trade.price, trade.margin - _fee);\n            emit LimitOrderExecuted(trade.asset, trade.direction, trade.price, trade.leverage, trade.margin - _fee, _id, trade.trader, _msgSender());\n        }\n    }\n\n    /\n     * @notice liquidate position\n     * @param _id id of the position NFT\n     * @param _priceData verifiable off-chain data\n     * @param _signature node signature\n     /\n    function liquidatePosition(\n        uint _id,\n        PriceData calldata _priceData,\n        bytes calldata _signature\n    )\n        external\n    {\n        unchecked {\n            tradingExtension._checkGas();\n            IPosition.Trade memory _trade = position.trades(_id);\n            if (_trade.orderType != 0) revert(""4""); //IsLimit\n\n            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);\n            (uint256 _positionSizeAfterPrice, int256 _payout) = TradingLibrary.pnl(_trade.direction, _price, _trade.price, _trade.margin, _trade.leverage, _trade.accInterest);\n            uint256 _positionSize = _trade.margin_trade.leverage/1e18;\n            if (_payout &gt; int256(_trade.margin(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert NotLiquidatable();\n            if (_trade.direction) {\n                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, false, _positionSize);\n            } else {\n                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, false, _positionSize);\n            }\n            _updateFunding(_trade.asset, _trade.tigAsset);\n            _handleCloseFees(_trade.asset, type(uint).max, _trade.tigAsset, _positionSizeAfterPrice, _trade.trader, true);\n            position.burn(_id);\n            emit PositionLiquidated(_id, _trade.trader, _msgSender());\n        }\n    }\n\n    /\n     * @dev close position at a pre-set price\n     * @param _id id of the position NFT\n     * @param _tp true if take profit\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     /\n    function limitClose(\n        uint _id,\n        bool _tp,\n        PriceData calldata _priceData,\n        bytes calldata _signature\n    )\n        external\n    {\n        _checkDelay(_id, false);\n        (uint _limitPrice, address _tigAsset) = tradingExtension._limitClose(_id, _tp, _priceData, _signature);\n        _closePosition(_id, DIVISION_CONSTANT, _limitPrice, address(0), _tigAsset, true);\n    }\n\n    /\n     * @notice Trader can approve a proxy wallet address for it to trade on its behalf. Can also provide proxy wallet with gas.\n     * @param _proxy proxy wallet address\n     * @param _timestamp end timestamp of approval period\n     */\n    function approveProxy(address _proxy, uint256 _timestamp) external payable {\n        proxyApprovals[_msgSender()] = Proxy(\n            _proxy,\n            _timestamp\n        );\n        payable(_proxy).transfer(msg.value);\n    }\n\n    // ===== INTERNAL FUNCTIONS =====\n\n    /\n     * @dev close the initiated position.\n     * @param _id id of the position NFT\n     * @param _percent percent of the position being closed\n     * @param _price pair price\n     * @param _stableVault StableVault address\n     * @param _outputToken Token that trader will receive\n     * @param _isBot false if closed via market order\n     /\n    function _closePosition(\n        uint _id,\n        uint _percent,\n        uint _price,\n        address _stableVault,\n        address _outputToken,\n        bool _isBot\n    )\n        internal\n    {\n        (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout) = tradingExtension._closePosition(_id, _price, _percent);\n        position.setAccInterest(_id);\n        _updateFunding(_trade.asset, _trade.tigAsset);\n        if (_percent &lt; DIVISION_CONSTANT) {\n            if ((_trade.margin_trade.leverage(DIVISION_CONSTANT-_percent)/DIVISION_CONSTANT)/1e18 &lt; tradingExtension.minPos(_trade.tigAsset)) revert(""!size"");\n            position.reducePosition(_id, _percent);\n        } else {\n            position.burn(_id);\n        }\n        uint256 _toMint;\n        if (_payout &gt; 0) {\n            unchecked {\n                _toMint = _handleCloseFees(_trade.asset, uint256(_payout)_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize_percent/DIVISION_CONSTANT, _trade.trader, _isBot);\n                if (maxWinPercent &gt; 0 &amp;&amp; _toMint &gt; _trade.marginmaxWinPercent/DIVISION_CONSTANT) {\n                    _toMint = _trade.marginmaxWinPercent/DIVISION_CONSTANT;\n                }\n            }\n            _handleWithdraw(_trade, _stableVault, _outputToken, _toMint);\n        }\n        emit PositionClosed(_id, _price, _percent, _toMint, _trade.trader, _isBot ? _msgSender() : _trade.trader);\n    }\n\n    /\n     * @dev handle stablevault deposits for different trading functions\n     * @param _tigAsset tigAsset token address\n     * @param _marginAsset token being deposited into stablevault\n     * @param _margin amount being deposited\n     * @param _stableVault StableVault address\n     * @param _permitData Data for approval via permit\n     * @param _trader Trader address to take tokens from\n     /\n    function _handleDeposit(address _tigAsset, address _marginAsset, uint256 _margin, address _stableVault, ERC20PermitData calldata _permitData, address _trader) internal {\n        IStable tigAsset = IStable(_tigAsset);\n        if (_tigAsset != _marginAsset) {\n            if (_permitData.usePermit) {\n                ERC20Permit(_marginAsset).permit(_trader, address(this), _permitData.amount, _permitData.deadline, _permitData.v, _permitData.r, _permitData.s);\n            }\n            uint256 _balBefore = tigAsset.balanceOf(address(this));\n            uint _marginDecMultiplier = 10(18-ExtendedIERC20(_marginAsset).decimals());\n            IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);\n            IERC20(_marginAsset).approve(_stableVault, type(uint).max);\n            IStableVault(_stableVault).deposit(_marginAsset, _margin/_marginDecMultiplier);\n            if (tigAsset.balanceOf(address(this)) != _balBefore + _margin) revert BadDeposit();\n            tigAsset.burnFrom(address(this), tigAsset.balanceOf(address(this)));\n        } else {\n            tigAsset.burnFrom(_trader, _margin);\n        }        \n    }\n\n    /\n     * @dev handle stablevault withdrawals for different trading functions\n     * @param _trade Position info\n     * @param _stableVault StableVault address\n     * @param _outputToken Output token address\n     * @param _toMint Amount of tigAsset minted to be used for withdrawal\n     /\n    function _handleWithdraw(IPosition.Trade memory _trade, address _stableVault, address _outputToken, uint _toMint) internal {\n        IStable(_trade.tigAsset).mintFor(address(this), _toMint);\n        if (_outputToken == _trade.tigAsset) {\n            IERC20(_outputToken).transfer(_trade.trader, _toMint);\n        } else {\n            uint256 _balBefore = IERC20(_outputToken).balanceOf(address(this));\n            IStableVault(_stableVault).withdraw(_outputToken, _toMint);\n            if (IERC20(_outputToken).balanceOf(address(this)) != _balBefore + _toMint/(10(18-ExtendedIERC20(_outputToken).decimals()))) revert BadWithdraw();\n            IERC20(_outputToken).transfer(_trade.trader, IERC20(_outputToken).balanceOf(address(this)) - _balBefore);\n        }        \n    }\n\n    /\n     * @dev handle fees distribution for opening\n     * @param _asset asset id\n     * @param _positionSize position size\n     * @param _trader trader address\n     * @param _tigAsset tigAsset address\n     * @param _isBot false if opened via market order\n     * @return _feePaid total fees paid during opening\n     /\n    function _handleOpenFees(\n        uint _asset,\n        uint _positionSize,\n        address _trader,\n        address _tigAsset,\n        bool _isBot\n    )\n        internal\n        returns (uint _feePaid)\n    {\n        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);\n        Fees memory _fees = openFees;\n        unchecked {\n            _fees.daoFees = _fees.daoFees * asset.feeMultiplier / DIVISION_CONSTANT;\n            _fees.burnFees = _fees.burnFees * asset.feeMultiplier / DIVISION_CONSTANT;\n            _fees.referralFees = _fees.referralFees * asset.feeMultiplier / DIVISION_CONSTANT;\n            _fees.botFees = _fees.botFees * asset.feeMultiplier / DIVISION_CONSTANT;\n        }\n        address _referrer = tradingExtension.getRef(_trader); //referrals.getReferral(referrals.getReferred(_trader));\n        if (_referrer != address(0)) {\n            unchecked {\n                IStable(_tigAsset).mintFor(\n                    _referrer,\n                    _positionSize\n                    * _fees.referralFees // get referral fee%\n                    / DIVISION_CONSTANT // divide by 100%\n                );\n            }\n            _fees.daoFees = _fees.daoFees - _fees.referralFees2;\n        }\n        if (_isBot) {\n            unchecked {\n                IStable(_tigAsset).mintFor(\n                    _msgSender(),\n                    _positionSize\n                    * _fees.botFees // get bot fee%\n                    / DIVISION_CONSTANT // divide by 100%\n                );\n            }\n            _fees.daoFees = _fees.daoFees - _fees.botFees;\n        } else {\n            _fees.botFees = 0;\n        }\n        unchecked {\n            uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT;\n            _feePaid =\n                _positionSize\n                * (_fees.burnFees + _fees.botFees) // get total fee%\n                / DIVISION_CONSTANT // divide by 100%\n                + _daoFeesPaid;\n            emit FeesDistributed(\n                _tigAsset,\n                _daoFeesPaid,\n                _positionSize * _fees.burnFees / DIVISION_CONSTANT,\n                _referrer != address(0) ? _positionSize * _fees.referralFees / DIVISION_CONSTANT : 0,\n                _positionSize * _fees.botFees / DIVISION_CONSTANT,\n                _referrer\n            );\n            IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);\n        }\n        gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));\n    }\n\n    /\n     * @dev handle fees distribution for closing\n     * @param asset asset id\n     * @param _payout payout to trader before fees\n     * @param _tigAsset margin asset\n     * @param _positionSize position size\n     * @param _trader trader address\n     * @param _isBot false if closed via market order\n     * @return payout payout to trader after fees\n     /\n    function _handleCloseFees(\n        uint _asset,\n        uint _payout,\n        address _tigAsset,\n        uint _positionSize,\n        address _trader,\n        bool _isBot\n    )\n        internal\n        returns (uint payout)\n    {\n        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);\n        Fees memory _fees = closeFees;\n        uint _daoFeesPaid;\n        uint _burnFeesPaid;\n        uint _referralFeesPaid;\n        unchecked {\n            _daoFeesPaid = (_positionSize_fees.daoFees/DIVISION_CONSTANT)asset.feeMultiplier/DIVISION_CONSTANT;\n            _burnFeesPaid = (_positionSize_fees.burnFees/DIVISION_CONSTANT)asset.feeMultiplier/DIVISION_CONSTANT;\n        }\n        uint _botFeesPaid;\n        address _referrer = tradingExtension.getRef(_trader);//referrals.getReferral(referrals.getReferred(_trader));\n        if (_referrer != address(0)) {\n            unchecked {\n                _referralFeesPaid = (_positionSize_fees.referralFees/DIVISION_CONSTANT)asset.feeMultiplier/DIVISION_CONSTANT;\n            }\n            IStable(_tigAsset).mintFor(\n                _referrer,\n                _referralFeesPaid\n            );\n             _daoFeesPaid = _daoFeesPaid-_referralFeesPaid2;\n        }\n        if (_isBot) {\n            unchecked {\n                _botFeesPaid = (_positionSize_fees.botFees/DIVISION_CONSTANT)asset.feeMultiplier/DIVISION_CONSTANT;\n                IStable(tigAsset).mintFor(\n                    _msgSender(),\n                    _botFeesPaid\n                );\n            }\n            _daoFeesPaid = _daoFeesPaid - _botFeesPaid;\n        }\n        emit FeesDistributed(_tigAsset, _daoFeesPaid, _burnFeesPaid, _referralFeesPaid, _botFeesPaid, _referrer);\n        payout = payout - _daoFeesPaid - _burnFeesPaid - _botFeesPaid;\n        IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);\n        IStable(_tigAsset).approve(address(gov), type(uint).max);\n        gov.distribute(_tigAsset, _daoFeesPaid);\n        return payout;\n    }\n\n    /\n     * @dev update funding rates after open interest changes\n     * @param _asset asset id\n     * @param _tigAsset tigAsset used for OI\n     /\n    function _updateFunding(uint256 _asset, address _tigAsset) internal {\n        position.updateFunding(\n            _asset,\n            _tigAsset,\n            pairsContract.idToOi(_asset, _tigAsset).longOi,\n            pairsContract.idToOi(_asset, _tigAsset).shortOi,\n            pairsContract.idToAsset(_asset).baseFundingRate,\n            vaultFundingPercent\n        );\n    }\n\n    /\n     * @dev check that SL price is valid compared to market price\n     * @param _sl SL price\n     * @param _direction long/short\n     * @param _price market price\n     */\n    function _checkSl(uint _sl, bool _direction, uint _price) internal pure {\n        if (_direction) {\n            if (_sl &gt; _price) revert(""3""); //BadStopLoss\n        } else {\n            if (_sl &lt; _price &amp;&amp; _sl != 0) revert(""3""); //BadStopLoss\n        }\n    }\n\n    /\n     * @dev check that trader address owns the position\n     * @param _id position id\n     * @param _trader trader address\n     /\n    function _checkOwner(uint _id, address _trader) internal view {\n        if (position.ownerOf(_id) != _trader) revert(""2""); //NotPositionOwner   \n    }\n\n    /\n     * @notice Check that sufficient time has passed between opening and closing\n     * @dev This is to prevent profitable opening and closing in the same tx with two different prices in the ""valid signature pool"".\n     * @param _id position id\n     * @param _type true for opening, false for closing\n     /\n    function _checkDelay(uint _id, bool _type) internal {\n        unchecked {\n            Delay memory _delay = blockDelayPassed[_id];\n            if (_delay.actionType == _type) {\n                blockDelayPassed[_id].delay = block.number + blockDelay;\n            } else {\n                if (block.number &lt; _delay.delay) revert(""0""); //Wait\n                blockDelayPassed[_id].delay = block.number + blockDelay;\n                blockDelayPassed[_id].actionType = _type;\n            }\n        }\n    }\n\n    /\n     * @dev Check that the stablevault input is whitelisted and the margin asset is whitelisted in the vault\n     * @param _stableVault StableVault address\n     * @param _token Margin asset token address\n     */\n    function _checkVault(address _stableVault, address _token) internal view {\n        require(allowedVault[_stableVault], ""Unapproved stablevault"");\n        require(_token == IStableVault(_stableVault).stable() || IStableVault(_stableVault).allowed(_token), ""Token not approved in vault"");\n    }\n\n    /\n     * @dev Check that the trader has approved the proxy address to trade for it\n     * @param _trader Trader address\n     /\n    function _validateProxy(address _trader) internal view {\n        if (_trader != _msgSender()) {\n            Proxy memory _proxy = proxyApprovals[_trader];\n            require(_proxy.proxy == _msgSender() &amp;&amp; _proxy.time &gt;= block.timestamp, ""Proxy not approved"");\n        }\n    }\n\n    // ===== GOVERNANCE-ONLY =====\n\n    /\n     * @dev Sets block delay between opening and closing\n     * @notice In blocks not seconds\n     * @param _blockDelay delay amount\n     /\n    function setBlockDelay(\n        uint _blockDelay\n    )\n        external\n        onlyOwner\n    {\n        blockDelay = _blockDelay;\n    }\n\n    /\n     * @dev Whitelists a stablevault contract address\n     * @param _stableVault StableVault address\n     * @param _bool true if allowed\n     */\n    function setAllowedVault(\n        address _stableVault,\n        bool _bool\n    )\n        external\n        onlyOwner\n    {\n        allowedVault[_stableVault] = _bool;\n    }\n\n    /\n     * @dev Sets max payout % compared to margin\n     * @param _maxWinPercent payout %\n     /\n    function setMaxWinPercent(\n        uint _maxWinPercent\n    )\n        external\n        onlyOwner\n    {\n        maxWinPercent = _maxWinPercent;\n    }\n\n    /\n     * @dev Sets executable price range for limit orders\n     * @param _range price range in %\n     /\n    function setLimitOrderPriceRange(uint _range) external onlyOwner {\n        limitOrderPriceRange = _range;\n    }\n\n    /\n     * @dev Sets the fees for the trading protocol\n     * @param _open True if open fees are being set\n     * @param _daoFees Fees distributed to the DAO\n     * @param _burnFees Fees which get burned\n     * @param _referralFees Fees given to referrers\n     * @param _botFees Fees given to bots that execute limit orders\n     * @param _percent Percent of earned funding fees going to StableVault\n     /\n    function setFees(bool _open, uint _daoFees, uint _burnFees, uint _referralFees, uint _botFees, uint _percent) external onlyOwner {\n        unchecked {\n            require(_daoFees &gt;= _botFees+_referralFees2);\n            if (_open) {\n                openFees.daoFees = _daoFees;\n                openFees.burnFees = _burnFees;\n                openFees.referralFees = _referralFees;\n                openFees.botFees = _botFees;\n            } else {\n                closeFees.daoFees = _daoFees;\n                closeFees.burnFees = _burnFees;\n                closeFees.referralFees = _referralFees;\n                closeFees.botFees = _botFees;                \n            }\n            require(_percent &lt;= DIVISION_CONSTANT);\n            vaultFundingPercent = _percent;\n        }\n    }\n\n    /\n     * @dev Sets the extension contract address for trading\n     * @param _ext extension contract address\n     */\n    function setTradingExtension(\n        address _ext\n    ) external onlyOwner() {\n        tradingExtension = ITradingExtension(_ext);\n    }\n\n    // ===== EVENTS =====\n\n    event PositionOpened(\n        TradeInfo _tradeInfo,\n        uint _orderType,\n        uint _price,\n        uint _id,\n        address _trader,\n        uint _marginAfterFees\n    );\n\n    event PositionClosed(\n        uint _id,\n        uint _closePrice,\n        uint _percent,\n        uint _payout,\n        address _trader,\n        address _executor\n    );\n\n    event PositionLiquidated(\n        uint _id,\n        address _trader,\n        address _executor\n    );\n\n    event LimitOrderExecuted(\n        uint _asset,\n        bool _direction,\n        uint _openPrice,\n        uint _lev,\n        uint _margin,\n        uint _id,\n        address _trader,\n        address _executor\n    );\n\n    event UpdateTPSL(\n        uint _id,\n        bool _isTp,\n        uint _price,\n        address _trader\n    );\n\n    event LimitCancelled(\n        uint _id,\n        address _trader\n    );\n\n    event MarginModified(\n        uint _id,\n        uint _newMargin,\n        uint _newLeverage,\n        bool _isMarginAdded,\n        address _trader\n    );\n\n    event AddToPosition(\n        uint _id,\n        uint _newMargin,\n        uint _newPrice,\n        address _trader\n    );\n\n    event FeesDistributed(\n        address _tigAsset,\n        uint _daoFees,\n        uint _burnFees,\n        uint _refFees,\n        uint _botFees,\n        address _referrer\n    );\n}\n', 'ideas': ' Unchecked Low-level Calls Identified.\n\n\nUNCHECKED LOW-LEVEL CALL\n\'\'\'\nIn the function `_handleDeposit`, the contract performs a low-level call to `IERC20(_marginAsset).transferFrom(...)` without checking if the call was successful. If the transfer fails (for example, due to insufficient balance or allowance), the contract will continue executing without reverting, potentially leading to unexpected states or loss of funds.\n\nRecommended Mitigation/Fix:\nAdd a require statement to check the success of the transfer operation:\nsolidity\nbool success = IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);\nrequire(success, ""Transfer failed"");\n\n\'\'\'\n\n\n\nUNCHECKED LOW-LEVEL CALL\n\'\'\'\nIn the function `_handleWithdraw`, the contract calls `IStableVault(_stableVault).withdraw(...)` without checking if the withdrawal was successful. If the withdrawal fails, the contract will not revert, which could lead to inconsistencies in the state of the contract and potential loss of funds.\n\nRecommended Mitigation/Fix:\nAdd a require statement to check the success of the withdrawal operation:\nsolidity\nbool success = IStableVault(_stableVault).withdraw(_outputToken, _toMint);\nrequire(success, ""Withdrawal failed"");\n\n\'\'\'\n\n\n\nUNCHECKED LOW-LEVEL CALL\n\'\'\'\nIn the function `_handleOpenFees`, the contract calls `IStable(_tigAsset).mintFor(...)` without checking if the minting operation was successful. If the minting fails, the contract will not revert, which could lead to incorrect fee distributions and loss of funds.\n\nRecommended Mitigation/Fix:\nAdd a require statement to check the success of the minting operation:\nsolidity\nbool success = IStable(_tigAsset).mintFor(_referrer, _positionSize * _fees.referralFees / DIVISION_CONSTANT);\nrequire(success, ""Minting failed"");\n\n\'\'\'\n\n\n\nUNCHECKED LOW-LEVEL CALL\n\'\'\'\nIn the function `_handleCloseFees`, the contract calls `IStable(_tigAsset).mintFor(...)` without checking if the minting operation was successful. If the minting fails, the contract will not revert, which could lead to incorrect fee distributions and loss of funds.\n\nRecommended Mitigation/Fix:\nAdd a require statement to check the success of the minting operation:\nsolidity\nbool success = IStable(_tigAsset).mintFor(_referrer, _referralFeesPaid);\nrequire(success, ""Minting failed"");\n\n\'\'\'\n\n\n\nUNCHECKED LOW-LEVEL CALL\n\'\'\'\nIn the function `approveProxy`, the contract transfers Ether to the proxy address using `payable(_proxy).transfer(msg.value);` without checking if the transfer was successful. If the transfer fails, the contract will not revert, which could lead to unexpected states.\n\nRecommended Mitigation/Fix:\nUse the `call` method instead of `transfer` and check for success:\nsolidity\n(bool success, ) = _proxy.call{value: msg.value}("""");\nrequire(success, ""Transfer to proxy failed"");\n\n\'\'\'\n'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-16-08 22:00:55 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | //SPDX-License-Identifier: Unlicense pragma solidity ^0.8.0; import ""./utils/MetaContext.sol""; import ""./interfaces/ITrading.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""./interfaces/IPairsContract.sol""; import ""./interfaces/IReferrals.sol""; import ""./interfaces/IPosition.sol""; import ""./interfaces/IGovNFT.sol""; import ""./interfaces/IStableVault.sol""; import ""./utils/TradingLibrary.sol""; interface ITradingExtension {     function getVerifiedPrice(         uint _asset,         PriceData calldata _priceData,         bytes calldata _signature,         uint _withSpreadIsLong     ) external returns(uint256 _price, uint256 _spread);     function getRef(         address _trader     ) external pure returns(address);     function _setReferral(         bytes32 _referral,         address _trader     ) external;     function validateTrade(uint _asset, address _tigAsset, uint _margin, uint _leverage) external view;     function isPaused() external view returns(bool);     function minPos(address) external view returns(uint);     function modifyLongOi(         uint _asset,         address _tigAsset,         bool _onOpen,         uint _size     ) external;     function modifyShortOi(         uint _asset,         address _tigAsset,         bool _onOpen,         uint _size     ) external;     function paused() external returns(bool);     function _limitClose(         uint _id,         bool _tp,         PriceData calldata _priceData,         bytes calldata _signature     ) external returns(uint _limitPrice, address _tigAsset);     function _checkGas() external view;     function _closePosition(         uint _id,         uint _price,         uint _percent     ) external returns (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout); } interface IStable is IERC20 {     function burnFrom(address account, uint amount) external;     function mintFor(address account, uint amount) external; } interface ExtendedIERC20 is IERC20 {     function decimals() external view returns (uint); } interface ERC20Permit is IERC20 {     function permit(         address owner,         address spender,         uint256 value,         uint256 deadline,         uint8 v,         bytes32 r,         bytes32 s     ) external; } contract Trading is MetaContext, ITrading { error LimitNotSet(); //7 error NotLiquidatable(); error TradingPaused(); error BadDeposit(); error BadWithdraw(); error ValueNotEqualToMargin(); error BadLeverage(); error NotMargin(); error NotAllowedPair(); error BelowMinPositionSize(); error BadClosePercent(); error NoPrice(); error LiqThreshold();  uint constant private DIVISION_CONSTANT = 1e10; // 100% uint private constant liqPercent = 9e9; // 90%  struct Fees {     uint daoFees;     uint burnFees;     uint referralFees;     uint botFees; } Fees public openFees = Fees(     0,     0,     0,     0 ); Fees public closeFees = Fees(     0,     0,     0,     0 ); uint public limitOrderPriceRange = 1e8; // 1%  uint public maxWinPercent; uint public vaultFundingPercent;  IPairsContract private pairsContract; IPosition private position; IGovNFT private gov; ITradingExtension private tradingExtension;  struct Delay {     uint delay; // Block number where delay ends     bool actionType; // True for open, False for close } mapping(uint =&gt; Delay) public blockDelayPassed; // id =&gt; Delay uint public blockDelay; mapping(uint =&gt; uint) public limitDelay; // id =&gt; block.timestamp  mapping(address =&gt; bool) public allowedVault;  struct Proxy {     address proxy;     uint256 time; }  mapping(address =&gt; Proxy) public proxyApprovals;  constructor(     address _position,     address _gov,     address _pairsContract ) {     position = IPosition(_position);     gov = IGovNFT(_gov);     pairsContract = IPairsContract(_pairsContract); }  // ===== END-USER FUNCTIONS =====  /**  * @param _tradeInfo Trade info  * @param _priceData verifiable off-chain price data  * @param _signature node signature  * @param _permitData data and signature needed for token approval  * @param _trader address the trade is initiated for  */ function initiateMarketOrder(     TradeInfo calldata _tradeInfo,     PriceData calldata _priceData,     bytes calldata _signature,     ERC20PermitData calldata _permitData,     address _trader )     external {     _validateProxy(_trader);     _checkDelay(position.getCount(), true);     _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);     address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();     tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);     tradingExtension._setReferral(_tradeInfo.referral, _trader);     uint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false);     uint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;     _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);     uint256 _isLong = _tradeInfo.direction ? 1 : 2;     (uint256 _price,) = tradingExtension.getVerifiedPrice(_tradeInfo.asset, _priceData, _signature, _isLong);     IPosition.MintTrade memory _mintTrade = IPosition.MintTrade(         _trader,         _marginAfterFees,         _tradeInfo.leverage,         _tradeInfo.asset,         _tradeInfo.direction,         _price,         _tradeInfo.tpPrice,         _tradeInfo.slPrice,         0,         _tigAsset     );     _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);     unchecked {         if (_tradeInfo.direction) {             tradingExtension.modifyLongOi(_tradeInfo.asset, _tigAsset, true, _positionSize);         } else {             tradingExtension.modifyShortOi(_tradeInfo.asset, _tigAsset, true, _positionSize);         }     }     _updateFunding(_tradeInfo.asset, _tigAsset);     position.mint(         _mintTrade     );     unchecked {         emit PositionOpened(_tradeInfo, 0, _price, position.getCount()-1, _trader, _marginAfterFees);     }    }  /**  * @dev initiate closing position  * @param _id id of the position NFT  * @param _percent percent of the position being closed in BP  * @param _priceData verifiable off-chain price data  * @param _signature node signature  * @param _stableVault StableVault address  * @param _outputToken Token received upon closing trade  * @param _trader address the trade is initiated for  */ function initiateCloseOrder(     uint _id,     uint _percent,     PriceData calldata _priceData,     bytes calldata _signature,     address _stableVault,     address _outputToken,     address _trader )     external {     _validateProxy(_trader);     _checkDelay(_id, false);     _checkOwner(_id, _trader);     _checkVault(_stableVault, _outputToken);     IPosition.Trade memory _trade = position.trades(_id);     if (_trade.orderType != 0) revert(""4""); //IsLimit             (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);      if (_percent &gt; DIVISION_CONSTANT || _percent == 0) revert BadClosePercent();     _closePosition(_id, _percent, _price, _stableVault, _outputToken, false);  }  /**  * @param _id position id  * @param _addMargin margin amount used to add to the position  * @param _priceData verifiable off-chain price data  * @param _signature node signature  * @param _stableVault StableVault address  * @param _marginAsset Token being used to add to the position  * @param _permitData data and signature needed for token approval  * @param _trader address the trade is initiated for  */ function addToPosition(     uint _id,     uint _addMargin,     PriceData calldata _priceData,     bytes calldata _signature,     address _stableVault,     address _marginAsset,     ERC20PermitData calldata _permitData,     address _trader )     external {     _validateProxy(_trader);     _checkOwner(_id, _trader);     _checkDelay(_id, true);     IPosition.Trade memory _trade = position.trades(_id);     tradingExtension.validateTrade(_trade.asset, _trade.tigAsset, _trade.margin + _addMargin, _trade.leverage);     _checkVault(_stableVault, _marginAsset);     if (_trade.orderType != 0) revert(""4""); //IsLimit     uint _fee = _handleOpenFees(_trade.asset, _addMargin*_trade.leverage/1e18, _trader, _trade.tigAsset, false);     _handleDeposit(         _trade.tigAsset,         _marginAsset,         _addMargin - _fee,         _stableVault,         _permitData,         _trader     );     position.setAccInterest(_id);     unchecked {         (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, _trade.direction ? 1 : 2);         uint _positionSize = (_addMargin - _fee) * _trade.leverage / 1e18;         if (_trade.direction) {             tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, true, _positionSize);         } else {             tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, true, _positionSize);              }         _updateFunding(_trade.asset, _trade.tigAsset);         _addMargin -= _fee;         uint _newMargin = _trade.margin + _addMargin;         uint _newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin;          position.addToPosition(             _trade.id,             _newMargin,             _newPrice         );          emit AddToPosition(_trade.id, _newMargin, _newPrice, _trade.trader);     } }  /**  * @param _tradeInfo Trade info  * @param _orderType type of limit order used to open the position  * @param _price limit price  * @param _permitData data and signature needed for token approval  * @param _trader address the trade is initiated for  */ function initiateLimitOrder(     TradeInfo calldata _tradeInfo,     uint256 _orderType, // 1 limit, 2 stop     uint256 _price,     ERC20PermitData calldata _permitData,     address _trader )     external {     _validateProxy(_trader);     address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();     tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);     _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);     if (_orderType == 0) revert(""5"");     if (_price == 0) revert NoPrice();     tradingExtension._setReferral(_tradeInfo.referral, _trader);     _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);     _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);     uint256 _id = position.getCount();     position.mint(         IPosition.MintTrade(             _trader,             _tradeInfo.margin,             _tradeInfo.leverage,             _tradeInfo.asset,             _tradeInfo.direction,             _price,             _tradeInfo.tpPrice,             _tradeInfo.slPrice,             _orderType,             _tigAsset         )     );     limitDelay[_id] = block.timestamp + 4;     emit PositionOpened(_tradeInfo, _orderType, _price, _id, _trader, _tradeInfo.margin); }  /**  * @param _id position ID  * @param _trader address the trade is initiated for  */ function cancelLimitOrder(     uint256 _id,     address _trader )     external {     _validateProxy(_trader);     _checkOwner(_id, _trader);     IPosition.Trade memory _trade = position.trades(_id);     if (_trade.orderType == 0) revert();     IStable(_trade.tigAsset).mintFor(_trader, _trade.margin);     position.burn(_id);     emit LimitCancelled(_id, _trader); }  /**  * @param _id position id  * @param _marginAsset Token being used to add to the position  * @param _stableVault StableVault address  * @param _addMargin margin amount being added to the position  * @param _permitData data and signature needed for token approval  * @param _trader address the trade is initiated for  */ function addMargin(     uint256 _id,     address _marginAsset,     address _stableVault,     uint256 _addMargin,     ERC20PermitData calldata _permitData,     address _trader )     external {     _validateProxy(_trader);     _checkOwner(_id, _trader);     _checkVault(_stableVault, _marginAsset);     IPosition.Trade memory _trade = position.trades(_id);     if (_trade.orderType != 0) revert(); //IsLimit     IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);     _handleDeposit(_trade.tigAsset, _marginAsset, _addMargin, _stableVault, _permitData, _trader);     unchecked {         uint256 _newMargin = _trade.margin + _addMargin;         uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;         if (_newLeverage &lt; asset.minLeverage) revert(""!lev"");         position.modifyMargin(_id, _newMargin, _newLeverage);         emit MarginModified(_id, _newMargin, _newLeverage, true, _trader);     } }  /**  * @param _id position id  * @param _stableVault StableVault address  * @param _outputToken token the trader will receive  * @param _removeMargin margin amount being removed from the position  * @param _priceData verifiable off-chain price data  * @param _signature node signature  * @param _trader address the trade is initiated for  */ function removeMargin(     uint256 _id,     address _stableVault,     address _outputToken,     uint256 _removeMargin,     PriceData calldata _priceData,     bytes calldata _signature,     address _trader )     external {     _validateProxy(_trader);     _checkOwner(_id, _trader);     _checkVault(_stableVault, _outputToken);     IPosition.Trade memory _trade = position.trades(_id);     if (_trade.orderType != 0) revert(); //IsLimit     IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);     uint256 _newMargin = _trade.margin - _removeMargin;     uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;     if (_newLeverage &gt; asset.maxLeverage) revert(""!lev"");     (uint _assetPrice,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);     (,int256 _payout) = TradingLibrary.pnl(_trade.direction, _assetPrice, _trade.price, _newMargin, _newLeverage, _trade.accInterest);     unchecked {         if (_payout &lt;= int256(_newMargin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert LiqThreshold();     }     position.modifyMargin(_trade.id, _newMargin, _newLeverage);     _handleWithdraw(_trade, _stableVault, _outputToken, _removeMargin);     emit MarginModified(_trade.id, _newMargin, _newLeverage, false, _trader); }  /**  * @param _type true for TP, false for SL  * @param _id position id  * @param _limitPrice TP/SL trigger price  * @param _priceData verifiable off-chain price data  * @param _signature node signature  * @param _trader address the trade is initiated for  */ function updateTpSl(     bool _type,     uint _id,     uint _limitPrice,     PriceData calldata _priceData,     bytes calldata _signature,     address _trader )     external {     _validateProxy(_trader);     _checkOwner(_id, _trader);     IPosition.Trade memory _trade = position.trades(_id);     if (_trade.orderType != 0) revert(""4""); //IsLimit     if (_type) {         position.modifyTp(_id, _limitPrice);     } else {         (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);         _checkSl(_limitPrice, _trade.direction, _price);         position.modifySl(_id, _limitPrice);     }     emit UpdateTPSL(_id, _type, _limitPrice, _trader); }  /**  * @param _id position id  * @param _priceData verifiable off-chain price data  * @param _signature node signature  */ function executeLimitOrder(     uint _id,      PriceData calldata _priceData,     bytes calldata _signature )      external {     unchecked {         _checkDelay(_id, true);         tradingExtension._checkGas();         if (tradingExtension.paused()) revert TradingPaused();         require(block.timestamp &gt;= limitDelay[_id]);         IPosition.Trade memory trade = position.trades(_id);         uint _fee = _handleOpenFees(trade.asset, trade.margin*trade.leverage/1e18, trade.trader, trade.tigAsset, true);         (uint256 _price, uint256 _spread) = tradingExtension.getVerifiedPrice(trade.asset, _priceData, _signature, 0);         if (trade.orderType == 0) revert(""5"");         if (_price &gt; trade.price+trade.price*limitOrderPriceRange/DIVISION_CONSTANT || _price &lt; trade.price-trade.price*limitOrderPriceRange/DIVISION_CONSTANT) revert(""6""); //LimitNotMet         if (trade.direction &amp;&amp; trade.orderType == 1) {             if (trade.price &lt; _price) revert(""6""); //LimitNotMet         } else if (!trade.direction &amp;&amp; trade.orderType == 1) {             if (trade.price &gt; _price) revert(""6""); //LimitNotMet         } else if (!trade.direction &amp;&amp; trade.orderType == 2) {             if (trade.price &lt; _price) revert(""6""); //LimitNotMet             trade.price = _price;         } else {             if (trade.price &gt; _price) revert(""6""); //LimitNotMet             trade.price = _price;         }          if(trade.direction) {             trade.price += trade.price * _spread / DIVISION_CONSTANT;         } else {             trade.price -= trade.price * _spread / DIVISION_CONSTANT;         }         if (trade.direction) {             tradingExtension.modifyLongOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);         } else {             tradingExtension.modifyShortOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);         }         _updateFunding(trade.asset, trade.tigAsset);         position.executeLimitOrder(_id, trade.price, trade.margin - _fee);         emit LimitOrderExecuted(trade.asset, trade.direction, trade.price, trade.leverage, trade.margin - _fee, _id, trade.trader, _msgSender());     } }  /**  * @notice liquidate position  * @param _id id of the position NFT  * @param _priceData verifiable off-chain data  * @param _signature node signature  */ function liquidatePosition(     uint _id,     PriceData calldata _priceData,     bytes calldata _signature )     external {     unchecked {         tradingExtension._checkGas();         IPosition.Trade memory _trade = position.trades(_id);         if (_trade.orderType != 0) revert(""4""); //IsLimit          (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);         (uint256 _positionSizeAfterPrice, int256 _payout) = TradingLibrary.pnl(_trade.direction, _price, _trade.price, _trade.margin, _trade.leverage, _trade.accInterest);         uint256 _positionSize = _trade.margin*_trade.leverage/1e18;         if (_payout &gt; int256(_trade.margin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert NotLiquidatable();         if (_trade.direction) {             tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, false, _positionSize);         } else {             tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, false, _positionSize);         }         _updateFunding(_trade.asset, _trade.tigAsset);         _handleCloseFees(_trade.asset, type(uint).max, _trade.tigAsset, _positionSizeAfterPrice, _trade.trader, true);         position.burn(_id);         emit PositionLiquidated(_id, _trade.trader, _msgSender());     } }  /**  * @dev close position at a pre-set price  * @param _id id of the position NFT  * @param _tp true if take profit  * @param _priceData verifiable off-chain price data  * @param _signature node signature  */ function limitClose(     uint _id,     bool _tp,     PriceData calldata _priceData,     bytes calldata _signature )     external {     _checkDelay(_id, false);     (uint _limitPrice, address _tigAsset) = tradingExtension._limitClose(_id, _tp, _priceData, _signature);     _closePosition(_id, DIVISION_CONSTANT, _limitPrice, address(0), _tigAsset, true); }  /**  * @notice Trader can approve a proxy wallet address for it to trade on its behalf. Can also provide proxy wallet with gas.  * @param _proxy proxy wallet address  * @param _timestamp end timestamp of approval period  */ function approveProxy(address _proxy, uint256 _timestamp) external payable {     proxyApprovals[_msgSender()] = Proxy(         _proxy,         _timestamp     );     payable(_proxy).transfer(msg.value); }  // ===== INTERNAL FUNCTIONS =====  /**  * @dev close the initiated position.  * @param _id id of the position NFT  * @param _percent percent of the position being closed  * @param _price pair price  * @param _stableVault StableVault address  * @param _outputToken Token that trader will receive  * @param _isBot false if closed via market order  */ function _closePosition(     uint _id,     uint _percent,     uint _price,     address _stableVault,     address _outputToken,     bool _isBot )     internal {     (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout) = tradingExtension._closePosition(_id, _price, _percent);     position.setAccInterest(_id);     _updateFunding(_trade.asset, _trade.tigAsset);     if (_percent &lt; DIVISION_CONSTANT) {         if ((_trade.margin*_trade.leverage*(DIVISION_CONSTANT-_percent)/DIVISION_CONSTANT)/1e18 &lt; tradingExtension.minPos(_trade.tigAsset)) revert(""!size"");         position.reducePosition(_id, _percent);     } else {         position.burn(_id);     }     uint256 _toMint;     if (_payout &gt; 0) {         unchecked {             _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);             if (maxWinPercent &gt; 0 &amp;&amp; _toMint &gt; _trade.margin*maxWinPercent/DIVISION_CONSTANT) {                 _toMint = _trade.margin*maxWinPercent/DIVISION_CONSTANT;             }         }         _handleWithdraw(_trade, _stableVault, _outputToken, _toMint);     }     emit PositionClosed(_id, _price, _percent, _toMint, _trade.trader, _isBot ? _msgSender() : _trade.trader); }  /**  * @dev handle stablevault deposits for different trading functions  * @param _tigAsset tigAsset token address  * @param _marginAsset token being deposited into stablevault  * @param _margin amount being deposited  * @param _stableVault StableVault address  * @param _permitData Data for approval via permit  * @param _trader Trader address to take tokens from  */ function _handleDeposit(address _tigAsset, address _marginAsset, uint256 _margin, address _stableVault, ERC20PermitData calldata _permitData, address _trader) internal {     IStable tigAsset = IStable(_tigAsset);     if (_tigAsset != _marginAsset) {         if (_permitData.usePermit) {             ERC20Permit(_marginAsset).permit(_trader, address(this), _permitData.amount, _permitData.deadline, _permitData.v, _permitData.r, _permitData.s);         }         uint256 _balBefore = tigAsset.balanceOf(address(this));         uint _marginDecMultiplier = 10**(18-ExtendedIERC20(_marginAsset).decimals());         IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);         IERC20(_marginAsset).approve(_stableVault, type(uint).max);         IStableVault(_stableVault).deposit(_marginAsset, _margin/_marginDecMultiplier);         if (tigAsset.balanceOf(address(this)) != _balBefore + _margin) revert BadDeposit();         tigAsset.burnFrom(address(this), tigAsset.balanceOf(address(this)));     } else {         tigAsset.burnFrom(_trader, _margin);     }         }  /**  * @dev handle stablevault withdrawals for different trading functions  * @param _trade Position info  * @param _stableVault StableVault address  * @param _outputToken Output token address  * @param _toMint Amount of tigAsset minted to be used for withdrawal  */ function _handleWithdraw(IPosition.Trade memory _trade, address _stableVault, address _outputToken, uint _toMint) internal {     IStable(_trade.tigAsset).mintFor(address(this), _toMint);     if (_outputToken == _trade.tigAsset) {         IERC20(_outputToken).transfer(_trade.trader, _toMint);     } else {         uint256 _balBefore = IERC20(_outputToken).balanceOf(address(this));         IStableVault(_stableVault).withdraw(_outputToken, _toMint);         if (IERC20(_outputToken).balanceOf(address(this)) != _balBefore + _toMint/(10**(18-ExtendedIERC20(_outputToken).decimals()))) revert BadWithdraw();         IERC20(_outputToken).transfer(_trade.trader, IERC20(_outputToken).balanceOf(address(this)) - _balBefore);     }         }  /**  * @dev handle fees distribution for opening  * @param _asset asset id  * @param _positionSize position size  * @param _trader trader address  * @param _tigAsset tigAsset address  * @param _isBot false if opened via market order  * @return _feePaid total fees paid during opening  */ function _handleOpenFees(     uint _asset,     uint _positionSize,     address _trader,     address _tigAsset,     bool _isBot )     internal     returns (uint _feePaid) {     IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);     Fees memory _fees = openFees;     unchecked {         _fees.daoFees = _fees.daoFees * asset.feeMultiplier / DIVISION_CONSTANT;         _fees.burnFees = _fees.burnFees * asset.feeMultiplier / DIVISION_CONSTANT;         _fees.referralFees = _fees.referralFees * asset.feeMultiplier / DIVISION_CONSTANT;         _fees.botFees = _fees.botFees * asset.feeMultiplier / DIVISION_CONSTANT;     }     address _referrer = tradingExtension.getRef(_trader); //referrals.getReferral(referrals.getReferred(_trader));     if (_referrer != address(0)) {         unchecked {             IStable(_tigAsset).mintFor(                 _referrer,                 _positionSize                 * _fees.referralFees // get referral fee%                 / DIVISION_CONSTANT // divide by 100%             );         }         _fees.daoFees = _fees.daoFees - _fees.referralFees*2;     }     if (_isBot) {         unchecked {             IStable(_tigAsset).mintFor(                 _msgSender(),                 _positionSize                 * _fees.botFees // get bot fee%                 / DIVISION_CONSTANT // divide by 100%             );         }         _fees.daoFees = _fees.daoFees - _fees.botFees;     } else {         _fees.botFees = 0;     }     unchecked {         uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT;         _feePaid =             _positionSize             * (_fees.burnFees + _fees.botFees) // get total fee%             / DIVISION_CONSTANT // divide by 100%             + _daoFeesPaid;         emit FeesDistributed(             _tigAsset,             _daoFeesPaid,             _positionSize * _fees.burnFees / DIVISION_CONSTANT,             _referrer != address(0) ? _positionSize * _fees.referralFees / DIVISION_CONSTANT : 0,             _positionSize * _fees.botFees / DIVISION_CONSTANT,             _referrer         );         IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);     }     gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this))); }  /**  * @dev handle fees distribution for closing  * @param _asset asset id  * @param _payout payout to trader before fees  * @param _tigAsset margin asset  * @param _positionSize position size  * @param _trader trader address  * @param _isBot false if closed via market order  * @return payout_ payout to trader after fees  */ function _handleCloseFees(     uint _asset,     uint _payout,     address _tigAsset,     uint _positionSize,     address _trader,     bool _isBot )     internal     returns (uint payout_) {     IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);     Fees memory _fees = closeFees;     uint _daoFeesPaid;     uint _burnFeesPaid;     uint _referralFeesPaid;     unchecked {         _daoFeesPaid = (_positionSize*_fees.daoFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;         _burnFeesPaid = (_positionSize*_fees.burnFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;     }     uint _botFeesPaid;     address _referrer = tradingExtension.getRef(_trader);//referrals.getReferral(referrals.getReferred(_trader));     if (_referrer != address(0)) {         unchecked {             _referralFeesPaid = (_positionSize*_fees.referralFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;         }         IStable(_tigAsset).mintFor(             _referrer,             _referralFeesPaid         );          _daoFeesPaid = _daoFeesPaid-_referralFeesPaid*2;     }     if (_isBot) {         unchecked {             _botFeesPaid = (_positionSize*_fees.botFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;             IStable(_tigAsset).mintFor(                 _msgSender(),                 _botFeesPaid             );         }         _daoFeesPaid = _daoFeesPaid - _botFeesPaid;     }     emit FeesDistributed(_tigAsset, _daoFeesPaid, _burnFeesPaid, _referralFeesPaid, _botFeesPaid, _referrer);     payout_ = _payout - _daoFeesPaid - _burnFeesPaid - _botFeesPaid;     IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);     IStable(_tigAsset).approve(address(gov), type(uint).max);     gov.distribute(_tigAsset, _daoFeesPaid);     return payout_; }  /**  * @dev update funding rates after open interest changes  * @param _asset asset id  * @param _tigAsset tigAsset used for OI  */ function _updateFunding(uint256 _asset, address _tigAsset) internal {     position.updateFunding(         _asset,         _tigAsset,         pairsContract.idToOi(_asset, _tigAsset).longOi,         pairsContract.idToOi(_asset, _tigAsset).shortOi,         pairsContract.idToAsset(_asset).baseFundingRate,         vaultFundingPercent     ); }  /**  * @dev check that SL price is valid compared to market price  * @param _sl SL price  * @param _direction long/short  * @param _price market price  */ function _checkSl(uint _sl, bool _direction, uint _price) internal pure {     if (_direction) {         if (_sl &gt; _price) revert(""3""); //BadStopLoss     } else {         if (_sl &lt; _price &amp;&amp; _sl != 0) revert(""3""); //BadStopLoss     } }  /**  * @dev check that trader address owns the position  * @param _id position id  * @param _trader trader address  */ function _checkOwner(uint _id, address _trader) internal view {     if (position.ownerOf(_id) != _trader) revert(""2""); //NotPositionOwner    }  /**  * @notice Check that sufficient time has passed between opening and closing  * @dev This is to prevent profitable opening and closing in the same tx with two different prices in the ""valid signature pool"".  * @param _id position id  * @param _type true for opening, false for closing  */ function _checkDelay(uint _id, bool _type) internal {     unchecked {         Delay memory _delay = blockDelayPassed[_id];         if (_delay.actionType == _type) {             blockDelayPassed[_id].delay = block.number + blockDelay;         } else {             if (block.number &lt; _delay.delay) revert(""0""); //Wait             blockDelayPassed[_id].delay = block.number + blockDelay;             blockDelayPassed[_id].actionType = _type;         }     } }  /**  * @dev Check that the stablevault input is whitelisted and the margin asset is whitelisted in the vault  * @param _stableVault StableVault address  * @param _token Margin asset token address  */ function _checkVault(address _stableVault, address _token) internal view {     require(allowedVault[_stableVault], ""Unapproved stablevault"");     require(_token == IStableVault(_stableVault).stable() || IStableVault(_stableVault).allowed(_token), ""Token not approved in vault""); }  /**  * @dev Check that the trader has approved the proxy address to trade for it  * @param _trader Trader address  */ function _validateProxy(address _trader) internal view {     if (_trader != _msgSender()) {         Proxy memory _proxy = proxyApprovals[_trader];         require(_proxy.proxy == _msgSender() &amp;&amp; _proxy.time &gt;= block.timestamp, ""Proxy not approved"");     } }  // ===== GOVERNANCE-ONLY =====  /**  * @dev Sets block delay between opening and closing  * @notice In blocks not seconds  * @param _blockDelay delay amount  */ function setBlockDelay(     uint _blockDelay )     external     onlyOwner {     blockDelay = _blockDelay; }  /**  * @dev Whitelists a stablevault contract address  * @param _stableVault StableVault address  * @param _bool true if allowed  */ function setAllowedVault(     address _stableVault,     bool _bool )     external     onlyOwner {     allowedVault[_stableVault] = _bool; }  /**  * @dev Sets max payout % compared to margin  * @param _maxWinPercent payout %  */ function setMaxWinPercent(     uint _maxWinPercent )     external     onlyOwner {     maxWinPercent = _maxWinPercent; }  /**  * @dev Sets executable price range for limit orders  * @param _range price range in %  */ function setLimitOrderPriceRange(uint _range) external onlyOwner {     limitOrderPriceRange = _range; }  /**  * @dev Sets the fees for the trading protocol  * @param _open True if open fees are being set  * @param _daoFees Fees distributed to the DAO  * @param _burnFees Fees which get burned  * @param _referralFees Fees given to referrers  * @param _botFees Fees given to bots that execute limit orders  * @param _percent Percent of earned funding fees going to StableVault  */ function setFees(bool _open, uint _daoFees, uint _burnFees, uint _referralFees, uint _botFees, uint _percent) external onlyOwner {     unchecked {         require(_daoFees &gt;= _botFees+_referralFees*2);         if (_open) {             openFees.daoFees = _daoFees;             openFees.burnFees = _burnFees;             openFees.referralFees = _referralFees;             openFees.botFees = _botFees;         } else {             closeFees.daoFees = _daoFees;             closeFees.burnFees = _burnFees;             closeFees.referralFees = _referralFees;             closeFees.botFees = _botFees;                         }         require(_percent &lt;= DIVISION_CONSTANT);         vaultFundingPercent = _percent;     } }  /**  * @dev Sets the extension contract address for trading  * @param _ext extension contract address  */ function setTradingExtension(     address _ext ) external onlyOwner() {     tradingExtension = ITradingExtension(_ext); }  // ===== EVENTS =====  event PositionOpened(     TradeInfo _tradeInfo,     uint _orderType,     uint _price,     uint _id,     address _trader,     uint _marginAfterFees );  event PositionClosed(     uint _id,     uint _closePrice,     uint _percent,     uint _payout,     address _trader,     address _executor );  event PositionLiquidated(     uint _id,     address _trader,     address _executor );  event LimitOrderExecuted(     uint _asset,     bool _direction,     uint _openPrice,     uint _lev,     uint _margin,     uint _id,     address _trader,     address _executor );  event UpdateTPSL(     uint _id,     bool _isTp,     uint _price,     address _trader );  event LimitCancelled(     uint _id,     address _trader );  event MarginModified(     uint _id,     uint _newMargin,     uint _newLeverage,     bool _isMarginAdded,     address _trader );  event AddToPosition(     uint _id,     uint _newMargin,     uint _newPrice,     address _trader );  event FeesDistributed(     address _tigAsset,     uint _daoFees,     uint _burnFees,     uint _refFees,     uint _botFees,     address _referrer );  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-16-08 22:00:55 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: //SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import ""./utils/MetaContext.sol"";
import ""./interfaces/ITrading.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./interfaces/IPairsContract.sol"";
import ""./interfaces/IReferrals.sol"";
import ""./interfaces/IPosition.sol"";
import ""./interfaces/IGovNFT.sol"";
import ""./interfaces/IStableVault.sol"";
import ""./utils/TradingLibrary.sol"";

interface ITradingExtension {
    function getVerifiedPrice(
        uint _asset,
        PriceData calldata _priceData,
        bytes calldata _signature,
        uint _withSpreadIsLong
    ) external returns(uint256 _price, uint256 _spread);
    function getRef(
        address _trader
    ) external pure returns(address);
    function _setReferral(
        bytes32 _referral,
        address _trader
    ) external;
    function validateTrade(uint _asset, address _tigAsset, uint _margin, uint _leverage) external view;
    function isPaused() external view returns(bool);
    function minPos(address) external view returns(uint);
    function modifyLongOi(
        uint _asset,
        address _tigAsset,
        bool _onOpen,
        uint _size
    ) external;
    function modifyShortOi(
        uint _asset,
        address _tigAsset,
        bool _onOpen,
        uint _size
    ) external;
    function paused() external returns(bool);
    function _limitClose(
        uint _id,
        bool _tp,
        PriceData calldata _priceData,
        bytes calldata _signature
    ) external returns(uint _limitPrice, address _tigAsset);
    function _checkGas() external view;
    function _closePosition(
        uint _id,
        uint _price,
        uint _percent
    ) external returns (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout);
}

interface IStable is IERC20 {
    function burnFrom(address account, uint amount) external;
    function mintFor(address account, uint amount) external;
}

interface ExtendedIERC20 is IERC20 {
    function decimals() external view returns (uint);
}

interface ERC20Permit is IERC20 {
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}

contract Trading is MetaContext, ITrading {

    error LimitNotSet(); //7
    error NotLiquidatable();
    error TradingPaused();
    error BadDeposit();
    error BadWithdraw();
    error ValueNotEqualToMargin();
    error BadLeverage();
    error NotMargin();
    error NotAllowedPair();
    error BelowMinPositionSize();
    error BadClosePercent();
    error NoPrice();
    error LiqThreshold();

    uint constant private DIVISION_CONSTANT = 1e10; // 100%
    uint private constant liqPercent = 9e9; // 90%

    struct Fees {
        uint daoFees;
        uint burnFees;
        uint referralFees;
        uint botFees;
    }
    Fees public openFees = Fees(
        0,
        0,
        0,
        0
    );
    Fees public closeFees = Fees(
        0,
        0,
        0,
        0
    );
    uint public limitOrderPriceRange = 1e8; // 1%

    uint public maxWinPercent;
    uint public vaultFundingPercent;

    IPairsContract private pairsContract;
    IPosition private position;
    IGovNFT private gov;
    ITradingExtension private tradingExtension;

    struct Delay {
        uint delay; // Block number where delay ends
        bool actionType; // True for open, False for close
    }
    mapping(uint => Delay) public blockDelayPassed; // id => Delay
    uint public blockDelay;
    mapping(uint => uint) public limitDelay; // id => block.timestamp

    mapping(address => bool) public allowedVault;

    struct Proxy {
        address proxy;
        uint256 time;
    }

    mapping(address => Proxy) public proxyApprovals;

    constructor(
        address _position,
        address _gov,
        address _pairsContract
    )
    {
        position = IPosition(_position);
        gov = IGovNFT(_gov);
        pairsContract = IPairsContract(_pairsContract);
    }

    // ===== END-USER FUNCTIONS =====

    /**
     * @param _tradeInfo Trade info
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _permitData data and signature needed for token approval
     * @param _trader address the trade is initiated for
     */
    function initiateMarketOrder(
        TradeInfo calldata _tradeInfo,
        PriceData calldata _priceData,
        bytes calldata _signature,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkDelay(position.getCount(), true);
        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);
        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();
        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);
        tradingExtension._setReferral(_tradeInfo.referral, _trader);
        uint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false);
        uint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;
        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);
        uint256 _isLong = _tradeInfo.direction ? 1 : 2;
        (uint256 _price,) = tradingExtension.getVerifiedPrice(_tradeInfo.asset, _priceData, _signature, _isLong);
        IPosition.MintTrade memory _mintTrade = IPosition.MintTrade(
            _trader,
            _marginAfterFees,
            _tradeInfo.leverage,
            _tradeInfo.asset,
            _tradeInfo.direction,
            _price,
            _tradeInfo.tpPrice,
            _tradeInfo.slPrice,
            0,
            _tigAsset
        );
        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);
        unchecked {
            if (_tradeInfo.direction) {
                tradingExtension.modifyLongOi(_tradeInfo.asset, _tigAsset, true, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_tradeInfo.asset, _tigAsset, true, _positionSize);
            }
        }
        _updateFunding(_tradeInfo.asset, _tigAsset);
        position.mint(
            _mintTrade
        );
        unchecked {
            emit PositionOpened(_tradeInfo, 0, _price, position.getCount()-1, _trader, _marginAfterFees);
        }   
    }

    /**
     * @dev initiate closing position
     * @param _id id of the position NFT
     * @param _percent percent of the position being closed in BP
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _stableVault StableVault address
     * @param _outputToken Token received upon closing trade
     * @param _trader address the trade is initiated for
     */
    function initiateCloseOrder(
        uint _id,
        uint _percent,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _stableVault,
        address _outputToken,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkDelay(_id, false);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _outputToken);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(""4""); //IsLimit        
        (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);

        if (_percent > DIVISION_CONSTANT || _percent == 0) revert BadClosePercent();
        _closePosition(_id, _percent, _price, _stableVault, _outputToken, false); 
    }

    /**
     * @param _id position id
     * @param _addMargin margin amount used to add to the position
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _stableVault StableVault address
     * @param _marginAsset Token being used to add to the position
     * @param _permitData data and signature needed for token approval
     * @param _trader address the trade is initiated for
     */
    function addToPosition(
        uint _id,
        uint _addMargin,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _stableVault,
        address _marginAsset,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkDelay(_id, true);
        IPosition.Trade memory _trade = position.trades(_id);
        tradingExtension.validateTrade(_trade.asset, _trade.tigAsset, _trade.margin + _addMargin, _trade.leverage);
        _checkVault(_stableVault, _marginAsset);
        if (_trade.orderType != 0) revert(""4""); //IsLimit
        uint _fee = _handleOpenFees(_trade.asset, _addMargin*_trade.leverage/1e18, _trader, _trade.tigAsset, false);
        _handleDeposit(
            _trade.tigAsset,
            _marginAsset,
            _addMargin - _fee,
            _stableVault,
            _permitData,
            _trader
        );
        position.setAccInterest(_id);
        unchecked {
            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, _trade.direction ? 1 : 2);
            uint _positionSize = (_addMargin - _fee) * _trade.leverage / 1e18;
            if (_trade.direction) {
                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, true, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, true, _positionSize);     
            }
            _updateFunding(_trade.asset, _trade.tigAsset);
            _addMargin -= _fee;
            uint _newMargin = _trade.margin + _addMargin;
            uint _newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin;

            position.addToPosition(
                _trade.id,
                _newMargin,
                _newPrice
            );
            
            emit AddToPosition(_trade.id, _newMargin, _newPrice, _trade.trader);
        }
    }

    /**
     * @param _tradeInfo Trade info
     * @param _orderType type of limit order used to open the position
     * @param _price limit price
     * @param _permitData data and signature needed for token approval
     * @param _trader address the trade is initiated for
     */
    function initiateLimitOrder(
        TradeInfo calldata _tradeInfo,
        uint256 _orderType, // 1 limit, 2 stop
        uint256 _price,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();
        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);
        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);
        if (_orderType == 0) revert(""5"");
        if (_price == 0) revert NoPrice();
        tradingExtension._setReferral(_tradeInfo.referral, _trader);
        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);
        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);
        uint256 _id = position.getCount();
        position.mint(
            IPosition.MintTrade(
                _trader,
                _tradeInfo.margin,
                _tradeInfo.leverage,
                _tradeInfo.asset,
                _tradeInfo.direction,
                _price,
                _tradeInfo.tpPrice,
                _tradeInfo.slPrice,
                _orderType,
                _tigAsset
            )
        );
        limitDelay[_id] = block.timestamp + 4;
        emit PositionOpened(_tradeInfo, _orderType, _price, _id, _trader, _tradeInfo.margin);
    }

    /**
     * @param _id position ID
     * @param _trader address the trade is initiated for
     */
    function cancelLimitOrder(
        uint256 _id,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType == 0) revert();
        IStable(_trade.tigAsset).mintFor(_trader, _trade.margin);
        position.burn(_id);
        emit LimitCancelled(_id, _trader);
    }

    /**
     * @param _id position id
     * @param _marginAsset Token being used to add to the position
     * @param _stableVault StableVault address
     * @param _addMargin margin amount being added to the position
     * @param _permitData data and signature needed for token approval
     * @param _trader address the trade is initiated for
     */
    function addMargin(
        uint256 _id,
        address _marginAsset,
        address _stableVault,
        uint256 _addMargin,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _marginAsset);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(); //IsLimit
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);
        _handleDeposit(_trade.tigAsset, _marginAsset, _addMargin, _stableVault, _permitData, _trader);
        unchecked {
            uint256 _newMargin = _trade.margin + _addMargin;
            uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;
            if (_newLeverage < asset.minLeverage) revert(""!lev"");
            position.modifyMargin(_id, _newMargin, _newLeverage);
            emit MarginModified(_id, _newMargin, _newLeverage, true, _trader);
        }
    }

    /**
     * @param _id position id
     * @param _stableVault StableVault address
     * @param _outputToken token the trader will receive
     * @param _removeMargin margin amount being removed from the position
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _trader address the trade is initiated for
     */
    function removeMargin(
        uint256 _id,
        address _stableVault,
        address _outputToken,
        uint256 _removeMargin,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _outputToken);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(); //IsLimit
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);
        uint256 _newMargin = _trade.margin - _removeMargin;
        uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;
        if (_newLeverage > asset.maxLeverage) revert(""!lev"");
        (uint _assetPrice,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
        (,int256 _payout) = TradingLibrary.pnl(_trade.direction, _assetPrice, _trade.price, _newMargin, _newLeverage, _trade.accInterest);
        unchecked {
            if (_payout <= int256(_newMargin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert LiqThreshold();
        }
        position.modifyMargin(_trade.id, _newMargin, _newLeverage);
        _handleWithdraw(_trade, _stableVault, _outputToken, _removeMargin);
        emit MarginModified(_trade.id, _newMargin, _newLeverage, false, _trader);
    }

    /**
     * @param _type true for TP, false for SL
     * @param _id position id
     * @param _limitPrice TP/SL trigger price
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _trader address the trade is initiated for
     */
    function updateTpSl(
        bool _type,
        uint _id,
        uint _limitPrice,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(""4""); //IsLimit
        if (_type) {
            position.modifyTp(_id, _limitPrice);
        } else {
            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
            _checkSl(_limitPrice, _trade.direction, _price);
            position.modifySl(_id, _limitPrice);
        }
        emit UpdateTPSL(_id, _type, _limitPrice, _trader);
    }

    /**
     * @param _id position id
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     */
    function executeLimitOrder(
        uint _id, 
        PriceData calldata _priceData,
        bytes calldata _signature
    ) 
        external
    {
        unchecked {
            _checkDelay(_id, true);
            tradingExtension._checkGas();
            if (tradingExtension.paused()) revert TradingPaused();
            require(block.timestamp >= limitDelay[_id]);
            IPosition.Trade memory trade = position.trades(_id);
            uint _fee = _handleOpenFees(trade.asset, trade.margin*trade.leverage/1e18, trade.trader, trade.tigAsset, true);
            (uint256 _price, uint256 _spread) = tradingExtension.getVerifiedPrice(trade.asset, _priceData, _signature, 0);
            if (trade.orderType == 0) revert(""5"");
            if (_price > trade.price+trade.price*limitOrderPriceRange/DIVISION_CONSTANT || _price < trade.price-trade.price*limitOrderPriceRange/DIVISION_CONSTANT) revert(""6""); //LimitNotMet
            if (trade.direction && trade.orderType == 1) {
                if (trade.price < _price) revert(""6""); //LimitNotMet
            } else if (!trade.direction && trade.orderType == 1) {
                if (trade.price > _price) revert(""6""); //LimitNotMet
            } else if (!trade.direction && trade.orderType == 2) {
                if (trade.price < _price) revert(""6""); //LimitNotMet
                trade.price = _price;
            } else {
                if (trade.price > _price) revert(""6""); //LimitNotMet
                trade.price = _price;
            } 
            if(trade.direction) {
                trade.price += trade.price * _spread / DIVISION_CONSTANT;
            } else {
                trade.price -= trade.price * _spread / DIVISION_CONSTANT;
            }
            if (trade.direction) {
                tradingExtension.modifyLongOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);
            } else {
                tradingExtension.modifyShortOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);
            }
            _updateFunding(trade.asset, trade.tigAsset);
            position.executeLimitOrder(_id, trade.price, trade.margin - _fee);
            emit LimitOrderExecuted(trade.asset, trade.direction, trade.price, trade.leverage, trade.margin - _fee, _id, trade.trader, _msgSender());
        }
    }

    /**
     * @notice liquidate position
     * @param _id id of the position NFT
     * @param _priceData verifiable off-chain data
     * @param _signature node signature
     */
    function liquidatePosition(
        uint _id,
        PriceData calldata _priceData,
        bytes calldata _signature
    )
        external
    {
        unchecked {
            tradingExtension._checkGas();
            IPosition.Trade memory _trade = position.trades(_id);
            if (_trade.orderType != 0) revert(""4""); //IsLimit

            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
            (uint256 _positionSizeAfterPrice, int256 _payout) = TradingLibrary.pnl(_trade.direction, _price, _trade.price, _trade.margin, _trade.leverage, _trade.accInterest);
            uint256 _positionSize = _trade.margin*_trade.leverage/1e18;
            if (_payout > int256(_trade.margin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert NotLiquidatable();
            if (_trade.direction) {
                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, false, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, false, _positionSize);
            }
            _updateFunding(_trade.asset, _trade.tigAsset);
            _handleCloseFees(_trade.asset, type(uint).max, _trade.tigAsset, _positionSizeAfterPrice, _trade.trader, true);
            position.burn(_id);
            emit PositionLiquidated(_id, _trade.trader, _msgSender());
        }
    }

    /**
     * @dev close position at a pre-set price
     * @param _id id of the position NFT
     * @param _tp true if take profit
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     */
    function limitClose(
        uint _id,
        bool _tp,
        PriceData calldata _priceData,
        bytes calldata _signature
    )
        external
    {
        _checkDelay(_id, false);
        (uint _limitPrice, address _tigAsset) = tradingExtension._limitClose(_id, _tp, _priceData, _signature);
        _closePosition(_id, DIVISION_CONSTANT, _limitPrice, address(0), _tigAsset, true);
    }

    /**
     * @notice Trader can approve a proxy wallet address for it to trade on its behalf. Can also provide proxy wallet with gas.
     * @param _proxy proxy wallet address
     * @param _timestamp end timestamp of approval period
     */
    function approveProxy(address _proxy, uint256 _timestamp) external payable {
        proxyApprovals[_msgSender()] = Proxy(
            _proxy,
            _timestamp
        );
        payable(_proxy).transfer(msg.value);
    }

    // ===== INTERNAL FUNCTIONS =====

    /**
     * @dev close the initiated position.
     * @param _id id of the position NFT
     * @param _percent percent of the position being closed
     * @param _price pair price
     * @param _stableVault StableVault address
     * @param _outputToken Token that trader will receive
     * @param _isBot false if closed via market order
     */
    function _closePosition(
        uint _id,
        uint _percent,
        uint _price,
        address _stableVault,
        address _outputToken,
        bool _isBot
    )
        internal
    {
        (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout) = tradingExtension._closePosition(_id, _price, _percent);
        position.setAccInterest(_id);
        _updateFunding(_trade.asset, _trade.tigAsset);
        if (_percent < DIVISION_CONSTANT) {
            if ((_trade.margin*_trade.leverage*(DIVISION_CONSTANT-_percent)/DIVISION_CONSTANT)/1e18 < tradingExtension.minPos(_trade.tigAsset)) revert(""!size"");
            position.reducePosition(_id, _percent);
        } else {
            position.burn(_id);
        }
        uint256 _toMint;
        if (_payout > 0) {
            unchecked {
                _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);
                if (maxWinPercent > 0 && _toMint > _trade.margin*maxWinPercent/DIVISION_CONSTANT) {
                    _toMint = _trade.margin*maxWinPercent/DIVISION_CONSTANT;
                }
            }
            _handleWithdraw(_trade, _stableVault, _outputToken, _toMint);
        }
        emit PositionClosed(_id, _price, _percent, _toMint, _trade.trader, _isBot ? _msgSender() : _trade.trader);
    }

    /**
     * @dev handle stablevault deposits for different trading functions
     * @param _tigAsset tigAsset token address
     * @param _marginAsset token being deposited into stablevault
     * @param _margin amount being deposited
     * @param _stableVault StableVault address
     * @param _permitData Data for approval via permit
     * @param _trader Trader address to take tokens from
     */
    function _handleDeposit(address _tigAsset, address _marginAsset, uint256 _margin, address _stableVault, ERC20PermitData calldata _permitData, address _trader) internal {
        IStable tigAsset = IStable(_tigAsset);
        if (_tigAsset != _marginAsset) {
            if (_permitData.usePermit) {
                ERC20Permit(_marginAsset).permit(_trader, address(this), _permitData.amount, _permitData.deadline, _permitData.v, _permitData.r, _permitData.s);
            }
            uint256 _balBefore = tigAsset.balanceOf(address(this));
            uint _marginDecMultiplier = 10**(18-ExtendedIERC20(_marginAsset).decimals());
            IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);
            IERC20(_marginAsset).approve(_stableVault, type(uint).max);
            IStableVault(_stableVault).deposit(_marginAsset, _margin/_marginDecMultiplier);
            if (tigAsset.balanceOf(address(this)) != _balBefore + _margin) revert BadDeposit();
            tigAsset.burnFrom(address(this), tigAsset.balanceOf(address(this)));
        } else {
            tigAsset.burnFrom(_trader, _margin);
        }        
    }

    /**
     * @dev handle stablevault withdrawals for different trading functions
     * @param _trade Position info
     * @param _stableVault StableVault address
     * @param _outputToken Output token address
     * @param _toMint Amount of tigAsset minted to be used for withdrawal
     */
    function _handleWithdraw(IPosition.Trade memory _trade, address _stableVault, address _outputToken, uint _toMint) internal {
        IStable(_trade.tigAsset).mintFor(address(this), _toMint);
        if (_outputToken == _trade.tigAsset) {
            IERC20(_outputToken).transfer(_trade.trader, _toMint);
        } else {
            uint256 _balBefore = IERC20(_outputToken).balanceOf(address(this));
            IStableVault(_stableVault).withdraw(_outputToken, _toMint);
            if (IERC20(_outputToken).balanceOf(address(this)) != _balBefore + _toMint/(10**(18-ExtendedIERC20(_outputToken).decimals()))) revert BadWithdraw();
            IERC20(_outputToken).transfer(_trade.trader, IERC20(_outputToken).balanceOf(address(this)) - _balBefore);
        }        
    }

    /**
     * @dev handle fees distribution for opening
     * @param _asset asset id
     * @param _positionSize position size
     * @param _trader trader address
     * @param _tigAsset tigAsset address
     * @param _isBot false if opened via market order
     * @return _feePaid total fees paid during opening
     */
    function _handleOpenFees(
        uint _asset,
        uint _positionSize,
        address _trader,
        address _tigAsset,
        bool _isBot
    )
        internal
        returns (uint _feePaid)
    {
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);
        Fees memory _fees = openFees;
        unchecked {
            _fees.daoFees = _fees.daoFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.burnFees = _fees.burnFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.referralFees = _fees.referralFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.botFees = _fees.botFees * asset.feeMultiplier / DIVISION_CONSTANT;
        }
        address _referrer = tradingExtension.getRef(_trader); //referrals.getReferral(referrals.getReferred(_trader));
        if (_referrer != address(0)) {
            unchecked {
                IStable(_tigAsset).mintFor(
                    _referrer,
                    _positionSize
                    * _fees.referralFees // get referral fee%
                    / DIVISION_CONSTANT // divide by 100%
                );
            }
            _fees.daoFees = _fees.daoFees - _fees.referralFees*2;
        }
        if (_isBot) {
            unchecked {
                IStable(_tigAsset).mintFor(
                    _msgSender(),
                    _positionSize
                    * _fees.botFees // get bot fee%
                    / DIVISION_CONSTANT // divide by 100%
                );
            }
            _fees.daoFees = _fees.daoFees - _fees.botFees;
        } else {
            _fees.botFees = 0;
        }
        unchecked {
            uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT;
            _feePaid =
                _positionSize
                * (_fees.burnFees + _fees.botFees) // get total fee%
                / DIVISION_CONSTANT // divide by 100%
                + _daoFeesPaid;
            emit FeesDistributed(
                _tigAsset,
                _daoFeesPaid,
                _positionSize * _fees.burnFees / DIVISION_CONSTANT,
                _referrer != address(0) ? _positionSize * _fees.referralFees / DIVISION_CONSTANT : 0,
                _positionSize * _fees.botFees / DIVISION_CONSTANT,
                _referrer
            );
            IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);
        }
        gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));
    }

    /**
     * @dev handle fees distribution for closing
     * @param _asset asset id
     * @param _payout payout to trader before fees
     * @param _tigAsset margin asset
     * @param _positionSize position size
     * @param _trader trader address
     * @param _isBot false if closed via market order
     * @return payout_ payout to trader after fees
     */
    function _handleCloseFees(
        uint _asset,
        uint _payout,
        address _tigAsset,
        uint _positionSize,
        address _trader,
        bool _isBot
    )
        internal
        returns (uint payout_)
    {
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);
        Fees memory _fees = closeFees;
        uint _daoFeesPaid;
        uint _burnFeesPaid;
        uint _referralFeesPaid;
        unchecked {
            _daoFeesPaid = (_positionSize*_fees.daoFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
            _burnFeesPaid = (_positionSize*_fees.burnFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
        }
        uint _botFeesPaid;
        address _referrer = tradingExtension.getRef(_trader);//referrals.getReferral(referrals.getReferred(_trader));
        if (_referrer != address(0)) {
            unchecked {
                _referralFeesPaid = (_positionSize*_fees.referralFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
            }
            IStable(_tigAsset).mintFor(
                _referrer,
                _referralFeesPaid
            );
             _daoFeesPaid = _daoFeesPaid-_referralFeesPaid*2;
        }
        if (_isBot) {
            unchecked {
                _botFeesPaid = (_positionSize*_fees.botFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
                IStable(_tigAsset).mintFor(
                    _msgSender(),
                    _botFeesPaid
                );
            }
            _daoFeesPaid = _daoFeesPaid - _botFeesPaid;
        }
        emit FeesDistributed(_tigAsset, _daoFeesPaid, _burnFeesPaid, _referralFeesPaid, _botFeesPaid, _referrer);
        payout_ = _payout - _daoFeesPaid - _burnFeesPaid - _botFeesPaid;
        IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);
        IStable(_tigAsset).approve(address(gov), type(uint).max);
        gov.distribute(_tigAsset, _daoFeesPaid);
        return payout_;
    }

    /**
     * @dev update funding rates after open interest changes
     * @param _asset asset id
     * @param _tigAsset tigAsset used for OI
     */
    function _updateFunding(uint256 _asset, address _tigAsset) internal {
        position.updateFunding(
            _asset,
            _tigAsset,
            pairsContract.idToOi(_asset, _tigAsset).longOi,
            pairsContract.idToOi(_asset, _tigAsset).shortOi,
            pairsContract.idToAsset(_asset).baseFundingRate,
            vaultFundingPercent
        );
    }

    /**
     * @dev check that SL price is valid compared to market price
     * @param _sl SL price
     * @param _direction long/short
     * @param _price market price
     */
    function _checkSl(uint _sl, bool _direction, uint _price) internal pure {
        if (_direction) {
            if (_sl > _price) revert(""3""); //BadStopLoss
        } else {
            if (_sl < _price && _sl != 0) revert(""3""); //BadStopLoss
        }
    }

    /**
     * @dev check that trader address owns the position
     * @param _id position id
     * @param _trader trader address
     */
    function _checkOwner(uint _id, address _trader) internal view {
        if (position.ownerOf(_id) != _trader) revert(""2""); //NotPositionOwner   
    }

    /**
     * @notice Check that sufficient time has passed between opening and closing
     * @dev This is to prevent profitable opening and closing in the same tx with two different prices in the ""valid signature pool"".
     * @param _id position id
     * @param _type true for opening, false for closing
     */
    function _checkDelay(uint _id, bool _type) internal {
        unchecked {
            Delay memory _delay = blockDelayPassed[_id];
            if (_delay.actionType == _type) {
                blockDelayPassed[_id].delay = block.number + blockDelay;
            } else {
                if (block.number < _delay.delay) revert(""0""); //Wait
                blockDelayPassed[_id].delay = block.number + blockDelay;
                blockDelayPassed[_id].actionType = _type;
            }
        }
    }

    /**
     * @dev Check that the stablevault input is whitelisted and the margin asset is whitelisted in the vault
     * @param _stableVault StableVault address
     * @param _token Margin asset token address
     */
    function _checkVault(address _stableVault, address _token) internal view {
        require(allowedVault[_stableVault], ""Unapproved stablevault"");
        require(_token == IStableVault(_stableVault).stable() || IStableVault(_stableVault).allowed(_token), ""Token not approved in vault"");
    }

    /**
     * @dev Check that the trader has approved the proxy address to trade for it
     * @param _trader Trader address
     */
    function _validateProxy(address _trader) internal view {
        if (_trader != _msgSender()) {
            Proxy memory _proxy = proxyApprovals[_trader];
            require(_proxy.proxy == _msgSender() && _proxy.time >= block.timestamp, ""Proxy not approved"");
        }
    }

    // ===== GOVERNANCE-ONLY =====

    /**
     * @dev Sets block delay between opening and closing
     * @notice In blocks not seconds
     * @param _blockDelay delay amount
     */
    function setBlockDelay(
        uint _blockDelay
    )
        external
        onlyOwner
    {
        blockDelay = _blockDelay;
    }

    /**
     * @dev Whitelists a stablevault contract address
     * @param _stableVault StableVault address
     * @param _bool true if allowed
     */
    function setAllowedVault(
        address _stableVault,
        bool _bool
    )
        external
        onlyOwner
    {
        allowedVault[_stableVault] = _bool;
    }

    /**
     * @dev Sets max payout % compared to margin
     * @param _maxWinPercent payout %
     */
    function setMaxWinPercent(
        uint _maxWinPercent
    )
        external
        onlyOwner
    {
        maxWinPercent = _maxWinPercent;
    }

    /**
     * @dev Sets executable price range for limit orders
     * @param _range price range in %
     */
    function setLimitOrderPriceRange(uint _range) external onlyOwner {
        limitOrderPriceRange = _range;
    }

    /**
     * @dev Sets the fees for the trading protocol
     * @param _open True if open fees are being set
     * @param _daoFees Fees distributed to the DAO
     * @param _burnFees Fees which get burned
     * @param _referralFees Fees given to referrers
     * @param _botFees Fees given to bots that execute limit orders
     * @param _percent Percent of earned funding fees going to StableVault
     */
    function setFees(bool _open, uint _daoFees, uint _burnFees, uint _referralFees, uint _botFees, uint _percent) external onlyOwner {
        unchecked {
            require(_daoFees >= _botFees+_referralFees*2);
            if (_open) {
                openFees.daoFees = _daoFees;
                openFees.burnFees = _burnFees;
                openFees.referralFees = _referralFees;
                openFees.botFees = _botFees;
            } else {
                closeFees.daoFees = _daoFees;
                closeFees.burnFees = _burnFees;
                closeFees.referralFees = _referralFees;
                closeFees.botFees = _botFees;                
            }
            require(_percent <= DIVISION_CONSTANT);
            vaultFundingPercent = _percent;
        }
    }

    /**
     * @dev Sets the extension contract address for trading
     * @param _ext extension contract address
     */
    function setTradingExtension(
        address _ext
    ) external onlyOwner() {
        tradingExtension = ITradingExtension(_ext);
    }

    // ===== EVENTS =====

    event PositionOpened(
        TradeInfo _tradeInfo,
        uint _orderType,
        uint _price,
        uint _id,
        address _trader,
        uint _marginAfterFees
    );

    event PositionClosed(
        uint _id,
        uint _closePrice,
        uint _percent,
        uint _payout,
        address _trader,
        address _executor
    );

    event PositionLiquidated(
        uint _id,
        address _trader,
        address _executor
    );

    event LimitOrderExecuted(
        uint _asset,
        bool _direction,
        uint _openPrice,
        uint _lev,
        uint _margin,
        uint _id,
        address _trader,
        address _executor
    );

    event UpdateTPSL(
        uint _id,
        bool _isTp,
        uint _price,
        address _trader
    );

    event LimitCancelled(
        uint _id,
        address _trader
    );

    event MarginModified(
        uint _id,
        uint _newMargin,
        uint _newLeverage,
        bool _isMarginAdded,
        address _trader
    );

    event AddToPosition(
        uint _id,
        uint _newMargin,
        uint _newPrice,
        address _trader
    );

    event FeesDistributed(
        address _tigAsset,
        uint _daoFees,
        uint _burnFees,
        uint _refFees,
        uint _botFees,
        address _referrer
    );
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import ""./utils/MetaContext.sol"";
import ""./interfaces/ITrading.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./interfaces/IPairsContract.sol"";
import ""./interfaces/IReferrals.sol"";
import ""./interfaces/IPosition.sol"";
import ""./interfaces/IGovNFT.sol"";
import ""./interfaces/IStableVault.sol"";
import ""./utils/TradingLibrary.sol"";

interface ITradingExtension {
    function getVerifiedPrice(
        uint _asset,
        PriceData calldata _priceData,
        bytes calldata _signature,
        uint _withSpreadIsLong
    ) external returns(uint256 _price, uint256 _spread);
    function getRef(
        address _trader
    ) external pure returns(address);
    function _setReferral(
        bytes32 _referral,
        address _trader
    ) external;
    function validateTrade(uint _asset, address _tigAsset, uint _margin, uint _leverage) external view;
    function isPaused() external view returns(bool);
    function minPos(address) external view returns(uint);
    function modifyLongOi(
        uint _asset,
        address _tigAsset,
        bool _onOpen,
        uint _size
    ) external;
    function modifyShortOi(
        uint _asset,
        address _tigAsset,
        bool _onOpen,
        uint _size
    ) external;
    function paused() external returns(bool);
    function _limitClose(
        uint _id,
        bool _tp,
        PriceData calldata _priceData,
        bytes calldata _signature
    ) external returns(uint _limitPrice, address _tigAsset);
    function _checkGas() external view;
    function _closePosition(
        uint _id,
        uint _price,
        uint _percent
    ) external returns (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout);
}

interface IStable is IERC20 {
    function burnFrom(address account, uint amount) external;
    function mintFor(address account, uint amount) external;
}

interface ExtendedIERC20 is IERC20 {
    function decimals() external view returns (uint);
}

interface ERC20Permit is IERC20 {
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}

contract Trading is MetaContext, ITrading {

    error LimitNotSet(); //7
    error NotLiquidatable();
    error TradingPaused();
    error BadDeposit();
    error BadWithdraw();
    error ValueNotEqualToMargin();
    error BadLeverage();
    error NotMargin();
    error NotAllowedPair();
    error BelowMinPositionSize();
    error BadClosePercent();
    error NoPrice();
    error LiqThreshold();

    uint constant private DIVISION_CONSTANT = 1e10; // 100%
    uint private constant liqPercent = 9e9; // 90%

    struct Fees {
        uint daoFees;
        uint burnFees;
        uint referralFees;
        uint botFees;
    }
    Fees public openFees = Fees(
        0,
        0,
        0,
        0
    );
    Fees public closeFees = Fees(
        0,
        0,
        0,
        0
    );
    uint public limitOrderPriceRange = 1e8; // 1%

    uint public maxWinPercent;
    uint public vaultFundingPercent;

    IPairsContract private pairsContract;
    IPosition private position;
    IGovNFT private gov;
    ITradingExtension private tradingExtension;

    struct Delay {
        uint delay; // Block number where delay ends
        bool actionType; // True for open, False for close
    }
    mapping(uint => Delay) public blockDelayPassed; // id => Delay
    uint public blockDelay;
    mapping(uint => uint) public limitDelay; // id => block.timestamp

    mapping(address => bool) public allowedVault;

    struct Proxy {
        address proxy;
        uint256 time;
    }

    mapping(address => Proxy) public proxyApprovals;

    constructor(
        address _position,
        address _gov,
        address _pairsContract
    )
    {
        position = IPosition(_position);
        gov = IGovNFT(_gov);
        pairsContract = IPairsContract(_pairsContract);
    }

    // ===== END-USER FUNCTIONS =====

    /**
     * @param _tradeInfo Trade info
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _permitData data and signature needed for token approval
     * @param _trader address the trade is initiated for
     */
    function initiateMarketOrder(
        TradeInfo calldata _tradeInfo,
        PriceData calldata _priceData,
        bytes calldata _signature,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkDelay(position.getCount(), true);
        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);
        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();
        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);
        tradingExtension._setReferral(_tradeInfo.referral, _trader);
        uint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false);
        uint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;
        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);
        uint256 _isLong = _tradeInfo.direction ? 1 : 2;
        (uint256 _price,) = tradingExtension.getVerifiedPrice(_tradeInfo.asset, _priceData, _signature, _isLong);
        IPosition.MintTrade memory _mintTrade = IPosition.MintTrade(
            _trader,
            _marginAfterFees,
            _tradeInfo.leverage,
            _tradeInfo.asset,
            _tradeInfo.direction,
            _price,
            _tradeInfo.tpPrice,
            _tradeInfo.slPrice,
            0,
            _tigAsset
        );
        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);
        unchecked {
            if (_tradeInfo.direction) {
                tradingExtension.modifyLongOi(_tradeInfo.asset, _tigAsset, true, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_tradeInfo.asset, _tigAsset, true, _positionSize);
            }
        }
        _updateFunding(_tradeInfo.asset, _tigAsset);
        position.mint(
            _mintTrade
        );
        unchecked {
            emit PositionOpened(_tradeInfo, 0, _price, position.getCount()-1, _trader, _marginAfterFees);
        }   
    }

    /**
     * @dev initiate closing position
     * @param _id id of the position NFT
     * @param _percent percent of the position being closed in BP
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _stableVault StableVault address
     * @param _outputToken Token received upon closing trade
     * @param _trader address the trade is initiated for
     */
    function initiateCloseOrder(
        uint _id,
        uint _percent,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _stableVault,
        address _outputToken,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkDelay(_id, false);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _outputToken);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(""4""); //IsLimit        
        (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);

        if (_percent > DIVISION_CONSTANT || _percent == 0) revert BadClosePercent();
        _closePosition(_id, _percent, _price, _stableVault, _outputToken, false); 
    }

    /**
     * @param _id position id
     * @param _addMargin margin amount used to add to the position
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _stableVault StableVault address
     * @param _marginAsset Token being used to add to the position
     * @param _permitData data and signature needed for token approval
     * @param _trader address the trade is initiated for
     */
    function addToPosition(
        uint _id,
        uint _addMargin,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _stableVault,
        address _marginAsset,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkDelay(_id, true);
        IPosition.Trade memory _trade = position.trades(_id);
        tradingExtension.validateTrade(_trade.asset, _trade.tigAsset, _trade.margin + _addMargin, _trade.leverage);
        _checkVault(_stableVault, _marginAsset);
        if (_trade.orderType != 0) revert(""4""); //IsLimit
        uint _fee = _handleOpenFees(_trade.asset, _addMargin*_trade.leverage/1e18, _trader, _trade.tigAsset, false);
        _handleDeposit(
            _trade.tigAsset,
            _marginAsset,
            _addMargin - _fee,
            _stableVault,
            _permitData,
            _trader
        );
        position.setAccInterest(_id);
        unchecked {
            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, _trade.direction ? 1 : 2);
            uint _positionSize = (_addMargin - _fee) * _trade.leverage / 1e18;
            if (_trade.direction) {
                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, true, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, true, _positionSize);     
            }
            _updateFunding(_trade.asset, _trade.tigAsset);
            _addMargin -= _fee;
            uint _newMargin = _trade.margin + _addMargin;
            uint _newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin;

            position.addToPosition(
                _trade.id,
                _newMargin,
                _newPrice
            );
            
            emit AddToPosition(_trade.id, _newMargin, _newPrice, _trade.trader);
        }
    }

    /**
     * @param _tradeInfo Trade info
     * @param _orderType type of limit order used to open the position
     * @param _price limit price
     * @param _permitData data and signature needed for token approval
     * @param _trader address the trade is initiated for
     */
    function initiateLimitOrder(
        TradeInfo calldata _tradeInfo,
        uint256 _orderType, // 1 limit, 2 stop
        uint256 _price,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();
        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);
        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);
        if (_orderType == 0) revert(""5"");
        if (_price == 0) revert NoPrice();
        tradingExtension._setReferral(_tradeInfo.referral, _trader);
        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);
        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);
        uint256 _id = position.getCount();
        position.mint(
            IPosition.MintTrade(
                _trader,
                _tradeInfo.margin,
                _tradeInfo.leverage,
                _tradeInfo.asset,
                _tradeInfo.direction,
                _price,
                _tradeInfo.tpPrice,
                _tradeInfo.slPrice,
                _orderType,
                _tigAsset
            )
        );
        limitDelay[_id] = block.timestamp + 4;
        emit PositionOpened(_tradeInfo, _orderType, _price, _id, _trader, _tradeInfo.margin);
    }

    /**
     * @param _id position ID
     * @param _trader address the trade is initiated for
     */
    function cancelLimitOrder(
        uint256 _id,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType == 0) revert();
        IStable(_trade.tigAsset).mintFor(_trader, _trade.margin);
        position.burn(_id);
        emit LimitCancelled(_id, _trader);
    }

    /**
     * @param _id position id
     * @param _marginAsset Token being used to add to the position
     * @param _stableVault StableVault address
     * @param _addMargin margin amount being added to the position
     * @param _permitData data and signature needed for token approval
     * @param _trader address the trade is initiated for
     */
    function addMargin(
        uint256 _id,
        address _marginAsset,
        address _stableVault,
        uint256 _addMargin,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _marginAsset);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(); //IsLimit
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);
        _handleDeposit(_trade.tigAsset, _marginAsset, _addMargin, _stableVault, _permitData, _trader);
        unchecked {
            uint256 _newMargin = _trade.margin + _addMargin;
            uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;
            if (_newLeverage < asset.minLeverage) revert(""!lev"");
            position.modifyMargin(_id, _newMargin, _newLeverage);
            emit MarginModified(_id, _newMargin, _newLeverage, true, _trader);
        }
    }

    /**
     * @param _id position id
     * @param _stableVault StableVault address
     * @param _outputToken token the trader will receive
     * @param _removeMargin margin amount being removed from the position
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _trader address the trade is initiated for
     */
    function removeMargin(
        uint256 _id,
        address _stableVault,
        address _outputToken,
        uint256 _removeMargin,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _outputToken);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(); //IsLimit
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);
        uint256 _newMargin = _trade.margin - _removeMargin;
        uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;
        if (_newLeverage > asset.maxLeverage) revert(""!lev"");
        (uint _assetPrice,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
        (,int256 _payout) = TradingLibrary.pnl(_trade.direction, _assetPrice, _trade.price, _newMargin, _newLeverage, _trade.accInterest);
        unchecked {
            if (_payout <= int256(_newMargin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert LiqThreshold();
        }
        position.modifyMargin(_trade.id, _newMargin, _newLeverage);
        _handleWithdraw(_trade, _stableVault, _outputToken, _removeMargin);
        emit MarginModified(_trade.id, _newMargin, _newLeverage, false, _trader);
    }

    /**
     * @param _type true for TP, false for SL
     * @param _id position id
     * @param _limitPrice TP/SL trigger price
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _trader address the trade is initiated for
     */
    function updateTpSl(
        bool _type,
        uint _id,
        uint _limitPrice,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(""4""); //IsLimit
        if (_type) {
            position.modifyTp(_id, _limitPrice);
        } else {
            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
            _checkSl(_limitPrice, _trade.direction, _price);
            position.modifySl(_id, _limitPrice);
        }
        emit UpdateTPSL(_id, _type, _limitPrice, _trader);
    }

    /**
     * @param _id position id
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     */
    function executeLimitOrder(
        uint _id, 
        PriceData calldata _priceData,
        bytes calldata _signature
    ) 
        external
    {
        unchecked {
            _checkDelay(_id, true);
            tradingExtension._checkGas();
            if (tradingExtension.paused()) revert TradingPaused();
            require(block.timestamp >= limitDelay[_id]);
            IPosition.Trade memory trade = position.trades(_id);
            uint _fee = _handleOpenFees(trade.asset, trade.margin*trade.leverage/1e18, trade.trader, trade.tigAsset, true);
            (uint256 _price, uint256 _spread) = tradingExtension.getVerifiedPrice(trade.asset, _priceData, _signature, 0);
            if (trade.orderType == 0) revert(""5"");
            if (_price > trade.price+trade.price*limitOrderPriceRange/DIVISION_CONSTANT || _price < trade.price-trade.price*limitOrderPriceRange/DIVISION_CONSTANT) revert(""6""); //LimitNotMet
            if (trade.direction && trade.orderType == 1) {
                if (trade.price < _price) revert(""6""); //LimitNotMet
            } else if (!trade.direction && trade.orderType == 1) {
                if (trade.price > _price) revert(""6""); //LimitNotMet
            } else if (!trade.direction && trade.orderType == 2) {
                if (trade.price < _price) revert(""6""); //LimitNotMet
                trade.price = _price;
            } else {
                if (trade.price > _price) revert(""6""); //LimitNotMet
                trade.price = _price;
            } 
            if(trade.direction) {
                trade.price += trade.price * _spread / DIVISION_CONSTANT;
            } else {
                trade.price -= trade.price * _spread / DIVISION_CONSTANT;
            }
            if (trade.direction) {
                tradingExtension.modifyLongOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);
            } else {
                tradingExtension.modifyShortOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);
            }
            _updateFunding(trade.asset, trade.tigAsset);
            position.executeLimitOrder(_id, trade.price, trade.margin - _fee);
            emit LimitOrderExecuted(trade.asset, trade.direction, trade.price, trade.leverage, trade.margin - _fee, _id, trade.trader, _msgSender());
        }
    }

    /**
     * @notice liquidate position
     * @param _id id of the position NFT
     * @param _priceData verifiable off-chain data
     * @param _signature node signature
     */
    function liquidatePosition(
        uint _id,
        PriceData calldata _priceData,
        bytes calldata _signature
    )
        external
    {
        unchecked {
            tradingExtension._checkGas();
            IPosition.Trade memory _trade = position.trades(_id);
            if (_trade.orderType != 0) revert(""4""); //IsLimit

            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
            (uint256 _positionSizeAfterPrice, int256 _payout) = TradingLibrary.pnl(_trade.direction, _price, _trade.price, _trade.margin, _trade.leverage, _trade.accInterest);
            uint256 _positionSize = _trade.margin*_trade.leverage/1e18;
            if (_payout > int256(_trade.margin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert NotLiquidatable();
            if (_trade.direction) {
                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, false, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, false, _positionSize);
            }
            _updateFunding(_trade.asset, _trade.tigAsset);
            _handleCloseFees(_trade.asset, type(uint).max, _trade.tigAsset, _positionSizeAfterPrice, _trade.trader, true);
            position.burn(_id);
            emit PositionLiquidated(_id, _trade.trader, _msgSender());
        }
    }

    /**
     * @dev close position at a pre-set price
     * @param _id id of the position NFT
     * @param _tp true if take profit
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     */
    function limitClose(
        uint _id,
        bool _tp,
        PriceData calldata _priceData,
        bytes calldata _signature
    )
        external
    {
        _checkDelay(_id, false);
        (uint _limitPrice, address _tigAsset) = tradingExtension._limitClose(_id, _tp, _priceData, _signature);
        _closePosition(_id, DIVISION_CONSTANT, _limitPrice, address(0), _tigAsset, true);
    }

    /**
     * @notice Trader can approve a proxy wallet address for it to trade on its behalf. Can also provide proxy wallet with gas.
     * @param _proxy proxy wallet address
     * @param _timestamp end timestamp of approval period
     */
    function approveProxy(address _proxy, uint256 _timestamp) external payable {
        proxyApprovals[_msgSender()] = Proxy(
            _proxy,
            _timestamp
        );
        payable(_proxy).transfer(msg.value);
    }

    // ===== INTERNAL FUNCTIONS =====

    /**
     * @dev close the initiated position.
     * @param _id id of the position NFT
     * @param _percent percent of the position being closed
     * @param _price pair price
     * @param _stableVault StableVault address
     * @param _outputToken Token that trader will receive
     * @param _isBot false if closed via market order
     */
    function _closePosition(
        uint _id,
        uint _percent,
        uint _price,
        address _stableVault,
        address _outputToken,
        bool _isBot
    )
        internal
    {
        (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout) = tradingExtension._closePosition(_id, _price, _percent);
        position.setAccInterest(_id);
        _updateFunding(_trade.asset, _trade.tigAsset);
        if (_percent < DIVISION_CONSTANT) {
            if ((_trade.margin*_trade.leverage*(DIVISION_CONSTANT-_percent)/DIVISION_CONSTANT)/1e18 < tradingExtension.minPos(_trade.tigAsset)) revert(""!size"");
            position.reducePosition(_id, _percent);
        } else {
            position.burn(_id);
        }
        uint256 _toMint;
        if (_payout > 0) {
            unchecked {
                _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);
                if (maxWinPercent > 0 && _toMint > _trade.margin*maxWinPercent/DIVISION_CONSTANT) {
                    _toMint = _trade.margin*maxWinPercent/DIVISION_CONSTANT;
                }
            }
            _handleWithdraw(_trade, _stableVault, _outputToken, _toMint);
        }
        emit PositionClosed(_id, _price, _percent, _toMint, _trade.trader, _isBot ? _msgSender() : _trade.trader);
    }

    /**
     * @dev handle stablevault deposits for different trading functions
     * @param _tigAsset tigAsset token address
     * @param _marginAsset token being deposited into stablevault
     * @param _margin amount being deposited
     * @param _stableVault StableVault address
     * @param _permitData Data for approval via permit
     * @param _trader Trader address to take tokens from
     */
    function _handleDeposit(address _tigAsset, address _marginAsset, uint256 _margin, address _stableVault, ERC20PermitData calldata _permitData, address _trader) internal {
        IStable tigAsset = IStable(_tigAsset);
        if (_tigAsset != _marginAsset) {
            if (_permitData.usePermit) {
                ERC20Permit(_marginAsset).permit(_trader, address(this), _permitData.amount, _permitData.deadline, _permitData.v, _permitData.r, _permitData.s);
            }
            uint256 _balBefore = tigAsset.balanceOf(address(this));
            uint _marginDecMultiplier = 10**(18-ExtendedIERC20(_marginAsset).decimals());
            IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);
            IERC20(_marginAsset).approve(_stableVault, type(uint).max);
            IStableVault(_stableVault).deposit(_marginAsset, _margin/_marginDecMultiplier);
            if (tigAsset.balanceOf(address(this)) != _balBefore + _margin) revert BadDeposit();
            tigAsset.burnFrom(address(this), tigAsset.balanceOf(address(this)));
        } else {
            tigAsset.burnFrom(_trader, _margin);
        }        
    }

    /**
     * @dev handle stablevault withdrawals for different trading functions
     * @param _trade Position info
     * @param _stableVault StableVault address
     * @param _outputToken Output token address
     * @param _toMint Amount of tigAsset minted to be used for withdrawal
     */
    function _handleWithdraw(IPosition.Trade memory _trade, address _stableVault, address _outputToken, uint _toMint) internal {
        IStable(_trade.tigAsset).mintFor(address(this), _toMint);
        if (_outputToken == _trade.tigAsset) {
            IERC20(_outputToken).transfer(_trade.trader, _toMint);
        } else {
            uint256 _balBefore = IERC20(_outputToken).balanceOf(address(this));
            IStableVault(_stableVault).withdraw(_outputToken, _toMint);
            if (IERC20(_outputToken).balanceOf(address(this)) != _balBefore + _toMint/(10**(18-ExtendedIERC20(_outputToken).decimals()))) revert BadWithdraw();
            IERC20(_outputToken).transfer(_trade.trader, IERC20(_outputToken).balanceOf(address(this)) - _balBefore);
        }        
    }

    /**
     * @dev handle fees distribution for opening
     * @param _asset asset id
     * @param _positionSize position size
     * @param _trader trader address
     * @param _tigAsset tigAsset address
     * @param _isBot false if opened via market order
     * @return _feePaid total fees paid during opening
     */
    function _handleOpenFees(
        uint _asset,
        uint _positionSize,
        address _trader,
        address _tigAsset,
        bool _isBot
    )
        internal
        returns (uint _feePaid)
    {
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);
        Fees memory _fees = openFees;
        unchecked {
            _fees.daoFees = _fees.daoFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.burnFees = _fees.burnFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.referralFees = _fees.referralFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.botFees = _fees.botFees * asset.feeMultiplier / DIVISION_CONSTANT;
        }
        address _referrer = tradingExtension.getRef(_trader); //referrals.getReferral(referrals.getReferred(_trader));
        if (_referrer != address(0)) {
            unchecked {
                IStable(_tigAsset).mintFor(
                    _referrer,
                    _positionSize
                    * _fees.referralFees // get referral fee%
                    / DIVISION_CONSTANT // divide by 100%
                );
            }
            _fees.daoFees = _fees.daoFees - _fees.referralFees*2;
        }
        if (_isBot) {
            unchecked {
                IStable(_tigAsset).mintFor(
                    _msgSender(),
                    _positionSize
                    * _fees.botFees // get bot fee%
                    / DIVISION_CONSTANT // divide by 100%
                );
            }
            _fees.daoFees = _fees.daoFees - _fees.botFees;
        } else {
            _fees.botFees = 0;
        }
        unchecked {
            uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT;
            _feePaid =
                _positionSize
                * (_fees.burnFees + _fees.botFees) // get total fee%
                / DIVISION_CONSTANT // divide by 100%
                + _daoFeesPaid;
            emit FeesDistributed(
                _tigAsset,
                _daoFeesPaid,
                _positionSize * _fees.burnFees / DIVISION_CONSTANT,
                _referrer != address(0) ? _positionSize * _fees.referralFees / DIVISION_CONSTANT : 0,
                _positionSize * _fees.botFees / DIVISION_CONSTANT,
                _referrer
            );
            IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);
        }
        gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));
    }

    /**
     * @dev handle fees distribution for closing
     * @param _asset asset id
     * @param _payout payout to trader before fees
     * @param _tigAsset margin asset
     * @param _positionSize position size
     * @param _trader trader address
     * @param _isBot false if closed via market order
     * @return payout_ payout to trader after fees
     */
    function _handleCloseFees(
        uint _asset,
        uint _payout,
        address _tigAsset,
        uint _positionSize,
        address _trader,
        bool _isBot
    )
        internal
        returns (uint payout_)
    {
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);
        Fees memory _fees = closeFees;
        uint _daoFeesPaid;
        uint _burnFeesPaid;
        uint _referralFeesPaid;
        unchecked {
            _daoFeesPaid = (_positionSize*_fees.daoFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
            _burnFeesPaid = (_positionSize*_fees.burnFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
        }
        uint _botFeesPaid;
        address _referrer = tradingExtension.getRef(_trader);//referrals.getReferral(referrals.getReferred(_trader));
        if (_referrer != address(0)) {
            unchecked {
                _referralFeesPaid = (_positionSize*_fees.referralFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
            }
            IStable(_tigAsset).mintFor(
                _referrer,
                _referralFeesPaid
            );
             _daoFeesPaid = _daoFeesPaid-_referralFeesPaid*2;
        }
        if (_isBot) {
            unchecked {
                _botFeesPaid = (_positionSize*_fees.botFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
                IStable(_tigAsset).mintFor(
                    _msgSender(),
                    _botFeesPaid
                );
            }
            _daoFeesPaid = _daoFeesPaid - _botFeesPaid;
        }
        emit FeesDistributed(_tigAsset, _daoFeesPaid, _burnFeesPaid, _referralFeesPaid, _botFeesPaid, _referrer);
        payout_ = _payout - _daoFeesPaid - _burnFeesPaid - _botFeesPaid;
        IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);
        IStable(_tigAsset).approve(address(gov), type(uint).max);
        gov.distribute(_tigAsset, _daoFeesPaid);
        return payout_;
    }

    /**
     * @dev update funding rates after open interest changes
     * @param _asset asset id
     * @param _tigAsset tigAsset used for OI
     */
    function _updateFunding(uint256 _asset, address _tigAsset) internal {
        position.updateFunding(
            _asset,
            _tigAsset,
            pairsContract.idToOi(_asset, _tigAsset).longOi,
            pairsContract.idToOi(_asset, _tigAsset).shortOi,
            pairsContract.idToAsset(_asset).baseFundingRate,
            vaultFundingPercent
        );
    }

    /**
     * @dev check that SL price is valid compared to market price
     * @param _sl SL price
     * @param _direction long/short
     * @param _price market price
     */
    function _checkSl(uint _sl, bool _direction, uint _price) internal pure {
        if (_direction) {
            if (_sl > _price) revert(""3""); //BadStopLoss
        } else {
            if (_sl < _price && _sl != 0) revert(""3""); //BadStopLoss
        }
    }

    /**
     * @dev check that trader address owns the position
     * @param _id position id
     * @param _trader trader address
     */
    function _checkOwner(uint _id, address _trader) internal view {
        if (position.ownerOf(_id) != _trader) revert(""2""); //NotPositionOwner   
    }

    /**
     * @notice Check that sufficient time has passed between opening and closing
     * @dev This is to prevent profitable opening and closing in the same tx with two different prices in the ""valid signature pool"".
     * @param _id position id
     * @param _type true for opening, false for closing
     */
    function _checkDelay(uint _id, bool _type) internal {
        unchecked {
            Delay memory _delay = blockDelayPassed[_id];
            if (_delay.actionType == _type) {
                blockDelayPassed[_id].delay = block.number + blockDelay;
            } else {
                if (block.number < _delay.delay) revert(""0""); //Wait
                blockDelayPassed[_id].delay = block.number + blockDelay;
                blockDelayPassed[_id].actionType = _type;
            }
        }
    }

    /**
     * @dev Check that the stablevault input is whitelisted and the margin asset is whitelisted in the vault
     * @param _stableVault StableVault address
     * @param _token Margin asset token address
     */
    function _checkVault(address _stableVault, address _token) internal view {
        require(allowedVault[_stableVault], ""Unapproved stablevault"");
        require(_token == IStableVault(_stableVault).stable() || IStableVault(_stableVault).allowed(_token), ""Token not approved in vault"");
    }

    /**
     * @dev Check that the trader has approved the proxy address to trade for it
     * @param _trader Trader address
     */
    function _validateProxy(address _trader) internal view {
        if (_trader != _msgSender()) {
            Proxy memory _proxy = proxyApprovals[_trader];
            require(_proxy.proxy == _msgSender() && _proxy.time >= block.timestamp, ""Proxy not approved"");
        }
    }

    // ===== GOVERNANCE-ONLY =====

    /**
     * @dev Sets block delay between opening and closing
     * @notice In blocks not seconds
     * @param _blockDelay delay amount
     */
    function setBlockDelay(
        uint _blockDelay
    )
        external
        onlyOwner
    {
        blockDelay = _blockDelay;
    }

    /**
     * @dev Whitelists a stablevault contract address
     * @param _stableVault StableVault address
     * @param _bool true if allowed
     */
    function setAllowedVault(
        address _stableVault,
        bool _bool
    )
        external
        onlyOwner
    {
        allowedVault[_stableVault] = _bool;
    }

    /**
     * @dev Sets max payout % compared to margin
     * @param _maxWinPercent payout %
     */
    function setMaxWinPercent(
        uint _maxWinPercent
    )
        external
        onlyOwner
    {
        maxWinPercent = _maxWinPercent;
    }

    /**
     * @dev Sets executable price range for limit orders
     * @param _range price range in %
     */
    function setLimitOrderPriceRange(uint _range) external onlyOwner {
        limitOrderPriceRange = _range;
    }

    /**
     * @dev Sets the fees for the trading protocol
     * @param _open True if open fees are being set
     * @param _daoFees Fees distributed to the DAO
     * @param _burnFees Fees which get burned
     * @param _referralFees Fees given to referrers
     * @param _botFees Fees given to bots that execute limit orders
     * @param _percent Percent of earned funding fees going to StableVault
     */
    function setFees(bool _open, uint _daoFees, uint _burnFees, uint _referralFees, uint _botFees, uint _percent) external onlyOwner {
        unchecked {
            require(_daoFees >= _botFees+_referralFees*2);
            if (_open) {
                openFees.daoFees = _daoFees;
                openFees.burnFees = _burnFees;
                openFees.referralFees = _referralFees;
                openFees.botFees = _botFees;
            } else {
                closeFees.daoFees = _daoFees;
                closeFees.burnFees = _burnFees;
                closeFees.referralFees = _referralFees;
                closeFees.botFees = _botFees;                
            }
            require(_percent <= DIVISION_CONSTANT);
            vaultFundingPercent = _percent;
        }
    }

    /**
     * @dev Sets the extension contract address for trading
     * @param _ext extension contract address
     */
    function setTradingExtension(
        address _ext
    ) external onlyOwner() {
        tradingExtension = ITradingExtension(_ext);
    }

    // ===== EVENTS =====

    event PositionOpened(
        TradeInfo _tradeInfo,
        uint _orderType,
        uint _price,
        uint _id,
        address _trader,
        uint _marginAfterFees
    );

    event PositionClosed(
        uint _id,
        uint _closePrice,
        uint _percent,
        uint _payout,
        address _trader,
        address _executor
    );

    event PositionLiquidated(
        uint _id,
        address _trader,
        address _executor
    );

    event LimitOrderExecuted(
        uint _asset,
        bool _direction,
        uint _openPrice,
        uint _lev,
        uint _margin,
        uint _id,
        address _trader,
        address _executor
    );

    event UpdateTPSL(
        uint _id,
        bool _isTp,
        uint _price,
        address _trader
    );

    event LimitCancelled(
        uint _id,
        address _trader
    );

    event MarginModified(
        uint _id,
        uint _newMargin,
        uint _newLeverage,
        bool _isMarginAdded,
        address _trader
    );

    event AddToPosition(
        uint _id,
        uint _newMargin,
        uint _newPrice,
        address _trader
    );

    event FeesDistributed(
        address _tigAsset,
        uint _daoFees,
        uint _burnFees,
        uint _refFees,
        uint _botFees,
        address _referrer
    );
}
"".
Ideas: "" Unchecked Low-level Calls Identified.

```
UNCHECKED LOW-LEVEL CALL
'''
In the function `_handleDeposit`, the contract performs a low-level call to `IERC20(_marginAsset).transferFrom(...)` without checking if the call was successful. If the transfer fails (for example, due to insufficient balance or allowance), the contract will continue executing without reverting, potentially leading to unexpected states or loss of funds.

Recommended Mitigation/Fix:
Add a require statement to check the success of the transfer operation:
```solidity
bool success = IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);
require(success, ""Transfer failed"");
```
'''
```

```
UNCHECKED LOW-LEVEL CALL
'''
In the function `_handleWithdraw`, the contract calls `IStableVault(_stableVault).withdraw(...)` without checking if the withdrawal was successful. If the withdrawal fails, the contract will not revert, which could lead to inconsistencies in the state of the contract and potential loss of funds.

Recommended Mitigation/Fix:
Add a require statement to check the success of the withdrawal operation:
```solidity
bool success = IStableVault(_stableVault).withdraw(_outputToken, _toMint);
require(success, ""Withdrawal failed"");
```
'''
```

```
UNCHECKED LOW-LEVEL CALL
'''
In the function `_handleOpenFees`, the contract calls `IStable(_tigAsset).mintFor(...)` without checking if the minting operation was successful. If the minting fails, the contract will not revert, which could lead to incorrect fee distributions and loss of funds.

Recommended Mitigation/Fix:
Add a require statement to check the success of the minting operation:
```solidity
bool success = IStable(_tigAsset).mintFor(_referrer, _positionSize * _fees.referralFees / DIVISION_CONSTANT);
require(success, ""Minting failed"");
```
'''
```

```
UNCHECKED LOW-LEVEL CALL
'''
In the function `_handleCloseFees`, the contract calls `IStable(_tigAsset).mintFor(...)` without checking if the minting operation was successful. If the minting fails, the contract will not revert, which could lead to incorrect fee distributions and loss of funds.

Recommended Mitigation/Fix:
Add a require statement to check the success of the minting operation:
```solidity
bool success = IStable(_tigAsset).mintFor(_referrer, _referralFeesPaid);
require(success, ""Minting failed"");
```
'''
```

```
UNCHECKED LOW-LEVEL CALL
'''
In the function `approveProxy`, the contract transfers Ether to the proxy address using `payable(_proxy).transfer(msg.value);` without checking if the transfer was successful. If the transfer fails, the contract will not revert, which could lead to unexpected states.

Recommended Mitigation/Fix:
Use the `call` method instead of `transfer` and check for success:
```solidity
(bool success, ) = _proxy.call{value: msg.value}("""");
require(success, ""Transfer to proxy failed"");
```
'''
```"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Transactions Order Dependence. Transactions Order Dependence vulnerabilities can result in unintended consequences and create opportunities for malicious actors to exploit transaction sequencing.
Please conduct a thorough analysis, considering the following information:
1. Review the contract's code logic to identify any potential areas where the order of transaction execution might have an impact on the contract's behavior.

2. Examine critical functions, particularly those involving fund transfers or resource allocation, to ensure they are not susceptible to Transactions Order Dependence.

3. Investigate scenarios in which gas prices can be manipulated to change the order of transaction execution.

If you identify Transactions Order Dependence, respond with: """,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
