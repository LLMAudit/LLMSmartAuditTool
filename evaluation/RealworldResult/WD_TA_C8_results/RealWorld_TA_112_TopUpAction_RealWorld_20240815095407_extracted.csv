Integer Overflow/Underflow Identified,Reentrancy Identified,Unchecked External Calls Identified,Unchecked Low-level Calls Identified,Transactions Order Dependence Identified,Timestamp Manipulation Identified,Predictable Randomness Identified,Unsafe `tx.origin` Identified,Unsafe Suicide Identified,Gas Limit Identified,Price Manipulation Identified,Assumption of Fixed-Length Array Identified,Lack of Withdrawal Function Identified,Lack of Authorization Identified,Potential Data Inconsistency Identified,Hash Collision Identified,Uninitialized Return Variable Identified,Misdeclared Constructor Identified,Missing 'onlyOwner' Modifier Identified,Misuse of `msg.value` within a Loop Identified,Precision Loss Identified,Redundant Conditional Check Identified,External Oracle Dependency Identified,Ownership Hijacking Identified,Centralization Risk Identified,Incorrect Funding Rate Calculation Identified,Flash Loan Fee Manipulation Identified,Misuse of Mapping Getter Identified,Lack of Getter Function Implementation Identified,Unnecessary Comparison Identified,Inconsistent Initialization Identified,Potential Inconsistency in Yield Source Swapping Identified,Incorrect Signer Verification Identified,Order of Inheritance Initialization Identified,Impracticality of Exact Match Identified,Inconsistent Base Tokens Identified,Handling Partial Withdrawals Identified,Fallback Function Identified,Unlimited Token Approval Identified,Lack of Input Validation Identified,DoS Vulnerability Identified
"<INFO> Integer Overflow/Underflow Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Reentrancy Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unchecked External Calls Identified."".
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unchecked Low-level Calls Identified."".
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Transactions Order Dependence Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades
'''
```
If you don't find any Transactions Order Dependence vulnerabilities, respond only with: ""","<INFO> Timestamp Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Predictable Randomness Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unsafe `tx.origin` Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unsafe Suicide Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Lack of Restriction on `selfdestruct` is found, respond only with: ""","<INFO> Gas Limit Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Price Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Assumption of Fixed-Length Array Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Withdrawal Function Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If a secure withdrawal function is found and no issues are identified, respond only with: ""","<INFO> Lack of Authorization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Lack of Authorization vulnerabilities are found, respond only with: ""","<INFO> Potential Data Inconsistency Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Potential Data Inconsistency vulnerabilities are found, respond only with: ""","<INFO> Hash Collision Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Hash Collision vulnerabilities are found, respond only with: ""","<INFO> Uninitialized Return Variable Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Uninitialized Return Variable vulnerabilities are found, respond only with: ""","<INFO> Misdeclared Constructor Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Misdeclared Constructor vulnerabilities are found, respond only with: ""","<INFO> Missing 'onlyOwner' Modifier Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Misuse of `msg.value` within a Loop Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Precision Loss Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Redundant Conditional Check Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> External Oracle Dependency Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: """,,"<INFO> Centralization Risk Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Incorrect Funding Rate Calculation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Flash Loan Fee Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Misuse of Mapping Getter Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Getter Function Implementation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unnecessary Comparison Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Inconsistent Initialization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Potential Inconsistency in Yield Source Swapping Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Incorrect Signer Verification Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Order of Inheritance Initialization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Impracticality of Exact Match Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Inconsistent Base Tokens Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Handling Partial Withdrawals Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Fallback Function Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unlimited Token Approval Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Input Validation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> DoS Vulnerability Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades.
'''
```
If you don't find any vulnerabilities, respond only with: """
,,"<INFO> Unchecked External Calls Identified.

```
VULNERABILITY NAME: Unchecked External Call in `lockFunds`
'''
In the `lockFunds` function of the `TopUpActionLibrary`, the call to `stakerVault

[2024-15-08 09:54:28 INFO] **[Seminar Conclusion]**:

 ",,,,,,,,"<INFO> Price Manipulation Identified.

**VULNERABILITY NAME: Centralized Price Manipulation Risk**
'''
The contract relies on external price feeds from liquidity pools and swappers to determine token prices. If the underlying liquidity pools or swappers are controlled by a centralized authority, they can manipulate the prices at will, leading to unfair trading conditions. This can result in users being misled about the actual value of their tokens, allowing the controlling entity to profit at the expense of others.

**Recommended Mitigation/Fix:**
Implement a decentralized price oracles system that aggregates prices from

[2024-15-08 09:54:57 INFO] **[Seminar Conclusion]**:

 ",,,"<INFO> Lack of Authorization Identified.

**Lack of Authorization**
'''
The

[2024-15-08 09:55:09 INFO] **[Seminar Conclusion]**:

 ","<INFO> Potential Data Inconsistency Identified.

**Potential Data In

[2024-15-08 09:55:12 INFO] **[Seminar Conclusion]**:

 ",,,,,,"<INFO> Precision Loss Identified.

**VULNERABILITY NAME: Precision Loss in Arithmetic Operations**
'''
The contract performs several arithmetic operations that could lead to precision loss, particularly in the `calcExchangeAmount` function and the `execute` function. For instance, the use of integer division in the calculation of amounts can truncate values, leading to incorrect results. This is especially critical in financial applications where even minor inaccuracies can result in significant monetary loss.

In the `calcExchange

[2024-15-08 09:55:31 INFO] **[Seminar Conclusion]**:

 ","<INFO> Redundant Conditional Check Identified.

**VULNERABILITY NAME: Redundant Conditional Checks in `execute` function**
'''
In the `execute`

[2024-15-08 09:55:35 INFO] **[Seminar Conclusion]**:

 ",,,"<INFO> Centralization Risk Identified.

**Centralized Control via Governance Functions**
'''
The contract contains several functions that can only be executed by the governance address, which is set during the initialization of the contract. This centralizes control over critical operations such as updating fees, changing handlers, and managing protocols. If the governance address is compromised, an attacker could potentially manipulate these parameters to their advantage, leading to significant financial losses or misuse of the contract.

Recommended Mitigation:
1. Implement a multi-signature wallet for governance functions to

[2024-15-08 09:55:46 INFO] **[Seminar Conclusion]**:

 ",,,,,"<INFO> Unnecessary Comparison Identified.

UNNECESSARY COMPARISON
'''
In the `execute` function, there are instances where boolean values are compared explicitly to `true` or `false`. For example, the line:
```solidity
require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);
```
could be simplified by directly using the boolean expression without the explicit comparison. This enhances readability and reduces the risk of logical errors. 

Recommended mitigation is to directly use the boolean expression in the require statement without unnecessary comparisons,

[2024-15-08 09:56:01 INFO] **[Seminar Conclusion]**:

 ",,"<INFO> Potential Inconsistency in Yield Source Swapping Identified.

POTENTIAL INCONSISTENCY IN YIELD SOURCE SWAPPING
'''
The contract allows for the swapping of yield sources through the `getSwapper`

[2024-15-08 09:56:08 INFO] **[Seminar Conclusion]**:

 ",,,,,,,,"<INFO> Lack of Input Validation Identified.

**VULNERABILITY NAME: Insufficient Input Validation in `register` Function**
'''
The `register` function does not validate the `depositAmount` against the `totalTopUpAmount` before proceeding with the locking of funds. This could lead to a

[2024-15-08 09:56:31 INFO] **[Seminar Conclusion]**:

 ","<INFO> DoS Vulnerability Identified.

**1. Unbounded Loop DoS**
'''
The function `usersWithPositions` contains a loop that iterates over the `_usersWithPositions` set based on the `howMany` parameter. If the number of users with positions is large, this could lead to excessive gas consumption, potentially exhausting the gas limit and causing a DoS. An attacker could exploit this by calling the function with a high cursor value or a large `howMany` parameter, leading to a situation where the transaction fails due to out-of-gas errors.

**Mitigation Measures:**
- Implement a maximum limit on the `howMany` parameter to ensure that the loop does not iterate excessively. For instance, you could limit `howMany` to a reasonable number (e.g., 100).
- Consider implementing pagination with a fixed maximum size to prevent excessive gas consumption.
'''

**2. External Call DoS**
'''
The function `execute` makes a delegate call to the `topUpHandler` contract. If the `topUpHandler` is malicious or fails for any reason, it can cause the entire transaction to revert, leading to a DoS situation. This is particularly concerning if the handler's implementation is not controlled or audited properly.

**Mitigation Measures:**
- Use `try/catch` patterns (if using Solidity 0.8.0 or later) to handle potential failures from external calls gracefully. This way, if the external call fails, the contract can handle the error without reverting the entire transaction.
- Ensure that the `topUpHandler` is a trusted contract and consider implementing checks to validate its address before making calls.
'''

**3. State Dependency DoS**
'''
In the `execute` function, the contract checks the `threshold` and `totalTopUpAmount` of the position. If an attacker can manipulate the state of the contract (e.g., by resetting positions or changing parameters), they could potentially cause the function to revert, leading to a DoS condition for legitimate users.

**Mitigation Measures:**
- Implement checks and balances to ensure that state changes are only allowed under certain conditions, preventing malicious manipulation.
- Consider using a circuit breaker pattern to pause operations if certain conditions are met, allowing for recovery from potential DoS attacks.
'''

**4. Block Gas Limit DoS**
'''
The `register` function calculates `gasDeposit` based on the `totalTopUpAmount` and `singleTopUpAmount`. If these amounts are large, it could lead to high gas consumption when registering multiple positions, potentially consuming the block gas limit and causing other transactions to fail.

**Mitigation Measures:**
- Set reasonable limits on the `totalTopUpAmount` and `singleTopUpAmount` to prevent excessive gas consumption.
- Consider implementing a mechanism to batch operations or limit the number of positions that can be registered in a single transaction.
'''

[2024-15-08 09:56:39 INFO] **[Seminar Conclusion]**:

 "
,,"<INFO> Unchecked External Calls Identified.

```
VULNERABILITY NAME: Unchecked External Call in `lockFunds`
'''
In the `lockFunds` function of the `TopUpActionLibrary`, the call to `stakerVault

[2024-15-08 09:54:28 INFO] **[Execute Detail]**

execute SimplePhase:[UncheckedLowLevelCallDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-15-08 09:54:28 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol""; import ""../../../interfaces/IGasBank.sol""; import ""../../../interfaces/pool/ILiquidityPool.sol""; import ""../../../interfaces/ISwapperRegistry.sol""; import ""../../../interfaces/IController.sol""; import ""../../../interfaces/IStakerVault.sol""; import ""../../../interfaces/ISwapper.sol""; import ""../../../interfaces/actions/topup/ITopUpHandler.sol""; import ""../../../interfaces/actions/topup/ITopUpAction.sol""; import ""../../../interfaces/actions/IActionFeeHandler.sol""; import ""../../../libraries/AddressProviderHelpers.sol""; import ""../../../libraries/Errors.sol""; import ""../../../libraries/ScaledMath.sol""; import ""../../../libraries/EnumerableExtensions.sol""; import ""../../access/Authorization.sol""; import ""../../utils/Preparable.sol""; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being ""too deep""  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee""; bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler""; bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler""; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage""; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             ""topUp(bytes32,address,uint256,bytes)"",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new ""balance"" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""Identify all Unchecked Low-level Call vulnerabilities in the provided Solidity contract."". Ideas: ""Look for instances where low-level calls (such as call, delegatecall, send) are made without proper error handling or checks to ensure the calls succeed."". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Unchecked Low-level Calls. There are three cases, the contract may have Unchecked Low-level Calls: 1. When low-level calls (such as call, delegatecall, send) are not adequately checked, the calling contract may execute code in the external contract without ensuring the external contract's behavior is as expected. 2. When the external contract's code is not trusted or its behavior is unpredictable, it can compromise the overall security and stability of the calling contract. 3. When the execution of low-level function calls fails, the contract does not handle errors. The contract does not provide any mechanism to handle or revert the transaction, potentially resulting in a loss of funds. If you identify Unchecked Low-level Calls, please respond with: "" Unchecked Low-level Calls Identified."". For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If you don't find any vulnerabilities, respond only with: "" NO Unchecked Low-level Calls."" |
| **phase_name** | UncheckedLowLevelCallDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";\nimport ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";\n\nimport ""../../../interfaces/IGasBank.sol"";\nimport ""../../../interfaces/pool/ILiquidityPool.sol"";\nimport ""../../../interfaces/ISwapperRegistry.sol"";\nimport ""../../../interfaces/IController.sol"";\nimport ""../../../interfaces/IStakerVault.sol"";\nimport ""../../../interfaces/ISwapper.sol"";\nimport ""../../../interfaces/actions/topup/ITopUpHandler.sol"";\nimport ""../../../interfaces/actions/topup/ITopUpAction.sol"";\nimport ""../../../interfaces/actions/IActionFeeHandler.sol"";\n\nimport ""../../../libraries/AddressProviderHelpers.sol"";\nimport ""../../../libraries/Errors.sol"";\nimport ""../../../libraries/ScaledMath.sol"";\nimport ""../../../libraries/EnumerableExtensions.sol"";\n\nimport ""../../access/Authorization.sol"";\nimport ""../../utils/Preparable.sol"";\n\n/\n * @notice The logic here should really be part of the top-up action\n * but is split in a library to circumvent the byte-code size limit\n */\nlibrary TopUpActionLibrary {\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    function lockFunds(\n        address stakerVaultAddress,\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) external {\n        uint256 amountLeft = lockAmount;\n        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);\n\n        // stake deposit amount\n        if (depositAmount &gt; 0) {\n            depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;\n            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);\n            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);\n            stakerVault.stake(depositAmount);\n            stakerVault.increaseActionLockedBalance(payer, depositAmount);\n            amountLeft -= depositAmount;\n        }\n\n        // use stake vault allowance if available and required\n        if (amountLeft &gt; 0) {\n            uint256 balance = stakerVault.balanceOf(payer);\n            uint256 allowance = stakerVault.allowance(payer, address(this));\n            uint256 availableFunds = balance &lt; allowance ? balance : allowance;\n            if (availableFunds &gt;= amountLeft) {\n                stakerVault.transferFrom(payer, address(this), amountLeft);\n                amountLeft = 0;\n            }\n        }\n\n        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);\n    }\n\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     /\n    function calcExchangeAmount(\n        IAddressProvider addressProvider,\n        address token,\n        address actionToken,\n        uint256 amount\n    ) external view returns (uint256) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        uint256 rate = pool.exchangeRate();\n        address underlying = pool.getUnderlying();\n        if (underlying == actionToken) {\n            return amount.scaledDivRoundUp(rate);\n        }\n\n        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);\n        uint256 swapperRate = swapper.getRate(underlying, actionToken);\n        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));\n    }\n\n    function getSwapper(\n        IAddressProvider addressProvider,\n        address underlying,\n        address actionToken\n    ) public view returns (ISwapper) {\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);\n        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);\n        return ISwapper(swapper);\n    }\n}\n\ncontract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {\n    using ScaledMath for uint256;\n    using ScaledMath for uint128;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using AddressProviderHelpers for IAddressProvider;\n\n    /\n     * @dev Temporary struct to hold local variables in execute\n     * and avoid the stack being ""too deep""\n     /\n    struct ExecuteLocalVars {\n        uint256 minActionAmountToTopUp;\n        uint256 actionTokenAmount;\n        uint256 depositTotalFeesAmount;\n        uint256 actionAmountWithFees;\n        uint256 userFactor;\n        uint256 rate;\n        uint256 depositAmountWithFees;\n        uint256 depositAmountWithoutFees;\n        uint256 actionFee;\n        uint256 totalActionTokenAmount;\n        uint128 totalTopUpAmount;\n        bool success;\n        bytes topupResult;\n        uint256 gasBankBalance;\n        uint256 initialGas;\n        uint256 gasConsumed;\n        uint256 userGasPrice;\n        uint256 estimatedRequiredGas;\n        uint256 estimatedRequiredWeiForGas;\n        uint256 requiredWeiForGas;\n        uint256 reimbursedWeiForGas;\n        address underlying;\n        bool removePosition;\n    }\n\n    EnumerableSet.AddressSet private _usableTokens;\n\n    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;\n\n    bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee"";\n    bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler"";\n    bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler"";\n    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage"";\n    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";\n\n    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;\n    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;\n    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    EnumerableSet.Bytes32Set internal _supportedProtocols;\n\n    /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record)\n    mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;\n\n    mapping(address =&gt; RecordMeta[]) internal _userPositions;\n\n    EnumerableSet.AddressSet internal _usersWithPositions;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        addressProvider = controller.addressProvider();\n        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);\n    }\n\n    receive() external payable {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function initialize(\n        address feeHandler,\n        bytes32[] calldata protocols,\n        address[] calldata handlers\n    ) external initializer onlyGovernance {\n        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);\n        _setConfig(_FEE_HANDLER_KEY, feeHandler);\n        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);\n        for (uint256 i = 0; i &lt; protocols.length; i++) {\n            bytes32 protocolKey = _getProtocolKey(protocols[i]);\n            _setConfig(protocolKey, handlers[i]);\n            _updateTopUpHandler(protocols[i], address(0), handlers[i]);\n        }\n    }\n\n    /\n     * @notice Register a top up action.\n     * @dev The depositAmount must be greater or equal to the totalTopUpAmount (which is denominated in actionToken).\n     * @param account Account to be topped up (first 20 bytes will typically be the address).\n     * @param depositAmount Amount of depositToken that will be locked.\n     * @param protocol Protocol which holds position to be topped up.\n     * @param record containing the data for the position to register\n     /\n    function register(\n        bytes32 account,\n        bytes32 protocol,\n        uint128 depositAmount,\n        Record memory record\n    ) external payable returns (bool) {\n        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);\n        require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);\n        require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);\n        require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);\n        require(\n            _positions[msg.sender][account][protocol].threshold == 0,\n            Error.POSITION_ALREADY_EXISTS\n        );\n        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);\n        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);\n\n        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) \n            record.maxFee *\n            getEstimatedGasUsage();\n\n        require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);\n\n        uint256 totalLockAmount = _calcExchangeAmount(\n            record.depositToken,\n            record.actionToken,\n            record.totalTopUpAmount\n        );\n        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);\n\n        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);\n\n        record.depositTokenBalance = uint128(totalLockAmount);\n        _positions[msg.sender][account][protocol] = record;\n        _userPositions[msg.sender].push(RecordMeta(account, protocol));\n        _usersWithPositions.add(msg.sender);\n\n        emit Register(\n            account,\n            protocol,\n            record.threshold,\n            msg.sender,\n            record.depositToken,\n            totalLockAmount,\n            record.actionToken,\n            record.singleTopUpAmount,\n            record.totalTopUpAmount,\n            record.maxFee,\n            record.extra\n        );\n        return true;\n    }\n\n    /\n     * @notice See overloaded version of execute for more details.\n     /\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol\n    ) external override returns (bool) {\n        return execute(payer, account, beneficiary, protocol, 0);\n    }\n\n    /\n     * @notice Delete a position to back on the given protocol for account.\n     * @param account Account holding the position.\n     * @param protocol Protocol the position is held on.\n     * @param unstake If the tokens should be unstaked from vault.\n     * @return true if successful.\n     /\n    function resetPosition(\n        bytes32 account,\n        bytes32 protocol,\n        bool unstake\n    ) external override returns (bool) {\n        address payer = msg.sender;\n        Record memory position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n\n        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist\n        IStakerVault staker = IStakerVault(vault);\n        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);\n        if (unstake) {\n            staker.unstake(position.depositTokenBalance);\n            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);\n        } else {\n            staker.transfer(payer, position.depositTokenBalance);\n        }\n\n        _removePosition(payer, account, protocol);\n        addressProvider.getGasBank().withdrawUnused(payer);\n        return true;\n    }\n\n    /\n     * @notice Execute top up handler update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @param protocol Protocol for which a new handler should be executed.\n     * @return Address of new handler.\n     */\n    function executeTopUpHandler(bytes32 protocol) external override returns (address) {\n        address oldHandler = _getHandler(protocol, false);\n        address newHandler = _executeAddress(_getProtocolKey(protocol));\n\n        _updateTopUpHandler(protocol, oldHandler, newHandler);\n        return newHandler;\n    }\n\n    /\n     * @notice Reset new top up handler deadline for a protocol.\n     * @param protocol Protocol for which top up handler deadline should be reset.\n     * @return true if successful.\n     /\n    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_getProtocolKey(protocol));\n    }\n\n    /\n     * @notice Prepare action fee update.\n     * @param newActionFee New fee to set.\n     * @return true if success.\n     /\n    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {\n        require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);\n        return _prepare(_ACTION_FEE_KEY, newActionFee);\n    }\n\n    /\n     * @notice Execute action fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeActionFee() external override returns (uint256) {\n        return _executeUInt256(_ACTION_FEE_KEY);\n    }\n\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     /\n    function resetActionFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ACTION_FEE_KEY);\n    }\n\n    /\n     * @notice Prepare swapper slippage update.\n     * @param newSwapperSlippage New slippage to set.\n     * @return true if success.\n     /\n    function prepareSwapperSlippage(uint256 newSwapperSlippage)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        require(\n            newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;\n                newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,\n            Error.INVALID_AMOUNT\n        );\n        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);\n    }\n\n    /\n     * @notice Execute swapper slippage update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeSwapperSlippage() external override returns (uint256) {\n        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     /\n    function resetSwapperSlippage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    / Set fee handler /\n    /\n     * @notice Prepare update of fee handler.\n     * @param handler New fee handler.\n     * @return true if success.\n     */\n    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {\n        return _prepare(_FEE_HANDLER_KEY, handler);\n    }\n\n    /\n     * @notice Execute update of fee handler (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return true if successful.\n     /\n    function executeFeeHandler() external override returns (address) {\n        return _executeAddress(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Reset the handler deadline.\n     * @return true if success.\n     /\n    function resetFeeHandler() external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Prepare update of estimated gas usage.\n     * @param gasUsage New estimated gas usage.\n     * @return true if success.\n     */\n    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {\n        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);\n    }\n\n    /\n     * @notice Execute update of gas usage (with time delay enforced).\n     * @return true if successful.\n     /\n    function executeEstimatedGasUsage() external returns (uint256) {\n        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Reset the gas usage deadline.\n     * @return true if success.\n     /\n    function resetGasUsage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Add a new deposit token that is supported by the action.\n     * @dev There is a separate check for whether the usable token (i.e. deposit token)\n     *      is swappable for some action token.\n     * @param token Address of deposit token that can be used by the action.\n     */\n    function addUsableToken(address token) external override onlyGovernance returns (bool) {\n        return _usableTokens.add(token);\n    }\n\n    /\n     * @notice Computes the total amount of ETH (as wei) required to pay for all\n     * the top-ups assuming the maximum gas price and the current estimated gas\n     * usage of a top-up\n     /\n    function getEthRequiredForGas(address payer) external view override returns (uint256) {\n        uint256 totalEthRequired = 0;\n        RecordMeta[] memory userRecordsMeta = _userPositions[payer];\n        uint256 gasUsagePerCall = getEstimatedGasUsage();\n        uint256 length = userRecordsMeta.length;\n        for (uint256 i = 0; i &lt; length; i++) {\n            RecordMeta memory meta = userRecordsMeta[i];\n            Record memory record = _positions[payer][meta.account][meta.protocol];\n            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);\n            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;\n        }\n        return totalEthRequired;\n    }\n\n    /\n     * @notice Returns a list of positions for the given payer\n     /\n    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {\n        return _userPositions[payer];\n    }\n\n    /\n     * @notice Get a list supported protocols.\n     * @return List of supported protocols.\n     /\n    function getSupportedProtocols() external view override returns (bytes32[] memory) {\n        uint256 length = _supportedProtocols.length();\n        bytes32[] memory protocols = new bytes32;\n        for (uint256 i = 0; i &lt; length; i++) {\n            protocols[i] = _supportedProtocols.at(i);\n        }\n        return protocols;\n    }\n\n    /\n     * @notice Gets a list of users that have an active position.\n     * @dev Uses cursor pagination.\n     * @param cursor The cursor for pagination (should start at 0 for first call).\n     * @param howMany Maximum number of users to return in this pagination request.\n     * @return users List of users that have an active position.\n     * @return nextCursor The cursor to use for the next pagination request.\n     */\n    function usersWithPositions(uint256 cursor, uint256 howMany)\n        external\n        view\n        override\n        returns (address[] memory users, uint256 nextCursor)\n    {\n        uint256 length = usersWithPositions.length();\n        if (cursor &gt;= length) return (new address, 0);\n        if (howMany &gt;= length - cursor) {\n            howMany = length - cursor;\n        }\n\n        address[] memory usersWithPositions = new address;\n        for (uint256 i = 0; i &lt; howMany; i++) {\n            usersWithPositions_[i] = usersWithPositions.at(i + cursor);\n        }\n\n        return (usersWithPositions, cursor + howMany);\n    }\n\n    /\n     * @notice Get a list of all tokens usable for this action.\n     * @dev This refers to all tokens that can be used as deposit tokens.\n     * @return Array of addresses of usable tokens.\n     /\n    function getUsableTokens() external view override returns (address[] memory) {\n        return _usableTokens.toArray();\n    }\n\n    /\n     * @notice Retrieves the topup handler for the given protocol\n     /\n    function getTopUpHandler(bytes32 protocol) external view returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice Successfully tops up a position if it\'s conditions are met.\n     * @dev pool and vault funds are rebalanced after withdrawal for top up\n     * @param payer Account that pays for the top up.\n     * @param account Account owning the position for top up.\n     * @param beneficiary Address of the keeper\'s wallet for fee accrual.\n     * @param protocol Protocol of the top up position.\n     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas\n     * @return true if successful.\n     */\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol,\n        uint256 maxWeiForGas\n    ) public override returns (bool) {\n        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);\n\n        ExecuteLocalVars memory vars;\n\n        vars.initialGas = gasleft();\n\n        Record storage position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n        require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);\n\n        address topUpHandler = _getHandler(protocol, true);\n        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);\n\n        // ensure that the position is actually below its set user factor threshold\n        require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);\n\n        IGasBank gasBank = addressProvider.getGasBank();\n\n        // fail early if the user does not have enough funds in the gas bank\n        // to cover the cost of the transaction\n        vars.estimatedRequiredGas = getEstimatedGasUsage();\n        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;\n\n        // compute the gas price that the user will be paying\n        vars.userGasPrice = block.basefee + position.priorityFee;\n        if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;\n        if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;\n\n        // ensure the current position allows for the gas to be paid\n        require(\n            vars.estimatedRequiredWeiForGas &lt;=\n                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,\n            Error.ESTIMATED_GAS_TOO_HIGH\n        );\n\n        vars.gasBankBalance = gasBank.balanceOf(payer);\n        // ensure the user has enough funds in the gas bank to cover the gas\n        require(\n            vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,\n            Error.GAS_BANK_BALANCE_TOO_LOW\n        );\n\n        vars.totalTopUpAmount = position.totalTopUpAmount;\n        vars.actionFee = getActionFee();\n        // add top-up fees to top-up amount\n        vars.minActionAmountToTopUp = position.singleTopUpAmount;\n        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(\n            ScaledMath.ONE + vars.actionFee\n        );\n\n        // if the amount that we want to top-up (including fees) is higher than\n        // the available topup amount, we lower this down to what is left of the position\n        if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {\n            vars.actionAmountWithFees = vars.totalTopUpAmount;\n            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(\n                ScaledMath.ONE + vars.actionFee\n            );\n        }\n        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);\n        vars.underlying = pool.getUnderlying();\n        vars.rate = pool.exchangeRate();\n\n        ISwapper swapper;\n\n        if (vars.underlying != position.actionToken) {\n            swapper = _getSwapper(vars.underlying, position.actionToken);\n            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));\n        }\n\n        // compute the deposit tokens amount with and without fees\n        // we will need to unstake the amount with fees and to\n        // swap the amount without fees into action tokens\n        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);\n        if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {\n            vars.depositAmountWithFees = position.depositTokenBalance;\n            vars.minActionAmountToTopUp =\n                (vars.depositAmountWithFees * vars.rate) /\n                (ScaledMath.ONE + vars.actionFee);\n        }\n\n        // compute amount of LP tokens needed to pay for action\n        // rate is expressed in actionToken per depositToken\n        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);\n        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;\n\n        // will revert if vault does not exist\n        address vault = addressProvider.getStakerVault(position.depositToken);\n\n        // unstake deposit tokens including fees\n        IStakerVault(vault).unstake(vars.depositAmountWithFees);\n        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);\n\n        // swap the amount without the fees\n        // as the fees are paid in deposit token, not in action token\n        // Redeem first and use swapper only if the underlying tokens are not action tokens\n        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);\n\n        if (address(swapper) != address(0)) {\n            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(\n                getSwapperSlippage()\n            );\n            _approve(vars.underlying, address(swapper));\n            vars.actionTokenAmount = swapper.swap(\n                vars.underlying,\n                position.actionToken,\n                vars.actionTokenAmount,\n                vars.minActionAmountToTopUp\n            );\n        }\n\n        // compute how much of action token was actually redeemed and add fees to it\n        // this is to ensure that no funds get locked inside the contract\n        vars.totalActionTokenAmount =\n            vars.actionTokenAmount +\n            vars.depositTotalFeesAmount.scaledMul(vars.rate);\n\n        // at this point, we have exactly vars.actionTokenAmount\n        // (at least position.singleTopUpAmount) of action token\n        // and exactly vars.depositTotalFeesAmount deposit tokens in the contract\n        // solhint-disable-next-line avoid-low-level-calls\n        (vars.success, vars.topupResult) = topUpHandler.delegatecall(\n            abi.encodeWithSignature(\n                ""topUp(bytes32,address,uint256,bytes)"",\n                account,\n                position.actionToken,\n                vars.actionTokenAmount,\n                position.extra\n            )\n        );\n\n        require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);\n\n        // totalTopUpAmount is updated to reflect the new ""balance"" of the position\n        if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {\n            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);\n        } else {\n            position.totalTopUpAmount = 0;\n        }\n\n        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);\n\n        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;\n        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);\n        if (vars.removePosition) {\n            if (position.depositTokenBalance &gt; 0) {\n                // transfer any unused locked tokens to the payer\n                IStakerVault(vault).transfer(payer, position.depositTokenBalance);\n                IStakerVault(vault).decreaseActionLockedBalance(\n                    payer,\n                    position.depositTokenBalance\n                );\n            }\n            _removePosition(payer, account, protocol);\n        }\n\n        emit TopUp(\n            account,\n            protocol,\n            payer,\n            position.depositToken,\n            vars.depositAmountWithFees,\n            position.actionToken,\n            vars.actionTokenAmount\n        );\n\n        // compute gas used and reimburse the keeper by using the\n        // funds of payer in the gas bank\n        // TODO: add constant gas consumed for transfer and tx prologue\n        vars.gasConsumed = vars.initialGas - gasleft();\n\n        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;\n        if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {\n            vars.reimbursedWeiForGas = vars.gasBankBalance;\n        }\n\n        // ensure that the keeper is not overpaying\n        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;\n        require(\n            vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,\n            Error.GAS_TOO_HIGH\n        );\n        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);\n        if (vars.removePosition) {\n            gasBank.withdrawUnused(payer);\n        }\n\n        return true;\n    }\n\n    /\n     * @notice Prepare new top up handler fee update.\n     * @dev Setting the addres to 0 means that the protocol will no longer be supported.\n     * @param protocol Protocol for which a new handler should be prepared.\n     * @param newHandler Address of new handler.\n     * @return true if success.\n     /\n    function prepareTopUpHandler(bytes32 protocol, address newHandler)\n        public\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_getProtocolKey(protocol), newHandler);\n    }\n\n    /\n     * @notice Check if action can be executed.\n     * @param protocol for which to get the health factor\n     * @param account for which to get the health factor\n     * @param extra data to be used by the topup handler\n     * @return healthFactor of the position\n     /\n    function getHealthFactor(\n        bytes32 protocol,\n        bytes32 account,\n        bytes memory extra\n    ) public view override returns (uint256 healthFactor) {\n        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));\n        return topUpHandler.getUserFactor(account, extra);\n    }\n\n    function getHandler(bytes32 protocol) public view override returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice returns the current estimated gas usage\n     */\n    function getEstimatedGasUsage() public view returns (uint256) {\n        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];\n    }\n\n    /\n     * @notice Returns the current action fee\n     /\n    function getActionFee() public view override returns (uint256) {\n        return currentUInts256[_ACTION_FEE_KEY];\n    }\n\n    /\n     * @notice Returns the current max swapper slippage\n     /\n    function getSwapperSlippage() public view override returns (uint256) {\n        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];\n    }\n\n    /\n     * @notice Returns the current fee handler\n     */\n    function getFeeHandler() public view override returns (address) {\n        return currentAddresses[_FEE_HANDLER_KEY];\n    }\n\n    /\n     * @notice Get the record for a position.\n     * @param payer Registered payer of the position.\n     * @param account Address holding the position.\n     * @param protocol Protocol where the position is held.\n     /\n    function getPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) public view override returns (Record memory) {\n        return _positions[payer][account][protocol];\n    }\n\n    /\n     * @notice Check whether a token is usable as a deposit token.\n     * @param token Address of token to check.\n     * @return True if token is usable as a deposit token for this action.\n     /\n    function isUsable(address token) public view override returns (bool) {\n        return _usableTokens.contains(token);\n    }\n\n    function _updateTopUpHandler(\n        bytes32 protocol,\n        address oldHandler,\n        address newHandler\n    ) internal {\n        if (newHandler == address(0)) {\n            _supportedProtocols.remove(protocol);\n        } else if (oldHandler == address(0)) {\n            _supportedProtocols.add(protocol);\n        }\n    }\n\n    /\n     * @dev Pays fees to the feeHandler\n     * @param payer The account who\'s position the fees are charged on\n     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)\n     * @param feeAmount The amount in tokens to pay as fees\n     * @param depositToken The LpToken used to pay the fees\n     */\n    function _payFees(\n        address payer,\n        address beneficiary,\n        uint256 feeAmount,\n        address depositToken\n    ) internal {\n        address feeHandler = getFeeHandler();\n        IERC20(depositToken).safeApprove(feeHandler, feeAmount);\n        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);\n    }\n\n    /\n     * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction\n     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.\n     * @param payer Owner of the funds to be locked\n     * @param token Token to lock\n     * @param lockAmount Minimum amount of token to lock\n     * @param depositAmount Amount of token that was deposited.\n     *                      If this is 0 then the staker vault allowance should be used.\n     *                      If this is greater than requiredAmount more tokens will be locked.\n     /\n    function _lockFunds(\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) internal {\n        address stakerVaultAddress = addressProvider.getStakerVault(token);\n        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);\n    }\n\n    function _removePosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        delete _positions[payer][account][protocol];\n        _removeUserPosition(payer, account, protocol);\n        if (_userPositions[payer].length == 0) {\n            _usersWithPositions.remove(payer);\n        }\n        emit Deregister(payer, account, protocol);\n    }\n\n    function _removeUserPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        RecordMeta[] storage positionsMeta = _userPositions[payer];\n        uint256 length = positionsMeta.length;\n        for (uint256 i = 0; i &lt; length; i++) {\n            RecordMeta storage positionMeta = positionsMeta[i];\n            if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {\n                positionsMeta[i] = positionsMeta[length - 1];\n                positionsMeta.pop();\n                return;\n            }\n        }\n    }\n\n    /\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     /\n    function _approve(address token, address spender) internal {\n        if (IERC20(token).allowance(address(this), spender) &gt; 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /*\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     /\n    function _calcExchangeAmount(\n        address token,\n        address actionToken,\n        uint256 amount\n    ) internal view returns (uint256) {\n        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);\n    }\n\n    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {\n        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);\n    }\n\n    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {\n        address handler = currentAddresses[_getProtocolKey(protocol)];\n        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);\n        return handler;\n    }\n\n    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);\n        address underlying = pool.getUnderlying();\n        if (underlying == toToken) {\n            return true;\n        }\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);\n    }\n\n    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));\n    }\n}\n', 'ideas': "" Unchecked External Calls Identified.\n\n``\nVULNERABILITY NAME: Unchecked External Call inlockFunds\n'''\nIn thelockFundsfunction of theTopUpActionLibrary, the call tostakerVault""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-15-08 09:54:28 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol""; import ""../../../interfaces/IGasBank.sol""; import ""../../../interfaces/pool/ILiquidityPool.sol""; import ""../../../interfaces/ISwapperRegistry.sol""; import ""../../../interfaces/IController.sol""; import ""../../../interfaces/IStakerVault.sol""; import ""../../../interfaces/ISwapper.sol""; import ""../../../interfaces/actions/topup/ITopUpHandler.sol""; import ""../../../interfaces/actions/topup/ITopUpAction.sol""; import ""../../../interfaces/actions/IActionFeeHandler.sol""; import ""../../../libraries/AddressProviderHelpers.sol""; import ""../../../libraries/Errors.sol""; import ""../../../libraries/ScaledMath.sol""; import ""../../../libraries/EnumerableExtensions.sol""; import ""../../access/Authorization.sol""; import ""../../utils/Preparable.sol""; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being ""too deep""  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee""; bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler""; bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler""; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage""; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             ""topUp(bytes32,address,uint256,bytes)"",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new ""balance"" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-15-08 09:54:28 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";

import ""../../../interfaces/IGasBank.sol"";
import ""../../../interfaces/pool/ILiquidityPool.sol"";
import ""../../../interfaces/ISwapperRegistry.sol"";
import ""../../../interfaces/IController.sol"";
import ""../../../interfaces/IStakerVault.sol"";
import ""../../../interfaces/ISwapper.sol"";
import ""../../../interfaces/actions/topup/ITopUpHandler.sol"";
import ""../../../interfaces/actions/topup/ITopUpAction.sol"";
import ""../../../interfaces/actions/IActionFeeHandler.sol"";

import ""../../../libraries/AddressProviderHelpers.sol"";
import ""../../../libraries/Errors.sol"";
import ""../../../libraries/ScaledMath.sol"";
import ""../../../libraries/EnumerableExtensions.sol"";

import ""../../access/Authorization.sol"";
import ""../../utils/Preparable.sol"";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being ""too deep""
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee"";
    bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler"";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler"";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage"";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                ""topUp(bytes32,address,uint256,bytes)"",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new ""balance"" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""Identify all Unchecked Low-level Call vulnerabilities in the provided Solidity contract."".
Ideas: ""Look for instances where low-level calls (such as `call`, `delegatecall`, `send`) are made without proper error handling or checks to ensure the calls succeed."".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Unchecked Low-level Calls. There are three cases, the contract may have Unchecked Low-level Calls:
1. When low-level calls (such as `call`, `delegatecall`, `send`) are not adequately checked, the calling contract may execute code in the external contract without ensuring the external contract's behavior is as expected.
2. When the external contract's code is not trusted or its behavior is unpredictable, it can compromise the overall security and stability of the calling contract.
3. When the execution of low-level function calls fails, the contract does not handle errors. The contract does not provide any mechanism to handle or revert the transaction, potentially resulting in a loss of funds.
If you identify Unchecked Low-level Calls, please respond with: """,,,,,,,,"<INFO> Price Manipulation Identified.

**VULNERABILITY NAME: Centralized Price Manipulation Risk**
'''
The contract relies on external price feeds from liquidity pools and swappers to determine token prices. If the underlying liquidity pools or swappers are controlled by a centralized authority, they can manipulate the prices at will, leading to unfair trading conditions. This can result in users being misled about the actual value of their tokens, allowing the controlling entity to profit at the expense of others.

**Recommended Mitigation/Fix:**
Implement a decentralized price oracles system that aggregates prices from

[2024-15-08 09:54:57 INFO] **[Execute Detail]**

execute SimplePhase:[DataCorruptionDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-15-08 09:54:58 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol""; import ""../../../interfaces/IGasBank.sol""; import ""../../../interfaces/pool/ILiquidityPool.sol""; import ""../../../interfaces/ISwapperRegistry.sol""; import ""../../../interfaces/IController.sol""; import ""../../../interfaces/IStakerVault.sol""; import ""../../../interfaces/ISwapper.sol""; import ""../../../interfaces/actions/topup/ITopUpHandler.sol""; import ""../../../interfaces/actions/topup/ITopUpAction.sol""; import ""../../../interfaces/actions/IActionFeeHandler.sol""; import ""../../../libraries/AddressProviderHelpers.sol""; import ""../../../libraries/Errors.sol""; import ""../../../libraries/ScaledMath.sol""; import ""../../../libraries/EnumerableExtensions.sol""; import ""../../access/Authorization.sol""; import ""../../utils/Preparable.sol""; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being ""too deep""  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee""; bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler""; bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler""; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage""; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             ""topUp(bytes32,address,uint256,bytes)"",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new ""balance"" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to conduct a comprehensive inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Assumption of Fixed-Length Array. There are two cases where the contract may have Assumption of Fixed-Length Array vulnerabilities: 1. When the contract incorrectly assumes that an array returned by a function has a fixed length, potentially leading to data corruption or out-of-bounds errors if the actual array length differs. 2. When the contract does not handle dynamic array lengths properly, causing incorrect data processing or logic errors. If you identify all Assumption of Fixed-Length Array vulnerabilities, respond with: "" Assumption of Fixed-Length Array Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code. ''' If you don't find any vulnerabilities, respond only with: "" No Assumption of Fixed-Length Array."" |
| **phase_name** | DataCorruptionDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";\nimport ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";\n\nimport ""../../../interfaces/IGasBank.sol"";\nimport ""../../../interfaces/pool/ILiquidityPool.sol"";\nimport ""../../../interfaces/ISwapperRegistry.sol"";\nimport ""../../../interfaces/IController.sol"";\nimport ""../../../interfaces/IStakerVault.sol"";\nimport ""../../../interfaces/ISwapper.sol"";\nimport ""../../../interfaces/actions/topup/ITopUpHandler.sol"";\nimport ""../../../interfaces/actions/topup/ITopUpAction.sol"";\nimport ""../../../interfaces/actions/IActionFeeHandler.sol"";\n\nimport ""../../../libraries/AddressProviderHelpers.sol"";\nimport ""../../../libraries/Errors.sol"";\nimport ""../../../libraries/ScaledMath.sol"";\nimport ""../../../libraries/EnumerableExtensions.sol"";\n\nimport ""../../access/Authorization.sol"";\nimport ""../../utils/Preparable.sol"";\n\n/\n * @notice The logic here should really be part of the top-up action\n * but is split in a library to circumvent the byte-code size limit\n */\nlibrary TopUpActionLibrary {\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    function lockFunds(\n        address stakerVaultAddress,\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) external {\n        uint256 amountLeft = lockAmount;\n        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);\n\n        // stake deposit amount\n        if (depositAmount &gt; 0) {\n            depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;\n            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);\n            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);\n            stakerVault.stake(depositAmount);\n            stakerVault.increaseActionLockedBalance(payer, depositAmount);\n            amountLeft -= depositAmount;\n        }\n\n        // use stake vault allowance if available and required\n        if (amountLeft &gt; 0) {\n            uint256 balance = stakerVault.balanceOf(payer);\n            uint256 allowance = stakerVault.allowance(payer, address(this));\n            uint256 availableFunds = balance &lt; allowance ? balance : allowance;\n            if (availableFunds &gt;= amountLeft) {\n                stakerVault.transferFrom(payer, address(this), amountLeft);\n                amountLeft = 0;\n            }\n        }\n\n        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);\n    }\n\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     /\n    function calcExchangeAmount(\n        IAddressProvider addressProvider,\n        address token,\n        address actionToken,\n        uint256 amount\n    ) external view returns (uint256) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        uint256 rate = pool.exchangeRate();\n        address underlying = pool.getUnderlying();\n        if (underlying == actionToken) {\n            return amount.scaledDivRoundUp(rate);\n        }\n\n        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);\n        uint256 swapperRate = swapper.getRate(underlying, actionToken);\n        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));\n    }\n\n    function getSwapper(\n        IAddressProvider addressProvider,\n        address underlying,\n        address actionToken\n    ) public view returns (ISwapper) {\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);\n        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);\n        return ISwapper(swapper);\n    }\n}\n\ncontract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {\n    using ScaledMath for uint256;\n    using ScaledMath for uint128;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using AddressProviderHelpers for IAddressProvider;\n\n    /\n     * @dev Temporary struct to hold local variables in execute\n     * and avoid the stack being ""too deep""\n     /\n    struct ExecuteLocalVars {\n        uint256 minActionAmountToTopUp;\n        uint256 actionTokenAmount;\n        uint256 depositTotalFeesAmount;\n        uint256 actionAmountWithFees;\n        uint256 userFactor;\n        uint256 rate;\n        uint256 depositAmountWithFees;\n        uint256 depositAmountWithoutFees;\n        uint256 actionFee;\n        uint256 totalActionTokenAmount;\n        uint128 totalTopUpAmount;\n        bool success;\n        bytes topupResult;\n        uint256 gasBankBalance;\n        uint256 initialGas;\n        uint256 gasConsumed;\n        uint256 userGasPrice;\n        uint256 estimatedRequiredGas;\n        uint256 estimatedRequiredWeiForGas;\n        uint256 requiredWeiForGas;\n        uint256 reimbursedWeiForGas;\n        address underlying;\n        bool removePosition;\n    }\n\n    EnumerableSet.AddressSet private _usableTokens;\n\n    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;\n\n    bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee"";\n    bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler"";\n    bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler"";\n    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage"";\n    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";\n\n    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;\n    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;\n    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    EnumerableSet.Bytes32Set internal _supportedProtocols;\n\n    /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record)\n    mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;\n\n    mapping(address =&gt; RecordMeta[]) internal _userPositions;\n\n    EnumerableSet.AddressSet internal _usersWithPositions;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        addressProvider = controller.addressProvider();\n        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);\n    }\n\n    receive() external payable {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function initialize(\n        address feeHandler,\n        bytes32[] calldata protocols,\n        address[] calldata handlers\n    ) external initializer onlyGovernance {\n        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);\n        _setConfig(_FEE_HANDLER_KEY, feeHandler);\n        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);\n        for (uint256 i = 0; i &lt; protocols.length; i++) {\n            bytes32 protocolKey = _getProtocolKey(protocols[i]);\n            _setConfig(protocolKey, handlers[i]);\n            _updateTopUpHandler(protocols[i], address(0), handlers[i]);\n        }\n    }\n\n    /\n     * @notice Register a top up action.\n     * @dev The depositAmount must be greater or equal to the totalTopUpAmount (which is denominated in actionToken).\n     * @param account Account to be topped up (first 20 bytes will typically be the address).\n     * @param depositAmount Amount of depositToken that will be locked.\n     * @param protocol Protocol which holds position to be topped up.\n     * @param record containing the data for the position to register\n     /\n    function register(\n        bytes32 account,\n        bytes32 protocol,\n        uint128 depositAmount,\n        Record memory record\n    ) external payable returns (bool) {\n        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);\n        require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);\n        require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);\n        require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);\n        require(\n            _positions[msg.sender][account][protocol].threshold == 0,\n            Error.POSITION_ALREADY_EXISTS\n        );\n        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);\n        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);\n\n        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) \n            record.maxFee *\n            getEstimatedGasUsage();\n\n        require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);\n\n        uint256 totalLockAmount = _calcExchangeAmount(\n            record.depositToken,\n            record.actionToken,\n            record.totalTopUpAmount\n        );\n        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);\n\n        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);\n\n        record.depositTokenBalance = uint128(totalLockAmount);\n        _positions[msg.sender][account][protocol] = record;\n        _userPositions[msg.sender].push(RecordMeta(account, protocol));\n        _usersWithPositions.add(msg.sender);\n\n        emit Register(\n            account,\n            protocol,\n            record.threshold,\n            msg.sender,\n            record.depositToken,\n            totalLockAmount,\n            record.actionToken,\n            record.singleTopUpAmount,\n            record.totalTopUpAmount,\n            record.maxFee,\n            record.extra\n        );\n        return true;\n    }\n\n    /\n     * @notice See overloaded version of execute for more details.\n     /\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol\n    ) external override returns (bool) {\n        return execute(payer, account, beneficiary, protocol, 0);\n    }\n\n    /\n     * @notice Delete a position to back on the given protocol for account.\n     * @param account Account holding the position.\n     * @param protocol Protocol the position is held on.\n     * @param unstake If the tokens should be unstaked from vault.\n     * @return true if successful.\n     /\n    function resetPosition(\n        bytes32 account,\n        bytes32 protocol,\n        bool unstake\n    ) external override returns (bool) {\n        address payer = msg.sender;\n        Record memory position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n\n        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist\n        IStakerVault staker = IStakerVault(vault);\n        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);\n        if (unstake) {\n            staker.unstake(position.depositTokenBalance);\n            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);\n        } else {\n            staker.transfer(payer, position.depositTokenBalance);\n        }\n\n        _removePosition(payer, account, protocol);\n        addressProvider.getGasBank().withdrawUnused(payer);\n        return true;\n    }\n\n    /\n     * @notice Execute top up handler update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @param protocol Protocol for which a new handler should be executed.\n     * @return Address of new handler.\n     */\n    function executeTopUpHandler(bytes32 protocol) external override returns (address) {\n        address oldHandler = _getHandler(protocol, false);\n        address newHandler = _executeAddress(_getProtocolKey(protocol));\n\n        _updateTopUpHandler(protocol, oldHandler, newHandler);\n        return newHandler;\n    }\n\n    /\n     * @notice Reset new top up handler deadline for a protocol.\n     * @param protocol Protocol for which top up handler deadline should be reset.\n     * @return true if successful.\n     /\n    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_getProtocolKey(protocol));\n    }\n\n    /\n     * @notice Prepare action fee update.\n     * @param newActionFee New fee to set.\n     * @return true if success.\n     /\n    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {\n        require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);\n        return _prepare(_ACTION_FEE_KEY, newActionFee);\n    }\n\n    /\n     * @notice Execute action fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeActionFee() external override returns (uint256) {\n        return _executeUInt256(_ACTION_FEE_KEY);\n    }\n\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     /\n    function resetActionFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ACTION_FEE_KEY);\n    }\n\n    /\n     * @notice Prepare swapper slippage update.\n     * @param newSwapperSlippage New slippage to set.\n     * @return true if success.\n     /\n    function prepareSwapperSlippage(uint256 newSwapperSlippage)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        require(\n            newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;\n                newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,\n            Error.INVALID_AMOUNT\n        );\n        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);\n    }\n\n    /\n     * @notice Execute swapper slippage update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeSwapperSlippage() external override returns (uint256) {\n        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     /\n    function resetSwapperSlippage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    / Set fee handler /\n    /\n     * @notice Prepare update of fee handler.\n     * @param handler New fee handler.\n     * @return true if success.\n     */\n    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {\n        return _prepare(_FEE_HANDLER_KEY, handler);\n    }\n\n    /\n     * @notice Execute update of fee handler (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return true if successful.\n     /\n    function executeFeeHandler() external override returns (address) {\n        return _executeAddress(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Reset the handler deadline.\n     * @return true if success.\n     /\n    function resetFeeHandler() external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Prepare update of estimated gas usage.\n     * @param gasUsage New estimated gas usage.\n     * @return true if success.\n     */\n    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {\n        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);\n    }\n\n    /\n     * @notice Execute update of gas usage (with time delay enforced).\n     * @return true if successful.\n     /\n    function executeEstimatedGasUsage() external returns (uint256) {\n        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Reset the gas usage deadline.\n     * @return true if success.\n     /\n    function resetGasUsage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Add a new deposit token that is supported by the action.\n     * @dev There is a separate check for whether the usable token (i.e. deposit token)\n     *      is swappable for some action token.\n     * @param token Address of deposit token that can be used by the action.\n     */\n    function addUsableToken(address token) external override onlyGovernance returns (bool) {\n        return _usableTokens.add(token);\n    }\n\n    /\n     * @notice Computes the total amount of ETH (as wei) required to pay for all\n     * the top-ups assuming the maximum gas price and the current estimated gas\n     * usage of a top-up\n     /\n    function getEthRequiredForGas(address payer) external view override returns (uint256) {\n        uint256 totalEthRequired = 0;\n        RecordMeta[] memory userRecordsMeta = _userPositions[payer];\n        uint256 gasUsagePerCall = getEstimatedGasUsage();\n        uint256 length = userRecordsMeta.length;\n        for (uint256 i = 0; i &lt; length; i++) {\n            RecordMeta memory meta = userRecordsMeta[i];\n            Record memory record = _positions[payer][meta.account][meta.protocol];\n            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);\n            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;\n        }\n        return totalEthRequired;\n    }\n\n    /\n     * @notice Returns a list of positions for the given payer\n     /\n    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {\n        return _userPositions[payer];\n    }\n\n    /\n     * @notice Get a list supported protocols.\n     * @return List of supported protocols.\n     /\n    function getSupportedProtocols() external view override returns (bytes32[] memory) {\n        uint256 length = _supportedProtocols.length();\n        bytes32[] memory protocols = new bytes32;\n        for (uint256 i = 0; i &lt; length; i++) {\n            protocols[i] = _supportedProtocols.at(i);\n        }\n        return protocols;\n    }\n\n    /\n     * @notice Gets a list of users that have an active position.\n     * @dev Uses cursor pagination.\n     * @param cursor The cursor for pagination (should start at 0 for first call).\n     * @param howMany Maximum number of users to return in this pagination request.\n     * @return users List of users that have an active position.\n     * @return nextCursor The cursor to use for the next pagination request.\n     */\n    function usersWithPositions(uint256 cursor, uint256 howMany)\n        external\n        view\n        override\n        returns (address[] memory users, uint256 nextCursor)\n    {\n        uint256 length = usersWithPositions.length();\n        if (cursor &gt;= length) return (new address, 0);\n        if (howMany &gt;= length - cursor) {\n            howMany = length - cursor;\n        }\n\n        address[] memory usersWithPositions = new address;\n        for (uint256 i = 0; i &lt; howMany; i++) {\n            usersWithPositions_[i] = usersWithPositions.at(i + cursor);\n        }\n\n        return (usersWithPositions, cursor + howMany);\n    }\n\n    /\n     * @notice Get a list of all tokens usable for this action.\n     * @dev This refers to all tokens that can be used as deposit tokens.\n     * @return Array of addresses of usable tokens.\n     /\n    function getUsableTokens() external view override returns (address[] memory) {\n        return _usableTokens.toArray();\n    }\n\n    /\n     * @notice Retrieves the topup handler for the given protocol\n     /\n    function getTopUpHandler(bytes32 protocol) external view returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice Successfully tops up a position if it\'s conditions are met.\n     * @dev pool and vault funds are rebalanced after withdrawal for top up\n     * @param payer Account that pays for the top up.\n     * @param account Account owning the position for top up.\n     * @param beneficiary Address of the keeper\'s wallet for fee accrual.\n     * @param protocol Protocol of the top up position.\n     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas\n     * @return true if successful.\n     */\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol,\n        uint256 maxWeiForGas\n    ) public override returns (bool) {\n        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);\n\n        ExecuteLocalVars memory vars;\n\n        vars.initialGas = gasleft();\n\n        Record storage position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n        require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);\n\n        address topUpHandler = _getHandler(protocol, true);\n        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);\n\n        // ensure that the position is actually below its set user factor threshold\n        require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);\n\n        IGasBank gasBank = addressProvider.getGasBank();\n\n        // fail early if the user does not have enough funds in the gas bank\n        // to cover the cost of the transaction\n        vars.estimatedRequiredGas = getEstimatedGasUsage();\n        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;\n\n        // compute the gas price that the user will be paying\n        vars.userGasPrice = block.basefee + position.priorityFee;\n        if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;\n        if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;\n\n        // ensure the current position allows for the gas to be paid\n        require(\n            vars.estimatedRequiredWeiForGas &lt;=\n                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,\n            Error.ESTIMATED_GAS_TOO_HIGH\n        );\n\n        vars.gasBankBalance = gasBank.balanceOf(payer);\n        // ensure the user has enough funds in the gas bank to cover the gas\n        require(\n            vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,\n            Error.GAS_BANK_BALANCE_TOO_LOW\n        );\n\n        vars.totalTopUpAmount = position.totalTopUpAmount;\n        vars.actionFee = getActionFee();\n        // add top-up fees to top-up amount\n        vars.minActionAmountToTopUp = position.singleTopUpAmount;\n        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(\n            ScaledMath.ONE + vars.actionFee\n        );\n\n        // if the amount that we want to top-up (including fees) is higher than\n        // the available topup amount, we lower this down to what is left of the position\n        if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {\n            vars.actionAmountWithFees = vars.totalTopUpAmount;\n            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(\n                ScaledMath.ONE + vars.actionFee\n            );\n        }\n        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);\n        vars.underlying = pool.getUnderlying();\n        vars.rate = pool.exchangeRate();\n\n        ISwapper swapper;\n\n        if (vars.underlying != position.actionToken) {\n            swapper = _getSwapper(vars.underlying, position.actionToken);\n            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));\n        }\n\n        // compute the deposit tokens amount with and without fees\n        // we will need to unstake the amount with fees and to\n        // swap the amount without fees into action tokens\n        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);\n        if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {\n            vars.depositAmountWithFees = position.depositTokenBalance;\n            vars.minActionAmountToTopUp =\n                (vars.depositAmountWithFees * vars.rate) /\n                (ScaledMath.ONE + vars.actionFee);\n        }\n\n        // compute amount of LP tokens needed to pay for action\n        // rate is expressed in actionToken per depositToken\n        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);\n        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;\n\n        // will revert if vault does not exist\n        address vault = addressProvider.getStakerVault(position.depositToken);\n\n        // unstake deposit tokens including fees\n        IStakerVault(vault).unstake(vars.depositAmountWithFees);\n        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);\n\n        // swap the amount without the fees\n        // as the fees are paid in deposit token, not in action token\n        // Redeem first and use swapper only if the underlying tokens are not action tokens\n        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);\n\n        if (address(swapper) != address(0)) {\n            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(\n                getSwapperSlippage()\n            );\n            _approve(vars.underlying, address(swapper));\n            vars.actionTokenAmount = swapper.swap(\n                vars.underlying,\n                position.actionToken,\n                vars.actionTokenAmount,\n                vars.minActionAmountToTopUp\n            );\n        }\n\n        // compute how much of action token was actually redeemed and add fees to it\n        // this is to ensure that no funds get locked inside the contract\n        vars.totalActionTokenAmount =\n            vars.actionTokenAmount +\n            vars.depositTotalFeesAmount.scaledMul(vars.rate);\n\n        // at this point, we have exactly vars.actionTokenAmount\n        // (at least position.singleTopUpAmount) of action token\n        // and exactly vars.depositTotalFeesAmount deposit tokens in the contract\n        // solhint-disable-next-line avoid-low-level-calls\n        (vars.success, vars.topupResult) = topUpHandler.delegatecall(\n            abi.encodeWithSignature(\n                ""topUp(bytes32,address,uint256,bytes)"",\n                account,\n                position.actionToken,\n                vars.actionTokenAmount,\n                position.extra\n            )\n        );\n\n        require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);\n\n        // totalTopUpAmount is updated to reflect the new ""balance"" of the position\n        if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {\n            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);\n        } else {\n            position.totalTopUpAmount = 0;\n        }\n\n        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);\n\n        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;\n        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);\n        if (vars.removePosition) {\n            if (position.depositTokenBalance &gt; 0) {\n                // transfer any unused locked tokens to the payer\n                IStakerVault(vault).transfer(payer, position.depositTokenBalance);\n                IStakerVault(vault).decreaseActionLockedBalance(\n                    payer,\n                    position.depositTokenBalance\n                );\n            }\n            _removePosition(payer, account, protocol);\n        }\n\n        emit TopUp(\n            account,\n            protocol,\n            payer,\n            position.depositToken,\n            vars.depositAmountWithFees,\n            position.actionToken,\n            vars.actionTokenAmount\n        );\n\n        // compute gas used and reimburse the keeper by using the\n        // funds of payer in the gas bank\n        // TODO: add constant gas consumed for transfer and tx prologue\n        vars.gasConsumed = vars.initialGas - gasleft();\n\n        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;\n        if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {\n            vars.reimbursedWeiForGas = vars.gasBankBalance;\n        }\n\n        // ensure that the keeper is not overpaying\n        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;\n        require(\n            vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,\n            Error.GAS_TOO_HIGH\n        );\n        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);\n        if (vars.removePosition) {\n            gasBank.withdrawUnused(payer);\n        }\n\n        return true;\n    }\n\n    /\n     * @notice Prepare new top up handler fee update.\n     * @dev Setting the addres to 0 means that the protocol will no longer be supported.\n     * @param protocol Protocol for which a new handler should be prepared.\n     * @param newHandler Address of new handler.\n     * @return true if success.\n     /\n    function prepareTopUpHandler(bytes32 protocol, address newHandler)\n        public\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_getProtocolKey(protocol), newHandler);\n    }\n\n    /\n     * @notice Check if action can be executed.\n     * @param protocol for which to get the health factor\n     * @param account for which to get the health factor\n     * @param extra data to be used by the topup handler\n     * @return healthFactor of the position\n     /\n    function getHealthFactor(\n        bytes32 protocol,\n        bytes32 account,\n        bytes memory extra\n    ) public view override returns (uint256 healthFactor) {\n        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));\n        return topUpHandler.getUserFactor(account, extra);\n    }\n\n    function getHandler(bytes32 protocol) public view override returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice returns the current estimated gas usage\n     */\n    function getEstimatedGasUsage() public view returns (uint256) {\n        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];\n    }\n\n    /\n     * @notice Returns the current action fee\n     /\n    function getActionFee() public view override returns (uint256) {\n        return currentUInts256[_ACTION_FEE_KEY];\n    }\n\n    /\n     * @notice Returns the current max swapper slippage\n     /\n    function getSwapperSlippage() public view override returns (uint256) {\n        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];\n    }\n\n    /\n     * @notice Returns the current fee handler\n     */\n    function getFeeHandler() public view override returns (address) {\n        return currentAddresses[_FEE_HANDLER_KEY];\n    }\n\n    /\n     * @notice Get the record for a position.\n     * @param payer Registered payer of the position.\n     * @param account Address holding the position.\n     * @param protocol Protocol where the position is held.\n     /\n    function getPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) public view override returns (Record memory) {\n        return _positions[payer][account][protocol];\n    }\n\n    /\n     * @notice Check whether a token is usable as a deposit token.\n     * @param token Address of token to check.\n     * @return True if token is usable as a deposit token for this action.\n     /\n    function isUsable(address token) public view override returns (bool) {\n        return _usableTokens.contains(token);\n    }\n\n    function _updateTopUpHandler(\n        bytes32 protocol,\n        address oldHandler,\n        address newHandler\n    ) internal {\n        if (newHandler == address(0)) {\n            _supportedProtocols.remove(protocol);\n        } else if (oldHandler == address(0)) {\n            _supportedProtocols.add(protocol);\n        }\n    }\n\n    /\n     * @dev Pays fees to the feeHandler\n     * @param payer The account who\'s position the fees are charged on\n     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)\n     * @param feeAmount The amount in tokens to pay as fees\n     * @param depositToken The LpToken used to pay the fees\n     */\n    function _payFees(\n        address payer,\n        address beneficiary,\n        uint256 feeAmount,\n        address depositToken\n    ) internal {\n        address feeHandler = getFeeHandler();\n        IERC20(depositToken).safeApprove(feeHandler, feeAmount);\n        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);\n    }\n\n    /\n     * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction\n     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.\n     * @param payer Owner of the funds to be locked\n     * @param token Token to lock\n     * @param lockAmount Minimum amount of token to lock\n     * @param depositAmount Amount of token that was deposited.\n     *                      If this is 0 then the staker vault allowance should be used.\n     *                      If this is greater than requiredAmount more tokens will be locked.\n     /\n    function _lockFunds(\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) internal {\n        address stakerVaultAddress = addressProvider.getStakerVault(token);\n        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);\n    }\n\n    function _removePosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        delete _positions[payer][account][protocol];\n        _removeUserPosition(payer, account, protocol);\n        if (_userPositions[payer].length == 0) {\n            _usersWithPositions.remove(payer);\n        }\n        emit Deregister(payer, account, protocol);\n    }\n\n    function _removeUserPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        RecordMeta[] storage positionsMeta = _userPositions[payer];\n        uint256 length = positionsMeta.length;\n        for (uint256 i = 0; i &lt; length; i++) {\n            RecordMeta storage positionMeta = positionsMeta[i];\n            if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {\n                positionsMeta[i] = positionsMeta[length - 1];\n                positionsMeta.pop();\n                return;\n            }\n        }\n    }\n\n    /\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     /\n    function _approve(address token, address spender) internal {\n        if (IERC20(token).allowance(address(this), spender) &gt; 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     */\n    function _calcExchangeAmount(\n        address token,\n        address actionToken,\n        uint256 amount\n    ) internal view returns (uint256) {\n        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);\n    }\n\n    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {\n        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);\n    }\n\n    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {\n        address handler = currentAddresses[_getProtocolKey(protocol)];\n        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);\n        return handler;\n    }\n\n    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);\n        address underlying = pool.getUnderlying();\n        if (underlying == toToken) {\n            return true;\n        }\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);\n    }\n\n    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));\n    }\n}\n', 'ideas': "" Price Manipulation Identified.\n\nVULNERABILITY NAME: Centralized Price Manipulation Risk\n'''\nThe contract relies on external price feeds from liquidity pools and swappers to determine token prices. If the underlying liquidity pools or swappers are controlled by a centralized authority, they can manipulate the prices at will, leading to unfair trading conditions. This can result in users being misled about the actual value of their tokens, allowing the controlling entity to profit at the expense of others.\n\nRecommended Mitigation/Fix:**\nImplement a decentralized price oracles system that aggregates prices from""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-15-08 09:54:58 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol""; import ""../../../interfaces/IGasBank.sol""; import ""../../../interfaces/pool/ILiquidityPool.sol""; import ""../../../interfaces/ISwapperRegistry.sol""; import ""../../../interfaces/IController.sol""; import ""../../../interfaces/IStakerVault.sol""; import ""../../../interfaces/ISwapper.sol""; import ""../../../interfaces/actions/topup/ITopUpHandler.sol""; import ""../../../interfaces/actions/topup/ITopUpAction.sol""; import ""../../../interfaces/actions/IActionFeeHandler.sol""; import ""../../../libraries/AddressProviderHelpers.sol""; import ""../../../libraries/Errors.sol""; import ""../../../libraries/ScaledMath.sol""; import ""../../../libraries/EnumerableExtensions.sol""; import ""../../access/Authorization.sol""; import ""../../utils/Preparable.sol""; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being ""too deep""  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee""; bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler""; bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler""; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage""; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             ""topUp(bytes32,address,uint256,bytes)"",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new ""balance"" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-15-08 09:54:58 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";

import ""../../../interfaces/IGasBank.sol"";
import ""../../../interfaces/pool/ILiquidityPool.sol"";
import ""../../../interfaces/ISwapperRegistry.sol"";
import ""../../../interfaces/IController.sol"";
import ""../../../interfaces/IStakerVault.sol"";
import ""../../../interfaces/ISwapper.sol"";
import ""../../../interfaces/actions/topup/ITopUpHandler.sol"";
import ""../../../interfaces/actions/topup/ITopUpAction.sol"";
import ""../../../interfaces/actions/IActionFeeHandler.sol"";

import ""../../../libraries/AddressProviderHelpers.sol"";
import ""../../../libraries/Errors.sol"";
import ""../../../libraries/ScaledMath.sol"";
import ""../../../libraries/EnumerableExtensions.sol"";

import ""../../access/Authorization.sol"";
import ""../../utils/Preparable.sol"";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being ""too deep""
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee"";
    bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler"";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler"";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage"";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                ""topUp(bytes32,address,uint256,bytes)"",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new ""balance"" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";

import ""../../../interfaces/IGasBank.sol"";
import ""../../../interfaces/pool/ILiquidityPool.sol"";
import ""../../../interfaces/ISwapperRegistry.sol"";
import ""../../../interfaces/IController.sol"";
import ""../../../interfaces/IStakerVault.sol"";
import ""../../../interfaces/ISwapper.sol"";
import ""../../../interfaces/actions/topup/ITopUpHandler.sol"";
import ""../../../interfaces/actions/topup/ITopUpAction.sol"";
import ""../../../interfaces/actions/IActionFeeHandler.sol"";

import ""../../../libraries/AddressProviderHelpers.sol"";
import ""../../../libraries/Errors.sol"";
import ""../../../libraries/ScaledMath.sol"";
import ""../../../libraries/EnumerableExtensions.sol"";

import ""../../access/Authorization.sol"";
import ""../../utils/Preparable.sol"";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being ""too deep""
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee"";
    bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler"";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler"";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage"";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                ""topUp(bytes32,address,uint256,bytes)"",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new ""balance"" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
"".
Ideas: "" Price Manipulation Identified.

**VULNERABILITY NAME: Centralized Price Manipulation Risk**
'''
The contract relies on external price feeds from liquidity pools and swappers to determine token prices. If the underlying liquidity pools or swappers are controlled by a centralized authority, they can manipulate the prices at will, leading to unfair trading conditions. This can result in users being misled about the actual value of their tokens, allowing the controlling entity to profit at the expense of others.

**Recommended Mitigation/Fix:**
Implement a decentralized price oracles system that aggregates prices from"".
As the Security Analyst, your primary objective is to conduct a comprehensive inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Assumption of Fixed-Length Array. There are two cases where the contract may have Assumption of Fixed-Length Array vulnerabilities:
1. When the contract incorrectly assumes that an array returned by a function has a fixed length, potentially leading to data corruption or out-of-bounds errors if the actual array length differs.
2. When the contract does not handle dynamic array lengths properly, causing incorrect data processing or logic errors.
If you identify all Assumption of Fixed-Length Array vulnerabilities, respond with: """,,,"<INFO> Lack of Authorization Identified.

**Lack of Authorization**
'''
The

[2024-15-08 09:55:09 INFO] **[Execute Detail]**

execute SimplePhase:[DataInconsistencyDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-15-08 09:55:09 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol""; import ""../../../interfaces/IGasBank.sol""; import ""../../../interfaces/pool/ILiquidityPool.sol""; import ""../../../interfaces/ISwapperRegistry.sol""; import ""../../../interfaces/IController.sol""; import ""../../../interfaces/IStakerVault.sol""; import ""../../../interfaces/ISwapper.sol""; import ""../../../interfaces/actions/topup/ITopUpHandler.sol""; import ""../../../interfaces/actions/topup/ITopUpAction.sol""; import ""../../../interfaces/actions/IActionFeeHandler.sol""; import ""../../../libraries/AddressProviderHelpers.sol""; import ""../../../libraries/Errors.sol""; import ""../../../libraries/ScaledMath.sol""; import ""../../../libraries/EnumerableExtensions.sol""; import ""../../access/Authorization.sol""; import ""../../utils/Preparable.sol""; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being ""too deep""  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee""; bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler""; bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler""; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage""; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             ""topUp(bytes32,address,uint256,bytes)"",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new ""balance"" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Potential Data Inconsistency. This type of vulnerability occurs when data may become inconsistent due to incorrect assumptions about how data is stored, accessed, or modified. Proceed with the following steps in your analysis: 1. Scrutinize the contract's code to identify any assumptions made about the behavior of storage and memory when handling data. 2. Look for patterns where data is copied from storage to memory, or vice versa, and determine if these operations are performed correctly. 3. Identify any functions or segments of code where temporary copies of data are made, and assess whether these copies are used appropriately without causing unintended modifications to the original data. 4. Evaluate the overall logic of data manipulation within the contract to ensure that all operations maintain consistency and integrity of the stored data. If you discover any Potential Data Inconsistency vulnerabilities, respond with: "" Potential Data Inconsistency Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If NO Potential Data Inconsistency vulnerabilities are found, respond only with: "" NO Potential Data Inconsistency."" |
| **phase_name** | DataInconsistencyDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";\nimport ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";\n\nimport ""../../../interfaces/IGasBank.sol"";\nimport ""../../../interfaces/pool/ILiquidityPool.sol"";\nimport ""../../../interfaces/ISwapperRegistry.sol"";\nimport ""../../../interfaces/IController.sol"";\nimport ""../../../interfaces/IStakerVault.sol"";\nimport ""../../../interfaces/ISwapper.sol"";\nimport ""../../../interfaces/actions/topup/ITopUpHandler.sol"";\nimport ""../../../interfaces/actions/topup/ITopUpAction.sol"";\nimport ""../../../interfaces/actions/IActionFeeHandler.sol"";\n\nimport ""../../../libraries/AddressProviderHelpers.sol"";\nimport ""../../../libraries/Errors.sol"";\nimport ""../../../libraries/ScaledMath.sol"";\nimport ""../../../libraries/EnumerableExtensions.sol"";\n\nimport ""../../access/Authorization.sol"";\nimport ""../../utils/Preparable.sol"";\n\n/\n * @notice The logic here should really be part of the top-up action\n * but is split in a library to circumvent the byte-code size limit\n */\nlibrary TopUpActionLibrary {\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    function lockFunds(\n        address stakerVaultAddress,\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) external {\n        uint256 amountLeft = lockAmount;\n        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);\n\n        // stake deposit amount\n        if (depositAmount &gt; 0) {\n            depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;\n            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);\n            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);\n            stakerVault.stake(depositAmount);\n            stakerVault.increaseActionLockedBalance(payer, depositAmount);\n            amountLeft -= depositAmount;\n        }\n\n        // use stake vault allowance if available and required\n        if (amountLeft &gt; 0) {\n            uint256 balance = stakerVault.balanceOf(payer);\n            uint256 allowance = stakerVault.allowance(payer, address(this));\n            uint256 availableFunds = balance &lt; allowance ? balance : allowance;\n            if (availableFunds &gt;= amountLeft) {\n                stakerVault.transferFrom(payer, address(this), amountLeft);\n                amountLeft = 0;\n            }\n        }\n\n        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);\n    }\n\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     /\n    function calcExchangeAmount(\n        IAddressProvider addressProvider,\n        address token,\n        address actionToken,\n        uint256 amount\n    ) external view returns (uint256) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        uint256 rate = pool.exchangeRate();\n        address underlying = pool.getUnderlying();\n        if (underlying == actionToken) {\n            return amount.scaledDivRoundUp(rate);\n        }\n\n        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);\n        uint256 swapperRate = swapper.getRate(underlying, actionToken);\n        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));\n    }\n\n    function getSwapper(\n        IAddressProvider addressProvider,\n        address underlying,\n        address actionToken\n    ) public view returns (ISwapper) {\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);\n        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);\n        return ISwapper(swapper);\n    }\n}\n\ncontract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {\n    using ScaledMath for uint256;\n    using ScaledMath for uint128;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using AddressProviderHelpers for IAddressProvider;\n\n    /\n     * @dev Temporary struct to hold local variables in execute\n     * and avoid the stack being ""too deep""\n     /\n    struct ExecuteLocalVars {\n        uint256 minActionAmountToTopUp;\n        uint256 actionTokenAmount;\n        uint256 depositTotalFeesAmount;\n        uint256 actionAmountWithFees;\n        uint256 userFactor;\n        uint256 rate;\n        uint256 depositAmountWithFees;\n        uint256 depositAmountWithoutFees;\n        uint256 actionFee;\n        uint256 totalActionTokenAmount;\n        uint128 totalTopUpAmount;\n        bool success;\n        bytes topupResult;\n        uint256 gasBankBalance;\n        uint256 initialGas;\n        uint256 gasConsumed;\n        uint256 userGasPrice;\n        uint256 estimatedRequiredGas;\n        uint256 estimatedRequiredWeiForGas;\n        uint256 requiredWeiForGas;\n        uint256 reimbursedWeiForGas;\n        address underlying;\n        bool removePosition;\n    }\n\n    EnumerableSet.AddressSet private _usableTokens;\n\n    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;\n\n    bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee"";\n    bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler"";\n    bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler"";\n    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage"";\n    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";\n\n    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;\n    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;\n    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    EnumerableSet.Bytes32Set internal _supportedProtocols;\n\n    /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record)\n    mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;\n\n    mapping(address =&gt; RecordMeta[]) internal _userPositions;\n\n    EnumerableSet.AddressSet internal _usersWithPositions;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        addressProvider = controller.addressProvider();\n        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);\n    }\n\n    receive() external payable {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function initialize(\n        address feeHandler,\n        bytes32[] calldata protocols,\n        address[] calldata handlers\n    ) external initializer onlyGovernance {\n        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);\n        _setConfig(_FEE_HANDLER_KEY, feeHandler);\n        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);\n        for (uint256 i = 0; i &lt; protocols.length; i++) {\n            bytes32 protocolKey = _getProtocolKey(protocols[i]);\n            _setConfig(protocolKey, handlers[i]);\n            _updateTopUpHandler(protocols[i], address(0), handlers[i]);\n        }\n    }\n\n    /\n     * @notice Register a top up action.\n     * @dev The depositAmount must be greater or equal to the totalTopUpAmount (which is denominated in actionToken).\n     * @param account Account to be topped up (first 20 bytes will typically be the address).\n     * @param depositAmount Amount of depositToken that will be locked.\n     * @param protocol Protocol which holds position to be topped up.\n     * @param record containing the data for the position to register\n     /\n    function register(\n        bytes32 account,\n        bytes32 protocol,\n        uint128 depositAmount,\n        Record memory record\n    ) external payable returns (bool) {\n        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);\n        require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);\n        require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);\n        require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);\n        require(\n            _positions[msg.sender][account][protocol].threshold == 0,\n            Error.POSITION_ALREADY_EXISTS\n        );\n        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);\n        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);\n\n        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) \n            record.maxFee *\n            getEstimatedGasUsage();\n\n        require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);\n\n        uint256 totalLockAmount = _calcExchangeAmount(\n            record.depositToken,\n            record.actionToken,\n            record.totalTopUpAmount\n        );\n        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);\n\n        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);\n\n        record.depositTokenBalance = uint128(totalLockAmount);\n        _positions[msg.sender][account][protocol] = record;\n        _userPositions[msg.sender].push(RecordMeta(account, protocol));\n        _usersWithPositions.add(msg.sender);\n\n        emit Register(\n            account,\n            protocol,\n            record.threshold,\n            msg.sender,\n            record.depositToken,\n            totalLockAmount,\n            record.actionToken,\n            record.singleTopUpAmount,\n            record.totalTopUpAmount,\n            record.maxFee,\n            record.extra\n        );\n        return true;\n    }\n\n    /\n     * @notice See overloaded version of execute for more details.\n     /\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol\n    ) external override returns (bool) {\n        return execute(payer, account, beneficiary, protocol, 0);\n    }\n\n    /\n     * @notice Delete a position to back on the given protocol for account.\n     * @param account Account holding the position.\n     * @param protocol Protocol the position is held on.\n     * @param unstake If the tokens should be unstaked from vault.\n     * @return true if successful.\n     /\n    function resetPosition(\n        bytes32 account,\n        bytes32 protocol,\n        bool unstake\n    ) external override returns (bool) {\n        address payer = msg.sender;\n        Record memory position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n\n        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist\n        IStakerVault staker = IStakerVault(vault);\n        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);\n        if (unstake) {\n            staker.unstake(position.depositTokenBalance);\n            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);\n        } else {\n            staker.transfer(payer, position.depositTokenBalance);\n        }\n\n        _removePosition(payer, account, protocol);\n        addressProvider.getGasBank().withdrawUnused(payer);\n        return true;\n    }\n\n    /\n     * @notice Execute top up handler update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @param protocol Protocol for which a new handler should be executed.\n     * @return Address of new handler.\n     */\n    function executeTopUpHandler(bytes32 protocol) external override returns (address) {\n        address oldHandler = _getHandler(protocol, false);\n        address newHandler = _executeAddress(_getProtocolKey(protocol));\n\n        _updateTopUpHandler(protocol, oldHandler, newHandler);\n        return newHandler;\n    }\n\n    /\n     * @notice Reset new top up handler deadline for a protocol.\n     * @param protocol Protocol for which top up handler deadline should be reset.\n     * @return true if successful.\n     /\n    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_getProtocolKey(protocol));\n    }\n\n    /\n     * @notice Prepare action fee update.\n     * @param newActionFee New fee to set.\n     * @return true if success.\n     /\n    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {\n        require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);\n        return _prepare(_ACTION_FEE_KEY, newActionFee);\n    }\n\n    /\n     * @notice Execute action fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeActionFee() external override returns (uint256) {\n        return _executeUInt256(_ACTION_FEE_KEY);\n    }\n\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     /\n    function resetActionFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ACTION_FEE_KEY);\n    }\n\n    /\n     * @notice Prepare swapper slippage update.\n     * @param newSwapperSlippage New slippage to set.\n     * @return true if success.\n     /\n    function prepareSwapperSlippage(uint256 newSwapperSlippage)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        require(\n            newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;\n                newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,\n            Error.INVALID_AMOUNT\n        );\n        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);\n    }\n\n    /\n     * @notice Execute swapper slippage update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeSwapperSlippage() external override returns (uint256) {\n        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     /\n    function resetSwapperSlippage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    / Set fee handler /\n    /\n     * @notice Prepare update of fee handler.\n     * @param handler New fee handler.\n     * @return true if success.\n     */\n    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {\n        return _prepare(_FEE_HANDLER_KEY, handler);\n    }\n\n    /\n     * @notice Execute update of fee handler (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return true if successful.\n     /\n    function executeFeeHandler() external override returns (address) {\n        return _executeAddress(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Reset the handler deadline.\n     * @return true if success.\n     /\n    function resetFeeHandler() external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Prepare update of estimated gas usage.\n     * @param gasUsage New estimated gas usage.\n     * @return true if success.\n     */\n    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {\n        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);\n    }\n\n    /\n     * @notice Execute update of gas usage (with time delay enforced).\n     * @return true if successful.\n     /\n    function executeEstimatedGasUsage() external returns (uint256) {\n        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Reset the gas usage deadline.\n     * @return true if success.\n     /\n    function resetGasUsage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Add a new deposit token that is supported by the action.\n     * @dev There is a separate check for whether the usable token (i.e. deposit token)\n     *      is swappable for some action token.\n     * @param token Address of deposit token that can be used by the action.\n     */\n    function addUsableToken(address token) external override onlyGovernance returns (bool) {\n        return _usableTokens.add(token);\n    }\n\n    /\n     * @notice Computes the total amount of ETH (as wei) required to pay for all\n     * the top-ups assuming the maximum gas price and the current estimated gas\n     * usage of a top-up\n     /\n    function getEthRequiredForGas(address payer) external view override returns (uint256) {\n        uint256 totalEthRequired = 0;\n        RecordMeta[] memory userRecordsMeta = _userPositions[payer];\n        uint256 gasUsagePerCall = getEstimatedGasUsage();\n        uint256 length = userRecordsMeta.length;\n        for (uint256 i = 0; i &lt; length; i++) {\n            RecordMeta memory meta = userRecordsMeta[i];\n            Record memory record = _positions[payer][meta.account][meta.protocol];\n            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);\n            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;\n        }\n        return totalEthRequired;\n    }\n\n    /\n     * @notice Returns a list of positions for the given payer\n     /\n    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {\n        return _userPositions[payer];\n    }\n\n    /\n     * @notice Get a list supported protocols.\n     * @return List of supported protocols.\n     /\n    function getSupportedProtocols() external view override returns (bytes32[] memory) {\n        uint256 length = _supportedProtocols.length();\n        bytes32[] memory protocols = new bytes32;\n        for (uint256 i = 0; i &lt; length; i++) {\n            protocols[i] = _supportedProtocols.at(i);\n        }\n        return protocols;\n    }\n\n    /\n     * @notice Gets a list of users that have an active position.\n     * @dev Uses cursor pagination.\n     * @param cursor The cursor for pagination (should start at 0 for first call).\n     * @param howMany Maximum number of users to return in this pagination request.\n     * @return users List of users that have an active position.\n     * @return nextCursor The cursor to use for the next pagination request.\n     */\n    function usersWithPositions(uint256 cursor, uint256 howMany)\n        external\n        view\n        override\n        returns (address[] memory users, uint256 nextCursor)\n    {\n        uint256 length = usersWithPositions.length();\n        if (cursor &gt;= length) return (new address, 0);\n        if (howMany &gt;= length - cursor) {\n            howMany = length - cursor;\n        }\n\n        address[] memory usersWithPositions = new address;\n        for (uint256 i = 0; i &lt; howMany; i++) {\n            usersWithPositions_[i] = usersWithPositions.at(i + cursor);\n        }\n\n        return (usersWithPositions, cursor + howMany);\n    }\n\n    /\n     * @notice Get a list of all tokens usable for this action.\n     * @dev This refers to all tokens that can be used as deposit tokens.\n     * @return Array of addresses of usable tokens.\n     /\n    function getUsableTokens() external view override returns (address[] memory) {\n        return _usableTokens.toArray();\n    }\n\n    /\n     * @notice Retrieves the topup handler for the given protocol\n     /\n    function getTopUpHandler(bytes32 protocol) external view returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice Successfully tops up a position if it\'s conditions are met.\n     * @dev pool and vault funds are rebalanced after withdrawal for top up\n     * @param payer Account that pays for the top up.\n     * @param account Account owning the position for top up.\n     * @param beneficiary Address of the keeper\'s wallet for fee accrual.\n     * @param protocol Protocol of the top up position.\n     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas\n     * @return true if successful.\n     */\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol,\n        uint256 maxWeiForGas\n    ) public override returns (bool) {\n        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);\n\n        ExecuteLocalVars memory vars;\n\n        vars.initialGas = gasleft();\n\n        Record storage position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n        require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);\n\n        address topUpHandler = _getHandler(protocol, true);\n        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);\n\n        // ensure that the position is actually below its set user factor threshold\n        require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);\n\n        IGasBank gasBank = addressProvider.getGasBank();\n\n        // fail early if the user does not have enough funds in the gas bank\n        // to cover the cost of the transaction\n        vars.estimatedRequiredGas = getEstimatedGasUsage();\n        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;\n\n        // compute the gas price that the user will be paying\n        vars.userGasPrice = block.basefee + position.priorityFee;\n        if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;\n        if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;\n\n        // ensure the current position allows for the gas to be paid\n        require(\n            vars.estimatedRequiredWeiForGas &lt;=\n                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,\n            Error.ESTIMATED_GAS_TOO_HIGH\n        );\n\n        vars.gasBankBalance = gasBank.balanceOf(payer);\n        // ensure the user has enough funds in the gas bank to cover the gas\n        require(\n            vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,\n            Error.GAS_BANK_BALANCE_TOO_LOW\n        );\n\n        vars.totalTopUpAmount = position.totalTopUpAmount;\n        vars.actionFee = getActionFee();\n        // add top-up fees to top-up amount\n        vars.minActionAmountToTopUp = position.singleTopUpAmount;\n        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(\n            ScaledMath.ONE + vars.actionFee\n        );\n\n        // if the amount that we want to top-up (including fees) is higher than\n        // the available topup amount, we lower this down to what is left of the position\n        if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {\n            vars.actionAmountWithFees = vars.totalTopUpAmount;\n            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(\n                ScaledMath.ONE + vars.actionFee\n            );\n        }\n        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);\n        vars.underlying = pool.getUnderlying();\n        vars.rate = pool.exchangeRate();\n\n        ISwapper swapper;\n\n        if (vars.underlying != position.actionToken) {\n            swapper = _getSwapper(vars.underlying, position.actionToken);\n            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));\n        }\n\n        // compute the deposit tokens amount with and without fees\n        // we will need to unstake the amount with fees and to\n        // swap the amount without fees into action tokens\n        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);\n        if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {\n            vars.depositAmountWithFees = position.depositTokenBalance;\n            vars.minActionAmountToTopUp =\n                (vars.depositAmountWithFees * vars.rate) /\n                (ScaledMath.ONE + vars.actionFee);\n        }\n\n        // compute amount of LP tokens needed to pay for action\n        // rate is expressed in actionToken per depositToken\n        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);\n        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;\n\n        // will revert if vault does not exist\n        address vault = addressProvider.getStakerVault(position.depositToken);\n\n        // unstake deposit tokens including fees\n        IStakerVault(vault).unstake(vars.depositAmountWithFees);\n        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);\n\n        // swap the amount without the fees\n        // as the fees are paid in deposit token, not in action token\n        // Redeem first and use swapper only if the underlying tokens are not action tokens\n        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);\n\n        if (address(swapper) != address(0)) {\n            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(\n                getSwapperSlippage()\n            );\n            _approve(vars.underlying, address(swapper));\n            vars.actionTokenAmount = swapper.swap(\n                vars.underlying,\n                position.actionToken,\n                vars.actionTokenAmount,\n                vars.minActionAmountToTopUp\n            );\n        }\n\n        // compute how much of action token was actually redeemed and add fees to it\n        // this is to ensure that no funds get locked inside the contract\n        vars.totalActionTokenAmount =\n            vars.actionTokenAmount +\n            vars.depositTotalFeesAmount.scaledMul(vars.rate);\n\n        // at this point, we have exactly vars.actionTokenAmount\n        // (at least position.singleTopUpAmount) of action token\n        // and exactly vars.depositTotalFeesAmount deposit tokens in the contract\n        // solhint-disable-next-line avoid-low-level-calls\n        (vars.success, vars.topupResult) = topUpHandler.delegatecall(\n            abi.encodeWithSignature(\n                ""topUp(bytes32,address,uint256,bytes)"",\n                account,\n                position.actionToken,\n                vars.actionTokenAmount,\n                position.extra\n            )\n        );\n\n        require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);\n\n        // totalTopUpAmount is updated to reflect the new ""balance"" of the position\n        if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {\n            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);\n        } else {\n            position.totalTopUpAmount = 0;\n        }\n\n        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);\n\n        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;\n        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);\n        if (vars.removePosition) {\n            if (position.depositTokenBalance &gt; 0) {\n                // transfer any unused locked tokens to the payer\n                IStakerVault(vault).transfer(payer, position.depositTokenBalance);\n                IStakerVault(vault).decreaseActionLockedBalance(\n                    payer,\n                    position.depositTokenBalance\n                );\n            }\n            _removePosition(payer, account, protocol);\n        }\n\n        emit TopUp(\n            account,\n            protocol,\n            payer,\n            position.depositToken,\n            vars.depositAmountWithFees,\n            position.actionToken,\n            vars.actionTokenAmount\n        );\n\n        // compute gas used and reimburse the keeper by using the\n        // funds of payer in the gas bank\n        // TODO: add constant gas consumed for transfer and tx prologue\n        vars.gasConsumed = vars.initialGas - gasleft();\n\n        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;\n        if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {\n            vars.reimbursedWeiForGas = vars.gasBankBalance;\n        }\n\n        // ensure that the keeper is not overpaying\n        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;\n        require(\n            vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,\n            Error.GAS_TOO_HIGH\n        );\n        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);\n        if (vars.removePosition) {\n            gasBank.withdrawUnused(payer);\n        }\n\n        return true;\n    }\n\n    /\n     * @notice Prepare new top up handler fee update.\n     * @dev Setting the addres to 0 means that the protocol will no longer be supported.\n     * @param protocol Protocol for which a new handler should be prepared.\n     * @param newHandler Address of new handler.\n     * @return true if success.\n     /\n    function prepareTopUpHandler(bytes32 protocol, address newHandler)\n        public\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_getProtocolKey(protocol), newHandler);\n    }\n\n    /\n     * @notice Check if action can be executed.\n     * @param protocol for which to get the health factor\n     * @param account for which to get the health factor\n     * @param extra data to be used by the topup handler\n     * @return healthFactor of the position\n     /\n    function getHealthFactor(\n        bytes32 protocol,\n        bytes32 account,\n        bytes memory extra\n    ) public view override returns (uint256 healthFactor) {\n        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));\n        return topUpHandler.getUserFactor(account, extra);\n    }\n\n    function getHandler(bytes32 protocol) public view override returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice returns the current estimated gas usage\n     */\n    function getEstimatedGasUsage() public view returns (uint256) {\n        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];\n    }\n\n    /\n     * @notice Returns the current action fee\n     /\n    function getActionFee() public view override returns (uint256) {\n        return currentUInts256[_ACTION_FEE_KEY];\n    }\n\n    /\n     * @notice Returns the current max swapper slippage\n     /\n    function getSwapperSlippage() public view override returns (uint256) {\n        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];\n    }\n\n    /\n     * @notice Returns the current fee handler\n     */\n    function getFeeHandler() public view override returns (address) {\n        return currentAddresses[_FEE_HANDLER_KEY];\n    }\n\n    /\n     * @notice Get the record for a position.\n     * @param payer Registered payer of the position.\n     * @param account Address holding the position.\n     * @param protocol Protocol where the position is held.\n     /\n    function getPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) public view override returns (Record memory) {\n        return _positions[payer][account][protocol];\n    }\n\n    /\n     * @notice Check whether a token is usable as a deposit token.\n     * @param token Address of token to check.\n     * @return True if token is usable as a deposit token for this action.\n     /\n    function isUsable(address token) public view override returns (bool) {\n        return _usableTokens.contains(token);\n    }\n\n    function _updateTopUpHandler(\n        bytes32 protocol,\n        address oldHandler,\n        address newHandler\n    ) internal {\n        if (newHandler == address(0)) {\n            _supportedProtocols.remove(protocol);\n        } else if (oldHandler == address(0)) {\n            _supportedProtocols.add(protocol);\n        }\n    }\n\n    /\n     * @dev Pays fees to the feeHandler\n     * @param payer The account who\'s position the fees are charged on\n     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)\n     * @param feeAmount The amount in tokens to pay as fees\n     * @param depositToken The LpToken used to pay the fees\n     */\n    function _payFees(\n        address payer,\n        address beneficiary,\n        uint256 feeAmount,\n        address depositToken\n    ) internal {\n        address feeHandler = getFeeHandler();\n        IERC20(depositToken).safeApprove(feeHandler, feeAmount);\n        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);\n    }\n\n    /\n     * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction\n     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.\n     * @param payer Owner of the funds to be locked\n     * @param token Token to lock\n     * @param lockAmount Minimum amount of token to lock\n     * @param depositAmount Amount of token that was deposited.\n     *                      If this is 0 then the staker vault allowance should be used.\n     *                      If this is greater than requiredAmount more tokens will be locked.\n     /\n    function _lockFunds(\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) internal {\n        address stakerVaultAddress = addressProvider.getStakerVault(token);\n        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);\n    }\n\n    function _removePosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        delete _positions[payer][account][protocol];\n        _removeUserPosition(payer, account, protocol);\n        if (_userPositions[payer].length == 0) {\n            _usersWithPositions.remove(payer);\n        }\n        emit Deregister(payer, account, protocol);\n    }\n\n    function _removeUserPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        RecordMeta[] storage positionsMeta = _userPositions[payer];\n        uint256 length = positionsMeta.length;\n        for (uint256 i = 0; i &lt; length; i++) {\n            RecordMeta storage positionMeta = positionsMeta[i];\n            if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {\n                positionsMeta[i] = positionsMeta[length - 1];\n                positionsMeta.pop();\n                return;\n            }\n        }\n    }\n\n    /\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     /\n    function _approve(address token, address spender) internal {\n        if (IERC20(token).allowance(address(this), spender) &gt; 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     */\n    function _calcExchangeAmount(\n        address token,\n        address actionToken,\n        uint256 amount\n    ) internal view returns (uint256) {\n        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);\n    }\n\n    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {\n        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);\n    }\n\n    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {\n        address handler = currentAddresses[_getProtocolKey(protocol)];\n        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);\n        return handler;\n    }\n\n    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);\n        address underlying = pool.getUnderlying();\n        if (underlying == toToken) {\n            return true;\n        }\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);\n    }\n\n    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));\n    }\n}\n', 'ideas': "" Lack of Authorization Identified.\n\nLack of Authorization**\n'''\nThe""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-15-08 09:55:09 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol""; import ""../../../interfaces/IGasBank.sol""; import ""../../../interfaces/pool/ILiquidityPool.sol""; import ""../../../interfaces/ISwapperRegistry.sol""; import ""../../../interfaces/IController.sol""; import ""../../../interfaces/IStakerVault.sol""; import ""../../../interfaces/ISwapper.sol""; import ""../../../interfaces/actions/topup/ITopUpHandler.sol""; import ""../../../interfaces/actions/topup/ITopUpAction.sol""; import ""../../../interfaces/actions/IActionFeeHandler.sol""; import ""../../../libraries/AddressProviderHelpers.sol""; import ""../../../libraries/Errors.sol""; import ""../../../libraries/ScaledMath.sol""; import ""../../../libraries/EnumerableExtensions.sol""; import ""../../access/Authorization.sol""; import ""../../utils/Preparable.sol""; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being ""too deep""  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee""; bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler""; bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler""; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage""; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             ""topUp(bytes32,address,uint256,bytes)"",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new ""balance"" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-15-08 09:55:09 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";

import ""../../../interfaces/IGasBank.sol"";
import ""../../../interfaces/pool/ILiquidityPool.sol"";
import ""../../../interfaces/ISwapperRegistry.sol"";
import ""../../../interfaces/IController.sol"";
import ""../../../interfaces/IStakerVault.sol"";
import ""../../../interfaces/ISwapper.sol"";
import ""../../../interfaces/actions/topup/ITopUpHandler.sol"";
import ""../../../interfaces/actions/topup/ITopUpAction.sol"";
import ""../../../interfaces/actions/IActionFeeHandler.sol"";

import ""../../../libraries/AddressProviderHelpers.sol"";
import ""../../../libraries/Errors.sol"";
import ""../../../libraries/ScaledMath.sol"";
import ""../../../libraries/EnumerableExtensions.sol"";

import ""../../access/Authorization.sol"";
import ""../../utils/Preparable.sol"";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being ""too deep""
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee"";
    bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler"";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler"";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage"";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                ""topUp(bytes32,address,uint256,bytes)"",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new ""balance"" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";

import ""../../../interfaces/IGasBank.sol"";
import ""../../../interfaces/pool/ILiquidityPool.sol"";
import ""../../../interfaces/ISwapperRegistry.sol"";
import ""../../../interfaces/IController.sol"";
import ""../../../interfaces/IStakerVault.sol"";
import ""../../../interfaces/ISwapper.sol"";
import ""../../../interfaces/actions/topup/ITopUpHandler.sol"";
import ""../../../interfaces/actions/topup/ITopUpAction.sol"";
import ""../../../interfaces/actions/IActionFeeHandler.sol"";

import ""../../../libraries/AddressProviderHelpers.sol"";
import ""../../../libraries/Errors.sol"";
import ""../../../libraries/ScaledMath.sol"";
import ""../../../libraries/EnumerableExtensions.sol"";

import ""../../access/Authorization.sol"";
import ""../../utils/Preparable.sol"";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being ""too deep""
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee"";
    bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler"";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler"";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage"";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                ""topUp(bytes32,address,uint256,bytes)"",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new ""balance"" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
"".
Ideas: "" Lack of Authorization Identified.

**Lack of Authorization**
'''
The"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Potential Data Inconsistency. This type of vulnerability occurs when data may become inconsistent due to incorrect assumptions about how data is stored, accessed, or modified.
Proceed with the following steps in your analysis:
1. Scrutinize the contract's code to identify any assumptions made about the behavior of storage and memory when handling data.
2. Look for patterns where data is copied from storage to memory, or vice versa, and determine if these operations are performed correctly.
3. Identify any functions or segments of code where temporary copies of data are made, and assess whether these copies are used appropriately without causing unintended modifications to the original data.
4. Evaluate the overall logic of data manipulation within the contract to ensure that all operations maintain consistency and integrity of the stored data.
If you discover any Potential Data Inconsistency vulnerabilities, respond with: ""","<INFO> Potential Data Inconsistency Identified.

**Potential Data In

[2024-15-08 09:55:12 INFO] **[Execute Detail]**

execute SimplePhase:[HashCollisionDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-15-08 09:55:12 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol""; import ""../../../interfaces/IGasBank.sol""; import ""../../../interfaces/pool/ILiquidityPool.sol""; import ""../../../interfaces/ISwapperRegistry.sol""; import ""../../../interfaces/IController.sol""; import ""../../../interfaces/IStakerVault.sol""; import ""../../../interfaces/ISwapper.sol""; import ""../../../interfaces/actions/topup/ITopUpHandler.sol""; import ""../../../interfaces/actions/topup/ITopUpAction.sol""; import ""../../../interfaces/actions/IActionFeeHandler.sol""; import ""../../../libraries/AddressProviderHelpers.sol""; import ""../../../libraries/Errors.sol""; import ""../../../libraries/ScaledMath.sol""; import ""../../../libraries/EnumerableExtensions.sol""; import ""../../access/Authorization.sol""; import ""../../utils/Preparable.sol""; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being ""too deep""  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee""; bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler""; bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler""; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage""; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             ""topUp(bytes32,address,uint256,bytes)"",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new ""balance"" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Hash Collision. This type of vulnerability occurs when different inputs produce the same hash due to improper handling of concatenated values, leading to potential security issues. Proceed with the following steps in your analysis: 1. Scrutinize the contract's code to identify any functions that generate hashes from input values. 2. Look for patterns where multiple input values are concatenated without clear delimiters before hashing. Pay special attention to the use of abi.encodePacked for concatenation. 3. Determine if the concatenated inputs can produce the same hash for different combinations of input values, leading to potential hash collisions. 4. Evaluate the logic for generating and handling hashes within the contract to ensure that the potential for hash collisions is minimized. If you discover any Hash Collision vulnerabilities, respond with: "" Hash Collision Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If NO Hash Collision vulnerabilities are found, respond only with: "" NO Hash Collision."" |
| **phase_name** | HashCollisionDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";\nimport ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";\n\nimport ""../../../interfaces/IGasBank.sol"";\nimport ""../../../interfaces/pool/ILiquidityPool.sol"";\nimport ""../../../interfaces/ISwapperRegistry.sol"";\nimport ""../../../interfaces/IController.sol"";\nimport ""../../../interfaces/IStakerVault.sol"";\nimport ""../../../interfaces/ISwapper.sol"";\nimport ""../../../interfaces/actions/topup/ITopUpHandler.sol"";\nimport ""../../../interfaces/actions/topup/ITopUpAction.sol"";\nimport ""../../../interfaces/actions/IActionFeeHandler.sol"";\n\nimport ""../../../libraries/AddressProviderHelpers.sol"";\nimport ""../../../libraries/Errors.sol"";\nimport ""../../../libraries/ScaledMath.sol"";\nimport ""../../../libraries/EnumerableExtensions.sol"";\n\nimport ""../../access/Authorization.sol"";\nimport ""../../utils/Preparable.sol"";\n\n/\n * @notice The logic here should really be part of the top-up action\n * but is split in a library to circumvent the byte-code size limit\n */\nlibrary TopUpActionLibrary {\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    function lockFunds(\n        address stakerVaultAddress,\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) external {\n        uint256 amountLeft = lockAmount;\n        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);\n\n        // stake deposit amount\n        if (depositAmount &gt; 0) {\n            depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;\n            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);\n            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);\n            stakerVault.stake(depositAmount);\n            stakerVault.increaseActionLockedBalance(payer, depositAmount);\n            amountLeft -= depositAmount;\n        }\n\n        // use stake vault allowance if available and required\n        if (amountLeft &gt; 0) {\n            uint256 balance = stakerVault.balanceOf(payer);\n            uint256 allowance = stakerVault.allowance(payer, address(this));\n            uint256 availableFunds = balance &lt; allowance ? balance : allowance;\n            if (availableFunds &gt;= amountLeft) {\n                stakerVault.transferFrom(payer, address(this), amountLeft);\n                amountLeft = 0;\n            }\n        }\n\n        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);\n    }\n\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     /\n    function calcExchangeAmount(\n        IAddressProvider addressProvider,\n        address token,\n        address actionToken,\n        uint256 amount\n    ) external view returns (uint256) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        uint256 rate = pool.exchangeRate();\n        address underlying = pool.getUnderlying();\n        if (underlying == actionToken) {\n            return amount.scaledDivRoundUp(rate);\n        }\n\n        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);\n        uint256 swapperRate = swapper.getRate(underlying, actionToken);\n        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));\n    }\n\n    function getSwapper(\n        IAddressProvider addressProvider,\n        address underlying,\n        address actionToken\n    ) public view returns (ISwapper) {\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);\n        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);\n        return ISwapper(swapper);\n    }\n}\n\ncontract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {\n    using ScaledMath for uint256;\n    using ScaledMath for uint128;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using AddressProviderHelpers for IAddressProvider;\n\n    /\n     * @dev Temporary struct to hold local variables in execute\n     * and avoid the stack being ""too deep""\n     /\n    struct ExecuteLocalVars {\n        uint256 minActionAmountToTopUp;\n        uint256 actionTokenAmount;\n        uint256 depositTotalFeesAmount;\n        uint256 actionAmountWithFees;\n        uint256 userFactor;\n        uint256 rate;\n        uint256 depositAmountWithFees;\n        uint256 depositAmountWithoutFees;\n        uint256 actionFee;\n        uint256 totalActionTokenAmount;\n        uint128 totalTopUpAmount;\n        bool success;\n        bytes topupResult;\n        uint256 gasBankBalance;\n        uint256 initialGas;\n        uint256 gasConsumed;\n        uint256 userGasPrice;\n        uint256 estimatedRequiredGas;\n        uint256 estimatedRequiredWeiForGas;\n        uint256 requiredWeiForGas;\n        uint256 reimbursedWeiForGas;\n        address underlying;\n        bool removePosition;\n    }\n\n    EnumerableSet.AddressSet private _usableTokens;\n\n    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;\n\n    bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee"";\n    bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler"";\n    bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler"";\n    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage"";\n    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";\n\n    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;\n    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;\n    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    EnumerableSet.Bytes32Set internal _supportedProtocols;\n\n    /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record)\n    mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;\n\n    mapping(address =&gt; RecordMeta[]) internal _userPositions;\n\n    EnumerableSet.AddressSet internal _usersWithPositions;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        addressProvider = controller.addressProvider();\n        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);\n    }\n\n    receive() external payable {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function initialize(\n        address feeHandler,\n        bytes32[] calldata protocols,\n        address[] calldata handlers\n    ) external initializer onlyGovernance {\n        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);\n        _setConfig(_FEE_HANDLER_KEY, feeHandler);\n        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);\n        for (uint256 i = 0; i &lt; protocols.length; i++) {\n            bytes32 protocolKey = _getProtocolKey(protocols[i]);\n            _setConfig(protocolKey, handlers[i]);\n            _updateTopUpHandler(protocols[i], address(0), handlers[i]);\n        }\n    }\n\n    /\n     * @notice Register a top up action.\n     * @dev The depositAmount must be greater or equal to the totalTopUpAmount (which is denominated in actionToken).\n     * @param account Account to be topped up (first 20 bytes will typically be the address).\n     * @param depositAmount Amount of depositToken that will be locked.\n     * @param protocol Protocol which holds position to be topped up.\n     * @param record containing the data for the position to register\n     /\n    function register(\n        bytes32 account,\n        bytes32 protocol,\n        uint128 depositAmount,\n        Record memory record\n    ) external payable returns (bool) {\n        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);\n        require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);\n        require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);\n        require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);\n        require(\n            _positions[msg.sender][account][protocol].threshold == 0,\n            Error.POSITION_ALREADY_EXISTS\n        );\n        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);\n        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);\n\n        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) \n            record.maxFee *\n            getEstimatedGasUsage();\n\n        require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);\n\n        uint256 totalLockAmount = _calcExchangeAmount(\n            record.depositToken,\n            record.actionToken,\n            record.totalTopUpAmount\n        );\n        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);\n\n        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);\n\n        record.depositTokenBalance = uint128(totalLockAmount);\n        _positions[msg.sender][account][protocol] = record;\n        _userPositions[msg.sender].push(RecordMeta(account, protocol));\n        _usersWithPositions.add(msg.sender);\n\n        emit Register(\n            account,\n            protocol,\n            record.threshold,\n            msg.sender,\n            record.depositToken,\n            totalLockAmount,\n            record.actionToken,\n            record.singleTopUpAmount,\n            record.totalTopUpAmount,\n            record.maxFee,\n            record.extra\n        );\n        return true;\n    }\n\n    /\n     * @notice See overloaded version of execute for more details.\n     /\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol\n    ) external override returns (bool) {\n        return execute(payer, account, beneficiary, protocol, 0);\n    }\n\n    /\n     * @notice Delete a position to back on the given protocol for account.\n     * @param account Account holding the position.\n     * @param protocol Protocol the position is held on.\n     * @param unstake If the tokens should be unstaked from vault.\n     * @return true if successful.\n     /\n    function resetPosition(\n        bytes32 account,\n        bytes32 protocol,\n        bool unstake\n    ) external override returns (bool) {\n        address payer = msg.sender;\n        Record memory position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n\n        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist\n        IStakerVault staker = IStakerVault(vault);\n        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);\n        if (unstake) {\n            staker.unstake(position.depositTokenBalance);\n            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);\n        } else {\n            staker.transfer(payer, position.depositTokenBalance);\n        }\n\n        _removePosition(payer, account, protocol);\n        addressProvider.getGasBank().withdrawUnused(payer);\n        return true;\n    }\n\n    /\n     * @notice Execute top up handler update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @param protocol Protocol for which a new handler should be executed.\n     * @return Address of new handler.\n     */\n    function executeTopUpHandler(bytes32 protocol) external override returns (address) {\n        address oldHandler = _getHandler(protocol, false);\n        address newHandler = _executeAddress(_getProtocolKey(protocol));\n\n        _updateTopUpHandler(protocol, oldHandler, newHandler);\n        return newHandler;\n    }\n\n    /\n     * @notice Reset new top up handler deadline for a protocol.\n     * @param protocol Protocol for which top up handler deadline should be reset.\n     * @return true if successful.\n     /\n    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_getProtocolKey(protocol));\n    }\n\n    /\n     * @notice Prepare action fee update.\n     * @param newActionFee New fee to set.\n     * @return true if success.\n     /\n    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {\n        require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);\n        return _prepare(_ACTION_FEE_KEY, newActionFee);\n    }\n\n    /\n     * @notice Execute action fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeActionFee() external override returns (uint256) {\n        return _executeUInt256(_ACTION_FEE_KEY);\n    }\n\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     /\n    function resetActionFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ACTION_FEE_KEY);\n    }\n\n    /\n     * @notice Prepare swapper slippage update.\n     * @param newSwapperSlippage New slippage to set.\n     * @return true if success.\n     /\n    function prepareSwapperSlippage(uint256 newSwapperSlippage)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        require(\n            newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;\n                newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,\n            Error.INVALID_AMOUNT\n        );\n        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);\n    }\n\n    /\n     * @notice Execute swapper slippage update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeSwapperSlippage() external override returns (uint256) {\n        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     /\n    function resetSwapperSlippage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    / Set fee handler /\n    /\n     * @notice Prepare update of fee handler.\n     * @param handler New fee handler.\n     * @return true if success.\n     */\n    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {\n        return _prepare(_FEE_HANDLER_KEY, handler);\n    }\n\n    /\n     * @notice Execute update of fee handler (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return true if successful.\n     /\n    function executeFeeHandler() external override returns (address) {\n        return _executeAddress(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Reset the handler deadline.\n     * @return true if success.\n     /\n    function resetFeeHandler() external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Prepare update of estimated gas usage.\n     * @param gasUsage New estimated gas usage.\n     * @return true if success.\n     */\n    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {\n        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);\n    }\n\n    /\n     * @notice Execute update of gas usage (with time delay enforced).\n     * @return true if successful.\n     /\n    function executeEstimatedGasUsage() external returns (uint256) {\n        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Reset the gas usage deadline.\n     * @return true if success.\n     /\n    function resetGasUsage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Add a new deposit token that is supported by the action.\n     * @dev There is a separate check for whether the usable token (i.e. deposit token)\n     *      is swappable for some action token.\n     * @param token Address of deposit token that can be used by the action.\n     */\n    function addUsableToken(address token) external override onlyGovernance returns (bool) {\n        return _usableTokens.add(token);\n    }\n\n    /\n     * @notice Computes the total amount of ETH (as wei) required to pay for all\n     * the top-ups assuming the maximum gas price and the current estimated gas\n     * usage of a top-up\n     /\n    function getEthRequiredForGas(address payer) external view override returns (uint256) {\n        uint256 totalEthRequired = 0;\n        RecordMeta[] memory userRecordsMeta = _userPositions[payer];\n        uint256 gasUsagePerCall = getEstimatedGasUsage();\n        uint256 length = userRecordsMeta.length;\n        for (uint256 i = 0; i &lt; length; i++) {\n            RecordMeta memory meta = userRecordsMeta[i];\n            Record memory record = _positions[payer][meta.account][meta.protocol];\n            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);\n            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;\n        }\n        return totalEthRequired;\n    }\n\n    /\n     * @notice Returns a list of positions for the given payer\n     /\n    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {\n        return _userPositions[payer];\n    }\n\n    /\n     * @notice Get a list supported protocols.\n     * @return List of supported protocols.\n     /\n    function getSupportedProtocols() external view override returns (bytes32[] memory) {\n        uint256 length = _supportedProtocols.length();\n        bytes32[] memory protocols = new bytes32;\n        for (uint256 i = 0; i &lt; length; i++) {\n            protocols[i] = _supportedProtocols.at(i);\n        }\n        return protocols;\n    }\n\n    /\n     * @notice Gets a list of users that have an active position.\n     * @dev Uses cursor pagination.\n     * @param cursor The cursor for pagination (should start at 0 for first call).\n     * @param howMany Maximum number of users to return in this pagination request.\n     * @return users List of users that have an active position.\n     * @return nextCursor The cursor to use for the next pagination request.\n     */\n    function usersWithPositions(uint256 cursor, uint256 howMany)\n        external\n        view\n        override\n        returns (address[] memory users, uint256 nextCursor)\n    {\n        uint256 length = usersWithPositions.length();\n        if (cursor &gt;= length) return (new address, 0);\n        if (howMany &gt;= length - cursor) {\n            howMany = length - cursor;\n        }\n\n        address[] memory usersWithPositions = new address;\n        for (uint256 i = 0; i &lt; howMany; i++) {\n            usersWithPositions_[i] = usersWithPositions.at(i + cursor);\n        }\n\n        return (usersWithPositions, cursor + howMany);\n    }\n\n    /\n     * @notice Get a list of all tokens usable for this action.\n     * @dev This refers to all tokens that can be used as deposit tokens.\n     * @return Array of addresses of usable tokens.\n     /\n    function getUsableTokens() external view override returns (address[] memory) {\n        return _usableTokens.toArray();\n    }\n\n    /\n     * @notice Retrieves the topup handler for the given protocol\n     /\n    function getTopUpHandler(bytes32 protocol) external view returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice Successfully tops up a position if it\'s conditions are met.\n     * @dev pool and vault funds are rebalanced after withdrawal for top up\n     * @param payer Account that pays for the top up.\n     * @param account Account owning the position for top up.\n     * @param beneficiary Address of the keeper\'s wallet for fee accrual.\n     * @param protocol Protocol of the top up position.\n     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas\n     * @return true if successful.\n     */\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol,\n        uint256 maxWeiForGas\n    ) public override returns (bool) {\n        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);\n\n        ExecuteLocalVars memory vars;\n\n        vars.initialGas = gasleft();\n\n        Record storage position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n        require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);\n\n        address topUpHandler = _getHandler(protocol, true);\n        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);\n\n        // ensure that the position is actually below its set user factor threshold\n        require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);\n\n        IGasBank gasBank = addressProvider.getGasBank();\n\n        // fail early if the user does not have enough funds in the gas bank\n        // to cover the cost of the transaction\n        vars.estimatedRequiredGas = getEstimatedGasUsage();\n        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;\n\n        // compute the gas price that the user will be paying\n        vars.userGasPrice = block.basefee + position.priorityFee;\n        if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;\n        if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;\n\n        // ensure the current position allows for the gas to be paid\n        require(\n            vars.estimatedRequiredWeiForGas &lt;=\n                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,\n            Error.ESTIMATED_GAS_TOO_HIGH\n        );\n\n        vars.gasBankBalance = gasBank.balanceOf(payer);\n        // ensure the user has enough funds in the gas bank to cover the gas\n        require(\n            vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,\n            Error.GAS_BANK_BALANCE_TOO_LOW\n        );\n\n        vars.totalTopUpAmount = position.totalTopUpAmount;\n        vars.actionFee = getActionFee();\n        // add top-up fees to top-up amount\n        vars.minActionAmountToTopUp = position.singleTopUpAmount;\n        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(\n            ScaledMath.ONE + vars.actionFee\n        );\n\n        // if the amount that we want to top-up (including fees) is higher than\n        // the available topup amount, we lower this down to what is left of the position\n        if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {\n            vars.actionAmountWithFees = vars.totalTopUpAmount;\n            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(\n                ScaledMath.ONE + vars.actionFee\n            );\n        }\n        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);\n        vars.underlying = pool.getUnderlying();\n        vars.rate = pool.exchangeRate();\n\n        ISwapper swapper;\n\n        if (vars.underlying != position.actionToken) {\n            swapper = _getSwapper(vars.underlying, position.actionToken);\n            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));\n        }\n\n        // compute the deposit tokens amount with and without fees\n        // we will need to unstake the amount with fees and to\n        // swap the amount without fees into action tokens\n        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);\n        if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {\n            vars.depositAmountWithFees = position.depositTokenBalance;\n            vars.minActionAmountToTopUp =\n                (vars.depositAmountWithFees * vars.rate) /\n                (ScaledMath.ONE + vars.actionFee);\n        }\n\n        // compute amount of LP tokens needed to pay for action\n        // rate is expressed in actionToken per depositToken\n        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);\n        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;\n\n        // will revert if vault does not exist\n        address vault = addressProvider.getStakerVault(position.depositToken);\n\n        // unstake deposit tokens including fees\n        IStakerVault(vault).unstake(vars.depositAmountWithFees);\n        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);\n\n        // swap the amount without the fees\n        // as the fees are paid in deposit token, not in action token\n        // Redeem first and use swapper only if the underlying tokens are not action tokens\n        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);\n\n        if (address(swapper) != address(0)) {\n            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(\n                getSwapperSlippage()\n            );\n            _approve(vars.underlying, address(swapper));\n            vars.actionTokenAmount = swapper.swap(\n                vars.underlying,\n                position.actionToken,\n                vars.actionTokenAmount,\n                vars.minActionAmountToTopUp\n            );\n        }\n\n        // compute how much of action token was actually redeemed and add fees to it\n        // this is to ensure that no funds get locked inside the contract\n        vars.totalActionTokenAmount =\n            vars.actionTokenAmount +\n            vars.depositTotalFeesAmount.scaledMul(vars.rate);\n\n        // at this point, we have exactly vars.actionTokenAmount\n        // (at least position.singleTopUpAmount) of action token\n        // and exactly vars.depositTotalFeesAmount deposit tokens in the contract\n        // solhint-disable-next-line avoid-low-level-calls\n        (vars.success, vars.topupResult) = topUpHandler.delegatecall(\n            abi.encodeWithSignature(\n                ""topUp(bytes32,address,uint256,bytes)"",\n                account,\n                position.actionToken,\n                vars.actionTokenAmount,\n                position.extra\n            )\n        );\n\n        require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);\n\n        // totalTopUpAmount is updated to reflect the new ""balance"" of the position\n        if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {\n            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);\n        } else {\n            position.totalTopUpAmount = 0;\n        }\n\n        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);\n\n        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;\n        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);\n        if (vars.removePosition) {\n            if (position.depositTokenBalance &gt; 0) {\n                // transfer any unused locked tokens to the payer\n                IStakerVault(vault).transfer(payer, position.depositTokenBalance);\n                IStakerVault(vault).decreaseActionLockedBalance(\n                    payer,\n                    position.depositTokenBalance\n                );\n            }\n            _removePosition(payer, account, protocol);\n        }\n\n        emit TopUp(\n            account,\n            protocol,\n            payer,\n            position.depositToken,\n            vars.depositAmountWithFees,\n            position.actionToken,\n            vars.actionTokenAmount\n        );\n\n        // compute gas used and reimburse the keeper by using the\n        // funds of payer in the gas bank\n        // TODO: add constant gas consumed for transfer and tx prologue\n        vars.gasConsumed = vars.initialGas - gasleft();\n\n        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;\n        if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {\n            vars.reimbursedWeiForGas = vars.gasBankBalance;\n        }\n\n        // ensure that the keeper is not overpaying\n        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;\n        require(\n            vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,\n            Error.GAS_TOO_HIGH\n        );\n        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);\n        if (vars.removePosition) {\n            gasBank.withdrawUnused(payer);\n        }\n\n        return true;\n    }\n\n    /\n     * @notice Prepare new top up handler fee update.\n     * @dev Setting the addres to 0 means that the protocol will no longer be supported.\n     * @param protocol Protocol for which a new handler should be prepared.\n     * @param newHandler Address of new handler.\n     * @return true if success.\n     /\n    function prepareTopUpHandler(bytes32 protocol, address newHandler)\n        public\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_getProtocolKey(protocol), newHandler);\n    }\n\n    /\n     * @notice Check if action can be executed.\n     * @param protocol for which to get the health factor\n     * @param account for which to get the health factor\n     * @param extra data to be used by the topup handler\n     * @return healthFactor of the position\n     /\n    function getHealthFactor(\n        bytes32 protocol,\n        bytes32 account,\n        bytes memory extra\n    ) public view override returns (uint256 healthFactor) {\n        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));\n        return topUpHandler.getUserFactor(account, extra);\n    }\n\n    function getHandler(bytes32 protocol) public view override returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice returns the current estimated gas usage\n     */\n    function getEstimatedGasUsage() public view returns (uint256) {\n        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];\n    }\n\n    /\n     * @notice Returns the current action fee\n     /\n    function getActionFee() public view override returns (uint256) {\n        return currentUInts256[_ACTION_FEE_KEY];\n    }\n\n    /\n     * @notice Returns the current max swapper slippage\n     /\n    function getSwapperSlippage() public view override returns (uint256) {\n        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];\n    }\n\n    /\n     * @notice Returns the current fee handler\n     */\n    function getFeeHandler() public view override returns (address) {\n        return currentAddresses[_FEE_HANDLER_KEY];\n    }\n\n    /\n     * @notice Get the record for a position.\n     * @param payer Registered payer of the position.\n     * @param account Address holding the position.\n     * @param protocol Protocol where the position is held.\n     /\n    function getPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) public view override returns (Record memory) {\n        return _positions[payer][account][protocol];\n    }\n\n    /\n     * @notice Check whether a token is usable as a deposit token.\n     * @param token Address of token to check.\n     * @return True if token is usable as a deposit token for this action.\n     /\n    function isUsable(address token) public view override returns (bool) {\n        return _usableTokens.contains(token);\n    }\n\n    function _updateTopUpHandler(\n        bytes32 protocol,\n        address oldHandler,\n        address newHandler\n    ) internal {\n        if (newHandler == address(0)) {\n            _supportedProtocols.remove(protocol);\n        } else if (oldHandler == address(0)) {\n            _supportedProtocols.add(protocol);\n        }\n    }\n\n    /\n     * @dev Pays fees to the feeHandler\n     * @param payer The account who\'s position the fees are charged on\n     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)\n     * @param feeAmount The amount in tokens to pay as fees\n     * @param depositToken The LpToken used to pay the fees\n     */\n    function _payFees(\n        address payer,\n        address beneficiary,\n        uint256 feeAmount,\n        address depositToken\n    ) internal {\n        address feeHandler = getFeeHandler();\n        IERC20(depositToken).safeApprove(feeHandler, feeAmount);\n        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);\n    }\n\n    /\n     * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction\n     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.\n     * @param payer Owner of the funds to be locked\n     * @param token Token to lock\n     * @param lockAmount Minimum amount of token to lock\n     * @param depositAmount Amount of token that was deposited.\n     *                      If this is 0 then the staker vault allowance should be used.\n     *                      If this is greater than requiredAmount more tokens will be locked.\n     /\n    function _lockFunds(\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) internal {\n        address stakerVaultAddress = addressProvider.getStakerVault(token);\n        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);\n    }\n\n    function _removePosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        delete _positions[payer][account][protocol];\n        _removeUserPosition(payer, account, protocol);\n        if (_userPositions[payer].length == 0) {\n            _usersWithPositions.remove(payer);\n        }\n        emit Deregister(payer, account, protocol);\n    }\n\n    function _removeUserPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        RecordMeta[] storage positionsMeta = _userPositions[payer];\n        uint256 length = positionsMeta.length;\n        for (uint256 i = 0; i &lt; length; i++) {\n            RecordMeta storage positionMeta = positionsMeta[i];\n            if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {\n                positionsMeta[i] = positionsMeta[length - 1];\n                positionsMeta.pop();\n                return;\n            }\n        }\n    }\n\n    /\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     /\n    function _approve(address token, address spender) internal {\n        if (IERC20(token).allowance(address(this), spender) &gt; 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     */\n    function _calcExchangeAmount(\n        address token,\n        address actionToken,\n        uint256 amount\n    ) internal view returns (uint256) {\n        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);\n    }\n\n    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {\n        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);\n    }\n\n    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {\n        address handler = currentAddresses[_getProtocolKey(protocol)];\n        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);\n        return handler;\n    }\n\n    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);\n        address underlying = pool.getUnderlying();\n        if (underlying == toToken) {\n            return true;\n        }\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);\n    }\n\n    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));\n    }\n}\n', 'ideas': ' Potential Data Inconsistency Identified.\n\nPotential Data In'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-15-08 09:55:12 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol""; import ""../../../interfaces/IGasBank.sol""; import ""../../../interfaces/pool/ILiquidityPool.sol""; import ""../../../interfaces/ISwapperRegistry.sol""; import ""../../../interfaces/IController.sol""; import ""../../../interfaces/IStakerVault.sol""; import ""../../../interfaces/ISwapper.sol""; import ""../../../interfaces/actions/topup/ITopUpHandler.sol""; import ""../../../interfaces/actions/topup/ITopUpAction.sol""; import ""../../../interfaces/actions/IActionFeeHandler.sol""; import ""../../../libraries/AddressProviderHelpers.sol""; import ""../../../libraries/Errors.sol""; import ""../../../libraries/ScaledMath.sol""; import ""../../../libraries/EnumerableExtensions.sol""; import ""../../access/Authorization.sol""; import ""../../utils/Preparable.sol""; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being ""too deep""  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee""; bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler""; bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler""; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage""; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             ""topUp(bytes32,address,uint256,bytes)"",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new ""balance"" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-15-08 09:55:12 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";

import ""../../../interfaces/IGasBank.sol"";
import ""../../../interfaces/pool/ILiquidityPool.sol"";
import ""../../../interfaces/ISwapperRegistry.sol"";
import ""../../../interfaces/IController.sol"";
import ""../../../interfaces/IStakerVault.sol"";
import ""../../../interfaces/ISwapper.sol"";
import ""../../../interfaces/actions/topup/ITopUpHandler.sol"";
import ""../../../interfaces/actions/topup/ITopUpAction.sol"";
import ""../../../interfaces/actions/IActionFeeHandler.sol"";

import ""../../../libraries/AddressProviderHelpers.sol"";
import ""../../../libraries/Errors.sol"";
import ""../../../libraries/ScaledMath.sol"";
import ""../../../libraries/EnumerableExtensions.sol"";

import ""../../access/Authorization.sol"";
import ""../../utils/Preparable.sol"";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being ""too deep""
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee"";
    bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler"";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler"";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage"";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                ""topUp(bytes32,address,uint256,bytes)"",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new ""balance"" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";

import ""../../../interfaces/IGasBank.sol"";
import ""../../../interfaces/pool/ILiquidityPool.sol"";
import ""../../../interfaces/ISwapperRegistry.sol"";
import ""../../../interfaces/IController.sol"";
import ""../../../interfaces/IStakerVault.sol"";
import ""../../../interfaces/ISwapper.sol"";
import ""../../../interfaces/actions/topup/ITopUpHandler.sol"";
import ""../../../interfaces/actions/topup/ITopUpAction.sol"";
import ""../../../interfaces/actions/IActionFeeHandler.sol"";

import ""../../../libraries/AddressProviderHelpers.sol"";
import ""../../../libraries/Errors.sol"";
import ""../../../libraries/ScaledMath.sol"";
import ""../../../libraries/EnumerableExtensions.sol"";

import ""../../access/Authorization.sol"";
import ""../../utils/Preparable.sol"";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being ""too deep""
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee"";
    bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler"";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler"";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage"";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                ""topUp(bytes32,address,uint256,bytes)"",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new ""balance"" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
"".
Ideas: "" Potential Data Inconsistency Identified.

**Potential Data In"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Hash Collision. This type of vulnerability occurs when different inputs produce the same hash due to improper handling of concatenated values, leading to potential security issues.
Proceed with the following steps in your analysis:
1. Scrutinize the contract's code to identify any functions that generate hashes from input values.
2. Look for patterns where multiple input values are concatenated without clear delimiters before hashing. Pay special attention to the use of `abi.encodePacked` for concatenation.
3. Determine if the concatenated inputs can produce the same hash for different combinations of input values, leading to potential hash collisions.
4. Evaluate the logic for generating and handling hashes within the contract to ensure that the potential for hash collisions is minimized.
If you discover any Hash Collision vulnerabilities, respond with: """,,,,,,"<INFO> Precision Loss Identified.

**VULNERABILITY NAME: Precision Loss in Arithmetic Operations**
'''
The contract performs several arithmetic operations that could lead to precision loss, particularly in the `calcExchangeAmount` function and the `execute` function. For instance, the use of integer division in the calculation of amounts can truncate values, leading to incorrect results. This is especially critical in financial applications where even minor inaccuracies can result in significant monetary loss.

In the `calcExchange

[2024-15-08 09:55:31 INFO] **[Execute Detail]**

execute SimplePhase:[RedundantConditionalDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-15-08 09:55:31 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol""; import ""../../../interfaces/IGasBank.sol""; import ""../../../interfaces/pool/ILiquidityPool.sol""; import ""../../../interfaces/ISwapperRegistry.sol""; import ""../../../interfaces/IController.sol""; import ""../../../interfaces/IStakerVault.sol""; import ""../../../interfaces/ISwapper.sol""; import ""../../../interfaces/actions/topup/ITopUpHandler.sol""; import ""../../../interfaces/actions/topup/ITopUpAction.sol""; import ""../../../interfaces/actions/IActionFeeHandler.sol""; import ""../../../libraries/AddressProviderHelpers.sol""; import ""../../../libraries/Errors.sol""; import ""../../../libraries/ScaledMath.sol""; import ""../../../libraries/EnumerableExtensions.sol""; import ""../../access/Authorization.sol""; import ""../../utils/Preparable.sol""; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being ""too deep""  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee""; bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler""; bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler""; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage""; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             ""topUp(bytes32,address,uint256,bytes)"",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new ""balance"" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Redundant Conditional Checks. There are specific cases where the code may have Redundant Conditional Check vulnerabilities: 1. Conditional checks that always evaluate to true or false, which add unnecessary complexity and gas costs to the code. 2. Conditions that duplicate checks already performed earlier in the code, leading to redundant operations and inefficient execution. If you identify any redundant conditional checks, respond with: "" Redundant Conditional Check Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If you don't find any vulnerabilities, respond only with: "" NO Redundant Conditional Checks."" |
| **phase_name** | RedundantConditionalDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";\nimport ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";\n\nimport ""../../../interfaces/IGasBank.sol"";\nimport ""../../../interfaces/pool/ILiquidityPool.sol"";\nimport ""../../../interfaces/ISwapperRegistry.sol"";\nimport ""../../../interfaces/IController.sol"";\nimport ""../../../interfaces/IStakerVault.sol"";\nimport ""../../../interfaces/ISwapper.sol"";\nimport ""../../../interfaces/actions/topup/ITopUpHandler.sol"";\nimport ""../../../interfaces/actions/topup/ITopUpAction.sol"";\nimport ""../../../interfaces/actions/IActionFeeHandler.sol"";\n\nimport ""../../../libraries/AddressProviderHelpers.sol"";\nimport ""../../../libraries/Errors.sol"";\nimport ""../../../libraries/ScaledMath.sol"";\nimport ""../../../libraries/EnumerableExtensions.sol"";\n\nimport ""../../access/Authorization.sol"";\nimport ""../../utils/Preparable.sol"";\n\n/\n * @notice The logic here should really be part of the top-up action\n * but is split in a library to circumvent the byte-code size limit\n */\nlibrary TopUpActionLibrary {\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    function lockFunds(\n        address stakerVaultAddress,\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) external {\n        uint256 amountLeft = lockAmount;\n        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);\n\n        // stake deposit amount\n        if (depositAmount &gt; 0) {\n            depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;\n            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);\n            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);\n            stakerVault.stake(depositAmount);\n            stakerVault.increaseActionLockedBalance(payer, depositAmount);\n            amountLeft -= depositAmount;\n        }\n\n        // use stake vault allowance if available and required\n        if (amountLeft &gt; 0) {\n            uint256 balance = stakerVault.balanceOf(payer);\n            uint256 allowance = stakerVault.allowance(payer, address(this));\n            uint256 availableFunds = balance &lt; allowance ? balance : allowance;\n            if (availableFunds &gt;= amountLeft) {\n                stakerVault.transferFrom(payer, address(this), amountLeft);\n                amountLeft = 0;\n            }\n        }\n\n        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);\n    }\n\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     /\n    function calcExchangeAmount(\n        IAddressProvider addressProvider,\n        address token,\n        address actionToken,\n        uint256 amount\n    ) external view returns (uint256) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        uint256 rate = pool.exchangeRate();\n        address underlying = pool.getUnderlying();\n        if (underlying == actionToken) {\n            return amount.scaledDivRoundUp(rate);\n        }\n\n        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);\n        uint256 swapperRate = swapper.getRate(underlying, actionToken);\n        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));\n    }\n\n    function getSwapper(\n        IAddressProvider addressProvider,\n        address underlying,\n        address actionToken\n    ) public view returns (ISwapper) {\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);\n        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);\n        return ISwapper(swapper);\n    }\n}\n\ncontract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {\n    using ScaledMath for uint256;\n    using ScaledMath for uint128;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using AddressProviderHelpers for IAddressProvider;\n\n    /\n     * @dev Temporary struct to hold local variables in execute\n     * and avoid the stack being ""too deep""\n     /\n    struct ExecuteLocalVars {\n        uint256 minActionAmountToTopUp;\n        uint256 actionTokenAmount;\n        uint256 depositTotalFeesAmount;\n        uint256 actionAmountWithFees;\n        uint256 userFactor;\n        uint256 rate;\n        uint256 depositAmountWithFees;\n        uint256 depositAmountWithoutFees;\n        uint256 actionFee;\n        uint256 totalActionTokenAmount;\n        uint128 totalTopUpAmount;\n        bool success;\n        bytes topupResult;\n        uint256 gasBankBalance;\n        uint256 initialGas;\n        uint256 gasConsumed;\n        uint256 userGasPrice;\n        uint256 estimatedRequiredGas;\n        uint256 estimatedRequiredWeiForGas;\n        uint256 requiredWeiForGas;\n        uint256 reimbursedWeiForGas;\n        address underlying;\n        bool removePosition;\n    }\n\n    EnumerableSet.AddressSet private _usableTokens;\n\n    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;\n\n    bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee"";\n    bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler"";\n    bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler"";\n    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage"";\n    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";\n\n    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;\n    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;\n    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    EnumerableSet.Bytes32Set internal _supportedProtocols;\n\n    /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record)\n    mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;\n\n    mapping(address =&gt; RecordMeta[]) internal _userPositions;\n\n    EnumerableSet.AddressSet internal _usersWithPositions;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        addressProvider = controller.addressProvider();\n        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);\n    }\n\n    receive() external payable {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function initialize(\n        address feeHandler,\n        bytes32[] calldata protocols,\n        address[] calldata handlers\n    ) external initializer onlyGovernance {\n        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);\n        _setConfig(_FEE_HANDLER_KEY, feeHandler);\n        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);\n        for (uint256 i = 0; i &lt; protocols.length; i++) {\n            bytes32 protocolKey = _getProtocolKey(protocols[i]);\n            _setConfig(protocolKey, handlers[i]);\n            _updateTopUpHandler(protocols[i], address(0), handlers[i]);\n        }\n    }\n\n    /\n     * @notice Register a top up action.\n     * @dev The depositAmount must be greater or equal to the totalTopUpAmount (which is denominated in actionToken).\n     * @param account Account to be topped up (first 20 bytes will typically be the address).\n     * @param depositAmount Amount of depositToken that will be locked.\n     * @param protocol Protocol which holds position to be topped up.\n     * @param record containing the data for the position to register\n     /\n    function register(\n        bytes32 account,\n        bytes32 protocol,\n        uint128 depositAmount,\n        Record memory record\n    ) external payable returns (bool) {\n        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);\n        require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);\n        require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);\n        require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);\n        require(\n            _positions[msg.sender][account][protocol].threshold == 0,\n            Error.POSITION_ALREADY_EXISTS\n        );\n        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);\n        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);\n\n        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) \n            record.maxFee *\n            getEstimatedGasUsage();\n\n        require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);\n\n        uint256 totalLockAmount = _calcExchangeAmount(\n            record.depositToken,\n            record.actionToken,\n            record.totalTopUpAmount\n        );\n        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);\n\n        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);\n\n        record.depositTokenBalance = uint128(totalLockAmount);\n        _positions[msg.sender][account][protocol] = record;\n        _userPositions[msg.sender].push(RecordMeta(account, protocol));\n        _usersWithPositions.add(msg.sender);\n\n        emit Register(\n            account,\n            protocol,\n            record.threshold,\n            msg.sender,\n            record.depositToken,\n            totalLockAmount,\n            record.actionToken,\n            record.singleTopUpAmount,\n            record.totalTopUpAmount,\n            record.maxFee,\n            record.extra\n        );\n        return true;\n    }\n\n    /\n     * @notice See overloaded version of execute for more details.\n     /\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol\n    ) external override returns (bool) {\n        return execute(payer, account, beneficiary, protocol, 0);\n    }\n\n    /\n     * @notice Delete a position to back on the given protocol for account.\n     * @param account Account holding the position.\n     * @param protocol Protocol the position is held on.\n     * @param unstake If the tokens should be unstaked from vault.\n     * @return true if successful.\n     /\n    function resetPosition(\n        bytes32 account,\n        bytes32 protocol,\n        bool unstake\n    ) external override returns (bool) {\n        address payer = msg.sender;\n        Record memory position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n\n        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist\n        IStakerVault staker = IStakerVault(vault);\n        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);\n        if (unstake) {\n            staker.unstake(position.depositTokenBalance);\n            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);\n        } else {\n            staker.transfer(payer, position.depositTokenBalance);\n        }\n\n        _removePosition(payer, account, protocol);\n        addressProvider.getGasBank().withdrawUnused(payer);\n        return true;\n    }\n\n    /\n     * @notice Execute top up handler update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @param protocol Protocol for which a new handler should be executed.\n     * @return Address of new handler.\n     */\n    function executeTopUpHandler(bytes32 protocol) external override returns (address) {\n        address oldHandler = _getHandler(protocol, false);\n        address newHandler = _executeAddress(_getProtocolKey(protocol));\n\n        _updateTopUpHandler(protocol, oldHandler, newHandler);\n        return newHandler;\n    }\n\n    /\n     * @notice Reset new top up handler deadline for a protocol.\n     * @param protocol Protocol for which top up handler deadline should be reset.\n     * @return true if successful.\n     /\n    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_getProtocolKey(protocol));\n    }\n\n    /\n     * @notice Prepare action fee update.\n     * @param newActionFee New fee to set.\n     * @return true if success.\n     /\n    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {\n        require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);\n        return _prepare(_ACTION_FEE_KEY, newActionFee);\n    }\n\n    /\n     * @notice Execute action fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeActionFee() external override returns (uint256) {\n        return _executeUInt256(_ACTION_FEE_KEY);\n    }\n\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     /\n    function resetActionFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ACTION_FEE_KEY);\n    }\n\n    /\n     * @notice Prepare swapper slippage update.\n     * @param newSwapperSlippage New slippage to set.\n     * @return true if success.\n     /\n    function prepareSwapperSlippage(uint256 newSwapperSlippage)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        require(\n            newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;\n                newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,\n            Error.INVALID_AMOUNT\n        );\n        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);\n    }\n\n    /\n     * @notice Execute swapper slippage update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeSwapperSlippage() external override returns (uint256) {\n        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     /\n    function resetSwapperSlippage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    / Set fee handler /\n    /\n     * @notice Prepare update of fee handler.\n     * @param handler New fee handler.\n     * @return true if success.\n     */\n    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {\n        return _prepare(_FEE_HANDLER_KEY, handler);\n    }\n\n    /\n     * @notice Execute update of fee handler (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return true if successful.\n     /\n    function executeFeeHandler() external override returns (address) {\n        return _executeAddress(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Reset the handler deadline.\n     * @return true if success.\n     /\n    function resetFeeHandler() external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Prepare update of estimated gas usage.\n     * @param gasUsage New estimated gas usage.\n     * @return true if success.\n     */\n    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {\n        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);\n    }\n\n    /\n     * @notice Execute update of gas usage (with time delay enforced).\n     * @return true if successful.\n     /\n    function executeEstimatedGasUsage() external returns (uint256) {\n        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Reset the gas usage deadline.\n     * @return true if success.\n     /\n    function resetGasUsage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Add a new deposit token that is supported by the action.\n     * @dev There is a separate check for whether the usable token (i.e. deposit token)\n     *      is swappable for some action token.\n     * @param token Address of deposit token that can be used by the action.\n     */\n    function addUsableToken(address token) external override onlyGovernance returns (bool) {\n        return _usableTokens.add(token);\n    }\n\n    /\n     * @notice Computes the total amount of ETH (as wei) required to pay for all\n     * the top-ups assuming the maximum gas price and the current estimated gas\n     * usage of a top-up\n     /\n    function getEthRequiredForGas(address payer) external view override returns (uint256) {\n        uint256 totalEthRequired = 0;\n        RecordMeta[] memory userRecordsMeta = _userPositions[payer];\n        uint256 gasUsagePerCall = getEstimatedGasUsage();\n        uint256 length = userRecordsMeta.length;\n        for (uint256 i = 0; i &lt; length; i++) {\n            RecordMeta memory meta = userRecordsMeta[i];\n            Record memory record = _positions[payer][meta.account][meta.protocol];\n            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);\n            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;\n        }\n        return totalEthRequired;\n    }\n\n    /\n     * @notice Returns a list of positions for the given payer\n     /\n    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {\n        return _userPositions[payer];\n    }\n\n    /\n     * @notice Get a list supported protocols.\n     * @return List of supported protocols.\n     /\n    function getSupportedProtocols() external view override returns (bytes32[] memory) {\n        uint256 length = _supportedProtocols.length();\n        bytes32[] memory protocols = new bytes32;\n        for (uint256 i = 0; i &lt; length; i++) {\n            protocols[i] = _supportedProtocols.at(i);\n        }\n        return protocols;\n    }\n\n    /\n     * @notice Gets a list of users that have an active position.\n     * @dev Uses cursor pagination.\n     * @param cursor The cursor for pagination (should start at 0 for first call).\n     * @param howMany Maximum number of users to return in this pagination request.\n     * @return users List of users that have an active position.\n     * @return nextCursor The cursor to use for the next pagination request.\n     */\n    function usersWithPositions(uint256 cursor, uint256 howMany)\n        external\n        view\n        override\n        returns (address[] memory users, uint256 nextCursor)\n    {\n        uint256 length = usersWithPositions.length();\n        if (cursor &gt;= length) return (new address, 0);\n        if (howMany &gt;= length - cursor) {\n            howMany = length - cursor;\n        }\n\n        address[] memory usersWithPositions = new address;\n        for (uint256 i = 0; i &lt; howMany; i++) {\n            usersWithPositions_[i] = usersWithPositions.at(i + cursor);\n        }\n\n        return (usersWithPositions, cursor + howMany);\n    }\n\n    /\n     * @notice Get a list of all tokens usable for this action.\n     * @dev This refers to all tokens that can be used as deposit tokens.\n     * @return Array of addresses of usable tokens.\n     /\n    function getUsableTokens() external view override returns (address[] memory) {\n        return _usableTokens.toArray();\n    }\n\n    /\n     * @notice Retrieves the topup handler for the given protocol\n     /\n    function getTopUpHandler(bytes32 protocol) external view returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice Successfully tops up a position if it\'s conditions are met.\n     * @dev pool and vault funds are rebalanced after withdrawal for top up\n     * @param payer Account that pays for the top up.\n     * @param account Account owning the position for top up.\n     * @param beneficiary Address of the keeper\'s wallet for fee accrual.\n     * @param protocol Protocol of the top up position.\n     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas\n     * @return true if successful.\n     */\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol,\n        uint256 maxWeiForGas\n    ) public override returns (bool) {\n        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);\n\n        ExecuteLocalVars memory vars;\n\n        vars.initialGas = gasleft();\n\n        Record storage position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n        require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);\n\n        address topUpHandler = _getHandler(protocol, true);\n        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);\n\n        // ensure that the position is actually below its set user factor threshold\n        require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);\n\n        IGasBank gasBank = addressProvider.getGasBank();\n\n        // fail early if the user does not have enough funds in the gas bank\n        // to cover the cost of the transaction\n        vars.estimatedRequiredGas = getEstimatedGasUsage();\n        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;\n\n        // compute the gas price that the user will be paying\n        vars.userGasPrice = block.basefee + position.priorityFee;\n        if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;\n        if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;\n\n        // ensure the current position allows for the gas to be paid\n        require(\n            vars.estimatedRequiredWeiForGas &lt;=\n                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,\n            Error.ESTIMATED_GAS_TOO_HIGH\n        );\n\n        vars.gasBankBalance = gasBank.balanceOf(payer);\n        // ensure the user has enough funds in the gas bank to cover the gas\n        require(\n            vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,\n            Error.GAS_BANK_BALANCE_TOO_LOW\n        );\n\n        vars.totalTopUpAmount = position.totalTopUpAmount;\n        vars.actionFee = getActionFee();\n        // add top-up fees to top-up amount\n        vars.minActionAmountToTopUp = position.singleTopUpAmount;\n        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(\n            ScaledMath.ONE + vars.actionFee\n        );\n\n        // if the amount that we want to top-up (including fees) is higher than\n        // the available topup amount, we lower this down to what is left of the position\n        if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {\n            vars.actionAmountWithFees = vars.totalTopUpAmount;\n            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(\n                ScaledMath.ONE + vars.actionFee\n            );\n        }\n        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);\n        vars.underlying = pool.getUnderlying();\n        vars.rate = pool.exchangeRate();\n\n        ISwapper swapper;\n\n        if (vars.underlying != position.actionToken) {\n            swapper = _getSwapper(vars.underlying, position.actionToken);\n            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));\n        }\n\n        // compute the deposit tokens amount with and without fees\n        // we will need to unstake the amount with fees and to\n        // swap the amount without fees into action tokens\n        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);\n        if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {\n            vars.depositAmountWithFees = position.depositTokenBalance;\n            vars.minActionAmountToTopUp =\n                (vars.depositAmountWithFees * vars.rate) /\n                (ScaledMath.ONE + vars.actionFee);\n        }\n\n        // compute amount of LP tokens needed to pay for action\n        // rate is expressed in actionToken per depositToken\n        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);\n        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;\n\n        // will revert if vault does not exist\n        address vault = addressProvider.getStakerVault(position.depositToken);\n\n        // unstake deposit tokens including fees\n        IStakerVault(vault).unstake(vars.depositAmountWithFees);\n        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);\n\n        // swap the amount without the fees\n        // as the fees are paid in deposit token, not in action token\n        // Redeem first and use swapper only if the underlying tokens are not action tokens\n        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);\n\n        if (address(swapper) != address(0)) {\n            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(\n                getSwapperSlippage()\n            );\n            _approve(vars.underlying, address(swapper));\n            vars.actionTokenAmount = swapper.swap(\n                vars.underlying,\n                position.actionToken,\n                vars.actionTokenAmount,\n                vars.minActionAmountToTopUp\n            );\n        }\n\n        // compute how much of action token was actually redeemed and add fees to it\n        // this is to ensure that no funds get locked inside the contract\n        vars.totalActionTokenAmount =\n            vars.actionTokenAmount +\n            vars.depositTotalFeesAmount.scaledMul(vars.rate);\n\n        // at this point, we have exactly vars.actionTokenAmount\n        // (at least position.singleTopUpAmount) of action token\n        // and exactly vars.depositTotalFeesAmount deposit tokens in the contract\n        // solhint-disable-next-line avoid-low-level-calls\n        (vars.success, vars.topupResult) = topUpHandler.delegatecall(\n            abi.encodeWithSignature(\n                ""topUp(bytes32,address,uint256,bytes)"",\n                account,\n                position.actionToken,\n                vars.actionTokenAmount,\n                position.extra\n            )\n        );\n\n        require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);\n\n        // totalTopUpAmount is updated to reflect the new ""balance"" of the position\n        if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {\n            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);\n        } else {\n            position.totalTopUpAmount = 0;\n        }\n\n        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);\n\n        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;\n        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);\n        if (vars.removePosition) {\n            if (position.depositTokenBalance &gt; 0) {\n                // transfer any unused locked tokens to the payer\n                IStakerVault(vault).transfer(payer, position.depositTokenBalance);\n                IStakerVault(vault).decreaseActionLockedBalance(\n                    payer,\n                    position.depositTokenBalance\n                );\n            }\n            _removePosition(payer, account, protocol);\n        }\n\n        emit TopUp(\n            account,\n            protocol,\n            payer,\n            position.depositToken,\n            vars.depositAmountWithFees,\n            position.actionToken,\n            vars.actionTokenAmount\n        );\n\n        // compute gas used and reimburse the keeper by using the\n        // funds of payer in the gas bank\n        // TODO: add constant gas consumed for transfer and tx prologue\n        vars.gasConsumed = vars.initialGas - gasleft();\n\n        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;\n        if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {\n            vars.reimbursedWeiForGas = vars.gasBankBalance;\n        }\n\n        // ensure that the keeper is not overpaying\n        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;\n        require(\n            vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,\n            Error.GAS_TOO_HIGH\n        );\n        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);\n        if (vars.removePosition) {\n            gasBank.withdrawUnused(payer);\n        }\n\n        return true;\n    }\n\n    /\n     * @notice Prepare new top up handler fee update.\n     * @dev Setting the addres to 0 means that the protocol will no longer be supported.\n     * @param protocol Protocol for which a new handler should be prepared.\n     * @param newHandler Address of new handler.\n     * @return true if success.\n     /\n    function prepareTopUpHandler(bytes32 protocol, address newHandler)\n        public\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_getProtocolKey(protocol), newHandler);\n    }\n\n    /\n     * @notice Check if action can be executed.\n     * @param protocol for which to get the health factor\n     * @param account for which to get the health factor\n     * @param extra data to be used by the topup handler\n     * @return healthFactor of the position\n     /\n    function getHealthFactor(\n        bytes32 protocol,\n        bytes32 account,\n        bytes memory extra\n    ) public view override returns (uint256 healthFactor) {\n        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));\n        return topUpHandler.getUserFactor(account, extra);\n    }\n\n    function getHandler(bytes32 protocol) public view override returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice returns the current estimated gas usage\n     */\n    function getEstimatedGasUsage() public view returns (uint256) {\n        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];\n    }\n\n    /\n     * @notice Returns the current action fee\n     /\n    function getActionFee() public view override returns (uint256) {\n        return currentUInts256[_ACTION_FEE_KEY];\n    }\n\n    /\n     * @notice Returns the current max swapper slippage\n     /\n    function getSwapperSlippage() public view override returns (uint256) {\n        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];\n    }\n\n    /\n     * @notice Returns the current fee handler\n     */\n    function getFeeHandler() public view override returns (address) {\n        return currentAddresses[_FEE_HANDLER_KEY];\n    }\n\n    /\n     * @notice Get the record for a position.\n     * @param payer Registered payer of the position.\n     * @param account Address holding the position.\n     * @param protocol Protocol where the position is held.\n     /\n    function getPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) public view override returns (Record memory) {\n        return _positions[payer][account][protocol];\n    }\n\n    /\n     * @notice Check whether a token is usable as a deposit token.\n     * @param token Address of token to check.\n     * @return True if token is usable as a deposit token for this action.\n     /\n    function isUsable(address token) public view override returns (bool) {\n        return _usableTokens.contains(token);\n    }\n\n    function _updateTopUpHandler(\n        bytes32 protocol,\n        address oldHandler,\n        address newHandler\n    ) internal {\n        if (newHandler == address(0)) {\n            _supportedProtocols.remove(protocol);\n        } else if (oldHandler == address(0)) {\n            _supportedProtocols.add(protocol);\n        }\n    }\n\n    /\n     * @dev Pays fees to the feeHandler\n     * @param payer The account who\'s position the fees are charged on\n     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)\n     * @param feeAmount The amount in tokens to pay as fees\n     * @param depositToken The LpToken used to pay the fees\n     */\n    function _payFees(\n        address payer,\n        address beneficiary,\n        uint256 feeAmount,\n        address depositToken\n    ) internal {\n        address feeHandler = getFeeHandler();\n        IERC20(depositToken).safeApprove(feeHandler, feeAmount);\n        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);\n    }\n\n    /\n     * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction\n     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.\n     * @param payer Owner of the funds to be locked\n     * @param token Token to lock\n     * @param lockAmount Minimum amount of token to lock\n     * @param depositAmount Amount of token that was deposited.\n     *                      If this is 0 then the staker vault allowance should be used.\n     *                      If this is greater than requiredAmount more tokens will be locked.\n     /\n    function _lockFunds(\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) internal {\n        address stakerVaultAddress = addressProvider.getStakerVault(token);\n        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);\n    }\n\n    function _removePosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        delete _positions[payer][account][protocol];\n        _removeUserPosition(payer, account, protocol);\n        if (_userPositions[payer].length == 0) {\n            _usersWithPositions.remove(payer);\n        }\n        emit Deregister(payer, account, protocol);\n    }\n\n    function _removeUserPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        RecordMeta[] storage positionsMeta = _userPositions[payer];\n        uint256 length = positionsMeta.length;\n        for (uint256 i = 0; i &lt; length; i++) {\n            RecordMeta storage positionMeta = positionsMeta[i];\n            if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {\n                positionsMeta[i] = positionsMeta[length - 1];\n                positionsMeta.pop();\n                return;\n            }\n        }\n    }\n\n    /\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     /\n    function _approve(address token, address spender) internal {\n        if (IERC20(token).allowance(address(this), spender) &gt; 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     */\n    function _calcExchangeAmount(\n        address token,\n        address actionToken,\n        uint256 amount\n    ) internal view returns (uint256) {\n        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);\n    }\n\n    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {\n        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);\n    }\n\n    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {\n        address handler = currentAddresses[_getProtocolKey(protocol)];\n        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);\n        return handler;\n    }\n\n    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);\n        address underlying = pool.getUnderlying();\n        if (underlying == toToken) {\n            return true;\n        }\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);\n    }\n\n    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));\n    }\n}\n', 'ideas': "" Precision Loss Identified.\n\nVULNERABILITY NAME: Precision Loss in Arithmetic Operations**\n'''\nThe contract performs several arithmetic operations that could lead to precision loss, particularly in the calcExchangeAmount function and the execute function. For instance, the use of integer division in the calculation of amounts can truncate values, leading to incorrect results. This is especially critical in financial applications where even minor inaccuracies can result in significant monetary loss.\n\nIn the `calcExchange""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-15-08 09:55:31 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol""; import ""../../../interfaces/IGasBank.sol""; import ""../../../interfaces/pool/ILiquidityPool.sol""; import ""../../../interfaces/ISwapperRegistry.sol""; import ""../../../interfaces/IController.sol""; import ""../../../interfaces/IStakerVault.sol""; import ""../../../interfaces/ISwapper.sol""; import ""../../../interfaces/actions/topup/ITopUpHandler.sol""; import ""../../../interfaces/actions/topup/ITopUpAction.sol""; import ""../../../interfaces/actions/IActionFeeHandler.sol""; import ""../../../libraries/AddressProviderHelpers.sol""; import ""../../../libraries/Errors.sol""; import ""../../../libraries/ScaledMath.sol""; import ""../../../libraries/EnumerableExtensions.sol""; import ""../../access/Authorization.sol""; import ""../../utils/Preparable.sol""; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being ""too deep""  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee""; bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler""; bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler""; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage""; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             ""topUp(bytes32,address,uint256,bytes)"",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new ""balance"" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-15-08 09:55:31 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";

import ""../../../interfaces/IGasBank.sol"";
import ""../../../interfaces/pool/ILiquidityPool.sol"";
import ""../../../interfaces/ISwapperRegistry.sol"";
import ""../../../interfaces/IController.sol"";
import ""../../../interfaces/IStakerVault.sol"";
import ""../../../interfaces/ISwapper.sol"";
import ""../../../interfaces/actions/topup/ITopUpHandler.sol"";
import ""../../../interfaces/actions/topup/ITopUpAction.sol"";
import ""../../../interfaces/actions/IActionFeeHandler.sol"";

import ""../../../libraries/AddressProviderHelpers.sol"";
import ""../../../libraries/Errors.sol"";
import ""../../../libraries/ScaledMath.sol"";
import ""../../../libraries/EnumerableExtensions.sol"";

import ""../../access/Authorization.sol"";
import ""../../utils/Preparable.sol"";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being ""too deep""
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee"";
    bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler"";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler"";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage"";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                ""topUp(bytes32,address,uint256,bytes)"",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new ""balance"" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";

import ""../../../interfaces/IGasBank.sol"";
import ""../../../interfaces/pool/ILiquidityPool.sol"";
import ""../../../interfaces/ISwapperRegistry.sol"";
import ""../../../interfaces/IController.sol"";
import ""../../../interfaces/IStakerVault.sol"";
import ""../../../interfaces/ISwapper.sol"";
import ""../../../interfaces/actions/topup/ITopUpHandler.sol"";
import ""../../../interfaces/actions/topup/ITopUpAction.sol"";
import ""../../../interfaces/actions/IActionFeeHandler.sol"";

import ""../../../libraries/AddressProviderHelpers.sol"";
import ""../../../libraries/Errors.sol"";
import ""../../../libraries/ScaledMath.sol"";
import ""../../../libraries/EnumerableExtensions.sol"";

import ""../../access/Authorization.sol"";
import ""../../utils/Preparable.sol"";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being ""too deep""
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee"";
    bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler"";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler"";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage"";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                ""topUp(bytes32,address,uint256,bytes)"",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new ""balance"" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
"".
Ideas: "" Precision Loss Identified.

**VULNERABILITY NAME: Precision Loss in Arithmetic Operations**
'''
The contract performs several arithmetic operations that could lead to precision loss, particularly in the `calcExchangeAmount` function and the `execute` function. For instance, the use of integer division in the calculation of amounts can truncate values, leading to incorrect results. This is especially critical in financial applications where even minor inaccuracies can result in significant monetary loss.

In the `calcExchange"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Redundant Conditional Checks. There are specific cases where the code may have Redundant Conditional Check vulnerabilities:
1. Conditional checks that always evaluate to true or false, which add unnecessary complexity and gas costs to the code.
2. Conditions that duplicate checks already performed earlier in the code, leading to redundant operations and inefficient execution.
If you identify any redundant conditional checks, respond with: ""","<INFO> Redundant Conditional Check Identified.

**VULNERABILITY NAME: Redundant Conditional Checks in `execute` function**
'''
In the `execute`

[2024-15-08 09:55:35 INFO] **[Execute Detail]**

execute SimplePhase:[OracleDependencyDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-15-08 09:55:35 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol""; import ""../../../interfaces/IGasBank.sol""; import ""../../../interfaces/pool/ILiquidityPool.sol""; import ""../../../interfaces/ISwapperRegistry.sol""; import ""../../../interfaces/IController.sol""; import ""../../../interfaces/IStakerVault.sol""; import ""../../../interfaces/ISwapper.sol""; import ""../../../interfaces/actions/topup/ITopUpHandler.sol""; import ""../../../interfaces/actions/topup/ITopUpAction.sol""; import ""../../../interfaces/actions/IActionFeeHandler.sol""; import ""../../../libraries/AddressProviderHelpers.sol""; import ""../../../libraries/Errors.sol""; import ""../../../libraries/ScaledMath.sol""; import ""../../../libraries/EnumerableExtensions.sol""; import ""../../access/Authorization.sol""; import ""../../utils/Preparable.sol""; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being ""too deep""  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee""; bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler""; bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler""; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage""; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             ""topUp(bytes32,address,uint256,bytes)"",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new ""balance"" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to External Oracle Dependency. There are two main concerns related to External Oracle Dependency vulnerabilities: 1. Dependence on a single external oracle for critical data, which pertains to the reliability of the data source. If the oracle is compromised, provides incorrect data, or becomes unavailable, the contract's functionalities could be adversely affected. 2. Lack of fallback mechanisms, which can lead to the contract failing if the external oracle call fails or returns invalid data. This could be exploited by adversaries to disrupt the contract's operations. If you identify reliance on a single external oracle for critical data, respond with: "" External Oracle Dependency Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If you don't find any vulnerabilities, respond only with: "" NO External Oracle Dependency."" |
| **phase_name** | OracleDependencyDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";\nimport ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";\n\nimport ""../../../interfaces/IGasBank.sol"";\nimport ""../../../interfaces/pool/ILiquidityPool.sol"";\nimport ""../../../interfaces/ISwapperRegistry.sol"";\nimport ""../../../interfaces/IController.sol"";\nimport ""../../../interfaces/IStakerVault.sol"";\nimport ""../../../interfaces/ISwapper.sol"";\nimport ""../../../interfaces/actions/topup/ITopUpHandler.sol"";\nimport ""../../../interfaces/actions/topup/ITopUpAction.sol"";\nimport ""../../../interfaces/actions/IActionFeeHandler.sol"";\n\nimport ""../../../libraries/AddressProviderHelpers.sol"";\nimport ""../../../libraries/Errors.sol"";\nimport ""../../../libraries/ScaledMath.sol"";\nimport ""../../../libraries/EnumerableExtensions.sol"";\n\nimport ""../../access/Authorization.sol"";\nimport ""../../utils/Preparable.sol"";\n\n/\n * @notice The logic here should really be part of the top-up action\n * but is split in a library to circumvent the byte-code size limit\n */\nlibrary TopUpActionLibrary {\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    function lockFunds(\n        address stakerVaultAddress,\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) external {\n        uint256 amountLeft = lockAmount;\n        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);\n\n        // stake deposit amount\n        if (depositAmount &gt; 0) {\n            depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;\n            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);\n            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);\n            stakerVault.stake(depositAmount);\n            stakerVault.increaseActionLockedBalance(payer, depositAmount);\n            amountLeft -= depositAmount;\n        }\n\n        // use stake vault allowance if available and required\n        if (amountLeft &gt; 0) {\n            uint256 balance = stakerVault.balanceOf(payer);\n            uint256 allowance = stakerVault.allowance(payer, address(this));\n            uint256 availableFunds = balance &lt; allowance ? balance : allowance;\n            if (availableFunds &gt;= amountLeft) {\n                stakerVault.transferFrom(payer, address(this), amountLeft);\n                amountLeft = 0;\n            }\n        }\n\n        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);\n    }\n\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     /\n    function calcExchangeAmount(\n        IAddressProvider addressProvider,\n        address token,\n        address actionToken,\n        uint256 amount\n    ) external view returns (uint256) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        uint256 rate = pool.exchangeRate();\n        address underlying = pool.getUnderlying();\n        if (underlying == actionToken) {\n            return amount.scaledDivRoundUp(rate);\n        }\n\n        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);\n        uint256 swapperRate = swapper.getRate(underlying, actionToken);\n        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));\n    }\n\n    function getSwapper(\n        IAddressProvider addressProvider,\n        address underlying,\n        address actionToken\n    ) public view returns (ISwapper) {\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);\n        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);\n        return ISwapper(swapper);\n    }\n}\n\ncontract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {\n    using ScaledMath for uint256;\n    using ScaledMath for uint128;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using AddressProviderHelpers for IAddressProvider;\n\n    /\n     * @dev Temporary struct to hold local variables in execute\n     * and avoid the stack being ""too deep""\n     /\n    struct ExecuteLocalVars {\n        uint256 minActionAmountToTopUp;\n        uint256 actionTokenAmount;\n        uint256 depositTotalFeesAmount;\n        uint256 actionAmountWithFees;\n        uint256 userFactor;\n        uint256 rate;\n        uint256 depositAmountWithFees;\n        uint256 depositAmountWithoutFees;\n        uint256 actionFee;\n        uint256 totalActionTokenAmount;\n        uint128 totalTopUpAmount;\n        bool success;\n        bytes topupResult;\n        uint256 gasBankBalance;\n        uint256 initialGas;\n        uint256 gasConsumed;\n        uint256 userGasPrice;\n        uint256 estimatedRequiredGas;\n        uint256 estimatedRequiredWeiForGas;\n        uint256 requiredWeiForGas;\n        uint256 reimbursedWeiForGas;\n        address underlying;\n        bool removePosition;\n    }\n\n    EnumerableSet.AddressSet private _usableTokens;\n\n    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;\n\n    bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee"";\n    bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler"";\n    bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler"";\n    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage"";\n    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";\n\n    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;\n    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;\n    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    EnumerableSet.Bytes32Set internal _supportedProtocols;\n\n    /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record)\n    mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;\n\n    mapping(address =&gt; RecordMeta[]) internal _userPositions;\n\n    EnumerableSet.AddressSet internal _usersWithPositions;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        addressProvider = controller.addressProvider();\n        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);\n    }\n\n    receive() external payable {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function initialize(\n        address feeHandler,\n        bytes32[] calldata protocols,\n        address[] calldata handlers\n    ) external initializer onlyGovernance {\n        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);\n        _setConfig(_FEE_HANDLER_KEY, feeHandler);\n        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);\n        for (uint256 i = 0; i &lt; protocols.length; i++) {\n            bytes32 protocolKey = _getProtocolKey(protocols[i]);\n            _setConfig(protocolKey, handlers[i]);\n            _updateTopUpHandler(protocols[i], address(0), handlers[i]);\n        }\n    }\n\n    /\n     * @notice Register a top up action.\n     * @dev The depositAmount must be greater or equal to the totalTopUpAmount (which is denominated in actionToken).\n     * @param account Account to be topped up (first 20 bytes will typically be the address).\n     * @param depositAmount Amount of depositToken that will be locked.\n     * @param protocol Protocol which holds position to be topped up.\n     * @param record containing the data for the position to register\n     /\n    function register(\n        bytes32 account,\n        bytes32 protocol,\n        uint128 depositAmount,\n        Record memory record\n    ) external payable returns (bool) {\n        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);\n        require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);\n        require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);\n        require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);\n        require(\n            _positions[msg.sender][account][protocol].threshold == 0,\n            Error.POSITION_ALREADY_EXISTS\n        );\n        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);\n        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);\n\n        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) \n            record.maxFee *\n            getEstimatedGasUsage();\n\n        require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);\n\n        uint256 totalLockAmount = _calcExchangeAmount(\n            record.depositToken,\n            record.actionToken,\n            record.totalTopUpAmount\n        );\n        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);\n\n        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);\n\n        record.depositTokenBalance = uint128(totalLockAmount);\n        _positions[msg.sender][account][protocol] = record;\n        _userPositions[msg.sender].push(RecordMeta(account, protocol));\n        _usersWithPositions.add(msg.sender);\n\n        emit Register(\n            account,\n            protocol,\n            record.threshold,\n            msg.sender,\n            record.depositToken,\n            totalLockAmount,\n            record.actionToken,\n            record.singleTopUpAmount,\n            record.totalTopUpAmount,\n            record.maxFee,\n            record.extra\n        );\n        return true;\n    }\n\n    /\n     * @notice See overloaded version of execute for more details.\n     /\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol\n    ) external override returns (bool) {\n        return execute(payer, account, beneficiary, protocol, 0);\n    }\n\n    /\n     * @notice Delete a position to back on the given protocol for account.\n     * @param account Account holding the position.\n     * @param protocol Protocol the position is held on.\n     * @param unstake If the tokens should be unstaked from vault.\n     * @return true if successful.\n     /\n    function resetPosition(\n        bytes32 account,\n        bytes32 protocol,\n        bool unstake\n    ) external override returns (bool) {\n        address payer = msg.sender;\n        Record memory position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n\n        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist\n        IStakerVault staker = IStakerVault(vault);\n        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);\n        if (unstake) {\n            staker.unstake(position.depositTokenBalance);\n            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);\n        } else {\n            staker.transfer(payer, position.depositTokenBalance);\n        }\n\n        _removePosition(payer, account, protocol);\n        addressProvider.getGasBank().withdrawUnused(payer);\n        return true;\n    }\n\n    /\n     * @notice Execute top up handler update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @param protocol Protocol for which a new handler should be executed.\n     * @return Address of new handler.\n     */\n    function executeTopUpHandler(bytes32 protocol) external override returns (address) {\n        address oldHandler = _getHandler(protocol, false);\n        address newHandler = _executeAddress(_getProtocolKey(protocol));\n\n        _updateTopUpHandler(protocol, oldHandler, newHandler);\n        return newHandler;\n    }\n\n    /\n     * @notice Reset new top up handler deadline for a protocol.\n     * @param protocol Protocol for which top up handler deadline should be reset.\n     * @return true if successful.\n     /\n    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_getProtocolKey(protocol));\n    }\n\n    /\n     * @notice Prepare action fee update.\n     * @param newActionFee New fee to set.\n     * @return true if success.\n     /\n    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {\n        require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);\n        return _prepare(_ACTION_FEE_KEY, newActionFee);\n    }\n\n    /\n     * @notice Execute action fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeActionFee() external override returns (uint256) {\n        return _executeUInt256(_ACTION_FEE_KEY);\n    }\n\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     /\n    function resetActionFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ACTION_FEE_KEY);\n    }\n\n    /\n     * @notice Prepare swapper slippage update.\n     * @param newSwapperSlippage New slippage to set.\n     * @return true if success.\n     /\n    function prepareSwapperSlippage(uint256 newSwapperSlippage)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        require(\n            newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;\n                newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,\n            Error.INVALID_AMOUNT\n        );\n        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);\n    }\n\n    /\n     * @notice Execute swapper slippage update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeSwapperSlippage() external override returns (uint256) {\n        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     /\n    function resetSwapperSlippage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    / Set fee handler /\n    /\n     * @notice Prepare update of fee handler.\n     * @param handler New fee handler.\n     * @return true if success.\n     */\n    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {\n        return _prepare(_FEE_HANDLER_KEY, handler);\n    }\n\n    /\n     * @notice Execute update of fee handler (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return true if successful.\n     /\n    function executeFeeHandler() external override returns (address) {\n        return _executeAddress(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Reset the handler deadline.\n     * @return true if success.\n     /\n    function resetFeeHandler() external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Prepare update of estimated gas usage.\n     * @param gasUsage New estimated gas usage.\n     * @return true if success.\n     */\n    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {\n        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);\n    }\n\n    /\n     * @notice Execute update of gas usage (with time delay enforced).\n     * @return true if successful.\n     /\n    function executeEstimatedGasUsage() external returns (uint256) {\n        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Reset the gas usage deadline.\n     * @return true if success.\n     /\n    function resetGasUsage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Add a new deposit token that is supported by the action.\n     * @dev There is a separate check for whether the usable token (i.e. deposit token)\n     *      is swappable for some action token.\n     * @param token Address of deposit token that can be used by the action.\n     */\n    function addUsableToken(address token) external override onlyGovernance returns (bool) {\n        return _usableTokens.add(token);\n    }\n\n    /\n     * @notice Computes the total amount of ETH (as wei) required to pay for all\n     * the top-ups assuming the maximum gas price and the current estimated gas\n     * usage of a top-up\n     /\n    function getEthRequiredForGas(address payer) external view override returns (uint256) {\n        uint256 totalEthRequired = 0;\n        RecordMeta[] memory userRecordsMeta = _userPositions[payer];\n        uint256 gasUsagePerCall = getEstimatedGasUsage();\n        uint256 length = userRecordsMeta.length;\n        for (uint256 i = 0; i &lt; length; i++) {\n            RecordMeta memory meta = userRecordsMeta[i];\n            Record memory record = _positions[payer][meta.account][meta.protocol];\n            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);\n            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;\n        }\n        return totalEthRequired;\n    }\n\n    /\n     * @notice Returns a list of positions for the given payer\n     /\n    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {\n        return _userPositions[payer];\n    }\n\n    /\n     * @notice Get a list supported protocols.\n     * @return List of supported protocols.\n     /\n    function getSupportedProtocols() external view override returns (bytes32[] memory) {\n        uint256 length = _supportedProtocols.length();\n        bytes32[] memory protocols = new bytes32;\n        for (uint256 i = 0; i &lt; length; i++) {\n            protocols[i] = _supportedProtocols.at(i);\n        }\n        return protocols;\n    }\n\n    /\n     * @notice Gets a list of users that have an active position.\n     * @dev Uses cursor pagination.\n     * @param cursor The cursor for pagination (should start at 0 for first call).\n     * @param howMany Maximum number of users to return in this pagination request.\n     * @return users List of users that have an active position.\n     * @return nextCursor The cursor to use for the next pagination request.\n     */\n    function usersWithPositions(uint256 cursor, uint256 howMany)\n        external\n        view\n        override\n        returns (address[] memory users, uint256 nextCursor)\n    {\n        uint256 length = usersWithPositions.length();\n        if (cursor &gt;= length) return (new address, 0);\n        if (howMany &gt;= length - cursor) {\n            howMany = length - cursor;\n        }\n\n        address[] memory usersWithPositions = new address;\n        for (uint256 i = 0; i &lt; howMany; i++) {\n            usersWithPositions_[i] = usersWithPositions.at(i + cursor);\n        }\n\n        return (usersWithPositions, cursor + howMany);\n    }\n\n    /\n     * @notice Get a list of all tokens usable for this action.\n     * @dev This refers to all tokens that can be used as deposit tokens.\n     * @return Array of addresses of usable tokens.\n     /\n    function getUsableTokens() external view override returns (address[] memory) {\n        return _usableTokens.toArray();\n    }\n\n    /\n     * @notice Retrieves the topup handler for the given protocol\n     /\n    function getTopUpHandler(bytes32 protocol) external view returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice Successfully tops up a position if it\'s conditions are met.\n     * @dev pool and vault funds are rebalanced after withdrawal for top up\n     * @param payer Account that pays for the top up.\n     * @param account Account owning the position for top up.\n     * @param beneficiary Address of the keeper\'s wallet for fee accrual.\n     * @param protocol Protocol of the top up position.\n     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas\n     * @return true if successful.\n     */\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol,\n        uint256 maxWeiForGas\n    ) public override returns (bool) {\n        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);\n\n        ExecuteLocalVars memory vars;\n\n        vars.initialGas = gasleft();\n\n        Record storage position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n        require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);\n\n        address topUpHandler = _getHandler(protocol, true);\n        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);\n\n        // ensure that the position is actually below its set user factor threshold\n        require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);\n\n        IGasBank gasBank = addressProvider.getGasBank();\n\n        // fail early if the user does not have enough funds in the gas bank\n        // to cover the cost of the transaction\n        vars.estimatedRequiredGas = getEstimatedGasUsage();\n        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;\n\n        // compute the gas price that the user will be paying\n        vars.userGasPrice = block.basefee + position.priorityFee;\n        if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;\n        if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;\n\n        // ensure the current position allows for the gas to be paid\n        require(\n            vars.estimatedRequiredWeiForGas &lt;=\n                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,\n            Error.ESTIMATED_GAS_TOO_HIGH\n        );\n\n        vars.gasBankBalance = gasBank.balanceOf(payer);\n        // ensure the user has enough funds in the gas bank to cover the gas\n        require(\n            vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,\n            Error.GAS_BANK_BALANCE_TOO_LOW\n        );\n\n        vars.totalTopUpAmount = position.totalTopUpAmount;\n        vars.actionFee = getActionFee();\n        // add top-up fees to top-up amount\n        vars.minActionAmountToTopUp = position.singleTopUpAmount;\n        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(\n            ScaledMath.ONE + vars.actionFee\n        );\n\n        // if the amount that we want to top-up (including fees) is higher than\n        // the available topup amount, we lower this down to what is left of the position\n        if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {\n            vars.actionAmountWithFees = vars.totalTopUpAmount;\n            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(\n                ScaledMath.ONE + vars.actionFee\n            );\n        }\n        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);\n        vars.underlying = pool.getUnderlying();\n        vars.rate = pool.exchangeRate();\n\n        ISwapper swapper;\n\n        if (vars.underlying != position.actionToken) {\n            swapper = _getSwapper(vars.underlying, position.actionToken);\n            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));\n        }\n\n        // compute the deposit tokens amount with and without fees\n        // we will need to unstake the amount with fees and to\n        // swap the amount without fees into action tokens\n        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);\n        if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {\n            vars.depositAmountWithFees = position.depositTokenBalance;\n            vars.minActionAmountToTopUp =\n                (vars.depositAmountWithFees * vars.rate) /\n                (ScaledMath.ONE + vars.actionFee);\n        }\n\n        // compute amount of LP tokens needed to pay for action\n        // rate is expressed in actionToken per depositToken\n        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);\n        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;\n\n        // will revert if vault does not exist\n        address vault = addressProvider.getStakerVault(position.depositToken);\n\n        // unstake deposit tokens including fees\n        IStakerVault(vault).unstake(vars.depositAmountWithFees);\n        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);\n\n        // swap the amount without the fees\n        // as the fees are paid in deposit token, not in action token\n        // Redeem first and use swapper only if the underlying tokens are not action tokens\n        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);\n\n        if (address(swapper) != address(0)) {\n            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(\n                getSwapperSlippage()\n            );\n            _approve(vars.underlying, address(swapper));\n            vars.actionTokenAmount = swapper.swap(\n                vars.underlying,\n                position.actionToken,\n                vars.actionTokenAmount,\n                vars.minActionAmountToTopUp\n            );\n        }\n\n        // compute how much of action token was actually redeemed and add fees to it\n        // this is to ensure that no funds get locked inside the contract\n        vars.totalActionTokenAmount =\n            vars.actionTokenAmount +\n            vars.depositTotalFeesAmount.scaledMul(vars.rate);\n\n        // at this point, we have exactly vars.actionTokenAmount\n        // (at least position.singleTopUpAmount) of action token\n        // and exactly vars.depositTotalFeesAmount deposit tokens in the contract\n        // solhint-disable-next-line avoid-low-level-calls\n        (vars.success, vars.topupResult) = topUpHandler.delegatecall(\n            abi.encodeWithSignature(\n                ""topUp(bytes32,address,uint256,bytes)"",\n                account,\n                position.actionToken,\n                vars.actionTokenAmount,\n                position.extra\n            )\n        );\n\n        require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);\n\n        // totalTopUpAmount is updated to reflect the new ""balance"" of the position\n        if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {\n            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);\n        } else {\n            position.totalTopUpAmount = 0;\n        }\n\n        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);\n\n        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;\n        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);\n        if (vars.removePosition) {\n            if (position.depositTokenBalance &gt; 0) {\n                // transfer any unused locked tokens to the payer\n                IStakerVault(vault).transfer(payer, position.depositTokenBalance);\n                IStakerVault(vault).decreaseActionLockedBalance(\n                    payer,\n                    position.depositTokenBalance\n                );\n            }\n            _removePosition(payer, account, protocol);\n        }\n\n        emit TopUp(\n            account,\n            protocol,\n            payer,\n            position.depositToken,\n            vars.depositAmountWithFees,\n            position.actionToken,\n            vars.actionTokenAmount\n        );\n\n        // compute gas used and reimburse the keeper by using the\n        // funds of payer in the gas bank\n        // TODO: add constant gas consumed for transfer and tx prologue\n        vars.gasConsumed = vars.initialGas - gasleft();\n\n        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;\n        if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {\n            vars.reimbursedWeiForGas = vars.gasBankBalance;\n        }\n\n        // ensure that the keeper is not overpaying\n        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;\n        require(\n            vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,\n            Error.GAS_TOO_HIGH\n        );\n        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);\n        if (vars.removePosition) {\n            gasBank.withdrawUnused(payer);\n        }\n\n        return true;\n    }\n\n    /\n     * @notice Prepare new top up handler fee update.\n     * @dev Setting the addres to 0 means that the protocol will no longer be supported.\n     * @param protocol Protocol for which a new handler should be prepared.\n     * @param newHandler Address of new handler.\n     * @return true if success.\n     /\n    function prepareTopUpHandler(bytes32 protocol, address newHandler)\n        public\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_getProtocolKey(protocol), newHandler);\n    }\n\n    /\n     * @notice Check if action can be executed.\n     * @param protocol for which to get the health factor\n     * @param account for which to get the health factor\n     * @param extra data to be used by the topup handler\n     * @return healthFactor of the position\n     /\n    function getHealthFactor(\n        bytes32 protocol,\n        bytes32 account,\n        bytes memory extra\n    ) public view override returns (uint256 healthFactor) {\n        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));\n        return topUpHandler.getUserFactor(account, extra);\n    }\n\n    function getHandler(bytes32 protocol) public view override returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice returns the current estimated gas usage\n     */\n    function getEstimatedGasUsage() public view returns (uint256) {\n        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];\n    }\n\n    /\n     * @notice Returns the current action fee\n     /\n    function getActionFee() public view override returns (uint256) {\n        return currentUInts256[_ACTION_FEE_KEY];\n    }\n\n    /\n     * @notice Returns the current max swapper slippage\n     /\n    function getSwapperSlippage() public view override returns (uint256) {\n        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];\n    }\n\n    /\n     * @notice Returns the current fee handler\n     */\n    function getFeeHandler() public view override returns (address) {\n        return currentAddresses[_FEE_HANDLER_KEY];\n    }\n\n    /\n     * @notice Get the record for a position.\n     * @param payer Registered payer of the position.\n     * @param account Address holding the position.\n     * @param protocol Protocol where the position is held.\n     /\n    function getPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) public view override returns (Record memory) {\n        return _positions[payer][account][protocol];\n    }\n\n    /\n     * @notice Check whether a token is usable as a deposit token.\n     * @param token Address of token to check.\n     * @return True if token is usable as a deposit token for this action.\n     /\n    function isUsable(address token) public view override returns (bool) {\n        return _usableTokens.contains(token);\n    }\n\n    function _updateTopUpHandler(\n        bytes32 protocol,\n        address oldHandler,\n        address newHandler\n    ) internal {\n        if (newHandler == address(0)) {\n            _supportedProtocols.remove(protocol);\n        } else if (oldHandler == address(0)) {\n            _supportedProtocols.add(protocol);\n        }\n    }\n\n    /\n     * @dev Pays fees to the feeHandler\n     * @param payer The account who\'s position the fees are charged on\n     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)\n     * @param feeAmount The amount in tokens to pay as fees\n     * @param depositToken The LpToken used to pay the fees\n     */\n    function _payFees(\n        address payer,\n        address beneficiary,\n        uint256 feeAmount,\n        address depositToken\n    ) internal {\n        address feeHandler = getFeeHandler();\n        IERC20(depositToken).safeApprove(feeHandler, feeAmount);\n        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);\n    }\n\n    /\n     * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction\n     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.\n     * @param payer Owner of the funds to be locked\n     * @param token Token to lock\n     * @param lockAmount Minimum amount of token to lock\n     * @param depositAmount Amount of token that was deposited.\n     *                      If this is 0 then the staker vault allowance should be used.\n     *                      If this is greater than requiredAmount more tokens will be locked.\n     /\n    function _lockFunds(\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) internal {\n        address stakerVaultAddress = addressProvider.getStakerVault(token);\n        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);\n    }\n\n    function _removePosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        delete _positions[payer][account][protocol];\n        _removeUserPosition(payer, account, protocol);\n        if (_userPositions[payer].length == 0) {\n            _usersWithPositions.remove(payer);\n        }\n        emit Deregister(payer, account, protocol);\n    }\n\n    function _removeUserPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        RecordMeta[] storage positionsMeta = _userPositions[payer];\n        uint256 length = positionsMeta.length;\n        for (uint256 i = 0; i &lt; length; i++) {\n            RecordMeta storage positionMeta = positionsMeta[i];\n            if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {\n                positionsMeta[i] = positionsMeta[length - 1];\n                positionsMeta.pop();\n                return;\n            }\n        }\n    }\n\n    /\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     /\n    function _approve(address token, address spender) internal {\n        if (IERC20(token).allowance(address(this), spender) &gt; 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     */\n    function _calcExchangeAmount(\n        address token,\n        address actionToken,\n        uint256 amount\n    ) internal view returns (uint256) {\n        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);\n    }\n\n    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {\n        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);\n    }\n\n    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {\n        address handler = currentAddresses[_getProtocolKey(protocol)];\n        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);\n        return handler;\n    }\n\n    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);\n        address underlying = pool.getUnderlying();\n        if (underlying == toToken) {\n            return true;\n        }\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);\n    }\n\n    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));\n    }\n}\n', 'ideas': "" Redundant Conditional Check Identified.\n\nVULNERABILITY NAME: Redundant Conditional Checks in execute function**\n'''\nIn the execute""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-15-08 09:55:35 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol""; import ""../../../interfaces/IGasBank.sol""; import ""../../../interfaces/pool/ILiquidityPool.sol""; import ""../../../interfaces/ISwapperRegistry.sol""; import ""../../../interfaces/IController.sol""; import ""../../../interfaces/IStakerVault.sol""; import ""../../../interfaces/ISwapper.sol""; import ""../../../interfaces/actions/topup/ITopUpHandler.sol""; import ""../../../interfaces/actions/topup/ITopUpAction.sol""; import ""../../../interfaces/actions/IActionFeeHandler.sol""; import ""../../../libraries/AddressProviderHelpers.sol""; import ""../../../libraries/Errors.sol""; import ""../../../libraries/ScaledMath.sol""; import ""../../../libraries/EnumerableExtensions.sol""; import ""../../access/Authorization.sol""; import ""../../utils/Preparable.sol""; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being ""too deep""  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee""; bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler""; bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler""; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage""; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             ""topUp(bytes32,address,uint256,bytes)"",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new ""balance"" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-15-08 09:55:35 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";

import ""../../../interfaces/IGasBank.sol"";
import ""../../../interfaces/pool/ILiquidityPool.sol"";
import ""../../../interfaces/ISwapperRegistry.sol"";
import ""../../../interfaces/IController.sol"";
import ""../../../interfaces/IStakerVault.sol"";
import ""../../../interfaces/ISwapper.sol"";
import ""../../../interfaces/actions/topup/ITopUpHandler.sol"";
import ""../../../interfaces/actions/topup/ITopUpAction.sol"";
import ""../../../interfaces/actions/IActionFeeHandler.sol"";

import ""../../../libraries/AddressProviderHelpers.sol"";
import ""../../../libraries/Errors.sol"";
import ""../../../libraries/ScaledMath.sol"";
import ""../../../libraries/EnumerableExtensions.sol"";

import ""../../access/Authorization.sol"";
import ""../../utils/Preparable.sol"";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being ""too deep""
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee"";
    bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler"";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler"";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage"";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                ""topUp(bytes32,address,uint256,bytes)"",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new ""balance"" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";

import ""../../../interfaces/IGasBank.sol"";
import ""../../../interfaces/pool/ILiquidityPool.sol"";
import ""../../../interfaces/ISwapperRegistry.sol"";
import ""../../../interfaces/IController.sol"";
import ""../../../interfaces/IStakerVault.sol"";
import ""../../../interfaces/ISwapper.sol"";
import ""../../../interfaces/actions/topup/ITopUpHandler.sol"";
import ""../../../interfaces/actions/topup/ITopUpAction.sol"";
import ""../../../interfaces/actions/IActionFeeHandler.sol"";

import ""../../../libraries/AddressProviderHelpers.sol"";
import ""../../../libraries/Errors.sol"";
import ""../../../libraries/ScaledMath.sol"";
import ""../../../libraries/EnumerableExtensions.sol"";

import ""../../access/Authorization.sol"";
import ""../../utils/Preparable.sol"";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being ""too deep""
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee"";
    bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler"";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler"";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage"";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                ""topUp(bytes32,address,uint256,bytes)"",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new ""balance"" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
"".
Ideas: "" Redundant Conditional Check Identified.

**VULNERABILITY NAME: Redundant Conditional Checks in `execute` function**
'''
In the `execute`"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to External Oracle Dependency. There are two main concerns related to External Oracle Dependency vulnerabilities:
1. Dependence on a single external oracle for critical data, which pertains to the reliability of the data source. If the oracle is compromised, provides incorrect data, or becomes unavailable, the contract's functionalities could be adversely affected.
2. Lack of fallback mechanisms, which can lead to the contract failing if the external oracle call fails or returns invalid data. This could be exploited by adversaries to disrupt the contract's operations.
If you identify reliance on a single external oracle for critical data, respond with: """,,,"<INFO> Centralization Risk Identified.

**Centralized Control via Governance Functions**
'''
The contract contains several functions that can only be executed by the governance address, which is set during the initialization of the contract. This centralizes control over critical operations such as updating fees, changing handlers, and managing protocols. If the governance address is compromised, an attacker could potentially manipulate these parameters to their advantage, leading to significant financial losses or misuse of the contract.

Recommended Mitigation:
1. Implement a multi-signature wallet for governance functions to

[2024-15-08 09:55:46 INFO] **[Execute Detail]**

execute SimplePhase:[FundingCalculationDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-15-08 09:55:46 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol""; import ""../../../interfaces/IGasBank.sol""; import ""../../../interfaces/pool/ILiquidityPool.sol""; import ""../../../interfaces/ISwapperRegistry.sol""; import ""../../../interfaces/IController.sol""; import ""../../../interfaces/IStakerVault.sol""; import ""../../../interfaces/ISwapper.sol""; import ""../../../interfaces/actions/topup/ITopUpHandler.sol""; import ""../../../interfaces/actions/topup/ITopUpAction.sol""; import ""../../../interfaces/actions/IActionFeeHandler.sol""; import ""../../../libraries/AddressProviderHelpers.sol""; import ""../../../libraries/Errors.sol""; import ""../../../libraries/ScaledMath.sol""; import ""../../../libraries/EnumerableExtensions.sol""; import ""../../access/Authorization.sol""; import ""../../utils/Preparable.sol""; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being ""too deep""  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee""; bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler""; bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler""; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage""; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             ""topUp(bytes32,address,uint256,bytes)"",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new ""balance"" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Funding Rate Calculation Precision. There are two cases where the code may have Funding Rate Calculation Precision vulnerabilities: 1. Simplistic funding rate calculation that does not consider all necessary factors. This can lead to incorrect funding rates, which can be manipulated by providing incorrect input values. A robust funding rate calculation should account for various factors and validations to prevent exploitation. 2. Lack of input validation for critical parameters (e.g., spotPrice, markPrice) used in the funding rate calculation. Malicious actors could potentially manipulate these parameters to influence the funding rate calculation. If you identify a Simplistic funding rate calculation or Lack of input validation, respond with: "" Incorrect Funding Rate Calculation Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If you don't find any vulnerabilities, respond only with: "" NO Incorrect Funding Rate Calculation."" |
| **phase_name** | FundingCalculationDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";\nimport ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";\n\nimport ""../../../interfaces/IGasBank.sol"";\nimport ""../../../interfaces/pool/ILiquidityPool.sol"";\nimport ""../../../interfaces/ISwapperRegistry.sol"";\nimport ""../../../interfaces/IController.sol"";\nimport ""../../../interfaces/IStakerVault.sol"";\nimport ""../../../interfaces/ISwapper.sol"";\nimport ""../../../interfaces/actions/topup/ITopUpHandler.sol"";\nimport ""../../../interfaces/actions/topup/ITopUpAction.sol"";\nimport ""../../../interfaces/actions/IActionFeeHandler.sol"";\n\nimport ""../../../libraries/AddressProviderHelpers.sol"";\nimport ""../../../libraries/Errors.sol"";\nimport ""../../../libraries/ScaledMath.sol"";\nimport ""../../../libraries/EnumerableExtensions.sol"";\n\nimport ""../../access/Authorization.sol"";\nimport ""../../utils/Preparable.sol"";\n\n/\n * @notice The logic here should really be part of the top-up action\n * but is split in a library to circumvent the byte-code size limit\n */\nlibrary TopUpActionLibrary {\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    function lockFunds(\n        address stakerVaultAddress,\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) external {\n        uint256 amountLeft = lockAmount;\n        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);\n\n        // stake deposit amount\n        if (depositAmount &gt; 0) {\n            depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;\n            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);\n            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);\n            stakerVault.stake(depositAmount);\n            stakerVault.increaseActionLockedBalance(payer, depositAmount);\n            amountLeft -= depositAmount;\n        }\n\n        // use stake vault allowance if available and required\n        if (amountLeft &gt; 0) {\n            uint256 balance = stakerVault.balanceOf(payer);\n            uint256 allowance = stakerVault.allowance(payer, address(this));\n            uint256 availableFunds = balance &lt; allowance ? balance : allowance;\n            if (availableFunds &gt;= amountLeft) {\n                stakerVault.transferFrom(payer, address(this), amountLeft);\n                amountLeft = 0;\n            }\n        }\n\n        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);\n    }\n\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     /\n    function calcExchangeAmount(\n        IAddressProvider addressProvider,\n        address token,\n        address actionToken,\n        uint256 amount\n    ) external view returns (uint256) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        uint256 rate = pool.exchangeRate();\n        address underlying = pool.getUnderlying();\n        if (underlying == actionToken) {\n            return amount.scaledDivRoundUp(rate);\n        }\n\n        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);\n        uint256 swapperRate = swapper.getRate(underlying, actionToken);\n        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));\n    }\n\n    function getSwapper(\n        IAddressProvider addressProvider,\n        address underlying,\n        address actionToken\n    ) public view returns (ISwapper) {\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);\n        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);\n        return ISwapper(swapper);\n    }\n}\n\ncontract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {\n    using ScaledMath for uint256;\n    using ScaledMath for uint128;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using AddressProviderHelpers for IAddressProvider;\n\n    /\n     * @dev Temporary struct to hold local variables in execute\n     * and avoid the stack being ""too deep""\n     /\n    struct ExecuteLocalVars {\n        uint256 minActionAmountToTopUp;\n        uint256 actionTokenAmount;\n        uint256 depositTotalFeesAmount;\n        uint256 actionAmountWithFees;\n        uint256 userFactor;\n        uint256 rate;\n        uint256 depositAmountWithFees;\n        uint256 depositAmountWithoutFees;\n        uint256 actionFee;\n        uint256 totalActionTokenAmount;\n        uint128 totalTopUpAmount;\n        bool success;\n        bytes topupResult;\n        uint256 gasBankBalance;\n        uint256 initialGas;\n        uint256 gasConsumed;\n        uint256 userGasPrice;\n        uint256 estimatedRequiredGas;\n        uint256 estimatedRequiredWeiForGas;\n        uint256 requiredWeiForGas;\n        uint256 reimbursedWeiForGas;\n        address underlying;\n        bool removePosition;\n    }\n\n    EnumerableSet.AddressSet private _usableTokens;\n\n    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;\n\n    bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee"";\n    bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler"";\n    bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler"";\n    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage"";\n    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";\n\n    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;\n    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;\n    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    EnumerableSet.Bytes32Set internal _supportedProtocols;\n\n    /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record)\n    mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;\n\n    mapping(address =&gt; RecordMeta[]) internal _userPositions;\n\n    EnumerableSet.AddressSet internal _usersWithPositions;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        addressProvider = controller.addressProvider();\n        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);\n    }\n\n    receive() external payable {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function initialize(\n        address feeHandler,\n        bytes32[] calldata protocols,\n        address[] calldata handlers\n    ) external initializer onlyGovernance {\n        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);\n        _setConfig(_FEE_HANDLER_KEY, feeHandler);\n        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);\n        for (uint256 i = 0; i &lt; protocols.length; i++) {\n            bytes32 protocolKey = _getProtocolKey(protocols[i]);\n            _setConfig(protocolKey, handlers[i]);\n            _updateTopUpHandler(protocols[i], address(0), handlers[i]);\n        }\n    }\n\n    /\n     * @notice Register a top up action.\n     * @dev The depositAmount must be greater or equal to the totalTopUpAmount (which is denominated in actionToken).\n     * @param account Account to be topped up (first 20 bytes will typically be the address).\n     * @param depositAmount Amount of depositToken that will be locked.\n     * @param protocol Protocol which holds position to be topped up.\n     * @param record containing the data for the position to register\n     /\n    function register(\n        bytes32 account,\n        bytes32 protocol,\n        uint128 depositAmount,\n        Record memory record\n    ) external payable returns (bool) {\n        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);\n        require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);\n        require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);\n        require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);\n        require(\n            _positions[msg.sender][account][protocol].threshold == 0,\n            Error.POSITION_ALREADY_EXISTS\n        );\n        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);\n        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);\n\n        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) \n            record.maxFee *\n            getEstimatedGasUsage();\n\n        require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);\n\n        uint256 totalLockAmount = _calcExchangeAmount(\n            record.depositToken,\n            record.actionToken,\n            record.totalTopUpAmount\n        );\n        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);\n\n        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);\n\n        record.depositTokenBalance = uint128(totalLockAmount);\n        _positions[msg.sender][account][protocol] = record;\n        _userPositions[msg.sender].push(RecordMeta(account, protocol));\n        _usersWithPositions.add(msg.sender);\n\n        emit Register(\n            account,\n            protocol,\n            record.threshold,\n            msg.sender,\n            record.depositToken,\n            totalLockAmount,\n            record.actionToken,\n            record.singleTopUpAmount,\n            record.totalTopUpAmount,\n            record.maxFee,\n            record.extra\n        );\n        return true;\n    }\n\n    /\n     * @notice See overloaded version of execute for more details.\n     /\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol\n    ) external override returns (bool) {\n        return execute(payer, account, beneficiary, protocol, 0);\n    }\n\n    /\n     * @notice Delete a position to back on the given protocol for account.\n     * @param account Account holding the position.\n     * @param protocol Protocol the position is held on.\n     * @param unstake If the tokens should be unstaked from vault.\n     * @return true if successful.\n     /\n    function resetPosition(\n        bytes32 account,\n        bytes32 protocol,\n        bool unstake\n    ) external override returns (bool) {\n        address payer = msg.sender;\n        Record memory position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n\n        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist\n        IStakerVault staker = IStakerVault(vault);\n        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);\n        if (unstake) {\n            staker.unstake(position.depositTokenBalance);\n            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);\n        } else {\n            staker.transfer(payer, position.depositTokenBalance);\n        }\n\n        _removePosition(payer, account, protocol);\n        addressProvider.getGasBank().withdrawUnused(payer);\n        return true;\n    }\n\n    /\n     * @notice Execute top up handler update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @param protocol Protocol for which a new handler should be executed.\n     * @return Address of new handler.\n     */\n    function executeTopUpHandler(bytes32 protocol) external override returns (address) {\n        address oldHandler = _getHandler(protocol, false);\n        address newHandler = _executeAddress(_getProtocolKey(protocol));\n\n        _updateTopUpHandler(protocol, oldHandler, newHandler);\n        return newHandler;\n    }\n\n    /\n     * @notice Reset new top up handler deadline for a protocol.\n     * @param protocol Protocol for which top up handler deadline should be reset.\n     * @return true if successful.\n     /\n    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_getProtocolKey(protocol));\n    }\n\n    /\n     * @notice Prepare action fee update.\n     * @param newActionFee New fee to set.\n     * @return true if success.\n     /\n    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {\n        require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);\n        return _prepare(_ACTION_FEE_KEY, newActionFee);\n    }\n\n    /\n     * @notice Execute action fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeActionFee() external override returns (uint256) {\n        return _executeUInt256(_ACTION_FEE_KEY);\n    }\n\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     /\n    function resetActionFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ACTION_FEE_KEY);\n    }\n\n    /\n     * @notice Prepare swapper slippage update.\n     * @param newSwapperSlippage New slippage to set.\n     * @return true if success.\n     /\n    function prepareSwapperSlippage(uint256 newSwapperSlippage)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        require(\n            newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;\n                newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,\n            Error.INVALID_AMOUNT\n        );\n        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);\n    }\n\n    /\n     * @notice Execute swapper slippage update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeSwapperSlippage() external override returns (uint256) {\n        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     /\n    function resetSwapperSlippage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    / Set fee handler /\n    /\n     * @notice Prepare update of fee handler.\n     * @param handler New fee handler.\n     * @return true if success.\n     */\n    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {\n        return _prepare(_FEE_HANDLER_KEY, handler);\n    }\n\n    /\n     * @notice Execute update of fee handler (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return true if successful.\n     /\n    function executeFeeHandler() external override returns (address) {\n        return _executeAddress(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Reset the handler deadline.\n     * @return true if success.\n     /\n    function resetFeeHandler() external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Prepare update of estimated gas usage.\n     * @param gasUsage New estimated gas usage.\n     * @return true if success.\n     */\n    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {\n        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);\n    }\n\n    /\n     * @notice Execute update of gas usage (with time delay enforced).\n     * @return true if successful.\n     /\n    function executeEstimatedGasUsage() external returns (uint256) {\n        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Reset the gas usage deadline.\n     * @return true if success.\n     /\n    function resetGasUsage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Add a new deposit token that is supported by the action.\n     * @dev There is a separate check for whether the usable token (i.e. deposit token)\n     *      is swappable for some action token.\n     * @param token Address of deposit token that can be used by the action.\n     */\n    function addUsableToken(address token) external override onlyGovernance returns (bool) {\n        return _usableTokens.add(token);\n    }\n\n    /\n     * @notice Computes the total amount of ETH (as wei) required to pay for all\n     * the top-ups assuming the maximum gas price and the current estimated gas\n     * usage of a top-up\n     /\n    function getEthRequiredForGas(address payer) external view override returns (uint256) {\n        uint256 totalEthRequired = 0;\n        RecordMeta[] memory userRecordsMeta = _userPositions[payer];\n        uint256 gasUsagePerCall = getEstimatedGasUsage();\n        uint256 length = userRecordsMeta.length;\n        for (uint256 i = 0; i &lt; length; i++) {\n            RecordMeta memory meta = userRecordsMeta[i];\n            Record memory record = _positions[payer][meta.account][meta.protocol];\n            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);\n            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;\n        }\n        return totalEthRequired;\n    }\n\n    /\n     * @notice Returns a list of positions for the given payer\n     /\n    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {\n        return _userPositions[payer];\n    }\n\n    /\n     * @notice Get a list supported protocols.\n     * @return List of supported protocols.\n     /\n    function getSupportedProtocols() external view override returns (bytes32[] memory) {\n        uint256 length = _supportedProtocols.length();\n        bytes32[] memory protocols = new bytes32;\n        for (uint256 i = 0; i &lt; length; i++) {\n            protocols[i] = _supportedProtocols.at(i);\n        }\n        return protocols;\n    }\n\n    /\n     * @notice Gets a list of users that have an active position.\n     * @dev Uses cursor pagination.\n     * @param cursor The cursor for pagination (should start at 0 for first call).\n     * @param howMany Maximum number of users to return in this pagination request.\n     * @return users List of users that have an active position.\n     * @return nextCursor The cursor to use for the next pagination request.\n     */\n    function usersWithPositions(uint256 cursor, uint256 howMany)\n        external\n        view\n        override\n        returns (address[] memory users, uint256 nextCursor)\n    {\n        uint256 length = usersWithPositions.length();\n        if (cursor &gt;= length) return (new address, 0);\n        if (howMany &gt;= length - cursor) {\n            howMany = length - cursor;\n        }\n\n        address[] memory usersWithPositions = new address;\n        for (uint256 i = 0; i &lt; howMany; i++) {\n            usersWithPositions_[i] = usersWithPositions.at(i + cursor);\n        }\n\n        return (usersWithPositions, cursor + howMany);\n    }\n\n    /\n     * @notice Get a list of all tokens usable for this action.\n     * @dev This refers to all tokens that can be used as deposit tokens.\n     * @return Array of addresses of usable tokens.\n     /\n    function getUsableTokens() external view override returns (address[] memory) {\n        return _usableTokens.toArray();\n    }\n\n    /\n     * @notice Retrieves the topup handler for the given protocol\n     /\n    function getTopUpHandler(bytes32 protocol) external view returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice Successfully tops up a position if it\'s conditions are met.\n     * @dev pool and vault funds are rebalanced after withdrawal for top up\n     * @param payer Account that pays for the top up.\n     * @param account Account owning the position for top up.\n     * @param beneficiary Address of the keeper\'s wallet for fee accrual.\n     * @param protocol Protocol of the top up position.\n     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas\n     * @return true if successful.\n     */\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol,\n        uint256 maxWeiForGas\n    ) public override returns (bool) {\n        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);\n\n        ExecuteLocalVars memory vars;\n\n        vars.initialGas = gasleft();\n\n        Record storage position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n        require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);\n\n        address topUpHandler = _getHandler(protocol, true);\n        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);\n\n        // ensure that the position is actually below its set user factor threshold\n        require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);\n\n        IGasBank gasBank = addressProvider.getGasBank();\n\n        // fail early if the user does not have enough funds in the gas bank\n        // to cover the cost of the transaction\n        vars.estimatedRequiredGas = getEstimatedGasUsage();\n        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;\n\n        // compute the gas price that the user will be paying\n        vars.userGasPrice = block.basefee + position.priorityFee;\n        if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;\n        if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;\n\n        // ensure the current position allows for the gas to be paid\n        require(\n            vars.estimatedRequiredWeiForGas &lt;=\n                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,\n            Error.ESTIMATED_GAS_TOO_HIGH\n        );\n\n        vars.gasBankBalance = gasBank.balanceOf(payer);\n        // ensure the user has enough funds in the gas bank to cover the gas\n        require(\n            vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,\n            Error.GAS_BANK_BALANCE_TOO_LOW\n        );\n\n        vars.totalTopUpAmount = position.totalTopUpAmount;\n        vars.actionFee = getActionFee();\n        // add top-up fees to top-up amount\n        vars.minActionAmountToTopUp = position.singleTopUpAmount;\n        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(\n            ScaledMath.ONE + vars.actionFee\n        );\n\n        // if the amount that we want to top-up (including fees) is higher than\n        // the available topup amount, we lower this down to what is left of the position\n        if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {\n            vars.actionAmountWithFees = vars.totalTopUpAmount;\n            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(\n                ScaledMath.ONE + vars.actionFee\n            );\n        }\n        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);\n        vars.underlying = pool.getUnderlying();\n        vars.rate = pool.exchangeRate();\n\n        ISwapper swapper;\n\n        if (vars.underlying != position.actionToken) {\n            swapper = _getSwapper(vars.underlying, position.actionToken);\n            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));\n        }\n\n        // compute the deposit tokens amount with and without fees\n        // we will need to unstake the amount with fees and to\n        // swap the amount without fees into action tokens\n        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);\n        if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {\n            vars.depositAmountWithFees = position.depositTokenBalance;\n            vars.minActionAmountToTopUp =\n                (vars.depositAmountWithFees * vars.rate) /\n                (ScaledMath.ONE + vars.actionFee);\n        }\n\n        // compute amount of LP tokens needed to pay for action\n        // rate is expressed in actionToken per depositToken\n        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);\n        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;\n\n        // will revert if vault does not exist\n        address vault = addressProvider.getStakerVault(position.depositToken);\n\n        // unstake deposit tokens including fees\n        IStakerVault(vault).unstake(vars.depositAmountWithFees);\n        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);\n\n        // swap the amount without the fees\n        // as the fees are paid in deposit token, not in action token\n        // Redeem first and use swapper only if the underlying tokens are not action tokens\n        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);\n\n        if (address(swapper) != address(0)) {\n            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(\n                getSwapperSlippage()\n            );\n            _approve(vars.underlying, address(swapper));\n            vars.actionTokenAmount = swapper.swap(\n                vars.underlying,\n                position.actionToken,\n                vars.actionTokenAmount,\n                vars.minActionAmountToTopUp\n            );\n        }\n\n        // compute how much of action token was actually redeemed and add fees to it\n        // this is to ensure that no funds get locked inside the contract\n        vars.totalActionTokenAmount =\n            vars.actionTokenAmount +\n            vars.depositTotalFeesAmount.scaledMul(vars.rate);\n\n        // at this point, we have exactly vars.actionTokenAmount\n        // (at least position.singleTopUpAmount) of action token\n        // and exactly vars.depositTotalFeesAmount deposit tokens in the contract\n        // solhint-disable-next-line avoid-low-level-calls\n        (vars.success, vars.topupResult) = topUpHandler.delegatecall(\n            abi.encodeWithSignature(\n                ""topUp(bytes32,address,uint256,bytes)"",\n                account,\n                position.actionToken,\n                vars.actionTokenAmount,\n                position.extra\n            )\n        );\n\n        require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);\n\n        // totalTopUpAmount is updated to reflect the new ""balance"" of the position\n        if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {\n            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);\n        } else {\n            position.totalTopUpAmount = 0;\n        }\n\n        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);\n\n        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;\n        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);\n        if (vars.removePosition) {\n            if (position.depositTokenBalance &gt; 0) {\n                // transfer any unused locked tokens to the payer\n                IStakerVault(vault).transfer(payer, position.depositTokenBalance);\n                IStakerVault(vault).decreaseActionLockedBalance(\n                    payer,\n                    position.depositTokenBalance\n                );\n            }\n            _removePosition(payer, account, protocol);\n        }\n\n        emit TopUp(\n            account,\n            protocol,\n            payer,\n            position.depositToken,\n            vars.depositAmountWithFees,\n            position.actionToken,\n            vars.actionTokenAmount\n        );\n\n        // compute gas used and reimburse the keeper by using the\n        // funds of payer in the gas bank\n        // TODO: add constant gas consumed for transfer and tx prologue\n        vars.gasConsumed = vars.initialGas - gasleft();\n\n        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;\n        if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {\n            vars.reimbursedWeiForGas = vars.gasBankBalance;\n        }\n\n        // ensure that the keeper is not overpaying\n        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;\n        require(\n            vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,\n            Error.GAS_TOO_HIGH\n        );\n        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);\n        if (vars.removePosition) {\n            gasBank.withdrawUnused(payer);\n        }\n\n        return true;\n    }\n\n    /\n     * @notice Prepare new top up handler fee update.\n     * @dev Setting the addres to 0 means that the protocol will no longer be supported.\n     * @param protocol Protocol for which a new handler should be prepared.\n     * @param newHandler Address of new handler.\n     * @return true if success.\n     /\n    function prepareTopUpHandler(bytes32 protocol, address newHandler)\n        public\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_getProtocolKey(protocol), newHandler);\n    }\n\n    /\n     * @notice Check if action can be executed.\n     * @param protocol for which to get the health factor\n     * @param account for which to get the health factor\n     * @param extra data to be used by the topup handler\n     * @return healthFactor of the position\n     /\n    function getHealthFactor(\n        bytes32 protocol,\n        bytes32 account,\n        bytes memory extra\n    ) public view override returns (uint256 healthFactor) {\n        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));\n        return topUpHandler.getUserFactor(account, extra);\n    }\n\n    function getHandler(bytes32 protocol) public view override returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice returns the current estimated gas usage\n     */\n    function getEstimatedGasUsage() public view returns (uint256) {\n        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];\n    }\n\n    /\n     * @notice Returns the current action fee\n     /\n    function getActionFee() public view override returns (uint256) {\n        return currentUInts256[_ACTION_FEE_KEY];\n    }\n\n    /\n     * @notice Returns the current max swapper slippage\n     /\n    function getSwapperSlippage() public view override returns (uint256) {\n        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];\n    }\n\n    /\n     * @notice Returns the current fee handler\n     */\n    function getFeeHandler() public view override returns (address) {\n        return currentAddresses[_FEE_HANDLER_KEY];\n    }\n\n    /\n     * @notice Get the record for a position.\n     * @param payer Registered payer of the position.\n     * @param account Address holding the position.\n     * @param protocol Protocol where the position is held.\n     /\n    function getPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) public view override returns (Record memory) {\n        return _positions[payer][account][protocol];\n    }\n\n    /\n     * @notice Check whether a token is usable as a deposit token.\n     * @param token Address of token to check.\n     * @return True if token is usable as a deposit token for this action.\n     /\n    function isUsable(address token) public view override returns (bool) {\n        return _usableTokens.contains(token);\n    }\n\n    function _updateTopUpHandler(\n        bytes32 protocol,\n        address oldHandler,\n        address newHandler\n    ) internal {\n        if (newHandler == address(0)) {\n            _supportedProtocols.remove(protocol);\n        } else if (oldHandler == address(0)) {\n            _supportedProtocols.add(protocol);\n        }\n    }\n\n    /\n     * @dev Pays fees to the feeHandler\n     * @param payer The account who\'s position the fees are charged on\n     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)\n     * @param feeAmount The amount in tokens to pay as fees\n     * @param depositToken The LpToken used to pay the fees\n     */\n    function _payFees(\n        address payer,\n        address beneficiary,\n        uint256 feeAmount,\n        address depositToken\n    ) internal {\n        address feeHandler = getFeeHandler();\n        IERC20(depositToken).safeApprove(feeHandler, feeAmount);\n        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);\n    }\n\n    /\n     * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction\n     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.\n     * @param payer Owner of the funds to be locked\n     * @param token Token to lock\n     * @param lockAmount Minimum amount of token to lock\n     * @param depositAmount Amount of token that was deposited.\n     *                      If this is 0 then the staker vault allowance should be used.\n     *                      If this is greater than requiredAmount more tokens will be locked.\n     /\n    function _lockFunds(\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) internal {\n        address stakerVaultAddress = addressProvider.getStakerVault(token);\n        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);\n    }\n\n    function _removePosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        delete _positions[payer][account][protocol];\n        _removeUserPosition(payer, account, protocol);\n        if (_userPositions[payer].length == 0) {\n            _usersWithPositions.remove(payer);\n        }\n        emit Deregister(payer, account, protocol);\n    }\n\n    function _removeUserPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        RecordMeta[] storage positionsMeta = _userPositions[payer];\n        uint256 length = positionsMeta.length;\n        for (uint256 i = 0; i &lt; length; i++) {\n            RecordMeta storage positionMeta = positionsMeta[i];\n            if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {\n                positionsMeta[i] = positionsMeta[length - 1];\n                positionsMeta.pop();\n                return;\n            }\n        }\n    }\n\n    /\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     /\n    function _approve(address token, address spender) internal {\n        if (IERC20(token).allowance(address(this), spender) &gt; 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     */\n    function _calcExchangeAmount(\n        address token,\n        address actionToken,\n        uint256 amount\n    ) internal view returns (uint256) {\n        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);\n    }\n\n    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {\n        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);\n    }\n\n    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {\n        address handler = currentAddresses[_getProtocolKey(protocol)];\n        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);\n        return handler;\n    }\n\n    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);\n        address underlying = pool.getUnderlying();\n        if (underlying == toToken) {\n            return true;\n        }\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);\n    }\n\n    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));\n    }\n}\n', 'ideas': "" Centralization Risk Identified.\n\nCentralized Control via Governance Functions**\n'''\nThe contract contains several functions that can only be executed by the governance address, which is set during the initialization of the contract. This centralizes control over critical operations such as updating fees, changing handlers, and managing protocols. If the governance address is compromised, an attacker could potentially manipulate these parameters to their advantage, leading to significant financial losses or misuse of the contract.\n\nRecommended Mitigation:\n1. Implement a multi-signature wallet for governance functions to""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-15-08 09:55:46 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol""; import ""../../../interfaces/IGasBank.sol""; import ""../../../interfaces/pool/ILiquidityPool.sol""; import ""../../../interfaces/ISwapperRegistry.sol""; import ""../../../interfaces/IController.sol""; import ""../../../interfaces/IStakerVault.sol""; import ""../../../interfaces/ISwapper.sol""; import ""../../../interfaces/actions/topup/ITopUpHandler.sol""; import ""../../../interfaces/actions/topup/ITopUpAction.sol""; import ""../../../interfaces/actions/IActionFeeHandler.sol""; import ""../../../libraries/AddressProviderHelpers.sol""; import ""../../../libraries/Errors.sol""; import ""../../../libraries/ScaledMath.sol""; import ""../../../libraries/EnumerableExtensions.sol""; import ""../../access/Authorization.sol""; import ""../../utils/Preparable.sol""; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being ""too deep""  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee""; bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler""; bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler""; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage""; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             ""topUp(bytes32,address,uint256,bytes)"",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new ""balance"" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-15-08 09:55:46 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";

import ""../../../interfaces/IGasBank.sol"";
import ""../../../interfaces/pool/ILiquidityPool.sol"";
import ""../../../interfaces/ISwapperRegistry.sol"";
import ""../../../interfaces/IController.sol"";
import ""../../../interfaces/IStakerVault.sol"";
import ""../../../interfaces/ISwapper.sol"";
import ""../../../interfaces/actions/topup/ITopUpHandler.sol"";
import ""../../../interfaces/actions/topup/ITopUpAction.sol"";
import ""../../../interfaces/actions/IActionFeeHandler.sol"";

import ""../../../libraries/AddressProviderHelpers.sol"";
import ""../../../libraries/Errors.sol"";
import ""../../../libraries/ScaledMath.sol"";
import ""../../../libraries/EnumerableExtensions.sol"";

import ""../../access/Authorization.sol"";
import ""../../utils/Preparable.sol"";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being ""too deep""
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee"";
    bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler"";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler"";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage"";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                ""topUp(bytes32,address,uint256,bytes)"",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new ""balance"" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";

import ""../../../interfaces/IGasBank.sol"";
import ""../../../interfaces/pool/ILiquidityPool.sol"";
import ""../../../interfaces/ISwapperRegistry.sol"";
import ""../../../interfaces/IController.sol"";
import ""../../../interfaces/IStakerVault.sol"";
import ""../../../interfaces/ISwapper.sol"";
import ""../../../interfaces/actions/topup/ITopUpHandler.sol"";
import ""../../../interfaces/actions/topup/ITopUpAction.sol"";
import ""../../../interfaces/actions/IActionFeeHandler.sol"";

import ""../../../libraries/AddressProviderHelpers.sol"";
import ""../../../libraries/Errors.sol"";
import ""../../../libraries/ScaledMath.sol"";
import ""../../../libraries/EnumerableExtensions.sol"";

import ""../../access/Authorization.sol"";
import ""../../utils/Preparable.sol"";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being ""too deep""
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee"";
    bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler"";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler"";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage"";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                ""topUp(bytes32,address,uint256,bytes)"",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new ""balance"" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
"".
Ideas: "" Centralization Risk Identified.

**Centralized Control via Governance Functions**
'''
The contract contains several functions that can only be executed by the governance address, which is set during the initialization of the contract. This centralizes control over critical operations such as updating fees, changing handlers, and managing protocols. If the governance address is compromised, an attacker could potentially manipulate these parameters to their advantage, leading to significant financial losses or misuse of the contract.

Recommended Mitigation:
1. Implement a multi-signature wallet for governance functions to"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Funding Rate Calculation Precision. There are two cases where the code may have Funding Rate Calculation Precision vulnerabilities:
1. Simplistic funding rate calculation that does not consider all necessary factors. This can lead to incorrect funding rates, which can be manipulated by providing incorrect input values. A robust funding rate calculation should account for various factors and validations to prevent exploitation.
2. Lack of input validation for critical parameters (e.g., spotPrice, markPrice) used in the funding rate calculation. Malicious actors could potentially manipulate these parameters to influence the funding rate calculation.
If you identify a Simplistic funding rate calculation or Lack of input validation, respond with: """,,,,,"<INFO> Unnecessary Comparison Identified.

UNNECESSARY COMPARISON
'''
In the `execute` function, there are instances where boolean values are compared explicitly to `true` or `false`. For example, the line:
```solidity
require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);
```
could be simplified by directly using the boolean expression without the explicit comparison. This enhances readability and reduces the risk of logical errors. 

Recommended mitigation is to directly use the boolean expression in the require statement without unnecessary comparisons,

[2024-15-08 09:56:01 INFO] **[Execute Detail]**

execute SimplePhase:[InconsistentInitializationDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-15-08 09:56:02 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol""; import ""../../../interfaces/IGasBank.sol""; import ""../../../interfaces/pool/ILiquidityPool.sol""; import ""../../../interfaces/ISwapperRegistry.sol""; import ""../../../interfaces/IController.sol""; import ""../../../interfaces/IStakerVault.sol""; import ""../../../interfaces/ISwapper.sol""; import ""../../../interfaces/actions/topup/ITopUpHandler.sol""; import ""../../../interfaces/actions/topup/ITopUpAction.sol""; import ""../../../interfaces/actions/IActionFeeHandler.sol""; import ""../../../libraries/AddressProviderHelpers.sol""; import ""../../../libraries/Errors.sol""; import ""../../../libraries/ScaledMath.sol""; import ""../../../libraries/EnumerableExtensions.sol""; import ""../../access/Authorization.sol""; import ""../../utils/Preparable.sol""; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being ""too deep""  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee""; bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler""; bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler""; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage""; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             ""topUp(bytes32,address,uint256,bytes)"",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new ""balance"" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Inconsistent Initialization. This type of vulnerability arises when state variables are initialized using a function that relies on the state of other variables, which may not yet be set or initialized, leading to unpredictable or unintended behavior. There are two cases where the code may have Inconsistent Initialization vulnerabilities: 1. Initialization of a state variable using a function call where the function's logic depends on the state of other variables that are not yet initialized. This can lead to incorrect values being set for the variable. 2. Initialization order of state variables where the value of one variable depends on the value of another variable that has not been initialized yet. If you identify Inconsistent Initialization, respond with: "" Inconsistent Initialization Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If you don't find any vulnerabilities, respond only with: "" NO Inconsistent Initialization."" |
| **phase_name** | InconsistentInitializationDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";\nimport ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";\n\nimport ""../../../interfaces/IGasBank.sol"";\nimport ""../../../interfaces/pool/ILiquidityPool.sol"";\nimport ""../../../interfaces/ISwapperRegistry.sol"";\nimport ""../../../interfaces/IController.sol"";\nimport ""../../../interfaces/IStakerVault.sol"";\nimport ""../../../interfaces/ISwapper.sol"";\nimport ""../../../interfaces/actions/topup/ITopUpHandler.sol"";\nimport ""../../../interfaces/actions/topup/ITopUpAction.sol"";\nimport ""../../../interfaces/actions/IActionFeeHandler.sol"";\n\nimport ""../../../libraries/AddressProviderHelpers.sol"";\nimport ""../../../libraries/Errors.sol"";\nimport ""../../../libraries/ScaledMath.sol"";\nimport ""../../../libraries/EnumerableExtensions.sol"";\n\nimport ""../../access/Authorization.sol"";\nimport ""../../utils/Preparable.sol"";\n\n/\n * @notice The logic here should really be part of the top-up action\n * but is split in a library to circumvent the byte-code size limit\n */\nlibrary TopUpActionLibrary {\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    function lockFunds(\n        address stakerVaultAddress,\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) external {\n        uint256 amountLeft = lockAmount;\n        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);\n\n        // stake deposit amount\n        if (depositAmount &gt; 0) {\n            depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;\n            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);\n            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);\n            stakerVault.stake(depositAmount);\n            stakerVault.increaseActionLockedBalance(payer, depositAmount);\n            amountLeft -= depositAmount;\n        }\n\n        // use stake vault allowance if available and required\n        if (amountLeft &gt; 0) {\n            uint256 balance = stakerVault.balanceOf(payer);\n            uint256 allowance = stakerVault.allowance(payer, address(this));\n            uint256 availableFunds = balance &lt; allowance ? balance : allowance;\n            if (availableFunds &gt;= amountLeft) {\n                stakerVault.transferFrom(payer, address(this), amountLeft);\n                amountLeft = 0;\n            }\n        }\n\n        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);\n    }\n\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     /\n    function calcExchangeAmount(\n        IAddressProvider addressProvider,\n        address token,\n        address actionToken,\n        uint256 amount\n    ) external view returns (uint256) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        uint256 rate = pool.exchangeRate();\n        address underlying = pool.getUnderlying();\n        if (underlying == actionToken) {\n            return amount.scaledDivRoundUp(rate);\n        }\n\n        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);\n        uint256 swapperRate = swapper.getRate(underlying, actionToken);\n        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));\n    }\n\n    function getSwapper(\n        IAddressProvider addressProvider,\n        address underlying,\n        address actionToken\n    ) public view returns (ISwapper) {\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);\n        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);\n        return ISwapper(swapper);\n    }\n}\n\ncontract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {\n    using ScaledMath for uint256;\n    using ScaledMath for uint128;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using AddressProviderHelpers for IAddressProvider;\n\n    /\n     * @dev Temporary struct to hold local variables in execute\n     * and avoid the stack being ""too deep""\n     /\n    struct ExecuteLocalVars {\n        uint256 minActionAmountToTopUp;\n        uint256 actionTokenAmount;\n        uint256 depositTotalFeesAmount;\n        uint256 actionAmountWithFees;\n        uint256 userFactor;\n        uint256 rate;\n        uint256 depositAmountWithFees;\n        uint256 depositAmountWithoutFees;\n        uint256 actionFee;\n        uint256 totalActionTokenAmount;\n        uint128 totalTopUpAmount;\n        bool success;\n        bytes topupResult;\n        uint256 gasBankBalance;\n        uint256 initialGas;\n        uint256 gasConsumed;\n        uint256 userGasPrice;\n        uint256 estimatedRequiredGas;\n        uint256 estimatedRequiredWeiForGas;\n        uint256 requiredWeiForGas;\n        uint256 reimbursedWeiForGas;\n        address underlying;\n        bool removePosition;\n    }\n\n    EnumerableSet.AddressSet private _usableTokens;\n\n    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;\n\n    bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee"";\n    bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler"";\n    bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler"";\n    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage"";\n    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";\n\n    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;\n    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;\n    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    EnumerableSet.Bytes32Set internal _supportedProtocols;\n\n    /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record)\n    mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;\n\n    mapping(address =&gt; RecordMeta[]) internal _userPositions;\n\n    EnumerableSet.AddressSet internal _usersWithPositions;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        addressProvider = controller.addressProvider();\n        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);\n    }\n\n    receive() external payable {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function initialize(\n        address feeHandler,\n        bytes32[] calldata protocols,\n        address[] calldata handlers\n    ) external initializer onlyGovernance {\n        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);\n        _setConfig(_FEE_HANDLER_KEY, feeHandler);\n        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);\n        for (uint256 i = 0; i &lt; protocols.length; i++) {\n            bytes32 protocolKey = _getProtocolKey(protocols[i]);\n            _setConfig(protocolKey, handlers[i]);\n            _updateTopUpHandler(protocols[i], address(0), handlers[i]);\n        }\n    }\n\n    /\n     * @notice Register a top up action.\n     * @dev The depositAmount must be greater or equal to the totalTopUpAmount (which is denominated in actionToken).\n     * @param account Account to be topped up (first 20 bytes will typically be the address).\n     * @param depositAmount Amount of depositToken that will be locked.\n     * @param protocol Protocol which holds position to be topped up.\n     * @param record containing the data for the position to register\n     /\n    function register(\n        bytes32 account,\n        bytes32 protocol,\n        uint128 depositAmount,\n        Record memory record\n    ) external payable returns (bool) {\n        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);\n        require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);\n        require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);\n        require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);\n        require(\n            _positions[msg.sender][account][protocol].threshold == 0,\n            Error.POSITION_ALREADY_EXISTS\n        );\n        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);\n        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);\n\n        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) \n            record.maxFee *\n            getEstimatedGasUsage();\n\n        require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);\n\n        uint256 totalLockAmount = _calcExchangeAmount(\n            record.depositToken,\n            record.actionToken,\n            record.totalTopUpAmount\n        );\n        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);\n\n        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);\n\n        record.depositTokenBalance = uint128(totalLockAmount);\n        _positions[msg.sender][account][protocol] = record;\n        _userPositions[msg.sender].push(RecordMeta(account, protocol));\n        _usersWithPositions.add(msg.sender);\n\n        emit Register(\n            account,\n            protocol,\n            record.threshold,\n            msg.sender,\n            record.depositToken,\n            totalLockAmount,\n            record.actionToken,\n            record.singleTopUpAmount,\n            record.totalTopUpAmount,\n            record.maxFee,\n            record.extra\n        );\n        return true;\n    }\n\n    /\n     * @notice See overloaded version of execute for more details.\n     /\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol\n    ) external override returns (bool) {\n        return execute(payer, account, beneficiary, protocol, 0);\n    }\n\n    /\n     * @notice Delete a position to back on the given protocol for account.\n     * @param account Account holding the position.\n     * @param protocol Protocol the position is held on.\n     * @param unstake If the tokens should be unstaked from vault.\n     * @return true if successful.\n     /\n    function resetPosition(\n        bytes32 account,\n        bytes32 protocol,\n        bool unstake\n    ) external override returns (bool) {\n        address payer = msg.sender;\n        Record memory position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n\n        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist\n        IStakerVault staker = IStakerVault(vault);\n        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);\n        if (unstake) {\n            staker.unstake(position.depositTokenBalance);\n            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);\n        } else {\n            staker.transfer(payer, position.depositTokenBalance);\n        }\n\n        _removePosition(payer, account, protocol);\n        addressProvider.getGasBank().withdrawUnused(payer);\n        return true;\n    }\n\n    /\n     * @notice Execute top up handler update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @param protocol Protocol for which a new handler should be executed.\n     * @return Address of new handler.\n     */\n    function executeTopUpHandler(bytes32 protocol) external override returns (address) {\n        address oldHandler = _getHandler(protocol, false);\n        address newHandler = _executeAddress(_getProtocolKey(protocol));\n\n        _updateTopUpHandler(protocol, oldHandler, newHandler);\n        return newHandler;\n    }\n\n    /\n     * @notice Reset new top up handler deadline for a protocol.\n     * @param protocol Protocol for which top up handler deadline should be reset.\n     * @return true if successful.\n     /\n    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_getProtocolKey(protocol));\n    }\n\n    /\n     * @notice Prepare action fee update.\n     * @param newActionFee New fee to set.\n     * @return true if success.\n     /\n    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {\n        require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);\n        return _prepare(_ACTION_FEE_KEY, newActionFee);\n    }\n\n    /\n     * @notice Execute action fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeActionFee() external override returns (uint256) {\n        return _executeUInt256(_ACTION_FEE_KEY);\n    }\n\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     /\n    function resetActionFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ACTION_FEE_KEY);\n    }\n\n    /\n     * @notice Prepare swapper slippage update.\n     * @param newSwapperSlippage New slippage to set.\n     * @return true if success.\n     /\n    function prepareSwapperSlippage(uint256 newSwapperSlippage)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        require(\n            newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;\n                newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,\n            Error.INVALID_AMOUNT\n        );\n        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);\n    }\n\n    /\n     * @notice Execute swapper slippage update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeSwapperSlippage() external override returns (uint256) {\n        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     /\n    function resetSwapperSlippage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    / Set fee handler /\n    /\n     * @notice Prepare update of fee handler.\n     * @param handler New fee handler.\n     * @return true if success.\n     */\n    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {\n        return _prepare(_FEE_HANDLER_KEY, handler);\n    }\n\n    /\n     * @notice Execute update of fee handler (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return true if successful.\n     /\n    function executeFeeHandler() external override returns (address) {\n        return _executeAddress(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Reset the handler deadline.\n     * @return true if success.\n     /\n    function resetFeeHandler() external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Prepare update of estimated gas usage.\n     * @param gasUsage New estimated gas usage.\n     * @return true if success.\n     */\n    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {\n        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);\n    }\n\n    /\n     * @notice Execute update of gas usage (with time delay enforced).\n     * @return true if successful.\n     /\n    function executeEstimatedGasUsage() external returns (uint256) {\n        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Reset the gas usage deadline.\n     * @return true if success.\n     /\n    function resetGasUsage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Add a new deposit token that is supported by the action.\n     * @dev There is a separate check for whether the usable token (i.e. deposit token)\n     *      is swappable for some action token.\n     * @param token Address of deposit token that can be used by the action.\n     */\n    function addUsableToken(address token) external override onlyGovernance returns (bool) {\n        return _usableTokens.add(token);\n    }\n\n    /\n     * @notice Computes the total amount of ETH (as wei) required to pay for all\n     * the top-ups assuming the maximum gas price and the current estimated gas\n     * usage of a top-up\n     /\n    function getEthRequiredForGas(address payer) external view override returns (uint256) {\n        uint256 totalEthRequired = 0;\n        RecordMeta[] memory userRecordsMeta = _userPositions[payer];\n        uint256 gasUsagePerCall = getEstimatedGasUsage();\n        uint256 length = userRecordsMeta.length;\n        for (uint256 i = 0; i &lt; length; i++) {\n            RecordMeta memory meta = userRecordsMeta[i];\n            Record memory record = _positions[payer][meta.account][meta.protocol];\n            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);\n            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;\n        }\n        return totalEthRequired;\n    }\n\n    /\n     * @notice Returns a list of positions for the given payer\n     /\n    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {\n        return _userPositions[payer];\n    }\n\n    /\n     * @notice Get a list supported protocols.\n     * @return List of supported protocols.\n     /\n    function getSupportedProtocols() external view override returns (bytes32[] memory) {\n        uint256 length = _supportedProtocols.length();\n        bytes32[] memory protocols = new bytes32;\n        for (uint256 i = 0; i &lt; length; i++) {\n            protocols[i] = _supportedProtocols.at(i);\n        }\n        return protocols;\n    }\n\n    /\n     * @notice Gets a list of users that have an active position.\n     * @dev Uses cursor pagination.\n     * @param cursor The cursor for pagination (should start at 0 for first call).\n     * @param howMany Maximum number of users to return in this pagination request.\n     * @return users List of users that have an active position.\n     * @return nextCursor The cursor to use for the next pagination request.\n     */\n    function usersWithPositions(uint256 cursor, uint256 howMany)\n        external\n        view\n        override\n        returns (address[] memory users, uint256 nextCursor)\n    {\n        uint256 length = usersWithPositions.length();\n        if (cursor &gt;= length) return (new address, 0);\n        if (howMany &gt;= length - cursor) {\n            howMany = length - cursor;\n        }\n\n        address[] memory usersWithPositions = new address;\n        for (uint256 i = 0; i &lt; howMany; i++) {\n            usersWithPositions_[i] = usersWithPositions.at(i + cursor);\n        }\n\n        return (usersWithPositions, cursor + howMany);\n    }\n\n    /\n     * @notice Get a list of all tokens usable for this action.\n     * @dev This refers to all tokens that can be used as deposit tokens.\n     * @return Array of addresses of usable tokens.\n     /\n    function getUsableTokens() external view override returns (address[] memory) {\n        return _usableTokens.toArray();\n    }\n\n    /\n     * @notice Retrieves the topup handler for the given protocol\n     /\n    function getTopUpHandler(bytes32 protocol) external view returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice Successfully tops up a position if it\'s conditions are met.\n     * @dev pool and vault funds are rebalanced after withdrawal for top up\n     * @param payer Account that pays for the top up.\n     * @param account Account owning the position for top up.\n     * @param beneficiary Address of the keeper\'s wallet for fee accrual.\n     * @param protocol Protocol of the top up position.\n     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas\n     * @return true if successful.\n     */\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol,\n        uint256 maxWeiForGas\n    ) public override returns (bool) {\n        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);\n\n        ExecuteLocalVars memory vars;\n\n        vars.initialGas = gasleft();\n\n        Record storage position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n        require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);\n\n        address topUpHandler = _getHandler(protocol, true);\n        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);\n\n        // ensure that the position is actually below its set user factor threshold\n        require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);\n\n        IGasBank gasBank = addressProvider.getGasBank();\n\n        // fail early if the user does not have enough funds in the gas bank\n        // to cover the cost of the transaction\n        vars.estimatedRequiredGas = getEstimatedGasUsage();\n        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;\n\n        // compute the gas price that the user will be paying\n        vars.userGasPrice = block.basefee + position.priorityFee;\n        if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;\n        if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;\n\n        // ensure the current position allows for the gas to be paid\n        require(\n            vars.estimatedRequiredWeiForGas &lt;=\n                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,\n            Error.ESTIMATED_GAS_TOO_HIGH\n        );\n\n        vars.gasBankBalance = gasBank.balanceOf(payer);\n        // ensure the user has enough funds in the gas bank to cover the gas\n        require(\n            vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,\n            Error.GAS_BANK_BALANCE_TOO_LOW\n        );\n\n        vars.totalTopUpAmount = position.totalTopUpAmount;\n        vars.actionFee = getActionFee();\n        // add top-up fees to top-up amount\n        vars.minActionAmountToTopUp = position.singleTopUpAmount;\n        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(\n            ScaledMath.ONE + vars.actionFee\n        );\n\n        // if the amount that we want to top-up (including fees) is higher than\n        // the available topup amount, we lower this down to what is left of the position\n        if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {\n            vars.actionAmountWithFees = vars.totalTopUpAmount;\n            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(\n                ScaledMath.ONE + vars.actionFee\n            );\n        }\n        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);\n        vars.underlying = pool.getUnderlying();\n        vars.rate = pool.exchangeRate();\n\n        ISwapper swapper;\n\n        if (vars.underlying != position.actionToken) {\n            swapper = _getSwapper(vars.underlying, position.actionToken);\n            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));\n        }\n\n        // compute the deposit tokens amount with and without fees\n        // we will need to unstake the amount with fees and to\n        // swap the amount without fees into action tokens\n        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);\n        if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {\n            vars.depositAmountWithFees = position.depositTokenBalance;\n            vars.minActionAmountToTopUp =\n                (vars.depositAmountWithFees * vars.rate) /\n                (ScaledMath.ONE + vars.actionFee);\n        }\n\n        // compute amount of LP tokens needed to pay for action\n        // rate is expressed in actionToken per depositToken\n        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);\n        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;\n\n        // will revert if vault does not exist\n        address vault = addressProvider.getStakerVault(position.depositToken);\n\n        // unstake deposit tokens including fees\n        IStakerVault(vault).unstake(vars.depositAmountWithFees);\n        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);\n\n        // swap the amount without the fees\n        // as the fees are paid in deposit token, not in action token\n        // Redeem first and use swapper only if the underlying tokens are not action tokens\n        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);\n\n        if (address(swapper) != address(0)) {\n            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(\n                getSwapperSlippage()\n            );\n            _approve(vars.underlying, address(swapper));\n            vars.actionTokenAmount = swapper.swap(\n                vars.underlying,\n                position.actionToken,\n                vars.actionTokenAmount,\n                vars.minActionAmountToTopUp\n            );\n        }\n\n        // compute how much of action token was actually redeemed and add fees to it\n        // this is to ensure that no funds get locked inside the contract\n        vars.totalActionTokenAmount =\n            vars.actionTokenAmount +\n            vars.depositTotalFeesAmount.scaledMul(vars.rate);\n\n        // at this point, we have exactly vars.actionTokenAmount\n        // (at least position.singleTopUpAmount) of action token\n        // and exactly vars.depositTotalFeesAmount deposit tokens in the contract\n        // solhint-disable-next-line avoid-low-level-calls\n        (vars.success, vars.topupResult) = topUpHandler.delegatecall(\n            abi.encodeWithSignature(\n                ""topUp(bytes32,address,uint256,bytes)"",\n                account,\n                position.actionToken,\n                vars.actionTokenAmount,\n                position.extra\n            )\n        );\n\n        require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);\n\n        // totalTopUpAmount is updated to reflect the new ""balance"" of the position\n        if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {\n            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);\n        } else {\n            position.totalTopUpAmount = 0;\n        }\n\n        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);\n\n        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;\n        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);\n        if (vars.removePosition) {\n            if (position.depositTokenBalance &gt; 0) {\n                // transfer any unused locked tokens to the payer\n                IStakerVault(vault).transfer(payer, position.depositTokenBalance);\n                IStakerVault(vault).decreaseActionLockedBalance(\n                    payer,\n                    position.depositTokenBalance\n                );\n            }\n            _removePosition(payer, account, protocol);\n        }\n\n        emit TopUp(\n            account,\n            protocol,\n            payer,\n            position.depositToken,\n            vars.depositAmountWithFees,\n            position.actionToken,\n            vars.actionTokenAmount\n        );\n\n        // compute gas used and reimburse the keeper by using the\n        // funds of payer in the gas bank\n        // TODO: add constant gas consumed for transfer and tx prologue\n        vars.gasConsumed = vars.initialGas - gasleft();\n\n        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;\n        if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {\n            vars.reimbursedWeiForGas = vars.gasBankBalance;\n        }\n\n        // ensure that the keeper is not overpaying\n        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;\n        require(\n            vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,\n            Error.GAS_TOO_HIGH\n        );\n        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);\n        if (vars.removePosition) {\n            gasBank.withdrawUnused(payer);\n        }\n\n        return true;\n    }\n\n    /\n     * @notice Prepare new top up handler fee update.\n     * @dev Setting the addres to 0 means that the protocol will no longer be supported.\n     * @param protocol Protocol for which a new handler should be prepared.\n     * @param newHandler Address of new handler.\n     * @return true if success.\n     /\n    function prepareTopUpHandler(bytes32 protocol, address newHandler)\n        public\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_getProtocolKey(protocol), newHandler);\n    }\n\n    /\n     * @notice Check if action can be executed.\n     * @param protocol for which to get the health factor\n     * @param account for which to get the health factor\n     * @param extra data to be used by the topup handler\n     * @return healthFactor of the position\n     /\n    function getHealthFactor(\n        bytes32 protocol,\n        bytes32 account,\n        bytes memory extra\n    ) public view override returns (uint256 healthFactor) {\n        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));\n        return topUpHandler.getUserFactor(account, extra);\n    }\n\n    function getHandler(bytes32 protocol) public view override returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice returns the current estimated gas usage\n     */\n    function getEstimatedGasUsage() public view returns (uint256) {\n        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];\n    }\n\n    /\n     * @notice Returns the current action fee\n     /\n    function getActionFee() public view override returns (uint256) {\n        return currentUInts256[_ACTION_FEE_KEY];\n    }\n\n    /\n     * @notice Returns the current max swapper slippage\n     /\n    function getSwapperSlippage() public view override returns (uint256) {\n        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];\n    }\n\n    /\n     * @notice Returns the current fee handler\n     */\n    function getFeeHandler() public view override returns (address) {\n        return currentAddresses[_FEE_HANDLER_KEY];\n    }\n\n    /\n     * @notice Get the record for a position.\n     * @param payer Registered payer of the position.\n     * @param account Address holding the position.\n     * @param protocol Protocol where the position is held.\n     /\n    function getPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) public view override returns (Record memory) {\n        return _positions[payer][account][protocol];\n    }\n\n    /\n     * @notice Check whether a token is usable as a deposit token.\n     * @param token Address of token to check.\n     * @return True if token is usable as a deposit token for this action.\n     /\n    function isUsable(address token) public view override returns (bool) {\n        return _usableTokens.contains(token);\n    }\n\n    function _updateTopUpHandler(\n        bytes32 protocol,\n        address oldHandler,\n        address newHandler\n    ) internal {\n        if (newHandler == address(0)) {\n            _supportedProtocols.remove(protocol);\n        } else if (oldHandler == address(0)) {\n            _supportedProtocols.add(protocol);\n        }\n    }\n\n    /\n     * @dev Pays fees to the feeHandler\n     * @param payer The account who\'s position the fees are charged on\n     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)\n     * @param feeAmount The amount in tokens to pay as fees\n     * @param depositToken The LpToken used to pay the fees\n     */\n    function _payFees(\n        address payer,\n        address beneficiary,\n        uint256 feeAmount,\n        address depositToken\n    ) internal {\n        address feeHandler = getFeeHandler();\n        IERC20(depositToken).safeApprove(feeHandler, feeAmount);\n        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);\n    }\n\n    /\n     * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction\n     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.\n     * @param payer Owner of the funds to be locked\n     * @param token Token to lock\n     * @param lockAmount Minimum amount of token to lock\n     * @param depositAmount Amount of token that was deposited.\n     *                      If this is 0 then the staker vault allowance should be used.\n     *                      If this is greater than requiredAmount more tokens will be locked.\n     /\n    function _lockFunds(\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) internal {\n        address stakerVaultAddress = addressProvider.getStakerVault(token);\n        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);\n    }\n\n    function _removePosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        delete _positions[payer][account][protocol];\n        _removeUserPosition(payer, account, protocol);\n        if (_userPositions[payer].length == 0) {\n            _usersWithPositions.remove(payer);\n        }\n        emit Deregister(payer, account, protocol);\n    }\n\n    function _removeUserPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        RecordMeta[] storage positionsMeta = _userPositions[payer];\n        uint256 length = positionsMeta.length;\n        for (uint256 i = 0; i &lt; length; i++) {\n            RecordMeta storage positionMeta = positionsMeta[i];\n            if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {\n                positionsMeta[i] = positionsMeta[length - 1];\n                positionsMeta.pop();\n                return;\n            }\n        }\n    }\n\n    /\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     /\n    function _approve(address token, address spender) internal {\n        if (IERC20(token).allowance(address(this), spender) &gt; 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /*\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     /\n    function _calcExchangeAmount(\n        address token,\n        address actionToken,\n        uint256 amount\n    ) internal view returns (uint256) {\n        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);\n    }\n\n    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {\n        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);\n    }\n\n    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {\n        address handler = currentAddresses[_getProtocolKey(protocol)];\n        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);\n        return handler;\n    }\n\n    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);\n        address underlying = pool.getUnderlying();\n        if (underlying == toToken) {\n            return true;\n        }\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);\n    }\n\n    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));\n    }\n}\n', 'ideas': "" Unnecessary Comparison Identified.\n\nUNNECESSARY COMPARISON\n'''\nIn the execute function, there are instances where boolean values are compared explicitly to true or false. For example, the line:\nsolidity\nrequire(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);\n\ncould be simplified by directly using the boolean expression without the explicit comparison. This enhances readability and reduces the risk of logical errors. \n\nRecommended mitigation is to directly use the boolean expression in the require statement without unnecessary comparisons,""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-15-08 09:56:02 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol""; import ""../../../interfaces/IGasBank.sol""; import ""../../../interfaces/pool/ILiquidityPool.sol""; import ""../../../interfaces/ISwapperRegistry.sol""; import ""../../../interfaces/IController.sol""; import ""../../../interfaces/IStakerVault.sol""; import ""../../../interfaces/ISwapper.sol""; import ""../../../interfaces/actions/topup/ITopUpHandler.sol""; import ""../../../interfaces/actions/topup/ITopUpAction.sol""; import ""../../../interfaces/actions/IActionFeeHandler.sol""; import ""../../../libraries/AddressProviderHelpers.sol""; import ""../../../libraries/Errors.sol""; import ""../../../libraries/ScaledMath.sol""; import ""../../../libraries/EnumerableExtensions.sol""; import ""../../access/Authorization.sol""; import ""../../utils/Preparable.sol""; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being ""too deep""  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee""; bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler""; bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler""; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage""; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             ""topUp(bytes32,address,uint256,bytes)"",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new ""balance"" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-15-08 09:56:02 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";

import ""../../../interfaces/IGasBank.sol"";
import ""../../../interfaces/pool/ILiquidityPool.sol"";
import ""../../../interfaces/ISwapperRegistry.sol"";
import ""../../../interfaces/IController.sol"";
import ""../../../interfaces/IStakerVault.sol"";
import ""../../../interfaces/ISwapper.sol"";
import ""../../../interfaces/actions/topup/ITopUpHandler.sol"";
import ""../../../interfaces/actions/topup/ITopUpAction.sol"";
import ""../../../interfaces/actions/IActionFeeHandler.sol"";

import ""../../../libraries/AddressProviderHelpers.sol"";
import ""../../../libraries/Errors.sol"";
import ""../../../libraries/ScaledMath.sol"";
import ""../../../libraries/EnumerableExtensions.sol"";

import ""../../access/Authorization.sol"";
import ""../../utils/Preparable.sol"";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being ""too deep""
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee"";
    bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler"";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler"";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage"";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                ""topUp(bytes32,address,uint256,bytes)"",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new ""balance"" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";

import ""../../../interfaces/IGasBank.sol"";
import ""../../../interfaces/pool/ILiquidityPool.sol"";
import ""../../../interfaces/ISwapperRegistry.sol"";
import ""../../../interfaces/IController.sol"";
import ""../../../interfaces/IStakerVault.sol"";
import ""../../../interfaces/ISwapper.sol"";
import ""../../../interfaces/actions/topup/ITopUpHandler.sol"";
import ""../../../interfaces/actions/topup/ITopUpAction.sol"";
import ""../../../interfaces/actions/IActionFeeHandler.sol"";

import ""../../../libraries/AddressProviderHelpers.sol"";
import ""../../../libraries/Errors.sol"";
import ""../../../libraries/ScaledMath.sol"";
import ""../../../libraries/EnumerableExtensions.sol"";

import ""../../access/Authorization.sol"";
import ""../../utils/Preparable.sol"";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being ""too deep""
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee"";
    bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler"";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler"";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage"";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                ""topUp(bytes32,address,uint256,bytes)"",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new ""balance"" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
"".
Ideas: "" Unnecessary Comparison Identified.

UNNECESSARY COMPARISON
'''
In the `execute` function, there are instances where boolean values are compared explicitly to `true` or `false`. For example, the line:
```solidity
require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);
```
could be simplified by directly using the boolean expression without the explicit comparison. This enhances readability and reduces the risk of logical errors. 

Recommended mitigation is to directly use the boolean expression in the require statement without unnecessary comparisons,"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Inconsistent Initialization. This type of vulnerability arises when state variables are initialized using a function that relies on the state of other variables, which may not yet be set or initialized, leading to unpredictable or unintended behavior.
There are two cases where the code may have Inconsistent Initialization vulnerabilities:
1. Initialization of a state variable using a function call where the function's logic depends on the state of other variables that are not yet initialized. This can lead to incorrect values being set for the variable.
2. Initialization order of state variables where the value of one variable depends on the value of another variable that has not been initialized yet.
If you identify Inconsistent Initialization, respond with: """,,"<INFO> Potential Inconsistency in Yield Source Swapping Identified.

POTENTIAL INCONSISTENCY IN YIELD SOURCE SWAPPING
'''
The contract allows for the swapping of yield sources through the `getSwapper`

[2024-15-08 09:56:08 INFO] **[Execute Detail]**

execute SimplePhase:[SignatureVerificationDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-15-08 09:56:08 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol""; import ""../../../interfaces/IGasBank.sol""; import ""../../../interfaces/pool/ILiquidityPool.sol""; import ""../../../interfaces/ISwapperRegistry.sol""; import ""../../../interfaces/IController.sol""; import ""../../../interfaces/IStakerVault.sol""; import ""../../../interfaces/ISwapper.sol""; import ""../../../interfaces/actions/topup/ITopUpHandler.sol""; import ""../../../interfaces/actions/topup/ITopUpAction.sol""; import ""../../../interfaces/actions/IActionFeeHandler.sol""; import ""../../../libraries/AddressProviderHelpers.sol""; import ""../../../libraries/Errors.sol""; import ""../../../libraries/ScaledMath.sol""; import ""../../../libraries/EnumerableExtensions.sol""; import ""../../access/Authorization.sol""; import ""../../utils/Preparable.sol""; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being ""too deep""  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee""; bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler""; bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler""; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage""; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             ""topUp(bytes32,address,uint256,bytes)"",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new ""balance"" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Incorrect Signature Verification. This type of vulnerability arises when the contract verifies the signer in an insecure or incorrect manner, which can lead to unauthorized transactions and potential security breaches. There is one primary case where the code may have Incorrect Signature Verification vulnerabilities: 1. A function that uses the signature to recover the signer and then verifies that the signer is the msg.sender. This allows any caller to execute transactions using their own signature, leading to unauthorized actions. If you identify Incorrect Signer Verification, respond with: "" Incorrect Signer Verification Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If you don't find any vulnerabilities, respond only with: "" NO Incorrect Signer Verification."" |
| **phase_name** | SignatureVerificationDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";\nimport ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";\n\nimport ""../../../interfaces/IGasBank.sol"";\nimport ""../../../interfaces/pool/ILiquidityPool.sol"";\nimport ""../../../interfaces/ISwapperRegistry.sol"";\nimport ""../../../interfaces/IController.sol"";\nimport ""../../../interfaces/IStakerVault.sol"";\nimport ""../../../interfaces/ISwapper.sol"";\nimport ""../../../interfaces/actions/topup/ITopUpHandler.sol"";\nimport ""../../../interfaces/actions/topup/ITopUpAction.sol"";\nimport ""../../../interfaces/actions/IActionFeeHandler.sol"";\n\nimport ""../../../libraries/AddressProviderHelpers.sol"";\nimport ""../../../libraries/Errors.sol"";\nimport ""../../../libraries/ScaledMath.sol"";\nimport ""../../../libraries/EnumerableExtensions.sol"";\n\nimport ""../../access/Authorization.sol"";\nimport ""../../utils/Preparable.sol"";\n\n/\n * @notice The logic here should really be part of the top-up action\n * but is split in a library to circumvent the byte-code size limit\n */\nlibrary TopUpActionLibrary {\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    function lockFunds(\n        address stakerVaultAddress,\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) external {\n        uint256 amountLeft = lockAmount;\n        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);\n\n        // stake deposit amount\n        if (depositAmount &gt; 0) {\n            depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;\n            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);\n            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);\n            stakerVault.stake(depositAmount);\n            stakerVault.increaseActionLockedBalance(payer, depositAmount);\n            amountLeft -= depositAmount;\n        }\n\n        // use stake vault allowance if available and required\n        if (amountLeft &gt; 0) {\n            uint256 balance = stakerVault.balanceOf(payer);\n            uint256 allowance = stakerVault.allowance(payer, address(this));\n            uint256 availableFunds = balance &lt; allowance ? balance : allowance;\n            if (availableFunds &gt;= amountLeft) {\n                stakerVault.transferFrom(payer, address(this), amountLeft);\n                amountLeft = 0;\n            }\n        }\n\n        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);\n    }\n\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     /\n    function calcExchangeAmount(\n        IAddressProvider addressProvider,\n        address token,\n        address actionToken,\n        uint256 amount\n    ) external view returns (uint256) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        uint256 rate = pool.exchangeRate();\n        address underlying = pool.getUnderlying();\n        if (underlying == actionToken) {\n            return amount.scaledDivRoundUp(rate);\n        }\n\n        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);\n        uint256 swapperRate = swapper.getRate(underlying, actionToken);\n        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));\n    }\n\n    function getSwapper(\n        IAddressProvider addressProvider,\n        address underlying,\n        address actionToken\n    ) public view returns (ISwapper) {\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);\n        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);\n        return ISwapper(swapper);\n    }\n}\n\ncontract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {\n    using ScaledMath for uint256;\n    using ScaledMath for uint128;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using AddressProviderHelpers for IAddressProvider;\n\n    /\n     * @dev Temporary struct to hold local variables in execute\n     * and avoid the stack being ""too deep""\n     /\n    struct ExecuteLocalVars {\n        uint256 minActionAmountToTopUp;\n        uint256 actionTokenAmount;\n        uint256 depositTotalFeesAmount;\n        uint256 actionAmountWithFees;\n        uint256 userFactor;\n        uint256 rate;\n        uint256 depositAmountWithFees;\n        uint256 depositAmountWithoutFees;\n        uint256 actionFee;\n        uint256 totalActionTokenAmount;\n        uint128 totalTopUpAmount;\n        bool success;\n        bytes topupResult;\n        uint256 gasBankBalance;\n        uint256 initialGas;\n        uint256 gasConsumed;\n        uint256 userGasPrice;\n        uint256 estimatedRequiredGas;\n        uint256 estimatedRequiredWeiForGas;\n        uint256 requiredWeiForGas;\n        uint256 reimbursedWeiForGas;\n        address underlying;\n        bool removePosition;\n    }\n\n    EnumerableSet.AddressSet private _usableTokens;\n\n    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;\n\n    bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee"";\n    bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler"";\n    bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler"";\n    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage"";\n    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";\n\n    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;\n    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;\n    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    EnumerableSet.Bytes32Set internal _supportedProtocols;\n\n    /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record)\n    mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;\n\n    mapping(address =&gt; RecordMeta[]) internal _userPositions;\n\n    EnumerableSet.AddressSet internal _usersWithPositions;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        addressProvider = controller.addressProvider();\n        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);\n    }\n\n    receive() external payable {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function initialize(\n        address feeHandler,\n        bytes32[] calldata protocols,\n        address[] calldata handlers\n    ) external initializer onlyGovernance {\n        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);\n        _setConfig(_FEE_HANDLER_KEY, feeHandler);\n        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);\n        for (uint256 i = 0; i &lt; protocols.length; i++) {\n            bytes32 protocolKey = _getProtocolKey(protocols[i]);\n            _setConfig(protocolKey, handlers[i]);\n            _updateTopUpHandler(protocols[i], address(0), handlers[i]);\n        }\n    }\n\n    /\n     * @notice Register a top up action.\n     * @dev The depositAmount must be greater or equal to the totalTopUpAmount (which is denominated in actionToken).\n     * @param account Account to be topped up (first 20 bytes will typically be the address).\n     * @param depositAmount Amount of depositToken that will be locked.\n     * @param protocol Protocol which holds position to be topped up.\n     * @param record containing the data for the position to register\n     /\n    function register(\n        bytes32 account,\n        bytes32 protocol,\n        uint128 depositAmount,\n        Record memory record\n    ) external payable returns (bool) {\n        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);\n        require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);\n        require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);\n        require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);\n        require(\n            _positions[msg.sender][account][protocol].threshold == 0,\n            Error.POSITION_ALREADY_EXISTS\n        );\n        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);\n        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);\n\n        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) \n            record.maxFee *\n            getEstimatedGasUsage();\n\n        require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);\n\n        uint256 totalLockAmount = _calcExchangeAmount(\n            record.depositToken,\n            record.actionToken,\n            record.totalTopUpAmount\n        );\n        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);\n\n        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);\n\n        record.depositTokenBalance = uint128(totalLockAmount);\n        _positions[msg.sender][account][protocol] = record;\n        _userPositions[msg.sender].push(RecordMeta(account, protocol));\n        _usersWithPositions.add(msg.sender);\n\n        emit Register(\n            account,\n            protocol,\n            record.threshold,\n            msg.sender,\n            record.depositToken,\n            totalLockAmount,\n            record.actionToken,\n            record.singleTopUpAmount,\n            record.totalTopUpAmount,\n            record.maxFee,\n            record.extra\n        );\n        return true;\n    }\n\n    /\n     * @notice See overloaded version of execute for more details.\n     /\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol\n    ) external override returns (bool) {\n        return execute(payer, account, beneficiary, protocol, 0);\n    }\n\n    /\n     * @notice Delete a position to back on the given protocol for account.\n     * @param account Account holding the position.\n     * @param protocol Protocol the position is held on.\n     * @param unstake If the tokens should be unstaked from vault.\n     * @return true if successful.\n     /\n    function resetPosition(\n        bytes32 account,\n        bytes32 protocol,\n        bool unstake\n    ) external override returns (bool) {\n        address payer = msg.sender;\n        Record memory position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n\n        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist\n        IStakerVault staker = IStakerVault(vault);\n        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);\n        if (unstake) {\n            staker.unstake(position.depositTokenBalance);\n            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);\n        } else {\n            staker.transfer(payer, position.depositTokenBalance);\n        }\n\n        _removePosition(payer, account, protocol);\n        addressProvider.getGasBank().withdrawUnused(payer);\n        return true;\n    }\n\n    /\n     * @notice Execute top up handler update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @param protocol Protocol for which a new handler should be executed.\n     * @return Address of new handler.\n     */\n    function executeTopUpHandler(bytes32 protocol) external override returns (address) {\n        address oldHandler = _getHandler(protocol, false);\n        address newHandler = _executeAddress(_getProtocolKey(protocol));\n\n        _updateTopUpHandler(protocol, oldHandler, newHandler);\n        return newHandler;\n    }\n\n    /\n     * @notice Reset new top up handler deadline for a protocol.\n     * @param protocol Protocol for which top up handler deadline should be reset.\n     * @return true if successful.\n     /\n    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_getProtocolKey(protocol));\n    }\n\n    /\n     * @notice Prepare action fee update.\n     * @param newActionFee New fee to set.\n     * @return true if success.\n     /\n    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {\n        require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);\n        return _prepare(_ACTION_FEE_KEY, newActionFee);\n    }\n\n    /\n     * @notice Execute action fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeActionFee() external override returns (uint256) {\n        return _executeUInt256(_ACTION_FEE_KEY);\n    }\n\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     /\n    function resetActionFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ACTION_FEE_KEY);\n    }\n\n    /\n     * @notice Prepare swapper slippage update.\n     * @param newSwapperSlippage New slippage to set.\n     * @return true if success.\n     /\n    function prepareSwapperSlippage(uint256 newSwapperSlippage)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        require(\n            newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;\n                newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,\n            Error.INVALID_AMOUNT\n        );\n        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);\n    }\n\n    /\n     * @notice Execute swapper slippage update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeSwapperSlippage() external override returns (uint256) {\n        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     /\n    function resetSwapperSlippage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    / Set fee handler /\n    /\n     * @notice Prepare update of fee handler.\n     * @param handler New fee handler.\n     * @return true if success.\n     */\n    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {\n        return _prepare(_FEE_HANDLER_KEY, handler);\n    }\n\n    /\n     * @notice Execute update of fee handler (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return true if successful.\n     /\n    function executeFeeHandler() external override returns (address) {\n        return _executeAddress(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Reset the handler deadline.\n     * @return true if success.\n     /\n    function resetFeeHandler() external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Prepare update of estimated gas usage.\n     * @param gasUsage New estimated gas usage.\n     * @return true if success.\n     */\n    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {\n        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);\n    }\n\n    /\n     * @notice Execute update of gas usage (with time delay enforced).\n     * @return true if successful.\n     /\n    function executeEstimatedGasUsage() external returns (uint256) {\n        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Reset the gas usage deadline.\n     * @return true if success.\n     /\n    function resetGasUsage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Add a new deposit token that is supported by the action.\n     * @dev There is a separate check for whether the usable token (i.e. deposit token)\n     *      is swappable for some action token.\n     * @param token Address of deposit token that can be used by the action.\n     */\n    function addUsableToken(address token) external override onlyGovernance returns (bool) {\n        return _usableTokens.add(token);\n    }\n\n    /\n     * @notice Computes the total amount of ETH (as wei) required to pay for all\n     * the top-ups assuming the maximum gas price and the current estimated gas\n     * usage of a top-up\n     /\n    function getEthRequiredForGas(address payer) external view override returns (uint256) {\n        uint256 totalEthRequired = 0;\n        RecordMeta[] memory userRecordsMeta = _userPositions[payer];\n        uint256 gasUsagePerCall = getEstimatedGasUsage();\n        uint256 length = userRecordsMeta.length;\n        for (uint256 i = 0; i &lt; length; i++) {\n            RecordMeta memory meta = userRecordsMeta[i];\n            Record memory record = _positions[payer][meta.account][meta.protocol];\n            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);\n            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;\n        }\n        return totalEthRequired;\n    }\n\n    /\n     * @notice Returns a list of positions for the given payer\n     /\n    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {\n        return _userPositions[payer];\n    }\n\n    /\n     * @notice Get a list supported protocols.\n     * @return List of supported protocols.\n     /\n    function getSupportedProtocols() external view override returns (bytes32[] memory) {\n        uint256 length = _supportedProtocols.length();\n        bytes32[] memory protocols = new bytes32;\n        for (uint256 i = 0; i &lt; length; i++) {\n            protocols[i] = _supportedProtocols.at(i);\n        }\n        return protocols;\n    }\n\n    /\n     * @notice Gets a list of users that have an active position.\n     * @dev Uses cursor pagination.\n     * @param cursor The cursor for pagination (should start at 0 for first call).\n     * @param howMany Maximum number of users to return in this pagination request.\n     * @return users List of users that have an active position.\n     * @return nextCursor The cursor to use for the next pagination request.\n     */\n    function usersWithPositions(uint256 cursor, uint256 howMany)\n        external\n        view\n        override\n        returns (address[] memory users, uint256 nextCursor)\n    {\n        uint256 length = usersWithPositions.length();\n        if (cursor &gt;= length) return (new address, 0);\n        if (howMany &gt;= length - cursor) {\n            howMany = length - cursor;\n        }\n\n        address[] memory usersWithPositions = new address;\n        for (uint256 i = 0; i &lt; howMany; i++) {\n            usersWithPositions_[i] = usersWithPositions.at(i + cursor);\n        }\n\n        return (usersWithPositions, cursor + howMany);\n    }\n\n    /\n     * @notice Get a list of all tokens usable for this action.\n     * @dev This refers to all tokens that can be used as deposit tokens.\n     * @return Array of addresses of usable tokens.\n     /\n    function getUsableTokens() external view override returns (address[] memory) {\n        return _usableTokens.toArray();\n    }\n\n    /\n     * @notice Retrieves the topup handler for the given protocol\n     /\n    function getTopUpHandler(bytes32 protocol) external view returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice Successfully tops up a position if it\'s conditions are met.\n     * @dev pool and vault funds are rebalanced after withdrawal for top up\n     * @param payer Account that pays for the top up.\n     * @param account Account owning the position for top up.\n     * @param beneficiary Address of the keeper\'s wallet for fee accrual.\n     * @param protocol Protocol of the top up position.\n     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas\n     * @return true if successful.\n     */\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol,\n        uint256 maxWeiForGas\n    ) public override returns (bool) {\n        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);\n\n        ExecuteLocalVars memory vars;\n\n        vars.initialGas = gasleft();\n\n        Record storage position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n        require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);\n\n        address topUpHandler = _getHandler(protocol, true);\n        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);\n\n        // ensure that the position is actually below its set user factor threshold\n        require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);\n\n        IGasBank gasBank = addressProvider.getGasBank();\n\n        // fail early if the user does not have enough funds in the gas bank\n        // to cover the cost of the transaction\n        vars.estimatedRequiredGas = getEstimatedGasUsage();\n        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;\n\n        // compute the gas price that the user will be paying\n        vars.userGasPrice = block.basefee + position.priorityFee;\n        if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;\n        if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;\n\n        // ensure the current position allows for the gas to be paid\n        require(\n            vars.estimatedRequiredWeiForGas &lt;=\n                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,\n            Error.ESTIMATED_GAS_TOO_HIGH\n        );\n\n        vars.gasBankBalance = gasBank.balanceOf(payer);\n        // ensure the user has enough funds in the gas bank to cover the gas\n        require(\n            vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,\n            Error.GAS_BANK_BALANCE_TOO_LOW\n        );\n\n        vars.totalTopUpAmount = position.totalTopUpAmount;\n        vars.actionFee = getActionFee();\n        // add top-up fees to top-up amount\n        vars.minActionAmountToTopUp = position.singleTopUpAmount;\n        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(\n            ScaledMath.ONE + vars.actionFee\n        );\n\n        // if the amount that we want to top-up (including fees) is higher than\n        // the available topup amount, we lower this down to what is left of the position\n        if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {\n            vars.actionAmountWithFees = vars.totalTopUpAmount;\n            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(\n                ScaledMath.ONE + vars.actionFee\n            );\n        }\n        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);\n        vars.underlying = pool.getUnderlying();\n        vars.rate = pool.exchangeRate();\n\n        ISwapper swapper;\n\n        if (vars.underlying != position.actionToken) {\n            swapper = _getSwapper(vars.underlying, position.actionToken);\n            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));\n        }\n\n        // compute the deposit tokens amount with and without fees\n        // we will need to unstake the amount with fees and to\n        // swap the amount without fees into action tokens\n        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);\n        if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {\n            vars.depositAmountWithFees = position.depositTokenBalance;\n            vars.minActionAmountToTopUp =\n                (vars.depositAmountWithFees * vars.rate) /\n                (ScaledMath.ONE + vars.actionFee);\n        }\n\n        // compute amount of LP tokens needed to pay for action\n        // rate is expressed in actionToken per depositToken\n        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);\n        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;\n\n        // will revert if vault does not exist\n        address vault = addressProvider.getStakerVault(position.depositToken);\n\n        // unstake deposit tokens including fees\n        IStakerVault(vault).unstake(vars.depositAmountWithFees);\n        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);\n\n        // swap the amount without the fees\n        // as the fees are paid in deposit token, not in action token\n        // Redeem first and use swapper only if the underlying tokens are not action tokens\n        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);\n\n        if (address(swapper) != address(0)) {\n            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(\n                getSwapperSlippage()\n            );\n            _approve(vars.underlying, address(swapper));\n            vars.actionTokenAmount = swapper.swap(\n                vars.underlying,\n                position.actionToken,\n                vars.actionTokenAmount,\n                vars.minActionAmountToTopUp\n            );\n        }\n\n        // compute how much of action token was actually redeemed and add fees to it\n        // this is to ensure that no funds get locked inside the contract\n        vars.totalActionTokenAmount =\n            vars.actionTokenAmount +\n            vars.depositTotalFeesAmount.scaledMul(vars.rate);\n\n        // at this point, we have exactly vars.actionTokenAmount\n        // (at least position.singleTopUpAmount) of action token\n        // and exactly vars.depositTotalFeesAmount deposit tokens in the contract\n        // solhint-disable-next-line avoid-low-level-calls\n        (vars.success, vars.topupResult) = topUpHandler.delegatecall(\n            abi.encodeWithSignature(\n                ""topUp(bytes32,address,uint256,bytes)"",\n                account,\n                position.actionToken,\n                vars.actionTokenAmount,\n                position.extra\n            )\n        );\n\n        require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);\n\n        // totalTopUpAmount is updated to reflect the new ""balance"" of the position\n        if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {\n            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);\n        } else {\n            position.totalTopUpAmount = 0;\n        }\n\n        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);\n\n        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;\n        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);\n        if (vars.removePosition) {\n            if (position.depositTokenBalance &gt; 0) {\n                // transfer any unused locked tokens to the payer\n                IStakerVault(vault).transfer(payer, position.depositTokenBalance);\n                IStakerVault(vault).decreaseActionLockedBalance(\n                    payer,\n                    position.depositTokenBalance\n                );\n            }\n            _removePosition(payer, account, protocol);\n        }\n\n        emit TopUp(\n            account,\n            protocol,\n            payer,\n            position.depositToken,\n            vars.depositAmountWithFees,\n            position.actionToken,\n            vars.actionTokenAmount\n        );\n\n        // compute gas used and reimburse the keeper by using the\n        // funds of payer in the gas bank\n        // TODO: add constant gas consumed for transfer and tx prologue\n        vars.gasConsumed = vars.initialGas - gasleft();\n\n        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;\n        if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {\n            vars.reimbursedWeiForGas = vars.gasBankBalance;\n        }\n\n        // ensure that the keeper is not overpaying\n        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;\n        require(\n            vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,\n            Error.GAS_TOO_HIGH\n        );\n        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);\n        if (vars.removePosition) {\n            gasBank.withdrawUnused(payer);\n        }\n\n        return true;\n    }\n\n    /\n     * @notice Prepare new top up handler fee update.\n     * @dev Setting the addres to 0 means that the protocol will no longer be supported.\n     * @param protocol Protocol for which a new handler should be prepared.\n     * @param newHandler Address of new handler.\n     * @return true if success.\n     /\n    function prepareTopUpHandler(bytes32 protocol, address newHandler)\n        public\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_getProtocolKey(protocol), newHandler);\n    }\n\n    /\n     * @notice Check if action can be executed.\n     * @param protocol for which to get the health factor\n     * @param account for which to get the health factor\n     * @param extra data to be used by the topup handler\n     * @return healthFactor of the position\n     /\n    function getHealthFactor(\n        bytes32 protocol,\n        bytes32 account,\n        bytes memory extra\n    ) public view override returns (uint256 healthFactor) {\n        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));\n        return topUpHandler.getUserFactor(account, extra);\n    }\n\n    function getHandler(bytes32 protocol) public view override returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice returns the current estimated gas usage\n     */\n    function getEstimatedGasUsage() public view returns (uint256) {\n        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];\n    }\n\n    /\n     * @notice Returns the current action fee\n     /\n    function getActionFee() public view override returns (uint256) {\n        return currentUInts256[_ACTION_FEE_KEY];\n    }\n\n    /\n     * @notice Returns the current max swapper slippage\n     /\n    function getSwapperSlippage() public view override returns (uint256) {\n        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];\n    }\n\n    /\n     * @notice Returns the current fee handler\n     */\n    function getFeeHandler() public view override returns (address) {\n        return currentAddresses[_FEE_HANDLER_KEY];\n    }\n\n    /\n     * @notice Get the record for a position.\n     * @param payer Registered payer of the position.\n     * @param account Address holding the position.\n     * @param protocol Protocol where the position is held.\n     /\n    function getPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) public view override returns (Record memory) {\n        return _positions[payer][account][protocol];\n    }\n\n    /\n     * @notice Check whether a token is usable as a deposit token.\n     * @param token Address of token to check.\n     * @return True if token is usable as a deposit token for this action.\n     /\n    function isUsable(address token) public view override returns (bool) {\n        return _usableTokens.contains(token);\n    }\n\n    function _updateTopUpHandler(\n        bytes32 protocol,\n        address oldHandler,\n        address newHandler\n    ) internal {\n        if (newHandler == address(0)) {\n            _supportedProtocols.remove(protocol);\n        } else if (oldHandler == address(0)) {\n            _supportedProtocols.add(protocol);\n        }\n    }\n\n    /\n     * @dev Pays fees to the feeHandler\n     * @param payer The account who\'s position the fees are charged on\n     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)\n     * @param feeAmount The amount in tokens to pay as fees\n     * @param depositToken The LpToken used to pay the fees\n     */\n    function _payFees(\n        address payer,\n        address beneficiary,\n        uint256 feeAmount,\n        address depositToken\n    ) internal {\n        address feeHandler = getFeeHandler();\n        IERC20(depositToken).safeApprove(feeHandler, feeAmount);\n        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);\n    }\n\n    /\n     * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction\n     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.\n     * @param payer Owner of the funds to be locked\n     * @param token Token to lock\n     * @param lockAmount Minimum amount of token to lock\n     * @param depositAmount Amount of token that was deposited.\n     *                      If this is 0 then the staker vault allowance should be used.\n     *                      If this is greater than requiredAmount more tokens will be locked.\n     /\n    function _lockFunds(\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) internal {\n        address stakerVaultAddress = addressProvider.getStakerVault(token);\n        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);\n    }\n\n    function _removePosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        delete _positions[payer][account][protocol];\n        _removeUserPosition(payer, account, protocol);\n        if (_userPositions[payer].length == 0) {\n            _usersWithPositions.remove(payer);\n        }\n        emit Deregister(payer, account, protocol);\n    }\n\n    function _removeUserPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        RecordMeta[] storage positionsMeta = _userPositions[payer];\n        uint256 length = positionsMeta.length;\n        for (uint256 i = 0; i &lt; length; i++) {\n            RecordMeta storage positionMeta = positionsMeta[i];\n            if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {\n                positionsMeta[i] = positionsMeta[length - 1];\n                positionsMeta.pop();\n                return;\n            }\n        }\n    }\n\n    /\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     /\n    function _approve(address token, address spender) internal {\n        if (IERC20(token).allowance(address(this), spender) &gt; 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /*\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     /\n    function _calcExchangeAmount(\n        address token,\n        address actionToken,\n        uint256 amount\n    ) internal view returns (uint256) {\n        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);\n    }\n\n    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {\n        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);\n    }\n\n    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {\n        address handler = currentAddresses[_getProtocolKey(protocol)];\n        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);\n        return handler;\n    }\n\n    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);\n        address underlying = pool.getUnderlying();\n        if (underlying == toToken) {\n            return true;\n        }\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);\n    }\n\n    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));\n    }\n}\n', 'ideas': "" Potential Inconsistency in Yield Source Swapping Identified.\n\nPOTENTIAL INCONSISTENCY IN YIELD SOURCE SWAPPING\n'''\nThe contract allows for the swapping of yield sources through the getSwapper""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-15-08 09:56:08 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol""; import ""../../../interfaces/IGasBank.sol""; import ""../../../interfaces/pool/ILiquidityPool.sol""; import ""../../../interfaces/ISwapperRegistry.sol""; import ""../../../interfaces/IController.sol""; import ""../../../interfaces/IStakerVault.sol""; import ""../../../interfaces/ISwapper.sol""; import ""../../../interfaces/actions/topup/ITopUpHandler.sol""; import ""../../../interfaces/actions/topup/ITopUpAction.sol""; import ""../../../interfaces/actions/IActionFeeHandler.sol""; import ""../../../libraries/AddressProviderHelpers.sol""; import ""../../../libraries/Errors.sol""; import ""../../../libraries/ScaledMath.sol""; import ""../../../libraries/EnumerableExtensions.sol""; import ""../../access/Authorization.sol""; import ""../../utils/Preparable.sol""; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being ""too deep""  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee""; bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler""; bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler""; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage""; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             ""topUp(bytes32,address,uint256,bytes)"",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new ""balance"" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-15-08 09:56:08 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";

import ""../../../interfaces/IGasBank.sol"";
import ""../../../interfaces/pool/ILiquidityPool.sol"";
import ""../../../interfaces/ISwapperRegistry.sol"";
import ""../../../interfaces/IController.sol"";
import ""../../../interfaces/IStakerVault.sol"";
import ""../../../interfaces/ISwapper.sol"";
import ""../../../interfaces/actions/topup/ITopUpHandler.sol"";
import ""../../../interfaces/actions/topup/ITopUpAction.sol"";
import ""../../../interfaces/actions/IActionFeeHandler.sol"";

import ""../../../libraries/AddressProviderHelpers.sol"";
import ""../../../libraries/Errors.sol"";
import ""../../../libraries/ScaledMath.sol"";
import ""../../../libraries/EnumerableExtensions.sol"";

import ""../../access/Authorization.sol"";
import ""../../utils/Preparable.sol"";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being ""too deep""
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee"";
    bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler"";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler"";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage"";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                ""topUp(bytes32,address,uint256,bytes)"",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new ""balance"" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";

import ""../../../interfaces/IGasBank.sol"";
import ""../../../interfaces/pool/ILiquidityPool.sol"";
import ""../../../interfaces/ISwapperRegistry.sol"";
import ""../../../interfaces/IController.sol"";
import ""../../../interfaces/IStakerVault.sol"";
import ""../../../interfaces/ISwapper.sol"";
import ""../../../interfaces/actions/topup/ITopUpHandler.sol"";
import ""../../../interfaces/actions/topup/ITopUpAction.sol"";
import ""../../../interfaces/actions/IActionFeeHandler.sol"";

import ""../../../libraries/AddressProviderHelpers.sol"";
import ""../../../libraries/Errors.sol"";
import ""../../../libraries/ScaledMath.sol"";
import ""../../../libraries/EnumerableExtensions.sol"";

import ""../../access/Authorization.sol"";
import ""../../utils/Preparable.sol"";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being ""too deep""
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee"";
    bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler"";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler"";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage"";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                ""topUp(bytes32,address,uint256,bytes)"",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new ""balance"" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
"".
Ideas: "" Potential Inconsistency in Yield Source Swapping Identified.

POTENTIAL INCONSISTENCY IN YIELD SOURCE SWAPPING
'''
The contract allows for the swapping of yield sources through the `getSwapper`"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Incorrect Signature Verification. This type of vulnerability arises when the contract verifies the signer in an insecure or incorrect manner, which can lead to unauthorized transactions and potential security breaches.
There is one primary case where the code may have Incorrect Signature Verification vulnerabilities:
1. A function that uses the signature to recover the signer and then verifies that the signer is the `msg.sender`. This allows any caller to execute transactions using their own signature, leading to unauthorized actions.
If you identify Incorrect Signer Verification, respond with: """,,,,,,,,"<INFO> Lack of Input Validation Identified.

**VULNERABILITY NAME: Insufficient Input Validation in `register` Function**
'''
The `register` function does not validate the `depositAmount` against the `totalTopUpAmount` before proceeding with the locking of funds. This could lead to a

[2024-15-08 09:56:31 INFO] **[Execute Detail]**

execute SimplePhase:[DoSDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-15-08 09:56:31 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol""; import ""../../../interfaces/IGasBank.sol""; import ""../../../interfaces/pool/ILiquidityPool.sol""; import ""../../../interfaces/ISwapperRegistry.sol""; import ""../../../interfaces/IController.sol""; import ""../../../interfaces/IStakerVault.sol""; import ""../../../interfaces/ISwapper.sol""; import ""../../../interfaces/actions/topup/ITopUpHandler.sol""; import ""../../../interfaces/actions/topup/ITopUpAction.sol""; import ""../../../interfaces/actions/IActionFeeHandler.sol""; import ""../../../libraries/AddressProviderHelpers.sol""; import ""../../../libraries/Errors.sol""; import ""../../../libraries/ScaledMath.sol""; import ""../../../libraries/EnumerableExtensions.sol""; import ""../../access/Authorization.sol""; import ""../../utils/Preparable.sol""; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being ""too deep""  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee""; bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler""; bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler""; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage""; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             ""topUp(bytes32,address,uint256,bytes)"",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new ""balance"" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""Identify all potential DoS (Denial of Service) vulnerabilities in the provided Solidity smart contract."". Ideas: ""DoS vulnerabilities can manifest in various forms in Solidity contracts, such as Gas Limit DoS, External Call DoS, Block Gas Limit DoS, and State Dependency DoS."". As the {assistant_role}, your primary objective is to conduct a comprehensive inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Denial of Service (DoS). DoS vulnerabilities can occur in the following cases: 1. When loops have an unbounded iteration count, leading to potential gas exhaustion. 2. When the contract makes external calls that can fail or consume excessive gas. 3. When the contract depends on certain state conditions that can be manipulated by an attacker to cause failures. 4. When an attacker can send high-gas transactions to consume most of the block's gas limit, making it difficult for other transactions to be included in the block. Please conduct a thorough analysis, considering the following information: 1. Review the contract's code logic to identify any potential areas where unbounded loops might cause gas exhaustion. 2. Examine external calls in the contract and ensure they are handled properly to avoid excessive gas consumption or failures. 3. Analyze state-dependent logic to identify any potential manipulations that could cause DoS. 4. Consider the overall design of the contract to ensure it is resilient against high-gas transactions and other DoS tactics. If you identify any DoS vulnerabilities, respond with: "" DoS Vulnerability Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades. ''' If you don't find any vulnerabilities, respond only with: "" No DoS Vulnerabilities."" |
| **phase_name** | DoSDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";\nimport ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";\n\nimport ""../../../interfaces/IGasBank.sol"";\nimport ""../../../interfaces/pool/ILiquidityPool.sol"";\nimport ""../../../interfaces/ISwapperRegistry.sol"";\nimport ""../../../interfaces/IController.sol"";\nimport ""../../../interfaces/IStakerVault.sol"";\nimport ""../../../interfaces/ISwapper.sol"";\nimport ""../../../interfaces/actions/topup/ITopUpHandler.sol"";\nimport ""../../../interfaces/actions/topup/ITopUpAction.sol"";\nimport ""../../../interfaces/actions/IActionFeeHandler.sol"";\n\nimport ""../../../libraries/AddressProviderHelpers.sol"";\nimport ""../../../libraries/Errors.sol"";\nimport ""../../../libraries/ScaledMath.sol"";\nimport ""../../../libraries/EnumerableExtensions.sol"";\n\nimport ""../../access/Authorization.sol"";\nimport ""../../utils/Preparable.sol"";\n\n/\n * @notice The logic here should really be part of the top-up action\n * but is split in a library to circumvent the byte-code size limit\n */\nlibrary TopUpActionLibrary {\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    function lockFunds(\n        address stakerVaultAddress,\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) external {\n        uint256 amountLeft = lockAmount;\n        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);\n\n        // stake deposit amount\n        if (depositAmount &gt; 0) {\n            depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;\n            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);\n            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);\n            stakerVault.stake(depositAmount);\n            stakerVault.increaseActionLockedBalance(payer, depositAmount);\n            amountLeft -= depositAmount;\n        }\n\n        // use stake vault allowance if available and required\n        if (amountLeft &gt; 0) {\n            uint256 balance = stakerVault.balanceOf(payer);\n            uint256 allowance = stakerVault.allowance(payer, address(this));\n            uint256 availableFunds = balance &lt; allowance ? balance : allowance;\n            if (availableFunds &gt;= amountLeft) {\n                stakerVault.transferFrom(payer, address(this), amountLeft);\n                amountLeft = 0;\n            }\n        }\n\n        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);\n    }\n\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     /\n    function calcExchangeAmount(\n        IAddressProvider addressProvider,\n        address token,\n        address actionToken,\n        uint256 amount\n    ) external view returns (uint256) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        uint256 rate = pool.exchangeRate();\n        address underlying = pool.getUnderlying();\n        if (underlying == actionToken) {\n            return amount.scaledDivRoundUp(rate);\n        }\n\n        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);\n        uint256 swapperRate = swapper.getRate(underlying, actionToken);\n        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));\n    }\n\n    function getSwapper(\n        IAddressProvider addressProvider,\n        address underlying,\n        address actionToken\n    ) public view returns (ISwapper) {\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);\n        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);\n        return ISwapper(swapper);\n    }\n}\n\ncontract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {\n    using ScaledMath for uint256;\n    using ScaledMath for uint128;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using AddressProviderHelpers for IAddressProvider;\n\n    /\n     * @dev Temporary struct to hold local variables in execute\n     * and avoid the stack being ""too deep""\n     /\n    struct ExecuteLocalVars {\n        uint256 minActionAmountToTopUp;\n        uint256 actionTokenAmount;\n        uint256 depositTotalFeesAmount;\n        uint256 actionAmountWithFees;\n        uint256 userFactor;\n        uint256 rate;\n        uint256 depositAmountWithFees;\n        uint256 depositAmountWithoutFees;\n        uint256 actionFee;\n        uint256 totalActionTokenAmount;\n        uint128 totalTopUpAmount;\n        bool success;\n        bytes topupResult;\n        uint256 gasBankBalance;\n        uint256 initialGas;\n        uint256 gasConsumed;\n        uint256 userGasPrice;\n        uint256 estimatedRequiredGas;\n        uint256 estimatedRequiredWeiForGas;\n        uint256 requiredWeiForGas;\n        uint256 reimbursedWeiForGas;\n        address underlying;\n        bool removePosition;\n    }\n\n    EnumerableSet.AddressSet private _usableTokens;\n\n    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;\n\n    bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee"";\n    bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler"";\n    bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler"";\n    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage"";\n    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";\n\n    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;\n    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;\n    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    EnumerableSet.Bytes32Set internal _supportedProtocols;\n\n    /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record)\n    mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;\n\n    mapping(address =&gt; RecordMeta[]) internal _userPositions;\n\n    EnumerableSet.AddressSet internal _usersWithPositions;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        addressProvider = controller.addressProvider();\n        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);\n    }\n\n    receive() external payable {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function initialize(\n        address feeHandler,\n        bytes32[] calldata protocols,\n        address[] calldata handlers\n    ) external initializer onlyGovernance {\n        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);\n        _setConfig(_FEE_HANDLER_KEY, feeHandler);\n        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);\n        for (uint256 i = 0; i &lt; protocols.length; i++) {\n            bytes32 protocolKey = _getProtocolKey(protocols[i]);\n            _setConfig(protocolKey, handlers[i]);\n            _updateTopUpHandler(protocols[i], address(0), handlers[i]);\n        }\n    }\n\n    /\n     * @notice Register a top up action.\n     * @dev The depositAmount must be greater or equal to the totalTopUpAmount (which is denominated in actionToken).\n     * @param account Account to be topped up (first 20 bytes will typically be the address).\n     * @param depositAmount Amount of depositToken that will be locked.\n     * @param protocol Protocol which holds position to be topped up.\n     * @param record containing the data for the position to register\n     /\n    function register(\n        bytes32 account,\n        bytes32 protocol,\n        uint128 depositAmount,\n        Record memory record\n    ) external payable returns (bool) {\n        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);\n        require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);\n        require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);\n        require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);\n        require(\n            _positions[msg.sender][account][protocol].threshold == 0,\n            Error.POSITION_ALREADY_EXISTS\n        );\n        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);\n        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);\n\n        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) \n            record.maxFee *\n            getEstimatedGasUsage();\n\n        require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);\n\n        uint256 totalLockAmount = _calcExchangeAmount(\n            record.depositToken,\n            record.actionToken,\n            record.totalTopUpAmount\n        );\n        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);\n\n        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);\n\n        record.depositTokenBalance = uint128(totalLockAmount);\n        _positions[msg.sender][account][protocol] = record;\n        _userPositions[msg.sender].push(RecordMeta(account, protocol));\n        _usersWithPositions.add(msg.sender);\n\n        emit Register(\n            account,\n            protocol,\n            record.threshold,\n            msg.sender,\n            record.depositToken,\n            totalLockAmount,\n            record.actionToken,\n            record.singleTopUpAmount,\n            record.totalTopUpAmount,\n            record.maxFee,\n            record.extra\n        );\n        return true;\n    }\n\n    /\n     * @notice See overloaded version of execute for more details.\n     /\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol\n    ) external override returns (bool) {\n        return execute(payer, account, beneficiary, protocol, 0);\n    }\n\n    /\n     * @notice Delete a position to back on the given protocol for account.\n     * @param account Account holding the position.\n     * @param protocol Protocol the position is held on.\n     * @param unstake If the tokens should be unstaked from vault.\n     * @return true if successful.\n     /\n    function resetPosition(\n        bytes32 account,\n        bytes32 protocol,\n        bool unstake\n    ) external override returns (bool) {\n        address payer = msg.sender;\n        Record memory position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n\n        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist\n        IStakerVault staker = IStakerVault(vault);\n        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);\n        if (unstake) {\n            staker.unstake(position.depositTokenBalance);\n            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);\n        } else {\n            staker.transfer(payer, position.depositTokenBalance);\n        }\n\n        _removePosition(payer, account, protocol);\n        addressProvider.getGasBank().withdrawUnused(payer);\n        return true;\n    }\n\n    /\n     * @notice Execute top up handler update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @param protocol Protocol for which a new handler should be executed.\n     * @return Address of new handler.\n     */\n    function executeTopUpHandler(bytes32 protocol) external override returns (address) {\n        address oldHandler = _getHandler(protocol, false);\n        address newHandler = _executeAddress(_getProtocolKey(protocol));\n\n        _updateTopUpHandler(protocol, oldHandler, newHandler);\n        return newHandler;\n    }\n\n    /\n     * @notice Reset new top up handler deadline for a protocol.\n     * @param protocol Protocol for which top up handler deadline should be reset.\n     * @return true if successful.\n     /\n    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_getProtocolKey(protocol));\n    }\n\n    /\n     * @notice Prepare action fee update.\n     * @param newActionFee New fee to set.\n     * @return true if success.\n     /\n    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {\n        require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);\n        return _prepare(_ACTION_FEE_KEY, newActionFee);\n    }\n\n    /\n     * @notice Execute action fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeActionFee() external override returns (uint256) {\n        return _executeUInt256(_ACTION_FEE_KEY);\n    }\n\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     /\n    function resetActionFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ACTION_FEE_KEY);\n    }\n\n    /\n     * @notice Prepare swapper slippage update.\n     * @param newSwapperSlippage New slippage to set.\n     * @return true if success.\n     /\n    function prepareSwapperSlippage(uint256 newSwapperSlippage)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        require(\n            newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;\n                newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,\n            Error.INVALID_AMOUNT\n        );\n        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);\n    }\n\n    /\n     * @notice Execute swapper slippage update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeSwapperSlippage() external override returns (uint256) {\n        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     /\n    function resetSwapperSlippage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    / Set fee handler /\n    /\n     * @notice Prepare update of fee handler.\n     * @param handler New fee handler.\n     * @return true if success.\n     */\n    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {\n        return _prepare(_FEE_HANDLER_KEY, handler);\n    }\n\n    /\n     * @notice Execute update of fee handler (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return true if successful.\n     /\n    function executeFeeHandler() external override returns (address) {\n        return _executeAddress(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Reset the handler deadline.\n     * @return true if success.\n     /\n    function resetFeeHandler() external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Prepare update of estimated gas usage.\n     * @param gasUsage New estimated gas usage.\n     * @return true if success.\n     */\n    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {\n        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);\n    }\n\n    /\n     * @notice Execute update of gas usage (with time delay enforced).\n     * @return true if successful.\n     /\n    function executeEstimatedGasUsage() external returns (uint256) {\n        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Reset the gas usage deadline.\n     * @return true if success.\n     /\n    function resetGasUsage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Add a new deposit token that is supported by the action.\n     * @dev There is a separate check for whether the usable token (i.e. deposit token)\n     *      is swappable for some action token.\n     * @param token Address of deposit token that can be used by the action.\n     */\n    function addUsableToken(address token) external override onlyGovernance returns (bool) {\n        return _usableTokens.add(token);\n    }\n\n    /\n     * @notice Computes the total amount of ETH (as wei) required to pay for all\n     * the top-ups assuming the maximum gas price and the current estimated gas\n     * usage of a top-up\n     /\n    function getEthRequiredForGas(address payer) external view override returns (uint256) {\n        uint256 totalEthRequired = 0;\n        RecordMeta[] memory userRecordsMeta = _userPositions[payer];\n        uint256 gasUsagePerCall = getEstimatedGasUsage();\n        uint256 length = userRecordsMeta.length;\n        for (uint256 i = 0; i &lt; length; i++) {\n            RecordMeta memory meta = userRecordsMeta[i];\n            Record memory record = _positions[payer][meta.account][meta.protocol];\n            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);\n            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;\n        }\n        return totalEthRequired;\n    }\n\n    /\n     * @notice Returns a list of positions for the given payer\n     /\n    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {\n        return _userPositions[payer];\n    }\n\n    /\n     * @notice Get a list supported protocols.\n     * @return List of supported protocols.\n     /\n    function getSupportedProtocols() external view override returns (bytes32[] memory) {\n        uint256 length = _supportedProtocols.length();\n        bytes32[] memory protocols = new bytes32;\n        for (uint256 i = 0; i &lt; length; i++) {\n            protocols[i] = _supportedProtocols.at(i);\n        }\n        return protocols;\n    }\n\n    /\n     * @notice Gets a list of users that have an active position.\n     * @dev Uses cursor pagination.\n     * @param cursor The cursor for pagination (should start at 0 for first call).\n     * @param howMany Maximum number of users to return in this pagination request.\n     * @return users List of users that have an active position.\n     * @return nextCursor The cursor to use for the next pagination request.\n     */\n    function usersWithPositions(uint256 cursor, uint256 howMany)\n        external\n        view\n        override\n        returns (address[] memory users, uint256 nextCursor)\n    {\n        uint256 length = usersWithPositions.length();\n        if (cursor &gt;= length) return (new address, 0);\n        if (howMany &gt;= length - cursor) {\n            howMany = length - cursor;\n        }\n\n        address[] memory usersWithPositions = new address;\n        for (uint256 i = 0; i &lt; howMany; i++) {\n            usersWithPositions_[i] = usersWithPositions.at(i + cursor);\n        }\n\n        return (usersWithPositions, cursor + howMany);\n    }\n\n    /\n     * @notice Get a list of all tokens usable for this action.\n     * @dev This refers to all tokens that can be used as deposit tokens.\n     * @return Array of addresses of usable tokens.\n     /\n    function getUsableTokens() external view override returns (address[] memory) {\n        return _usableTokens.toArray();\n    }\n\n    /\n     * @notice Retrieves the topup handler for the given protocol\n     /\n    function getTopUpHandler(bytes32 protocol) external view returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice Successfully tops up a position if it\'s conditions are met.\n     * @dev pool and vault funds are rebalanced after withdrawal for top up\n     * @param payer Account that pays for the top up.\n     * @param account Account owning the position for top up.\n     * @param beneficiary Address of the keeper\'s wallet for fee accrual.\n     * @param protocol Protocol of the top up position.\n     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas\n     * @return true if successful.\n     */\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol,\n        uint256 maxWeiForGas\n    ) public override returns (bool) {\n        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);\n\n        ExecuteLocalVars memory vars;\n\n        vars.initialGas = gasleft();\n\n        Record storage position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n        require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);\n\n        address topUpHandler = _getHandler(protocol, true);\n        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);\n\n        // ensure that the position is actually below its set user factor threshold\n        require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);\n\n        IGasBank gasBank = addressProvider.getGasBank();\n\n        // fail early if the user does not have enough funds in the gas bank\n        // to cover the cost of the transaction\n        vars.estimatedRequiredGas = getEstimatedGasUsage();\n        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;\n\n        // compute the gas price that the user will be paying\n        vars.userGasPrice = block.basefee + position.priorityFee;\n        if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;\n        if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;\n\n        // ensure the current position allows for the gas to be paid\n        require(\n            vars.estimatedRequiredWeiForGas &lt;=\n                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,\n            Error.ESTIMATED_GAS_TOO_HIGH\n        );\n\n        vars.gasBankBalance = gasBank.balanceOf(payer);\n        // ensure the user has enough funds in the gas bank to cover the gas\n        require(\n            vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,\n            Error.GAS_BANK_BALANCE_TOO_LOW\n        );\n\n        vars.totalTopUpAmount = position.totalTopUpAmount;\n        vars.actionFee = getActionFee();\n        // add top-up fees to top-up amount\n        vars.minActionAmountToTopUp = position.singleTopUpAmount;\n        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(\n            ScaledMath.ONE + vars.actionFee\n        );\n\n        // if the amount that we want to top-up (including fees) is higher than\n        // the available topup amount, we lower this down to what is left of the position\n        if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {\n            vars.actionAmountWithFees = vars.totalTopUpAmount;\n            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(\n                ScaledMath.ONE + vars.actionFee\n            );\n        }\n        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);\n        vars.underlying = pool.getUnderlying();\n        vars.rate = pool.exchangeRate();\n\n        ISwapper swapper;\n\n        if (vars.underlying != position.actionToken) {\n            swapper = _getSwapper(vars.underlying, position.actionToken);\n            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));\n        }\n\n        // compute the deposit tokens amount with and without fees\n        // we will need to unstake the amount with fees and to\n        // swap the amount without fees into action tokens\n        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);\n        if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {\n            vars.depositAmountWithFees = position.depositTokenBalance;\n            vars.minActionAmountToTopUp =\n                (vars.depositAmountWithFees * vars.rate) /\n                (ScaledMath.ONE + vars.actionFee);\n        }\n\n        // compute amount of LP tokens needed to pay for action\n        // rate is expressed in actionToken per depositToken\n        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);\n        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;\n\n        // will revert if vault does not exist\n        address vault = addressProvider.getStakerVault(position.depositToken);\n\n        // unstake deposit tokens including fees\n        IStakerVault(vault).unstake(vars.depositAmountWithFees);\n        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);\n\n        // swap the amount without the fees\n        // as the fees are paid in deposit token, not in action token\n        // Redeem first and use swapper only if the underlying tokens are not action tokens\n        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);\n\n        if (address(swapper) != address(0)) {\n            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(\n                getSwapperSlippage()\n            );\n            _approve(vars.underlying, address(swapper));\n            vars.actionTokenAmount = swapper.swap(\n                vars.underlying,\n                position.actionToken,\n                vars.actionTokenAmount,\n                vars.minActionAmountToTopUp\n            );\n        }\n\n        // compute how much of action token was actually redeemed and add fees to it\n        // this is to ensure that no funds get locked inside the contract\n        vars.totalActionTokenAmount =\n            vars.actionTokenAmount +\n            vars.depositTotalFeesAmount.scaledMul(vars.rate);\n\n        // at this point, we have exactly vars.actionTokenAmount\n        // (at least position.singleTopUpAmount) of action token\n        // and exactly vars.depositTotalFeesAmount deposit tokens in the contract\n        // solhint-disable-next-line avoid-low-level-calls\n        (vars.success, vars.topupResult) = topUpHandler.delegatecall(\n            abi.encodeWithSignature(\n                ""topUp(bytes32,address,uint256,bytes)"",\n                account,\n                position.actionToken,\n                vars.actionTokenAmount,\n                position.extra\n            )\n        );\n\n        require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);\n\n        // totalTopUpAmount is updated to reflect the new ""balance"" of the position\n        if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {\n            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);\n        } else {\n            position.totalTopUpAmount = 0;\n        }\n\n        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);\n\n        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;\n        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);\n        if (vars.removePosition) {\n            if (position.depositTokenBalance &gt; 0) {\n                // transfer any unused locked tokens to the payer\n                IStakerVault(vault).transfer(payer, position.depositTokenBalance);\n                IStakerVault(vault).decreaseActionLockedBalance(\n                    payer,\n                    position.depositTokenBalance\n                );\n            }\n            _removePosition(payer, account, protocol);\n        }\n\n        emit TopUp(\n            account,\n            protocol,\n            payer,\n            position.depositToken,\n            vars.depositAmountWithFees,\n            position.actionToken,\n            vars.actionTokenAmount\n        );\n\n        // compute gas used and reimburse the keeper by using the\n        // funds of payer in the gas bank\n        // TODO: add constant gas consumed for transfer and tx prologue\n        vars.gasConsumed = vars.initialGas - gasleft();\n\n        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;\n        if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {\n            vars.reimbursedWeiForGas = vars.gasBankBalance;\n        }\n\n        // ensure that the keeper is not overpaying\n        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;\n        require(\n            vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,\n            Error.GAS_TOO_HIGH\n        );\n        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);\n        if (vars.removePosition) {\n            gasBank.withdrawUnused(payer);\n        }\n\n        return true;\n    }\n\n    /\n     * @notice Prepare new top up handler fee update.\n     * @dev Setting the addres to 0 means that the protocol will no longer be supported.\n     * @param protocol Protocol for which a new handler should be prepared.\n     * @param newHandler Address of new handler.\n     * @return true if success.\n     /\n    function prepareTopUpHandler(bytes32 protocol, address newHandler)\n        public\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_getProtocolKey(protocol), newHandler);\n    }\n\n    /\n     * @notice Check if action can be executed.\n     * @param protocol for which to get the health factor\n     * @param account for which to get the health factor\n     * @param extra data to be used by the topup handler\n     * @return healthFactor of the position\n     /\n    function getHealthFactor(\n        bytes32 protocol,\n        bytes32 account,\n        bytes memory extra\n    ) public view override returns (uint256 healthFactor) {\n        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));\n        return topUpHandler.getUserFactor(account, extra);\n    }\n\n    function getHandler(bytes32 protocol) public view override returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice returns the current estimated gas usage\n     */\n    function getEstimatedGasUsage() public view returns (uint256) {\n        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];\n    }\n\n    /\n     * @notice Returns the current action fee\n     /\n    function getActionFee() public view override returns (uint256) {\n        return currentUInts256[_ACTION_FEE_KEY];\n    }\n\n    /\n     * @notice Returns the current max swapper slippage\n     /\n    function getSwapperSlippage() public view override returns (uint256) {\n        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];\n    }\n\n    /\n     * @notice Returns the current fee handler\n     */\n    function getFeeHandler() public view override returns (address) {\n        return currentAddresses[_FEE_HANDLER_KEY];\n    }\n\n    /\n     * @notice Get the record for a position.\n     * @param payer Registered payer of the position.\n     * @param account Address holding the position.\n     * @param protocol Protocol where the position is held.\n     /\n    function getPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) public view override returns (Record memory) {\n        return _positions[payer][account][protocol];\n    }\n\n    /\n     * @notice Check whether a token is usable as a deposit token.\n     * @param token Address of token to check.\n     * @return True if token is usable as a deposit token for this action.\n     /\n    function isUsable(address token) public view override returns (bool) {\n        return _usableTokens.contains(token);\n    }\n\n    function _updateTopUpHandler(\n        bytes32 protocol,\n        address oldHandler,\n        address newHandler\n    ) internal {\n        if (newHandler == address(0)) {\n            _supportedProtocols.remove(protocol);\n        } else if (oldHandler == address(0)) {\n            _supportedProtocols.add(protocol);\n        }\n    }\n\n    /\n     * @dev Pays fees to the feeHandler\n     * @param payer The account who\'s position the fees are charged on\n     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)\n     * @param feeAmount The amount in tokens to pay as fees\n     * @param depositToken The LpToken used to pay the fees\n     */\n    function _payFees(\n        address payer,\n        address beneficiary,\n        uint256 feeAmount,\n        address depositToken\n    ) internal {\n        address feeHandler = getFeeHandler();\n        IERC20(depositToken).safeApprove(feeHandler, feeAmount);\n        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);\n    }\n\n    /\n     * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction\n     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.\n     * @param payer Owner of the funds to be locked\n     * @param token Token to lock\n     * @param lockAmount Minimum amount of token to lock\n     * @param depositAmount Amount of token that was deposited.\n     *                      If this is 0 then the staker vault allowance should be used.\n     *                      If this is greater than requiredAmount more tokens will be locked.\n     /\n    function _lockFunds(\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) internal {\n        address stakerVaultAddress = addressProvider.getStakerVault(token);\n        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);\n    }\n\n    function _removePosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        delete _positions[payer][account][protocol];\n        _removeUserPosition(payer, account, protocol);\n        if (_userPositions[payer].length == 0) {\n            _usersWithPositions.remove(payer);\n        }\n        emit Deregister(payer, account, protocol);\n    }\n\n    function _removeUserPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        RecordMeta[] storage positionsMeta = _userPositions[payer];\n        uint256 length = positionsMeta.length;\n        for (uint256 i = 0; i &lt; length; i++) {\n            RecordMeta storage positionMeta = positionsMeta[i];\n            if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {\n                positionsMeta[i] = positionsMeta[length - 1];\n                positionsMeta.pop();\n                return;\n            }\n        }\n    }\n\n    /\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     /\n    function _approve(address token, address spender) internal {\n        if (IERC20(token).allowance(address(this), spender) &gt; 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     */\n    function _calcExchangeAmount(\n        address token,\n        address actionToken,\n        uint256 amount\n    ) internal view returns (uint256) {\n        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);\n    }\n\n    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {\n        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);\n    }\n\n    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {\n        address handler = currentAddresses[_getProtocolKey(protocol)];\n        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);\n        return handler;\n    }\n\n    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);\n        address underlying = pool.getUnderlying();\n        if (underlying == toToken) {\n            return true;\n        }\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);\n    }\n\n    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));\n    }\n}\n', 'ideas': "" Lack of Input Validation Identified.\n\nVULNERABILITY NAME: Insufficient Input Validation in register Function**\n'''\nThe register function does not validate the depositAmount against the totalTopUpAmount before proceeding with the locking of funds. This could lead to a""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-15-08 09:56:31 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol""; import ""../../../interfaces/IGasBank.sol""; import ""../../../interfaces/pool/ILiquidityPool.sol""; import ""../../../interfaces/ISwapperRegistry.sol""; import ""../../../interfaces/IController.sol""; import ""../../../interfaces/IStakerVault.sol""; import ""../../../interfaces/ISwapper.sol""; import ""../../../interfaces/actions/topup/ITopUpHandler.sol""; import ""../../../interfaces/actions/topup/ITopUpAction.sol""; import ""../../../interfaces/actions/IActionFeeHandler.sol""; import ""../../../libraries/AddressProviderHelpers.sol""; import ""../../../libraries/Errors.sol""; import ""../../../libraries/ScaledMath.sol""; import ""../../../libraries/EnumerableExtensions.sol""; import ""../../access/Authorization.sol""; import ""../../utils/Preparable.sol""; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being ""too deep""  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee""; bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler""; bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler""; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage""; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             ""topUp(bytes32,address,uint256,bytes)"",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new ""balance"" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-15-08 09:56:31 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";

import ""../../../interfaces/IGasBank.sol"";
import ""../../../interfaces/pool/ILiquidityPool.sol"";
import ""../../../interfaces/ISwapperRegistry.sol"";
import ""../../../interfaces/IController.sol"";
import ""../../../interfaces/IStakerVault.sol"";
import ""../../../interfaces/ISwapper.sol"";
import ""../../../interfaces/actions/topup/ITopUpHandler.sol"";
import ""../../../interfaces/actions/topup/ITopUpAction.sol"";
import ""../../../interfaces/actions/IActionFeeHandler.sol"";

import ""../../../libraries/AddressProviderHelpers.sol"";
import ""../../../libraries/Errors.sol"";
import ""../../../libraries/ScaledMath.sol"";
import ""../../../libraries/EnumerableExtensions.sol"";

import ""../../access/Authorization.sol"";
import ""../../utils/Preparable.sol"";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being ""too deep""
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee"";
    bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler"";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler"";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage"";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                ""topUp(bytes32,address,uint256,bytes)"",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new ""balance"" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""Identify all potential DoS (Denial of Service) vulnerabilities in the provided Solidity smart contract."".
Ideas: ""DoS vulnerabilities can manifest in various forms in Solidity contracts, such as Gas Limit DoS, External Call DoS, Block Gas Limit DoS, and State Dependency DoS."".
As the Security Analyst, your primary objective is to conduct a comprehensive inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Denial of Service (DoS). DoS vulnerabilities can occur in the following cases:
1. When loops have an unbounded iteration count, leading to potential gas exhaustion.
2. When the contract makes external calls that can fail or consume excessive gas.
3. When the contract depends on certain state conditions that can be manipulated by an attacker to cause failures.
4. When an attacker can send high-gas transactions to consume most of the block's gas limit, making it difficult for other transactions to be included in the block.
Please conduct a thorough analysis, considering the following information:
1. Review the contract's code logic to identify any potential areas where unbounded loops might cause gas exhaustion.
2. Examine external calls in the contract and ensure they are handled properly to avoid excessive gas consumption or failures.
3. Analyze state-dependent logic to identify any potential manipulations that could cause DoS.
4. Consider the overall design of the contract to ensure it is resilient against high-gas transactions and other DoS tactics.
If you identify any DoS vulnerabilities, respond with: ""","<INFO> DoS Vulnerability Identified.

**1. Unbounded Loop DoS**
'''
The function `usersWithPositions` contains a loop that iterates over the `_usersWithPositions` set based on the `howMany` parameter. If the number of users with positions is large, this could lead to excessive gas consumption, potentially exhausting the gas limit and causing a DoS. An attacker could exploit this by calling the function with a high cursor value or a large `howMany` parameter, leading to a situation where the transaction fails due to out-of-gas errors.

**Mitigation Measures:**
- Implement a maximum limit on the `howMany` parameter to ensure that the loop does not iterate excessively. For instance, you could limit `howMany` to a reasonable number (e.g., 100).
- Consider implementing pagination with a fixed maximum size to prevent excessive gas consumption.
'''

**2. External Call DoS**
'''
The function `execute` makes a delegate call to the `topUpHandler` contract. If the `topUpHandler` is malicious or fails for any reason, it can cause the entire transaction to revert, leading to a DoS situation. This is particularly concerning if the handler's implementation is not controlled or audited properly.

**Mitigation Measures:**
- Use `try/catch` patterns (if using Solidity 0.8.0 or later) to handle potential failures from external calls gracefully. This way, if the external call fails, the contract can handle the error without reverting the entire transaction.
- Ensure that the `topUpHandler` is a trusted contract and consider implementing checks to validate its address before making calls.
'''

**3. State Dependency DoS**
'''
In the `execute` function, the contract checks the `threshold` and `totalTopUpAmount` of the position. If an attacker can manipulate the state of the contract (e.g., by resetting positions or changing parameters), they could potentially cause the function to revert, leading to a DoS condition for legitimate users.

**Mitigation Measures:**
- Implement checks and balances to ensure that state changes are only allowed under certain conditions, preventing malicious manipulation.
- Consider using a circuit breaker pattern to pause operations if certain conditions are met, allowing for recovery from potential DoS attacks.
'''

**4. Block Gas Limit DoS**
'''
The `register` function calculates `gasDeposit` based on the `totalTopUpAmount` and `singleTopUpAmount`. If these amounts are large, it could lead to high gas consumption when registering multiple positions, potentially consuming the block gas limit and causing other transactions to fail.

**Mitigation Measures:**
- Set reasonable limits on the `totalTopUpAmount` and `singleTopUpAmount` to prevent excessive gas consumption.
- Consider implementing a mechanism to batch operations or limit the number of positions that can be registered in a single transaction.
'''

[2024-15-08 09:56:39 INFO] **[Post Info]**

Software Info: 

**cost**=$0.000000

**version_updates**=1.0

**num_code_files**=0

**num_png_files**=0

**num_doc_files**=5

**code_lines**=0

**env_lines**=-1

**manual_lines**=-1

**num_utterances**=86

**num_self_reflections**=1

**num_prompt_tokens**=686128

**num_completion_tokens**=1970

**num_total_tokens**=688098

**duration**=152.00s

ChatDev Starts (20240815095407)

ChatDev Ends (20240815095639)


"
