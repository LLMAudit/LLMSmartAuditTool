Integer Overflow/Underflow Identified,Reentrancy Identified,Unchecked External Calls Identified,Unchecked Low-level Calls Identified,Transactions Order Dependence Identified,Timestamp Manipulation Identified,Predictable Randomness Identified,Unsafe `tx.origin` Identified,Unsafe Suicide Identified,Gas Limit Identified,Price Manipulation Identified,Assumption of Fixed-Length Array Identified,Lack of Withdrawal Function Identified,Lack of Authorization Identified,Potential Data Inconsistency Identified,Hash Collision Identified,Uninitialized Return Variable Identified,Misdeclared Constructor Identified,Missing 'onlyOwner' Modifier Identified,Misuse of `msg.value` within a Loop Identified,Precision Loss Identified,Redundant Conditional Check Identified,External Oracle Dependency Identified,Ownership Hijacking Identified,Centralization Risk Identified,Incorrect Funding Rate Calculation Identified,Flash Loan Fee Manipulation Identified,Misuse of Mapping Getter Identified,Lack of Getter Function Implementation Identified,Unnecessary Comparison Identified,Inconsistent Initialization Identified,Potential Inconsistency in Yield Source Swapping Identified,Incorrect Signer Verification Identified,Order of Inheritance Initialization Identified,Impracticality of Exact Match Identified,Inconsistent Base Tokens Identified,Handling Partial Withdrawals Identified,Fallback Function Identified,Unlimited Token Approval Identified,Lack of Input Validation Identified,DoS Vulnerability Identified
"<INFO> Integer Overflow/Underflow Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Reentrancy Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unchecked External Calls Identified."".
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unchecked Low-level Calls Identified."".
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Transactions Order Dependence Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades
'''
```
If you don't find any Transactions Order Dependence vulnerabilities, respond only with: ""","<INFO> Timestamp Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Predictable Randomness Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unsafe `tx.origin` Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unsafe Suicide Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Lack of Restriction on `selfdestruct` is found, respond only with: ""","<INFO> Gas Limit Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Price Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Assumption of Fixed-Length Array Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Withdrawal Function Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If a secure withdrawal function is found and no issues are identified, respond only with: ""","<INFO> Lack of Authorization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Lack of Authorization vulnerabilities are found, respond only with: ""","<INFO> Potential Data Inconsistency Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Potential Data Inconsistency vulnerabilities are found, respond only with: ""","<INFO> Hash Collision Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Hash Collision vulnerabilities are found, respond only with: ""","<INFO> Uninitialized Return Variable Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Uninitialized Return Variable vulnerabilities are found, respond only with: ""","<INFO> Misdeclared Constructor Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Misdeclared Constructor vulnerabilities are found, respond only with: ""","<INFO> Missing 'onlyOwner' Modifier Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Misuse of `msg.value` within a Loop Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Precision Loss Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Redundant Conditional Check Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> External Oracle Dependency Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: """,,"<INFO> Centralization Risk Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Incorrect Funding Rate Calculation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Flash Loan Fee Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Misuse of Mapping Getter Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Getter Function Implementation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unnecessary Comparison Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Inconsistent Initialization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Potential Inconsistency in Yield Source Swapping Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Incorrect Signer Verification Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Order of Inheritance Initialization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Impracticality of Exact Match Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Inconsistent Base Tokens Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Handling Partial Withdrawals Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Fallback Function Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unlimited Token Approval Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Input Validation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> DoS Vulnerability Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades.
'''
```
If you don't find any vulnerabilities, respond only with: """
,,,"<INFO> Unchecked Low-level Calls Identified.

```
UNCHECKED LOW-LEVEL CALL
'''
In the `withdraw` function of the `BentoBoxV1` contract, there is a low-level call made to transfer ETH to the `to` address after withdrawing from the WETH contract. The line:
(bool success, ) = to.call{value: amount}("""");
This call does not check if the transfer was successful. If the transfer fails (for example, if the `to` address is a contract that does not accept ETH), the transaction will not revert, and the contract will not handle the failure properly. This could lead to a loss of funds as the user may not receive their withdrawn amount.

Recommended Mitigation:
Replace the low-level call with a safer alternative that checks for success, such as using `require` to ensure the transfer was successful:
require(success, ""BentoBox: ETH transfer failed"");
'''
```

```
UNCHECKED LOW-LEVEL CALL
'''
In the `flashLoan` function, the contract calls the `onFlashLoan` method on the borrower without checking if the call succeeds. The line:
borrower.onFlashLoan(msg.sender, token, amount, fee, data);
If the `onFlashLoan` function in the borrower contract fails, the transaction will not revert, and the contract will not handle the failure properly. This could lead to a situation where the loan is not repaid correctly, potentially resulting in a loss of funds.

Recommended Mitigation:
Wrap the call in a require statement to ensure that the call succeeds:
require(borrower.onFlashLoan(msg.sender, token, amount, fee, data), ""BentoBox: Flash loan callback failed"");
'''
```

```
UNCHECKED LOW-LEVEL CALL
'''
In the `batchFlashLoan` function, similar to the `flashLoan` function, the contract calls the `onBatchFlashLoan` method on the borrower without checking if the call succeeds. The line:
borrower.onBatchFlashLoan(msg.sender, tokens, amounts, fees, data);
Again, if the `onBatchFlashLoan` function in the borrower contract fails, the transaction will not revert, and the contract will not handle the failure properly, leading to potential loss of funds.

Recommended Mitigation:
Wrap the call in a require statement to ensure that the call succeeds:
require(borrower.onBatchFlashLoan(msg.sender, tokens, amounts, fees, data), ""BentoBox: Batch flash loan callback failed"");
'''
```

[2024-15-08 17:06:30 INFO] **[Seminar Conclusion]**:

 ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,"<INFO> Unchecked Low-level Calls Identified.

```
UNCHECKED LOW-LEVEL CALL
'''
In the `withdraw` function of the `BentoBoxV1` contract, there is a low-level call made to transfer ETH to the `to` address after withdrawing from the WETH contract. The line:
(bool success, ) = to.call{value: amount}("""");
This call does not check if the transfer was successful. If the transfer fails (for example, if the `to` address is a contract that does not accept ETH), the transaction will not revert, and the contract will not handle the failure properly. This could lead to a loss of funds as the user may not receive their withdrawn amount.

Recommended Mitigation:
Replace the low-level call with a safer alternative that checks for success, such as using `require` to ensure the transfer was successful:
require(success, ""BentoBox: ETH transfer failed"");
'''
```

```
UNCHECKED LOW-LEVEL CALL
'''
In the `flashLoan` function, the contract calls the `onFlashLoan` method on the borrower without checking if the call succeeds. The line:
borrower.onFlashLoan(msg.sender, token, amount, fee, data);
If the `onFlashLoan` function in the borrower contract fails, the transaction will not revert, and the contract will not handle the failure properly. This could lead to a situation where the loan is not repaid correctly, potentially resulting in a loss of funds.

Recommended Mitigation:
Wrap the call in a require statement to ensure that the call succeeds:
require(borrower.onFlashLoan(msg.sender, token, amount, fee, data), ""BentoBox: Flash loan callback failed"");
'''
```

```
UNCHECKED LOW-LEVEL CALL
'''
In the `batchFlashLoan` function, similar to the `flashLoan` function, the contract calls the `onBatchFlashLoan` method on the borrower without checking if the call succeeds. The line:
borrower.onBatchFlashLoan(msg.sender, tokens, amounts, fees, data);
Again, if the `onBatchFlashLoan` function in the borrower contract fails, the transaction will not revert, and the contract will not handle the failure properly, leading to potential loss of funds.

Recommended Mitigation:
Wrap the call in a require statement to ensure that the call succeeds:
require(borrower.onBatchFlashLoan(msg.sender, tokens, amounts, fees, data), ""BentoBox: Batch flash loan callback failed"");
'''
```

[2024-15-08 17:06:30 INFO] **[Execute Detail]**

execute SimplePhase:[TODDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-15-08 17:06:30 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED // The BentoBox //  ▄▄▄▄· ▄▄▄ . ▐ ▄ ▄▄▄▄▄      ▄▄▄▄·       ▐▄• ▄ //  ▐█ ▀█▪▀▄.▀·█▌▐█•██  ▪     ▐█ ▀█▪▪      █▌█▌▪ //  ▐█▀▀█▄▐▀▀▪▄▐█▐▐▌ ▐█.▪ ▄█▀▄ ▐█▀▀█▄ ▄█▀▄  ·██· //  ██▄▪▐█▐█▄▄▌██▐█▌ ▐█▌·▐█▌.▐▌██▄▪▐█▐█▌.▐▌▪▐█·█▌ //  ·▀▀▀▀  ▀▀▀ ▀▀ █▪ ▀▀▀  ▀█▄▀▪·▀▀▀▀  ▀█▄▀▪•▀▀ ▀▀ // This contract stores funds, handles their transfers, supports flash loans and strategies. // Copyright (c) 2021 BoringCrypto - All rights reserved // Twitter: @Boring_Crypto // Special thanks to Keno for all his hard work and support // Version 22-Mar-2021 pragma solidity 0.6.12; pragma experimental ABIEncoderV2; // solhint-disable avoid-low-level-calls // solhint-disable not-rely-on-time // solhint-disable no-inline-assembly // File @boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol@v1.2.0 // License-Identifier: MIT interface IERC20 {     function totalSupply() external view returns (uint256); function balanceOf(address account) external view returns (uint256);  function allowance(address owner, address spender) external view returns (uint256);  function approve(address spender, uint256 amount) external returns (bool);  event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value);  /// @notice EIP 2612 function permit(     address owner,     address spender,     uint256 value,     uint256 deadline,     uint8 v,     bytes32 r,     bytes32 s ) external;  } // File contracts/interfaces/IFlashLoan.sol // License-Identifier: MIT interface IFlashBorrower {     /// @notice The flashloan callback. amount + fee needs to repayed to msg.sender before this call returns.     /// @param sender The address of the invoker of this flashloan.     /// @param token The address of the token that is loaned.     /// @param amount of the token that is loaned.     /// @param fee The fee that needs to be paid on top for this loan. Needs to be the same as token.     /// @param data Additional data that was passed to the flashloan function.     function onFlashLoan(         address sender,         IERC20 token,         uint256 amount,         uint256 fee,         bytes calldata data     ) external; } interface IBatchFlashBorrower {     /// @notice The callback for batched flashloans. Every amount + fee needs to repayed to msg.sender before this call returns.     /// @param sender The address of the invoker of this flashloan.     /// @param tokens Array of addresses for ERC-20 tokens that is loaned.     /// @param amounts A one-to-one map to tokens that is loaned.     /// @param fees A one-to-one map to tokens that needs to be paid on top for each loan. Needs to be the same token.     /// @param data Additional data that was passed to the flashloan function.     function onBatchFlashLoan(         address sender,         IERC20[] calldata tokens,         uint256[] calldata amounts,         uint256[] calldata fees,         bytes calldata data     ) external; } // File contracts/interfaces/IWETH.sol // License-Identifier: MIT interface IWETH {     function deposit() external payable; function withdraw(uint256) external;  } // File contracts/interfaces/IStrategy.sol // License-Identifier: MIT interface IStrategy {     /// @notice Send the assets to the Strategy and call skim to invest them.     /// @param amount The amount of tokens to invest.     function skim(uint256 amount) external; /// @notice Harvest any profits made converted to the asset and pass them to the caller. /// @param balance The amount of tokens the caller thinks it has invested. /// @param sender The address of the initiator of this transaction. Can be used for reimbursements, etc. /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`. function harvest(uint256 balance, address sender) external returns (int256 amountAdded);  /// @notice Withdraw assets. The returned amount can differ from the requested amount due to rounding. /// @dev The `actualAmount` should be very close to the amount. /// The difference should NOT be used to report a loss. That's what harvest is for. /// @param amount The requested amount the caller wants to withdraw. /// @return actualAmount The real amount that is withdrawn. function withdraw(uint256 amount) external returns (uint256 actualAmount);  /// @notice Withdraw all assets in the safest way possible. This shouldn't fail. /// @param balance The amount of tokens the caller thinks it has invested. /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`. function exit(uint256 balance) external returns (int256 amountAdded);  } // File @boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol@v1.2.0 // License-Identifier: MIT library BoringERC20 {     bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()     bytes4 private constant SIG_NAME = 0x06fdde03; // name()     bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()     bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)     bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256) /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations. /// Reverts on a failed transfer. /// @param token The address of the ERC-20 token. /// @param to Transfer tokens to. /// @param amount The token amount. function safeTransfer(     IERC20 token,     address to,     uint256 amount ) internal {     (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));     require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), ""BoringERC20: Transfer failed""); }  /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations. /// Reverts on a failed transfer. /// @param token The address of the ERC-20 token. /// @param from Transfer tokens from. /// @param to Transfer tokens to. /// @param amount The token amount. function safeTransferFrom(     IERC20 token,     address from,     address to,     uint256 amount ) internal {     (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));     require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), ""BoringERC20: TransferFrom failed""); }  } // File @boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol@v1.2.0 // License-Identifier: MIT /// @notice A library for performing overflow-/underflow-safe math, /// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math). library BoringMath {     function add(uint256 a, uint256 b) internal pure returns (uint256 c) {         require((c = a + b) &gt;= b, ""BoringMath: Add Overflow"");     } function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {     require((c = a - b) &lt;= a, ""BoringMath: Underflow""); }  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {     require(b == 0 || (c = a * b) / b == a, ""BoringMath: Mul Overflow""); }  function to128(uint256 a) internal pure returns (uint128 c) {     require(a &lt;= uint128(-1), ""BoringMath: uint128 Overflow"");     c = uint128(a); }  function to64(uint256 a) internal pure returns (uint64 c) {     require(a &lt;= uint64(-1), ""BoringMath: uint64 Overflow"");     c = uint64(a); }  function to32(uint256 a) internal pure returns (uint32 c) {     require(a &lt;= uint32(-1), ""BoringMath: uint32 Overflow"");     c = uint32(a); }  } /// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint128. library BoringMath128 {     function add(uint128 a, uint128 b) internal pure returns (uint128 c) {         require((c = a + b) &gt;= b, ""BoringMath: Add Overflow"");     } function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {     require((c = a - b) &lt;= a, ""BoringMath: Underflow""); }  } /// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint64. library BoringMath64 {     function add(uint64 a, uint64 b) internal pure returns (uint64 c) {         require((c = a + b) &gt;= b, ""BoringMath: Add Overflow"");     } function sub(uint64 a, uint64 b) internal pure returns (uint64 c) {     require((c = a - b) &lt;= a, ""BoringMath: Underflow""); }  } /// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint32. library BoringMath32 {     function add(uint32 a, uint32 b) internal pure returns (uint32 c) {         require((c = a + b) &gt;= b, ""BoringMath: Add Overflow"");     } function sub(uint32 a, uint32 b) internal pure returns (uint32 c) {     require((c = a - b) &lt;= a, ""BoringMath: Underflow""); }  } // File @boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol@v1.2.0 // License-Identifier: MIT struct Rebase {     uint128 elastic;     uint128 base; } /// @notice A rebasing library using overflow-/underflow-safe math. library RebaseLibrary {     using BoringMath for uint256;     using BoringMath128 for uint128; /// @notice Calculates the base value in relationship to `elastic` and `total`. function toBase(     Rebase memory total,     uint256 elastic,     bool roundUp ) internal pure returns (uint256 base) {     if (total.elastic == 0) {         base = elastic;     } else {         base = elastic.mul(total.base) / total.elastic;         if (roundUp &amp;&amp; base.mul(total.elastic) / total.base &lt; elastic) {             base = base.add(1);         }     } }  /// @notice Calculates the elastic value in relationship to `base` and `total`. function toElastic(     Rebase memory total,     uint256 base,     bool roundUp ) internal pure returns (uint256 elastic) {     if (total.base == 0) {         elastic = base;     } else {         elastic = base.mul(total.elastic) / total.base;         if (roundUp &amp;&amp; elastic.mul(total.base) / total.elastic &lt; base) {             elastic = elastic.add(1);         }     } }  /// @notice Add `elastic` to `total` and doubles `total.base`. /// @return (Rebase) The new total. /// @return base in relationship to `elastic`. function add(     Rebase memory total,     uint256 elastic,     bool roundUp ) internal pure returns (Rebase memory, uint256 base) {     base = toBase(total, elastic, roundUp);     total.elastic = total.elastic.add(elastic.to128());     total.base = total.base.add(base.to128());     return (total, base); }  /// @notice Sub `base` from `total` and update `total.elastic`. /// @return (Rebase) The new total. /// @return elastic in relationship to `base`. function sub(     Rebase memory total,     uint256 base,     bool roundUp ) internal pure returns (Rebase memory, uint256 elastic) {     elastic = toElastic(total, base, roundUp);     total.elastic = total.elastic.sub(elastic.to128());     total.base = total.base.sub(base.to128());     return (total, elastic); }  /// @notice Add `elastic` and `base` to `total`. function add(     Rebase memory total,     uint256 elastic,     uint256 base ) internal pure returns (Rebase memory) {     total.elastic = total.elastic.add(elastic.to128());     total.base = total.base.add(base.to128());     return total; }  /// @notice Subtract `elastic` and `base` to `total`. function sub(     Rebase memory total,     uint256 elastic,     uint256 base ) internal pure returns (Rebase memory) {     total.elastic = total.elastic.sub(elastic.to128());     total.base = total.base.sub(base.to128());     return total; }  /// @notice Add `elastic` to `total` and update storage. /// @return newElastic Returns updated `elastic`. function addElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {     newElastic = total.elastic = total.elastic.add(elastic.to128()); }  /// @notice Subtract `elastic` from `total` and update storage. /// @return newElastic Returns updated `elastic`. function subElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {     newElastic = total.elastic = total.elastic.sub(elastic.to128()); }  } // File @boringcrypto/boring-solidity/contracts/BoringOwnable.sol@v1.2.0 // License-Identifier: MIT // Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol // Edited by BoringCrypto contract BoringOwnableData {     address public owner;     address public pendingOwner; } contract BoringOwnable is BoringOwnableData {     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /// @notice `owner` defaults to msg.sender on construction. constructor() public {     owner = msg.sender;     emit OwnershipTransferred(address(0), msg.sender); }  /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner. /// Can only be invoked by the current `owner`. /// @param newOwner Address of the new owner. /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`. /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise. function transferOwnership(     address newOwner,     bool direct,     bool renounce ) public onlyOwner {     if (direct) {         // Checks         require(newOwner != address(0) || renounce, ""Ownable: zero address"");          // Effects         emit OwnershipTransferred(owner, newOwner);         owner = newOwner;         pendingOwner = address(0);     } else {         // Effects         pendingOwner = newOwner;     } }  /// @notice Needs to be called by `pendingOwner` to claim ownership. function claimOwnership() public {     address _pendingOwner = pendingOwner;      // Checks     require(msg.sender == _pendingOwner, ""Ownable: caller != pending owner"");      // Effects     emit OwnershipTransferred(owner, _pendingOwner);     owner = _pendingOwner;     pendingOwner = address(0); }  /// @notice Only allows the `owner` to execute the function. modifier onlyOwner() {     require(msg.sender == owner, ""Ownable: caller is not the owner"");     _; }  } // File @boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol@v1.2.0 // License-Identifier: MIT interface IMasterContract {     /// @notice Init function that gets called from BoringFactory.deploy.     /// Also kown as the constructor for cloned contracts.     /// Any ETH send to BoringFactory.deploy ends up here.     /// @param data Can be abi encoded arguments or anything else.     function init(bytes calldata data) external payable; } // File @boringcrypto/boring-solidity/contracts/BoringFactory.sol@v1.2.0 // License-Identifier: MIT contract BoringFactory {     event LogDeploy(address indexed masterContract, bytes data, address indexed cloneAddress); /// @notice Mapping from clone contracts to their masterContract. mapping(address =&gt; address) public masterContractOf;  /// @notice Deploys a given master Contract as a clone. /// Any ETH transferred with this call is forwarded to the new clone. /// Emits `LogDeploy`. /// @param masterContract The address of the contract to clone. /// @param data Additional abi encoded calldata that is passed to the new clone via `IMasterContract.init`. /// @param useCreate2 Creates the clone by using the CREATE2 opcode, in this case `data` will be used as salt. /// @return cloneAddress Address of the created clone contract. function deploy(     address masterContract,     bytes calldata data,     bool useCreate2 ) public payable returns (address cloneAddress) {     require(masterContract != address(0), ""BoringFactory: No masterContract"");     bytes20 targetBytes = bytes20(masterContract); // Takes the first 20 bytes of the masterContract's address      if (useCreate2) {         // each masterContract has different code already. So clones are distinguished by their data only.         bytes32 salt = keccak256(data);          // Creates clone, more info here: https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/         assembly {             let clone := mload(0x40)             mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)             mstore(add(clone, 0x14), targetBytes)             mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)             cloneAddress := create2(0, clone, 0x37, salt)         }     } else {         assembly {             let clone := mload(0x40)             mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)             mstore(add(clone, 0x14), targetBytes)             mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)             cloneAddress := create(0, clone, 0x37)         }     }     masterContractOf[cloneAddress] = masterContract;      IMasterContract(cloneAddress).init{value: msg.value}(data);      emit LogDeploy(masterContract, data, cloneAddress); }  } // File contracts/MasterContractManager.sol // License-Identifier: UNLICENSED contract MasterContractManager is BoringOwnable, BoringFactory {     event LogWhiteListMasterContract(address indexed masterContract, bool approved);     event LogSetMasterContractApproval(address indexed masterContract, address indexed user, bool approved);     event LogRegisterProtocol(address indexed protocol); /// @notice masterContract to user to approval state mapping(address =&gt; mapping(address =&gt; bool)) public masterContractApproved; /// @notice masterContract to whitelisted state for approval without signed message mapping(address =&gt; bool) public whitelistedMasterContracts; /// @notice user nonces for masterContract approvals mapping(address =&gt; uint256) public nonces;  bytes32 private constant DOMAIN_SEPARATOR_SIGNATURE_HASH = keccak256(""EIP712Domain(string name,uint256 chainId,address verifyingContract)""); // See https://eips.ethereum.org/EIPS/eip-191 string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = ""\x19\x01""; bytes32 private constant APPROVAL_SIGNATURE_HASH =     keccak256(""SetMasterContractApproval(string warning,address user,address masterContract,bool approved,uint256 nonce)"");  // solhint-disable-next-line var-name-mixedcase bytes32 private immutable _DOMAIN_SEPARATOR; // solhint-disable-next-line var-name-mixedcase uint256 private immutable DOMAIN_SEPARATOR_CHAIN_ID;  constructor() public {     uint256 chainId;     assembly {         chainId := chainid()     }     _DOMAIN_SEPARATOR = _calculateDomainSeparator(DOMAIN_SEPARATOR_CHAIN_ID = chainId); }  function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {     return keccak256(abi.encode(DOMAIN_SEPARATOR_SIGNATURE_HASH, keccak256(""BentoBox V1""), chainId, address(this))); }  // solhint-disable-next-line func-name-mixedcase function DOMAIN_SEPARATOR() public view returns (bytes32) {     uint256 chainId;     assembly {         chainId := chainid()     }     return chainId == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId); }  /// @notice Other contracts need to register with this master contract so that users can approve them for the BentoBox. function registerProtocol() public {     masterContractOf[msg.sender] = msg.sender;     emit LogRegisterProtocol(msg.sender); }  /// @notice Enables or disables a contract for approval without signed message. function whitelistMasterContract(address masterContract, bool approved) public onlyOwner {     // Checks     require(masterContract != address(0), ""MasterCMgr: Cannot approve 0"");      // Effects     whitelistedMasterContracts[masterContract] = approved;     emit LogWhiteListMasterContract(masterContract, approved); }  /// @notice Approves or revokes a `masterContract` access to `user` funds. /// @param user The address of the user that approves or revokes access. /// @param masterContract The address who gains or loses access. /// @param approved If True approves access. If False revokes access. /// @param v Part of the signature. (See EIP-191) /// @param r Part of the signature. (See EIP-191) /// @param s Part of the signature. (See EIP-191) // F4 - Check behaviour for all function arguments when wrong or extreme // F4: Don't allow masterContract 0 to be approved. Unknown contracts will have a masterContract of 0. // F4: User can't be 0 for signed approvals because the recoveredAddress will be 0 if ecrecover fails function setMasterContractApproval(     address user,     address masterContract,     bool approved,     uint8 v,     bytes32 r,     bytes32 s ) public {     // Checks     require(masterContract != address(0), ""MasterCMgr: masterC not set""); // Important for security      // If no signature is provided, the fallback is executed     if (r == 0 &amp;&amp; s == 0 &amp;&amp; v == 0) {         require(user == msg.sender, ""MasterCMgr: user not sender"");         require(masterContractOf[user] == address(0), ""MasterCMgr: user is clone"");         require(whitelistedMasterContracts[masterContract], ""MasterCMgr: not whitelisted"");     } else {         // Important for security - any address without masterContract has address(0) as masterContract         // So approving address(0) would approve every address, leading to full loss of funds         // Also, ecrecover returns address(0) on failure. So we check this:         require(user != address(0), ""MasterCMgr: User cannot be 0"");          // C10 - Protect signatures against replay, use nonce and chainId (SWC-121)         // C10: nonce + chainId are used to prevent replays         // C11 - All signatures strictly EIP-712 (SWC-117 SWC-122)         // C11: signature is EIP-712 compliant         // C12 - abi.encodePacked can't contain variable length user input (SWC-133)         // C12: abi.encodePacked has fixed length parameters         bytes32 digest =             keccak256(                 abi.encodePacked(                     EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA,                     DOMAIN_SEPARATOR(),                     keccak256(                         abi.encode(                             APPROVAL_SIGNATURE_HASH,                             approved                                 ? keccak256(""Give FULL access to funds in (and approved to) BentoBox?"")                                 : keccak256(""Revoke access to BentoBox?""),                             user,                             masterContract,                             approved,                             nonces[user]++                         )                     )                 )             );         address recoveredAddress = ecrecover(digest, v, r, s);         require(recoveredAddress == user, ""MasterCMgr: Invalid Signature"");     }      // Effects     masterContractApproved[masterContract][user] = approved;     emit LogSetMasterContractApproval(masterContract, user, approved); }  } // File @boringcrypto/boring-solidity/contracts/BoringBatchable.sol@v1.2.0 // License-Identifier: MIT contract BaseBoringBatchable {     /// @dev Helper function to extract a useful revert message from a failed call.     /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.     function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {         // If the _res length is less than 68, then the transaction failed silently (without a revert message)         if (_returnData.length &lt; 68) return ""Transaction reverted silently"";     assembly {         // Slice the sighash.         _returnData := add(_returnData, 0x04)     }     return abi.decode(_returnData, (string)); // All that remains is the revert string }  /// @notice Allows batched call to self (this contract). /// @param calls An array of inputs for each call. /// @param revertOnFail If True then reverts after a failed call and stops doing further calls. /// @return successes An array indicating the success of a call, mapped one-to-one to `calls`. /// @return results An array with the returned data of each function call, mapped one-to-one to `calls`. // F1: External is ok here because this is the batch function, adding it to a batch makes no sense // F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value // C3: The length of the loop is fully under user control, so can't be exploited // C7: Delegatecall is only used on the same contract, so it's safe function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results) {     successes = new bool[](calls.length);     results = new bytes[](calls.length);     for (uint256 i = 0; i &lt; calls.length; i++) {         (bool success, bytes memory result) = address(this).delegatecall(calls[i]);         require(success || !revertOnFail, _getRevertMsg(result));         successes[i] = success;         results[i] = result;     } }  } contract BoringBatchable is BaseBoringBatchable {     /// @notice Call wrapper that performs ERC20.permit on token.     /// Lookup IERC20.permit.     // F6: Parameters can be used front-run the permit and the user's permit will fail (due to nonce or other revert)     //     if part of a batch this could be used to grief once as the second call would not need the permit     function permitToken(         IERC20 token,         address from,         address to,         uint256 amount,         uint256 deadline,         uint8 v,         bytes32 r,         bytes32 s     ) public {         token.permit(from, to, amount, deadline, v, r, s);     } } // File contracts/BentoBox.sol // License-Identifier: UNLICENSED /// @title BentoBox /// @author BoringCrypto, Keno /// @notice The BentoBox is a vault for tokens. The stored tokens can be flash loaned and used in strategies. /// Yield from this will go to the token depositors. /// Rebasing tokens ARE NOT supported and WILL cause loss of funds. /// Any funds transfered directly onto the BentoBox will be lost, use the deposit function instead. contract BentoBoxV1 is MasterContractManager, BoringBatchable {     using BoringMath for uint256;     using BoringMath128 for uint128;     using BoringERC20 for IERC20;     using RebaseLibrary for Rebase; // ************** // // *** EVENTS *** // // ************** //  event LogDeposit(IERC20 indexed token, address indexed from, address indexed to, uint256 amount, uint256 share); event LogWithdraw(IERC20 indexed token, address indexed from, address indexed to, uint256 amount, uint256 share); event LogTransfer(IERC20 indexed token, address indexed from, address indexed to, uint256 share);  event LogFlashLoan(address indexed borrower, IERC20 indexed token, uint256 amount, uint256 feeAmount, address indexed receiver);  event LogStrategyTargetPercentage(IERC20 indexed token, uint256 targetPercentage); event LogStrategyQueued(IERC20 indexed token, IStrategy indexed strategy); event LogStrategySet(IERC20 indexed token, IStrategy indexed strategy); event LogStrategyInvest(IERC20 indexed token, uint256 amount); event LogStrategyDivest(IERC20 indexed token, uint256 amount); event LogStrategyProfit(IERC20 indexed token, uint256 amount); event LogStrategyLoss(IERC20 indexed token, uint256 amount);  // *************** // // *** STRUCTS *** // // *************** //  struct StrategyData {     uint64 strategyStartDate;     uint64 targetPercentage;     uint128 balance; // the balance of the strategy that BentoBox thinks is in there }  // ******************************** // // *** CONSTANTS AND IMMUTABLES *** // // ******************************** //  // V2 - Can they be private? // V2: Private to save gas, to verify it's correct, check the constructor arguments IERC20 private immutable wethToken;  IERC20 private constant USE_ETHEREUM = IERC20(0); uint256 private constant FLASH_LOAN_FEE = 50; // 0.05% uint256 private constant FLASH_LOAN_FEE_PRECISION = 1e5; uint256 private constant STRATEGY_DELAY = 2 weeks; uint256 private constant MAX_TARGET_PERCENTAGE = 95; // 95% uint256 private constant MINIMUM_SHARE_BALANCE = 1000; // To prevent the ratio going off  // ***************** // // *** VARIABLES *** // // ***************** //  // Balance per token per address/contract in shares mapping(IERC20 =&gt; mapping(address =&gt; uint256)) public balanceOf;  // Rebase from amount to share mapping(IERC20 =&gt; Rebase) public totals;  mapping(IERC20 =&gt; IStrategy) public strategy; mapping(IERC20 =&gt; IStrategy) public pendingStrategy; mapping(IERC20 =&gt; StrategyData) public strategyData;  // ******************* // // *** CONSTRUCTOR *** // // ******************* //  constructor(IERC20 wethToken_) public {     wethToken = wethToken_; }  // ***************** // // *** MODIFIERS *** // // ***************** //  /// Modifier to check if the msg.sender is allowed to use funds belonging to the 'from' address. /// If 'from' is msg.sender, it's allowed. /// If 'from' is the BentoBox itself, it's allowed. Any ETH, token balances (above the known balances) or BentoBox balances /// can be taken by anyone. /// This is to enable skimming, not just for deposits, but also for withdrawals or transfers, enabling better composability. /// If 'from' is a clone of a masterContract AND the 'from' address has approved that masterContract, it's allowed. modifier allowed(address from) {     if (from != msg.sender &amp;&amp; from != address(this)) {         // From is sender or you are skimming         address masterContract = masterContractOf[msg.sender];         require(masterContract != address(0), ""BentoBox: no masterContract"");         require(masterContractApproved[masterContract][from], ""BentoBox: Transfer not approved"");     }     _; }  // ************************** // // *** INTERNAL FUNCTIONS *** // // ************************** //  /// @dev Returns the total balance of `token` this contracts holds, /// plus the total amount this contract thinks the strategy holds. function _tokenBalanceOf(IERC20 token) internal view returns (uint256 amount) {     amount = token.balanceOf(address(this)).add(strategyData[token].balance); }  // ************************ // // *** PUBLIC FUNCTIONS *** // // ************************ //  /// @dev Helper function to represent an `amount` of `token` in shares. /// @param token The ERC-20 token. /// @param amount The `token` amount. /// @param roundUp If the result `share` should be rounded up. /// @return share The token amount represented in shares. function toShare(     IERC20 token,     uint256 amount,     bool roundUp ) external view returns (uint256 share) {     share = totals[token].toBase(amount, roundUp); }  /// @dev Helper function represent shares back into the `token` amount. /// @param token The ERC-20 token. /// @param share The amount of shares. /// @param roundUp If the result should be rounded up. /// @return amount The share amount back into native representation. function toAmount(     IERC20 token,     uint256 share,     bool roundUp ) external view returns (uint256 amount) {     amount = totals[token].toElastic(share, roundUp); }  /// @notice Deposit an amount of `token` represented in either `amount` or `share`. /// @param token_ The ERC-20 token to deposit. /// @param from which account to pull the tokens. /// @param to which account to push the tokens. /// @param amount Token amount in native representation to deposit. /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`. /// @return amountOut The amount deposited. /// @return shareOut The deposited amount repesented in shares. function deposit(     IERC20 token_,     address from,     address to,     uint256 amount,     uint256 share ) public payable allowed(from) returns (uint256 amountOut, uint256 shareOut) {     // Checks     require(to != address(0), ""BentoBox: to not set""); // To avoid a bad UI from burning funds      // Effects     IERC20 token = token_ == USE_ETHEREUM ? wethToken : token_;     Rebase memory total = totals[token];      // If a new token gets added, the tokenSupply call checks that this is a deployed contract. Needed for security.     require(total.elastic != 0 || token.totalSupply() &gt; 0, ""BentoBox: No tokens"");     if (share == 0) {         // value of the share may be lower than the amount due to rounding, that's ok         share = total.toBase(amount, false);         // Any deposit should lead to at least the minimum share balance, otherwise it's ignored (no amount taken)         if (total.base.add(share.to128()) &lt; MINIMUM_SHARE_BALANCE) {             return (0, 0);         }     } else {         // amount may be lower than the value of share due to rounding, in that case, add 1 to amount (Always round up)         amount = total.toElastic(share, true);     }      // In case of skimming, check that only the skimmable amount is taken.     // For ETH, the full balance is available, so no need to check.     // During flashloans the _tokenBalanceOf is lower than 'reality', so skimming deposits will mostly fail during a flashloan.     require(         from != address(this) || token_ == USE_ETHEREUM || amount &lt;= _tokenBalanceOf(token).sub(total.elastic),         ""BentoBox: Skim too much""     );      balanceOf[token][to] = balanceOf[token][to].add(share);     total.base = total.base.add(share.to128());     total.elastic = total.elastic.add(amount.to128());     totals[token] = total;      // Interactions     // During the first deposit, we check that this token is 'real'     if (token_ == USE_ETHEREUM) {         // X2 - If there is an error, could it cause a DoS. Like balanceOf causing revert. (SWC-113)         // X2: If the WETH implementation is faulty or malicious, it will block adding ETH (but we know the WETH implementation)         IWETH(address(wethToken)).deposit{value: amount}();     } else if (from != address(this)) {         // X2 - If there is an error, could it cause a DoS. Like balanceOf causing revert. (SWC-113)         // X2: If the token implementation is faulty or malicious, it may block adding tokens. Good.         token.safeTransferFrom(from, address(this), amount);     }     emit LogDeposit(token, from, to, amount, share);     amountOut = amount;     shareOut = share; }  /// @notice Withdraws an amount of `token` from a user account. /// @param token_ The ERC-20 token to withdraw. /// @param from which user to pull the tokens. /// @param to which user to push the tokens. /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied. /// @param share Like above, but `share` takes precedence over `amount`. function withdraw(     IERC20 token_,     address from,     address to,     uint256 amount,     uint256 share ) public allowed(from) returns (uint256 amountOut, uint256 shareOut) {     // Checks     require(to != address(0), ""BentoBox: to not set""); // To avoid a bad UI from burning funds      // Effects     IERC20 token = token_ == USE_ETHEREUM ? wethToken : token_;     Rebase memory total = totals[token];     if (share == 0) {         // value of the share paid could be lower than the amount paid due to rounding, in that case, add a share (Always round up)         share = total.toBase(amount, true);     } else {         // amount may be lower than the value of share due to rounding, that's ok         amount = total.toElastic(share, false);     }      balanceOf[token][from] = balanceOf[token][from].sub(share);     total.elastic = total.elastic.sub(amount.to128());     total.base = total.base.sub(share.to128());     // There have to be at least 1000 shares left to prevent reseting the share/amount ratio (unless it's fully emptied)     require(total.base &gt;= MINIMUM_SHARE_BALANCE || total.base == 0, ""BentoBox: cannot empty"");     totals[token] = total;      // Interactions     if (token_ == USE_ETHEREUM) {         // X2, X3: A revert or big gas usage in the WETH contract could block withdrawals, but WETH9 is fine.         IWETH(address(wethToken)).withdraw(amount);         // X2, X3: A revert or big gas usage could block, however, the to address is under control of the caller.         (bool success, ) = to.call{value: amount}("""");         require(success, ""BentoBox: ETH transfer failed"");     } else {         // X2, X3: A malicious token could block withdrawal of just THAT token.         //         masterContracts may want to take care not to rely on withdraw always succeeding.         token.safeTransfer(to, amount);     }     emit LogWithdraw(token, from, to, amount, share);     amountOut = amount;     shareOut = share; }  /// @notice Transfer shares from a user account to another one. /// @param token The ERC-20 token to transfer. /// @param from which user to pull the tokens. /// @param to which user to push the tokens. /// @param share The amount of `token` in shares. // Clones of master contracts can transfer from any account that has approved them // F3 - Can it be combined with another similar function? // F3: This isn't combined with transferMultiple for gas optimization function transfer(     IERC20 token,     address from,     address to,     uint256 share ) public allowed(from) {     // Checks     require(to != address(0), ""BentoBox: to not set""); // To avoid a bad UI from burning funds      // Effects     balanceOf[token][from] = balanceOf[token][from].sub(share);     balanceOf[token][to] = balanceOf[token][to].add(share);      emit LogTransfer(token, from, to, share); }  /// @notice Transfer shares from a user account to multiple other ones. /// @param token The ERC-20 token to transfer. /// @param from which user to pull the tokens. /// @param tos The receivers of the tokens. /// @param shares The amount of `token` in shares for each receiver in `tos`. // F3 - Can it be combined with another similar function? // F3: This isn't combined with transfer for gas optimization function transferMultiple(     IERC20 token,     address from,     address[] calldata tos,     uint256[] calldata shares ) public allowed(from) {     // Checks     require(tos[0] != address(0), ""BentoBox: to[0] not set""); // To avoid a bad UI from burning funds      // Effects     uint256 totalAmount;     uint256 len = tos.length;     for (uint256 i = 0; i &lt; len; i++) {         address to = tos[i];         balanceOf[token][to] = balanceOf[token][to].add(shares[i]);         totalAmount = totalAmount.add(shares[i]);         emit LogTransfer(token, from, to, shares[i]);     }     balanceOf[token][from] = balanceOf[token][from].sub(totalAmount); }  /// @notice Flashloan ability. /// @param borrower The address of the contract that implements and conforms to `IFlashBorrower` and handles the flashloan. /// @param receiver Address of the token receiver. /// @param token The address of the token to receive. /// @param amount of the tokens to receive. /// @param data The calldata to pass to the `borrower` contract. // F5 - Checks-Effects-Interactions pattern followed? (SWC-107) // F5: Not possible to follow this here, reentrancy has been reviewed // F6 - Check for front-running possibilities, such as the approve function (SWC-114) // F6: Slight grieving possible by withdrawing an amount before someone tries to flashloan close to the full amount. function flashLoan(     IFlashBorrower borrower,     address receiver,     IERC20 token,     uint256 amount,     bytes calldata data ) public {     uint256 fee = amount.mul(FLASH_LOAN_FEE) / FLASH_LOAN_FEE_PRECISION;     token.safeTransfer(receiver, amount);      borrower.onFlashLoan(msg.sender, token, amount, fee, data);      require(_tokenBalanceOf(token) &gt;= totals[token].addElastic(fee.to128()), ""BentoBox: Wrong amount"");     emit LogFlashLoan(address(borrower), token, amount, fee, receiver); }  /// @notice Support for batched flashloans. Useful to request multiple different `tokens` in a single transaction. /// @param borrower The address of the contract that implements and conforms to `IBatchFlashBorrower` and handles the flashloan. /// @param receivers An array of the token receivers. A one-to-one mapping with `tokens` and `amounts`. /// @param tokens The addresses of the tokens. /// @param amounts of the tokens for each receiver. /// @param data The calldata to pass to the `borrower` contract. // F5 - Checks-Effects-Interactions pattern followed? (SWC-107) // F5: Not possible to follow this here, reentrancy has been reviewed // F6 - Check for front-running possibilities, such as the approve function (SWC-114) // F6: Slight grieving possible by withdrawing an amount before someone tries to flashloan close to the full amount. function batchFlashLoan(     IBatchFlashBorrower borrower,     address[] calldata receivers,     IERC20[] calldata tokens,     uint256[] calldata amounts,     bytes calldata data ) public {     uint256[] memory fees = new uint256[](tokens.length);      uint256 len = tokens.length;     for (uint256 i = 0; i &lt; len; i++) {         uint256 amount = amounts[i];         fees[i] = amount.mul(FLASH_LOAN_FEE) / FLASH_LOAN_FEE_PRECISION;          tokens[i].safeTransfer(receivers[i], amounts[i]);     }      borrower.onBatchFlashLoan(msg.sender, tokens, amounts, fees, data);      for (uint256 i = 0; i &lt; len; i++) {         IERC20 token = tokens[i];         require(_tokenBalanceOf(token) &gt;= totals[token].addElastic(fees[i].to128()), ""BentoBox: Wrong amount"");         emit LogFlashLoan(address(borrower), token, amounts[i], fees[i], receivers[i]);     } }  /// @notice Sets the target percentage of the strategy for `token`. /// @dev Only the owner of this contract is allowed to change this. /// @param token The address of the token that maps to a strategy to change. /// @param targetPercentage_ The new target in percent. Must be lesser or equal to `MAX_TARGET_PERCENTAGE`. function setStrategyTargetPercentage(IERC20 token, uint64 targetPercentage_) public onlyOwner {     // Checks     require(targetPercentage_ &lt;= MAX_TARGET_PERCENTAGE, ""StrategyManager: Target too high"");      // Effects     strategyData[token].targetPercentage = targetPercentage_;     emit LogStrategyTargetPercentage(token, targetPercentage_); }  /// @notice Sets the contract address of a new strategy that conforms to `IStrategy` for `token`. /// Must be called twice with the same arguments. /// A new strategy becomes pending first and can be activated once `STRATEGY_DELAY` is over. /// @dev Only the owner of this contract is allowed to change this. /// @param token The address of the token that maps to a strategy to change. /// @param newStrategy The address of the contract that conforms to `IStrategy`. // F5 - Checks-Effects-Interactions pattern followed? (SWC-107) // F5: Total amount is updated AFTER interaction. But strategy is under our control. // C4 - Use block.timestamp only for long intervals (SWC-116) // C4: block.timestamp is used for a period of 2 weeks, which is long enough function setStrategy(IERC20 token, IStrategy newStrategy) public onlyOwner {     StrategyData memory data = strategyData[token];     IStrategy pending = pendingStrategy[token];     if (data.strategyStartDate == 0 || pending != newStrategy) {         pendingStrategy[token] = newStrategy;         // C1 - All math done through BoringMath (SWC-101)         // C1: Our sun will swallow the earth well before this overflows         data.strategyStartDate = (block.timestamp + STRATEGY_DELAY).to64();         emit LogStrategyQueued(token, newStrategy);     } else {         require(data.strategyStartDate != 0 &amp;&amp; block.timestamp &gt;= data.strategyStartDate, ""StrategyManager: Too early"");         if (address(strategy[token]) != address(0)) {             int256 balanceChange = strategy[token].exit(data.balance);             // Effects             if (balanceChange &gt; 0) {                 uint256 add = uint256(balanceChange);                 totals[token].addElastic(add);                 emit LogStrategyProfit(token, add);             } else if (balanceChange &lt; 0) {                 uint256 sub = uint256(-balanceChange);                 totals[token].subElastic(sub);                 emit LogStrategyLoss(token, sub);             }              emit LogStrategyDivest(token, data.balance);         }         strategy[token] = pending;         data.strategyStartDate = 0;         data.balance = 0;         pendingStrategy[token] = IStrategy(0);         emit LogStrategySet(token, newStrategy);     }     strategyData[token] = data; }  /// @notice The actual process of yield farming. Executes the strategy of `token`. /// Optionally does housekeeping if `balance` is true. /// `maxChangeAmount` is relevant for skimming or withdrawing if `balance` is true. /// @param token The address of the token for which a strategy is deployed. /// @param balance True if housekeeping should be done. /// @param maxChangeAmount The maximum amount for either pulling or pushing from/to the `IStrategy` contract. // F5 - Checks-Effects-Interactions pattern followed? (SWC-107) // F5: Total amount is updated AFTER interaction. But strategy is under our control. // F5: Not followed to prevent reentrancy issues with flashloans and BentoBox skims? function harvest(     IERC20 token,     bool balance,     uint256 maxChangeAmount ) public {     StrategyData memory data = strategyData[token];     IStrategy _strategy = strategy[token];     int256 balanceChange = _strategy.harvest(data.balance, msg.sender);     if (balanceChange == 0 &amp;&amp; !balance) {         return;     }      uint256 totalElastic = totals[token].elastic;      if (balanceChange &gt; 0) {         uint256 add = uint256(balanceChange);         totalElastic = totalElastic.add(add);         totals[token].elastic = totalElastic.to128();         emit LogStrategyProfit(token, add);     } else if (balanceChange &lt; 0) {         // C1 - All math done through BoringMath (SWC-101)         // C1: balanceChange could overflow if it's max negative int128.         // But tokens with balances that large are not supported by the BentoBox.         uint256 sub = uint256(-balanceChange);         totalElastic = totalElastic.sub(sub);         totals[token].elastic = totalElastic.to128();         data.balance = data.balance.sub(sub.to128());         emit LogStrategyLoss(token, sub);     }      if (balance) {         uint256 targetBalance = totalElastic.mul(data.targetPercentage) / 100;         // if data.balance == targetBalance there is nothing to update         if (data.balance &lt; targetBalance) {             uint256 amountOut = targetBalance.sub(data.balance);             if (maxChangeAmount != 0 &amp;&amp; amountOut &gt; maxChangeAmount) {                 amountOut = maxChangeAmount;             }             token.safeTransfer(address(_strategy), amountOut);             data.balance = data.balance.add(amountOut.to128());             _strategy.skim(amountOut);             emit LogStrategyInvest(token, amountOut);         } else if (data.balance &gt; targetBalance) {             uint256 amountIn = data.balance.sub(targetBalance.to128());             if (maxChangeAmount != 0 &amp;&amp; amountIn &gt; maxChangeAmount) {                 amountIn = maxChangeAmount;             }              uint256 actualAmountIn = _strategy.withdraw(amountIn);              data.balance = data.balance.sub(actualAmountIn.to128());             emit LogStrategyDivest(token, actualAmountIn);         }     }      strategyData[token] = data; }  // Contract should be able to receive ETH deposits to support deposit &amp; skim // solhint-disable-next-line no-empty-blocks receive() external payable {}  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Transactions Order Dependence. Transactions Order Dependence vulnerabilities can result in unintended consequences and create opportunities for malicious actors to exploit transaction sequencing. Please conduct a thorough analysis, considering the following information: 1. Review the contract's code logic to identify any potential areas where the order of transaction execution might have an impact on the contract's behavior.   Examine critical functions, particularly those involving fund transfers or resource allocation, to ensure they are not susceptible to Transactions Order Dependence.   Investigate scenarios in which gas prices can be manipulated to change the order of transaction execution.   If you identify Transactions Order Dependence, respond with: "" Transactions Order Dependence Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades ''' If you don't find any Transactions Order Dependence vulnerabilities, respond only with: "" NO Transactions Order Dependence."" |
| **phase_name** | TODDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: UNLICENSED\n// The BentoBox\n\n//  ▄▄▄▄· ▄▄▄ . ▐ ▄ ▄▄▄▄▄      ▄▄▄▄·       ▐▄• ▄\n//  ▐█ ▀█▪▀▄.▀·█▌▐█•██  ▪     ▐█ ▀█▪▪      █▌█▌▪\n//  ▐█▀▀█▄▐▀▀▪▄▐█▐▐▌ ▐█.▪ ▄█▀▄ ▐█▀▀█▄ ▄█▀▄  ·██·\n//  ██▄▪▐█▐█▄▄▌██▐█▌ ▐█▌·▐█▌.▐▌██▄▪▐█▐█▌.▐▌▪▐█·█▌\n//  ·▀▀▀▀  ▀▀▀ ▀▀ █▪ ▀▀▀  ▀█▄▀▪·▀▀▀▀  ▀█▄▀▪•▀▀ ▀▀\n\n// This contract stores funds, handles their transfers, supports flash loans and strategies.\n\n// Copyright (c) 2021 BoringCrypto - All rights reserved\n// Twitter: @Boring_Crypto\n\n// Special thanks to Keno for all his hard work and support\n\n// Version 22-Mar-2021\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\n// solhint-disable avoid-low-level-calls\n// solhint-disable not-rely-on-time\n// solhint-disable no-inline-assembly\n\n// File @boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol@v1.2.0\n// License-Identifier: MIT\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\n// File contracts/interfaces/IFlashLoan.sol\n// License-Identifier: MIT\n\ninterface IFlashBorrower {\n    /// @notice The flashloan callback. amount + fee needs to repayed to msg.sender before this call returns.\n    /// @param sender The address of the invoker of this flashloan.\n    /// @param token The address of the token that is loaned.\n    /// @param amount of the token that is loaned.\n    /// @param fee The fee that needs to be paid on top for this loan. Needs to be the same as token.\n    /// @param data Additional data that was passed to the flashloan function.\n    function onFlashLoan(\n        address sender,\n        IERC20 token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external;\n}\n\ninterface IBatchFlashBorrower {\n    /// @notice The callback for batched flashloans. Every amount + fee needs to repayed to msg.sender before this call returns.\n    /// @param sender The address of the invoker of this flashloan.\n    /// @param tokens Array of addresses for ERC-20 tokens that is loaned.\n    /// @param amounts A one-to-one map to tokens that is loaned.\n    /// @param fees A one-to-one map to tokens that needs to be paid on top for each loan. Needs to be the same token.\n    /// @param data Additional data that was passed to the flashloan function.\n    function onBatchFlashLoan(\n        address sender,\n        IERC20[] calldata tokens,\n        uint256[] calldata amounts,\n        uint256[] calldata fees,\n        bytes calldata data\n    ) external;\n}\n\n// File contracts/interfaces/IWETH.sol\n// License-Identifier: MIT\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function withdraw(uint256) external;\n}\n\n// File contracts/interfaces/IStrategy.sol\n// License-Identifier: MIT\n\ninterface IStrategy {\n    /// @notice Send the assets to the Strategy and call skim to invest them.\n    /// @param amount The amount of tokens to invest.\n    function skim(uint256 amount) external;\n\n    /// @notice Harvest any profits made converted to the asset and pass them to the caller.\n    /// @param balance The amount of tokens the caller thinks it has invested.\n    /// @param sender The address of the initiator of this transaction. Can be used for reimbursements, etc.\n    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to balance.\n    function harvest(uint256 balance, address sender) external returns (int256 amountAdded);\n\n    /// @notice Withdraw assets. The returned amount can differ from the requested amount due to rounding.\n    /// @dev The actualAmount should be very close to the amount.\n    /// The difference should NOT be used to report a loss. That\'s what harvest is for.\n    /// @param amount The requested amount the caller wants to withdraw.\n    /// @return actualAmount The real amount that is withdrawn.\n    function withdraw(uint256 amount) external returns (uint256 actualAmount);\n\n    /// @notice Withdraw all assets in the safest way possible. This shouldn\'t fail.\n    /// @param balance The amount of tokens the caller thinks it has invested.\n    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to balance.\n    function exit(uint256 balance) external returns (int256 amountAdded);\n}\n\n// File @boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol@v1.2.0\n// License-Identifier: MIT\n\nlibrary BoringERC20 {\n    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()\n    bytes4 private constant SIG_NAME = 0x06fdde03; // name()\n    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()\n    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\n    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)\n\n    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\n    /// Reverts on a failed transfer.\n    /// @param token The address of the ERC-20 token.\n    /// @param to Transfer tokens to.\n    /// @param amount The token amount.\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));\n        require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), ""BoringERC20: Transfer failed"");\n    }\n\n    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.\n    /// Reverts on a failed transfer.\n    /// @param token The address of the ERC-20 token.\n    /// @param from Transfer tokens from.\n    /// @param to Transfer tokens to.\n    /// @param amount The token amount.\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));\n        require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), ""BoringERC20: TransferFrom failed"");\n    }\n}\n\n// File @boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol@v1.2.0\n// License-Identifier: MIT\n\n/// @notice A library for performing overflow-/underflow-safe math,\n/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).\nlibrary BoringMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require((c = a + b) &gt;= b, ""BoringMath: Add Overflow"");\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require((c = a - b) &lt;= a, ""BoringMath: Underflow"");\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require(b == 0 || (c = a * b) / b == a, ""BoringMath: Mul Overflow"");\n    }\n\n    function to128(uint256 a) internal pure returns (uint128 c) {\n        require(a &lt;= uint128(-1), ""BoringMath: uint128 Overflow"");\n        c = uint128(a);\n    }\n\n    function to64(uint256 a) internal pure returns (uint64 c) {\n        require(a &lt;= uint64(-1), ""BoringMath: uint64 Overflow"");\n        c = uint64(a);\n    }\n\n    function to32(uint256 a) internal pure returns (uint32 c) {\n        require(a &lt;= uint32(-1), ""BoringMath: uint32 Overflow"");\n        c = uint32(a);\n    }\n}\n\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint128.\nlibrary BoringMath128 {\n    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {\n        require((c = a + b) &gt;= b, ""BoringMath: Add Overflow"");\n    }\n\n    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {\n        require((c = a - b) &lt;= a, ""BoringMath: Underflow"");\n    }\n}\n\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint64.\nlibrary BoringMath64 {\n    function add(uint64 a, uint64 b) internal pure returns (uint64 c) {\n        require((c = a + b) &gt;= b, ""BoringMath: Add Overflow"");\n    }\n\n    function sub(uint64 a, uint64 b) internal pure returns (uint64 c) {\n        require((c = a - b) &lt;= a, ""BoringMath: Underflow"");\n    }\n}\n\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint32.\nlibrary BoringMath32 {\n    function add(uint32 a, uint32 b) internal pure returns (uint32 c) {\n        require((c = a + b) &gt;= b, ""BoringMath: Add Overflow"");\n    }\n\n    function sub(uint32 a, uint32 b) internal pure returns (uint32 c) {\n        require((c = a - b) &lt;= a, ""BoringMath: Underflow"");\n    }\n}\n\n// File @boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol@v1.2.0\n// License-Identifier: MIT\n\nstruct Rebase {\n    uint128 elastic;\n    uint128 base;\n}\n\n/// @notice A rebasing library using overflow-/underflow-safe math.\nlibrary RebaseLibrary {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n\n    /// @notice Calculates the base value in relationship to elastic and total.\n    function toBase(\n        Rebase memory total,\n        uint256 elastic,\n        bool roundUp\n    ) internal pure returns (uint256 base) {\n        if (total.elastic == 0) {\n            base = elastic;\n        } else {\n            base = elastic.mul(total.base) / total.elastic;\n            if (roundUp &amp;&amp; base.mul(total.elastic) / total.base &lt; elastic) {\n                base = base.add(1);\n            }\n        }\n    }\n\n    /// @notice Calculates the elastic value in relationship to base and total.\n    function toElastic(\n        Rebase memory total,\n        uint256 base,\n        bool roundUp\n    ) internal pure returns (uint256 elastic) {\n        if (total.base == 0) {\n            elastic = base;\n        } else {\n            elastic = base.mul(total.elastic) / total.base;\n            if (roundUp &amp;&amp; elastic.mul(total.base) / total.elastic &lt; base) {\n                elastic = elastic.add(1);\n            }\n        }\n    }\n\n    /// @notice Add elastic to total and doubles total.base.\n    /// @return (Rebase) The new total.\n    /// @return base in relationship to elastic.\n    function add(\n        Rebase memory total,\n        uint256 elastic,\n        bool roundUp\n    ) internal pure returns (Rebase memory, uint256 base) {\n        base = toBase(total, elastic, roundUp);\n        total.elastic = total.elastic.add(elastic.to128());\n        total.base = total.base.add(base.to128());\n        return (total, base);\n    }\n\n    /// @notice Sub base from total and update total.elastic.\n    /// @return (Rebase) The new total.\n    /// @return elastic in relationship to base.\n    function sub(\n        Rebase memory total,\n        uint256 base,\n        bool roundUp\n    ) internal pure returns (Rebase memory, uint256 elastic) {\n        elastic = toElastic(total, base, roundUp);\n        total.elastic = total.elastic.sub(elastic.to128());\n        total.base = total.base.sub(base.to128());\n        return (total, elastic);\n    }\n\n    /// @notice Add elastic and base to total.\n    function add(\n        Rebase memory total,\n        uint256 elastic,\n        uint256 base\n    ) internal pure returns (Rebase memory) {\n        total.elastic = total.elastic.add(elastic.to128());\n        total.base = total.base.add(base.to128());\n        return total;\n    }\n\n    /// @notice Subtract elastic and base to total.\n    function sub(\n        Rebase memory total,\n        uint256 elastic,\n        uint256 base\n    ) internal pure returns (Rebase memory) {\n        total.elastic = total.elastic.sub(elastic.to128());\n        total.base = total.base.sub(base.to128());\n        return total;\n    }\n\n    /// @notice Add elastic to total and update storage.\n    /// @return newElastic Returns updated elastic.\n    function addElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\n        newElastic = total.elastic = total.elastic.add(elastic.to128());\n    }\n\n    /// @notice Subtract elastic from total and update storage.\n    /// @return newElastic Returns updated elastic.\n    function subElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\n        newElastic = total.elastic = total.elastic.sub(elastic.to128());\n    }\n}\n\n// File @boringcrypto/boring-solidity/contracts/BoringOwnable.sol@v1.2.0\n// License-Identifier: MIT\n\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol\n// Edited by BoringCrypto\n\ncontract BoringOwnableData {\n    address public owner;\n    address public pendingOwner;\n}\n\ncontract BoringOwnable is BoringOwnableData {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice owner defaults to msg.sender on construction.\n    constructor() public {\n        owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    /// @notice Transfers ownership to newOwner. Either directly or claimable by the new pending owner.\n    /// Can only be invoked by the current owner.\n    /// @param newOwner Address of the new owner.\n    /// @param direct True if newOwner should be set immediately. False if newOwner needs to use claimOwnership.\n    /// @param renounce Allows the newOwner to be address(0) if direct and renounce is True. Has no effect otherwise.\n    function transferOwnership(\n        address newOwner,\n        bool direct,\n        bool renounce\n    ) public onlyOwner {\n        if (direct) {\n            // Checks\n            require(newOwner != address(0) || renounce, ""Ownable: zero address"");\n\n            // Effects\n            emit OwnershipTransferred(owner, newOwner);\n            owner = newOwner;\n            pendingOwner = address(0);\n        } else {\n            // Effects\n            pendingOwner = newOwner;\n        }\n    }\n\n    /// @notice Needs to be called by pendingOwner to claim ownership.\n    function claimOwnership() public {\n        address pendingOwner = pendingOwner;\n\n        // Checks\n        require(msg.sender == _pendingOwner, ""Ownable: caller != pending owner"");\n\n        // Effects\n        emit OwnershipTransferred(owner, _pendingOwner);\n        owner = _pendingOwner;\n        pendingOwner = address(0);\n    }\n\n    /// @notice Only allows the owner to execute the function.\n    modifier onlyOwner() {\n        require(msg.sender == owner, ""Ownable: caller is not the owner"");\n        ;\n    }\n}\n\n// File @boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol@v1.2.0\n// License-Identifier: MIT\n\ninterface IMasterContract {\n    /// @notice Init function that gets called from BoringFactory.deploy.\n    /// Also kown as the constructor for cloned contracts.\n    /// Any ETH send to BoringFactory.deploy ends up here.\n    /// @param data Can be abi encoded arguments or anything else.\n    function init(bytes calldata data) external payable;\n}\n\n// File @boringcrypto/boring-solidity/contracts/BoringFactory.sol@v1.2.0\n// License-Identifier: MIT\n\ncontract BoringFactory {\n    event LogDeploy(address indexed masterContract, bytes data, address indexed cloneAddress);\n\n    /// @notice Mapping from clone contracts to their masterContract.\n    mapping(address =&gt; address) public masterContractOf;\n\n    /// @notice Deploys a given master Contract as a clone.\n    /// Any ETH transferred with this call is forwarded to the new clone.\n    /// Emits LogDeploy.\n    /// @param masterContract The address of the contract to clone.\n    /// @param data Additional abi encoded calldata that is passed to the new clone via IMasterContract.init.\n    /// @param useCreate2 Creates the clone by using the CREATE2 opcode, in this case data will be used as salt.\n    /// @return cloneAddress Address of the created clone contract.\n    function deploy(\n        address masterContract,\n        bytes calldata data,\n        bool useCreate2\n    ) public payable returns (address cloneAddress) {\n        require(masterContract != address(0), ""BoringFactory: No masterContract"");\n        bytes20 targetBytes = bytes20(masterContract); // Takes the first 20 bytes of the masterContract\'s address\n\n        if (useCreate2) {\n            // each masterContract has different code already. So clones are distinguished by their data only.\n            bytes32 salt = keccak256(data);\n\n            // Creates clone, more info here: https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/\n            assembly {\n                let clone := mload(0x40)\n                mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n                mstore(add(clone, 0x14), targetBytes)\n                mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n                cloneAddress := create2(0, clone, 0x37, salt)\n            }\n        } else {\n            assembly {\n                let clone := mload(0x40)\n                mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n                mstore(add(clone, 0x14), targetBytes)\n                mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n                cloneAddress := create(0, clone, 0x37)\n            }\n        }\n        masterContractOf[cloneAddress] = masterContract;\n\n        IMasterContract(cloneAddress).init{value: msg.value}(data);\n\n        emit LogDeploy(masterContract, data, cloneAddress);\n    }\n}\n\n// File contracts/MasterContractManager.sol\n// License-Identifier: UNLICENSED\n\ncontract MasterContractManager is BoringOwnable, BoringFactory {\n    event LogWhiteListMasterContract(address indexed masterContract, bool approved);\n    event LogSetMasterContractApproval(address indexed masterContract, address indexed user, bool approved);\n    event LogRegisterProtocol(address indexed protocol);\n\n    /// @notice masterContract to user to approval state\n    mapping(address =&gt; mapping(address =&gt; bool)) public masterContractApproved;\n    /// @notice masterContract to whitelisted state for approval without signed message\n    mapping(address =&gt; bool) public whitelistedMasterContracts;\n    /// @notice user nonces for masterContract approvals\n    mapping(address =&gt; uint256) public nonces;\n\n    bytes32 private constant DOMAIN_SEPARATOR_SIGNATURE_HASH = keccak256(""EIP712Domain(string name,uint256 chainId,address verifyingContract)"");\n    // See https://eips.ethereum.org/EIPS/eip-191\n    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = ""\x19\x01"";\n    bytes32 private constant APPROVAL_SIGNATURE_HASH =\n        keccak256(""SetMasterContractApproval(string warning,address user,address masterContract,bool approved,uint256 nonce)"");\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private immutable DOMAIN_SEPARATOR;\n    // solhint-disable-next-line var-name-mixedcase\n    uint256 private immutable DOMAIN_SEPARATOR_CHAIN_ID;\n\n    constructor() public {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        _DOMAIN_SEPARATOR = _calculateDomainSeparator(DOMAIN_SEPARATOR_CHAIN_ID = chainId);\n    }\n\n    function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_SIGNATURE_HASH, keccak256(""BentoBox V1""), chainId, address(this)));\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() public view returns (bytes32) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId);\n    }\n\n    /// @notice Other contracts need to register with this master contract so that users can approve them for the BentoBox.\n    function registerProtocol() public {\n        masterContractOf[msg.sender] = msg.sender;\n        emit LogRegisterProtocol(msg.sender);\n    }\n\n    /// @notice Enables or disables a contract for approval without signed message.\n    function whitelistMasterContract(address masterContract, bool approved) public onlyOwner {\n        // Checks\n        require(masterContract != address(0), ""MasterCMgr: Cannot approve 0"");\n\n        // Effects\n        whitelistedMasterContracts[masterContract] = approved;\n        emit LogWhiteListMasterContract(masterContract, approved);\n    }\n\n    /// @notice Approves or revokes a masterContract access to user funds.\n    /// @param user The address of the user that approves or revokes access.\n    /// @param masterContract The address who gains or loses access.\n    /// @param approved If True approves access. If False revokes access.\n    /// @param v Part of the signature. (See EIP-191)\n    /// @param r Part of the signature. (See EIP-191)\n    /// @param s Part of the signature. (See EIP-191)\n    // F4 - Check behaviour for all function arguments when wrong or extreme\n    // F4: Don\'t allow masterContract 0 to be approved. Unknown contracts will have a masterContract of 0.\n    // F4: User can\'t be 0 for signed approvals because the recoveredAddress will be 0 if ecrecover fails\n    function setMasterContractApproval(\n        address user,\n        address masterContract,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        // Checks\n        require(masterContract != address(0), ""MasterCMgr: masterC not set""); // Important for security\n\n        // If no signature is provided, the fallback is executed\n        if (r == 0 &amp;&amp; s == 0 &amp;&amp; v == 0) {\n            require(user == msg.sender, ""MasterCMgr: user not sender"");\n            require(masterContractOf[user] == address(0), ""MasterCMgr: user is clone"");\n            require(whitelistedMasterContracts[masterContract], ""MasterCMgr: not whitelisted"");\n        } else {\n            // Important for security - any address without masterContract has address(0) as masterContract\n            // So approving address(0) would approve every address, leading to full loss of funds\n            // Also, ecrecover returns address(0) on failure. So we check this:\n            require(user != address(0), ""MasterCMgr: User cannot be 0"");\n\n            // C10 - Protect signatures against replay, use nonce and chainId (SWC-121)\n            // C10: nonce + chainId are used to prevent replays\n            // C11 - All signatures strictly EIP-712 (SWC-117 SWC-122)\n            // C11: signature is EIP-712 compliant\n            // C12 - abi.encodePacked can\'t contain variable length user input (SWC-133)\n            // C12: abi.encodePacked has fixed length parameters\n            bytes32 digest =\n                keccak256(\n                    abi.encodePacked(\n                        EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA,\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                APPROVAL_SIGNATURE_HASH,\n                                approved\n                                    ? keccak256(""Give FULL access to funds in (and approved to) BentoBox?"")\n                                    : keccak256(""Revoke access to BentoBox?""),\n                                user,\n                                masterContract,\n                                approved,\n                                nonces[user]++\n                            )\n                        )\n                    )\n                );\n            address recoveredAddress = ecrecover(digest, v, r, s);\n            require(recoveredAddress == user, ""MasterCMgr: Invalid Signature"");\n        }\n\n        // Effects\n        masterContractApproved[masterContract][user] = approved;\n        emit LogSetMasterContractApproval(masterContract, user, approved);\n    }\n}\n\n// File @boringcrypto/boring-solidity/contracts/BoringBatchable.sol@v1.2.0\n// License-Identifier: MIT\n\ncontract BaseBoringBatchable {\n    /// @dev Helper function to extract a useful revert message from a failed call.\n    /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.\n    function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length &lt; 68) return ""Transaction reverted silently"";\n\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n\n    /// @notice Allows batched call to self (this contract).\n    /// @param calls An array of inputs for each call.\n    /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.\n    /// @return successes An array indicating the success of a call, mapped one-to-one to calls.\n    /// @return results An array with the returned data of each function call, mapped one-to-one to calls.\n    // F1: External is ok here because this is the batch function, adding it to a batch makes no sense\n    // F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value\n    // C3: The length of the loop is fully under user control, so can\'t be exploited\n    // C7: Delegatecall is only used on the same contract, so it\'s safe\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results) {\n        successes = new bool;\n        results = new bytes;\n        for (uint256 i = 0; i &lt; calls.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\n            require(success || !revertOnFail, _getRevertMsg(result));\n            successes[i] = success;\n            results[i] = result;\n        }\n    }\n}\n\ncontract BoringBatchable is BaseBoringBatchable {\n    /// @notice Call wrapper that performs ERC20.permit on token.\n    /// Lookup IERC20.permit.\n    // F6: Parameters can be used front-run the permit and the user\'s permit will fail (due to nonce or other revert)\n    //     if part of a batch this could be used to grief once as the second call would not need the permit\n    function permitToken(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        token.permit(from, to, amount, deadline, v, r, s);\n    }\n}\n\n// File contracts/BentoBox.sol\n// License-Identifier: UNLICENSED\n\n/// @title BentoBox\n/// @author BoringCrypto, Keno\n/// @notice The BentoBox is a vault for tokens. The stored tokens can be flash loaned and used in strategies.\n/// Yield from this will go to the token depositors.\n/// Rebasing tokens ARE NOT supported and WILL cause loss of funds.\n/// Any funds transfered directly onto the BentoBox will be lost, use the deposit function instead.\ncontract BentoBoxV1 is MasterContractManager, BoringBatchable {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using BoringERC20 for IERC20;\n    using RebaseLibrary for Rebase;\n\n    // ** //\n    // *** EVENTS *** //\n    // ** //\n\n    event LogDeposit(IERC20 indexed token, address indexed from, address indexed to, uint256 amount, uint256 share);\n    event LogWithdraw(IERC20 indexed token, address indexed from, address indexed to, uint256 amount, uint256 share);\n    event LogTransfer(IERC20 indexed token, address indexed from, address indexed to, uint256 share);\n\n    event LogFlashLoan(address indexed borrower, IERC20 indexed token, uint256 amount, uint256 feeAmount, address indexed receiver);\n\n    event LogStrategyTargetPercentage(IERC20 indexed token, uint256 targetPercentage);\n    event LogStrategyQueued(IERC20 indexed token, IStrategy indexed strategy);\n    event LogStrategySet(IERC20 indexed token, IStrategy indexed strategy);\n    event LogStrategyInvest(IERC20 indexed token, uint256 amount);\n    event LogStrategyDivest(IERC20 indexed token, uint256 amount);\n    event LogStrategyProfit(IERC20 indexed token, uint256 amount);\n    event LogStrategyLoss(IERC20 indexed token, uint256 amount);\n\n    // ** //\n    // *** STRUCTS *** //\n    // ** //\n\n    struct StrategyData {\n        uint64 strategyStartDate;\n        uint64 targetPercentage;\n        uint128 balance; // the balance of the strategy that BentoBox thinks is in there\n    }\n\n    // ***** //\n    // *** CONSTANTS AND IMMUTABLES *** //\n    // **** //\n\n    // V2 - Can they be private?\n    // V2: Private to save gas, to verify it\'s correct, check the constructor arguments\n    IERC20 private immutable wethToken;\n\n    IERC20 private constant USE_ETHEREUM = IERC20(0);\n    uint256 private constant FLASH_LOAN_FEE = 50; // 0.05%\n    uint256 private constant FLASH_LOAN_FEE_PRECISION = 1e5;\n    uint256 private constant STRATEGY_DELAY = 2 weeks;\n    uint256 private constant MAX_TARGET_PERCENTAGE = 95; // 95%\n    uint256 private constant MINIMUM_SHARE_BALANCE = 1000; // To prevent the ratio going off\n\n    // ** //\n    // *** VARIABLES *** //\n    // ** //\n\n    // Balance per token per address/contract in shares\n    mapping(IERC20 =&gt; mapping(address =&gt; uint256)) public balanceOf;\n\n    // Rebase from amount to share\n    mapping(IERC20 =&gt; Rebase) public totals;\n\n    mapping(IERC20 =&gt; IStrategy) public strategy;\n    mapping(IERC20 =&gt; IStrategy) public pendingStrategy;\n    mapping(IERC20 =&gt; StrategyData) public strategyData;\n\n    // *** //\n    // *** CONSTRUCTOR *** //\n    // ** //\n\n    constructor(IERC20 wethToken_) public {\n        wethToken = wethToken_;\n    }\n\n    // ** //\n    // *** MODIFIERS *** //\n    // ** //\n\n    /// Modifier to check if the msg.sender is allowed to use funds belonging to the \'from\' address.\n    /// If \'from\' is msg.sender, it\'s allowed.\n    /// If \'from\' is the BentoBox itself, it\'s allowed. Any ETH, token balances (above the known balances) or BentoBox balances\n    /// can be taken by anyone.\n    /// This is to enable skimming, not just for deposits, but also for withdrawals or transfers, enabling better composability.\n    /// If \'from\' is a clone of a masterContract AND the \'from\' address has approved that masterContract, it\'s allowed.\n    modifier allowed(address from) {\n        if (from != msg.sender &amp;&amp; from != address(this)) {\n            // From is sender or you are skimming\n            address masterContract = masterContractOf[msg.sender];\n            require(masterContract != address(0), ""BentoBox: no masterContract"");\n            require(masterContractApproved[masterContract][from], ""BentoBox: Transfer not approved"");\n        }\n        _;\n    }\n\n    // *** //\n    // *** INTERNAL FUNCTIONS *** //\n    // *** //\n\n    /// @dev Returns the total balance of token this contracts holds,\n    /// plus the total amount this contract thinks the strategy holds.\n    function _tokenBalanceOf(IERC20 token) internal view returns (uint256 amount) {\n        amount = token.balanceOf(address(this)).add(strategyData[token].balance);\n    }\n\n    // *** //\n    // *** PUBLIC FUNCTIONS *** //\n    // ***** //\n\n    /// @dev Helper function to represent an amount of token in shares.\n    /// @param token The ERC-20 token.\n    /// @param amount The token amount.\n    /// @param roundUp If the result share should be rounded up.\n    /// @return share The token amount represented in shares.\n    function toShare(\n        IERC20 token,\n        uint256 amount,\n        bool roundUp\n    ) external view returns (uint256 share) {\n        share = totals[token].toBase(amount, roundUp);\n    }\n\n    /// @dev Helper function represent shares back into the token amount.\n    /// @param token The ERC-20 token.\n    /// @param share The amount of shares.\n    /// @param roundUp If the result should be rounded up.\n    /// @return amount The share amount back into native representation.\n    function toAmount(\n        IERC20 token,\n        uint256 share,\n        bool roundUp\n    ) external view returns (uint256 amount) {\n        amount = totals[token].toElastic(share, roundUp);\n    }\n\n    /// @notice Deposit an amount of token represented in either amount or share.\n    /// @param token The ERC-20 token to deposit.\n    /// @param from which account to pull the tokens.\n    /// @param to which account to push the tokens.\n    /// @param amount Token amount in native representation to deposit.\n    /// @param share Token amount represented in shares to deposit. Takes precedence over amount.\n    /// @return amountOut The amount deposited.\n    /// @return shareOut The deposited amount repesented in shares.\n    function deposit(\n        IERC20 token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) public payable allowed(from) returns (uint256 amountOut, uint256 shareOut) {\n        // Checks\n        require(to != address(0), ""BentoBox: to not set""); // To avoid a bad UI from burning funds\n\n        // Effects\n        IERC20 token = token_ == USE_ETHEREUM ? wethToken : token_;\n        Rebase memory total = totals[token];\n\n        // If a new token gets added, the tokenSupply call checks that this is a deployed contract. Needed for security.\n        require(total.elastic != 0 || token.totalSupply() &gt; 0, ""BentoBox: No tokens"");\n        if (share == 0) {\n            // value of the share may be lower than the amount due to rounding, that\'s ok\n            share = total.toBase(amount, false);\n            // Any deposit should lead to at least the minimum share balance, otherwise it\'s ignored (no amount taken)\n            if (total.base.add(share.to128()) &lt; MINIMUM_SHARE_BALANCE) {\n                return (0, 0);\n            }\n        } else {\n            // amount may be lower than the value of share due to rounding, in that case, add 1 to amount (Always round up)\n            amount = total.toElastic(share, true);\n        }\n\n        // In case of skimming, check that only the skimmable amount is taken.\n        // For ETH, the full balance is available, so no need to check.\n        // During flashloans the tokenBalanceOf is lower than \'reality\', so skimming deposits will mostly fail during a flashloan.\n        require(\n            from != address(this) || token == USE_ETHEREUM || amount &lt;= tokenBalanceOf(token).sub(total.elastic),\n            ""BentoBox: Skim too much""\n        );\n\n        balanceOf[token][to] = balanceOf[token][to].add(share);\n        total.base = total.base.add(share.to128());\n        total.elastic = total.elastic.add(amount.to128());\n        totals[token] = total;\n\n        // Interactions\n        // During the first deposit, we check that this token is \'real\'\n        if (token == USE_ETHEREUM) {\n            // X2 - If there is an error, could it cause a DoS. Like balanceOf causing revert. (SWC-113)\n            // X2: If the WETH implementation is faulty or malicious, it will block adding ETH (but we know the WETH implementation)\n            IWETH(address(wethToken)).deposit{value: amount}();\n        } else if (from != address(this)) {\n            // X2 - If there is an error, could it cause a DoS. Like balanceOf causing revert. (SWC-113)\n            // X2: If the token implementation is faulty or malicious, it may block adding tokens. Good.\n            token.safeTransferFrom(from, address(this), amount);\n        }\n        emit LogDeposit(token, from, to, amount, share);\n        amountOut = amount;\n        shareOut = share;\n    }\n\n    /// @notice Withdraws an amount of token from a user account.\n    /// @param token_ The ERC-20 token to withdraw.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param amount of tokens. Either one of amount or share needs to be supplied.\n    /// @param share Like above, but share takes precedence over amount.\n    function withdraw(\n        IERC20 token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) public allowed(from) returns (uint256 amountOut, uint256 shareOut) {\n        // Checks\n        require(to != address(0), ""BentoBox: to not set""); // To avoid a bad UI from burning funds\n\n        // Effects\n        IERC20 token = token_ == USE_ETHEREUM ? wethToken : token_;\n        Rebase memory total = totals[token];\n        if (share == 0) {\n            // value of the share paid could be lower than the amount paid due to rounding, in that case, add a share (Always round up)\n            share = total.toBase(amount, true);\n        } else {\n            // amount may be lower than the value of share due to rounding, that\'s ok\n            amount = total.toElastic(share, false);\n        }\n\n        balanceOf[token][from] = balanceOf[token][from].sub(share);\n        total.elastic = total.elastic.sub(amount.to128());\n        total.base = total.base.sub(share.to128());\n        // There have to be at least 1000 shares left to prevent reseting the share/amount ratio (unless it\'s fully emptied)\n        require(total.base &gt;= MINIMUM_SHARE_BALANCE || total.base == 0, ""BentoBox: cannot empty"");\n        totals[token] = total;\n\n        // Interactions\n        if (token_ == USE_ETHEREUM) {\n            // X2, X3: A revert or big gas usage in the WETH contract could block withdrawals, but WETH9 is fine.\n            IWETH(address(wethToken)).withdraw(amount);\n            // X2, X3: A revert or big gas usage could block, however, the to address is under control of the caller.\n            (bool success, ) = to.call{value: amount}("""");\n            require(success, ""BentoBox: ETH transfer failed"");\n        } else {\n            // X2, X3: A malicious token could block withdrawal of just THAT token.\n            //         masterContracts may want to take care not to rely on withdraw always succeeding.\n            token.safeTransfer(to, amount);\n        }\n        emit LogWithdraw(token, from, to, amount, share);\n        amountOut = amount;\n        shareOut = share;\n    }\n\n    /// @notice Transfer shares from a user account to another one.\n    /// @param token The ERC-20 token to transfer.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param share The amount of token in shares.\n    // Clones of master contracts can transfer from any account that has approved them\n    // F3 - Can it be combined with another similar function?\n    // F3: This isn\'t combined with transferMultiple for gas optimization\n    function transfer(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 share\n    ) public allowed(from) {\n        // Checks\n        require(to != address(0), ""BentoBox: to not set""); // To avoid a bad UI from burning funds\n\n        // Effects\n        balanceOf[token][from] = balanceOf[token][from].sub(share);\n        balanceOf[token][to] = balanceOf[token][to].add(share);\n\n        emit LogTransfer(token, from, to, share);\n    }\n\n    /// @notice Transfer shares from a user account to multiple other ones.\n    /// @param token The ERC-20 token to transfer.\n    /// @param from which user to pull the tokens.\n    /// @param tos The receivers of the tokens.\n    /// @param shares The amount of token in shares for each receiver in tos.\n    // F3 - Can it be combined with another similar function?\n    // F3: This isn\'t combined with transfer for gas optimization\n    function transferMultiple(\n        IERC20 token,\n        address from,\n        address[] calldata tos,\n        uint256[] calldata shares\n    ) public allowed(from) {\n        // Checks\n        require(tos[0] != address(0), ""BentoBox: to[0] not set""); // To avoid a bad UI from burning funds\n\n        // Effects\n        uint256 totalAmount;\n        uint256 len = tos.length;\n        for (uint256 i = 0; i &lt; len; i++) {\n            address to = tos[i];\n            balanceOf[token][to] = balanceOf[token][to].add(shares[i]);\n            totalAmount = totalAmount.add(shares[i]);\n            emit LogTransfer(token, from, to, shares[i]);\n        }\n        balanceOf[token][from] = balanceOf[token][from].sub(totalAmount);\n    }\n\n    /// @notice Flashloan ability.\n    /// @param borrower The address of the contract that implements and conforms to IFlashBorrower and handles the flashloan.\n    /// @param receiver Address of the token receiver.\n    /// @param token The address of the token to receive.\n    /// @param amount of the tokens to receive.\n    /// @param data The calldata to pass to the borrower contract.\n    // F5 - Checks-Effects-Interactions pattern followed? (SWC-107)\n    // F5: Not possible to follow this here, reentrancy has been reviewed\n    // F6 - Check for front-running possibilities, such as the approve function (SWC-114)\n    // F6: Slight grieving possible by withdrawing an amount before someone tries to flashloan close to the full amount.\n    function flashLoan(\n        IFlashBorrower borrower,\n        address receiver,\n        IERC20 token,\n        uint256 amount,\n        bytes calldata data\n    ) public {\n        uint256 fee = amount.mul(FLASH_LOAN_FEE) / FLASH_LOAN_FEE_PRECISION;\n        token.safeTransfer(receiver, amount);\n\n        borrower.onFlashLoan(msg.sender, token, amount, fee, data);\n\n        require(tokenBalanceOf(token) &gt;= totals[token].addElastic(fee.to128()), ""BentoBox: Wrong amount"");\n        emit LogFlashLoan(address(borrower), token, amount, fee, receiver);\n    }\n\n    /// @notice Support for batched flashloans. Useful to request multiple different tokens in a single transaction.\n    /// @param borrower The address of the contract that implements and conforms to IBatchFlashBorrower and handles the flashloan.\n    /// @param receivers An array of the token receivers. A one-to-one mapping with tokens and amounts.\n    /// @param tokens The addresses of the tokens.\n    /// @param amounts of the tokens for each receiver.\n    /// @param data The calldata to pass to the borrower contract.\n    // F5 - Checks-Effects-Interactions pattern followed? (SWC-107)\n    // F5: Not possible to follow this here, reentrancy has been reviewed\n    // F6 - Check for front-running possibilities, such as the approve function (SWC-114)\n    // F6: Slight grieving possible by withdrawing an amount before someone tries to flashloan close to the full amount.\n    function batchFlashLoan(\n        IBatchFlashBorrower borrower,\n        address[] calldata receivers,\n        IERC20[] calldata tokens,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public {\n        uint256[] memory fees = new uint256;\n\n        uint256 len = tokens.length;\n        for (uint256 i = 0; i &lt; len; i++) {\n            uint256 amount = amounts[i];\n            fees[i] = amount.mul(FLASH_LOAN_FEE) / FLASH_LOAN_FEE_PRECISION;\n\n            tokens[i].safeTransfer(receivers[i], amounts[i]);\n        }\n\n        borrower.onBatchFlashLoan(msg.sender, tokens, amounts, fees, data);\n\n        for (uint256 i = 0; i &lt; len; i++) {\n            IERC20 token = tokens[i];\n            require(_tokenBalanceOf(token) &gt;= totals[token].addElastic(fees[i].to128()), ""BentoBox: Wrong amount"");\n            emit LogFlashLoan(address(borrower), token, amounts[i], fees[i], receivers[i]);\n        }\n    }\n\n    /// @notice Sets the target percentage of the strategy for token.\n    /// @dev Only the owner of this contract is allowed to change this.\n    /// @param token The address of the token that maps to a strategy to change.\n    /// @param targetPercentage The new target in percent. Must be lesser or equal to MAX_TARGET_PERCENTAGE.\n    function setStrategyTargetPercentage(IERC20 token, uint64 targetPercentage_) public onlyOwner {\n        // Checks\n        require(targetPercentage_ &lt;= MAX_TARGET_PERCENTAGE, ""StrategyManager: Target too high"");\n\n        // Effects\n        strategyData[token].targetPercentage = targetPercentage_;\n        emit LogStrategyTargetPercentage(token, targetPercentage_);\n    }\n\n    /// @notice Sets the contract address of a new strategy that conforms to IStrategy for token.\n    /// Must be called twice with the same arguments.\n    /// A new strategy becomes pending first and can be activated once STRATEGY_DELAY is over.\n    /// @dev Only the owner of this contract is allowed to change this.\n    /// @param token The address of the token that maps to a strategy to change.\n    /// @param newStrategy The address of the contract that conforms to IStrategy.\n    // F5 - Checks-Effects-Interactions pattern followed? (SWC-107)\n    // F5: Total amount is updated AFTER interaction. But strategy is under our control.\n    // C4 - Use block.timestamp only for long intervals (SWC-116)\n    // C4: block.timestamp is used for a period of 2 weeks, which is long enough\n    function setStrategy(IERC20 token, IStrategy newStrategy) public onlyOwner {\n        StrategyData memory data = strategyData[token];\n        IStrategy pending = pendingStrategy[token];\n        if (data.strategyStartDate == 0 || pending != newStrategy) {\n            pendingStrategy[token] = newStrategy;\n            // C1 - All math done through BoringMath (SWC-101)\n            // C1: Our sun will swallow the earth well before this overflows\n            data.strategyStartDate = (block.timestamp + STRATEGY_DELAY).to64();\n            emit LogStrategyQueued(token, newStrategy);\n        } else {\n            require(data.strategyStartDate != 0 &amp;&amp; block.timestamp &gt;= data.strategyStartDate, ""StrategyManager: Too early"");\n            if (address(strategy[token]) != address(0)) {\n                int256 balanceChange = strategy[token].exit(data.balance);\n                // Effects\n                if (balanceChange &gt; 0) {\n                    uint256 add = uint256(balanceChange);\n                    totals[token].addElastic(add);\n                    emit LogStrategyProfit(token, add);\n                } else if (balanceChange &lt; 0) {\n                    uint256 sub = uint256(-balanceChange);\n                    totals[token].subElastic(sub);\n                    emit LogStrategyLoss(token, sub);\n                }\n\n                emit LogStrategyDivest(token, data.balance);\n            }\n            strategy[token] = pending;\n            data.strategyStartDate = 0;\n            data.balance = 0;\n            pendingStrategy[token] = IStrategy(0);\n            emit LogStrategySet(token, newStrategy);\n        }\n        strategyData[token] = data;\n    }\n\n    /// @notice The actual process of yield farming. Executes the strategy of token.\n    /// Optionally does housekeeping if balance is true.\n    /// maxChangeAmount is relevant for skimming or withdrawing if balance is true.\n    /// @param token The address of the token for which a strategy is deployed.\n    /// @param balance True if housekeeping should be done.\n    /// @param maxChangeAmount The maximum amount for either pulling or pushing from/to the IStrategy contract.\n    // F5 - Checks-Effects-Interactions pattern followed? (SWC-107)\n    // F5: Total amount is updated AFTER interaction. But strategy is under our control.\n    // F5: Not followed to prevent reentrancy issues with flashloans and BentoBox skims?\n    function harvest(\n        IERC20 token,\n        bool balance,\n        uint256 maxChangeAmount\n    ) public {\n        StrategyData memory data = strategyData[token];\n        IStrategy _strategy = strategy[token];\n        int256 balanceChange = _strategy.harvest(data.balance, msg.sender);\n        if (balanceChange == 0 &amp;&amp; !balance) {\n            return;\n        }\n\n        uint256 totalElastic = totals[token].elastic;\n\n        if (balanceChange &gt; 0) {\n            uint256 add = uint256(balanceChange);\n            totalElastic = totalElastic.add(add);\n            totals[token].elastic = totalElastic.to128();\n            emit LogStrategyProfit(token, add);\n        } else if (balanceChange &lt; 0) {\n            // C1 - All math done through BoringMath (SWC-101)\n            // C1: balanceChange could overflow if it\'s max negative int128.\n            // But tokens with balances that large are not supported by the BentoBox.\n            uint256 sub = uint256(-balanceChange);\n            totalElastic = totalElastic.sub(sub);\n            totals[token].elastic = totalElastic.to128();\n            data.balance = data.balance.sub(sub.to128());\n            emit LogStrategyLoss(token, sub);\n        }\n\n        if (balance) {\n            uint256 targetBalance = totalElastic.mul(data.targetPercentage) / 100;\n            // if data.balance == targetBalance there is nothing to update\n            if (data.balance &lt; targetBalance) {\n                uint256 amountOut = targetBalance.sub(data.balance);\n                if (maxChangeAmount != 0 &amp;&amp; amountOut &gt; maxChangeAmount) {\n                    amountOut = maxChangeAmount;\n                }\n                token.safeTransfer(address(_strategy), amountOut);\n                data.balance = data.balance.add(amountOut.to128());\n                _strategy.skim(amountOut);\n                emit LogStrategyInvest(token, amountOut);\n            } else if (data.balance &gt; targetBalance) {\n                uint256 amountIn = data.balance.sub(targetBalance.to128());\n                if (maxChangeAmount != 0 &amp;&amp; amountIn &gt; maxChangeAmount) {\n                    amountIn = maxChangeAmount;\n                }\n\n                uint256 actualAmountIn = _strategy.withdraw(amountIn);\n\n                data.balance = data.balance.sub(actualAmountIn.to128());\n                emit LogStrategyDivest(token, actualAmountIn);\n            }\n        }\n\n        strategyData[token] = data;\n    }\n\n    // Contract should be able to receive ETH deposits to support deposit &amp; skim\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n}\n', 'ideas': ' Unchecked Low-level Calls Identified.\n\n\nUNCHECKED LOW-LEVEL CALL\n\'\'\'\nIn the `withdraw` function of the `BentoBoxV1` contract, there is a low-level call made to transfer ETH to the `to` address after withdrawing from the WETH contract. The line:\n(bool success, ) = to.call{value: amount}("""");\nThis call does not check if the transfer was successful. If the transfer fails (for example, if the `to` address is a contract that does not accept ETH), the transaction will not revert, and the contract will not handle the failure properly. This could lead to a loss of funds as the user may not receive their withdrawn amount.\n\nRecommended Mitigation:\nReplace the low-level call with a safer alternative that checks for success, such as using `require` to ensure the transfer was successful:\nrequire(success, ""BentoBox: ETH transfer failed"");\n\'\'\'\n\n\n\nUNCHECKED LOW-LEVEL CALL\n\'\'\'\nIn the `flashLoan` function, the contract calls the `onFlashLoan` method on the borrower without checking if the call succeeds. The line:\nborrower.onFlashLoan(msg.sender, token, amount, fee, data);\nIf the `onFlashLoan` function in the borrower contract fails, the transaction will not revert, and the contract will not handle the failure properly. This could lead to a situation where the loan is not repaid correctly, potentially resulting in a loss of funds.\n\nRecommended Mitigation:\nWrap the call in a require statement to ensure that the call succeeds:\nrequire(borrower.onFlashLoan(msg.sender, token, amount, fee, data), ""BentoBox: Flash loan callback failed"");\n\'\'\'\n\n\n\nUNCHECKED LOW-LEVEL CALL\n\'\'\'\nIn the `batchFlashLoan` function, similar to the `flashLoan` function, the contract calls the `onBatchFlashLoan` method on the borrower without checking if the call succeeds. The line:\nborrower.onBatchFlashLoan(msg.sender, tokens, amounts, fees, data);\nAgain, if the `onBatchFlashLoan` function in the borrower contract fails, the transaction will not revert, and the contract will not handle the failure properly, leading to potential loss of funds.\n\nRecommended Mitigation:\nWrap the call in a require statement to ensure that the call succeeds:\nrequire(borrower.onBatchFlashLoan(msg.sender, tokens, amounts, fees, data), ""BentoBox: Batch flash loan callback failed"");\n\'\'\'\n'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-15-08 17:06:30 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED // The BentoBox //  ▄▄▄▄· ▄▄▄ . ▐ ▄ ▄▄▄▄▄      ▄▄▄▄·       ▐▄• ▄ //  ▐█ ▀█▪▀▄.▀·█▌▐█•██  ▪     ▐█ ▀█▪▪      █▌█▌▪ //  ▐█▀▀█▄▐▀▀▪▄▐█▐▐▌ ▐█.▪ ▄█▀▄ ▐█▀▀█▄ ▄█▀▄  ·██· //  ██▄▪▐█▐█▄▄▌██▐█▌ ▐█▌·▐█▌.▐▌██▄▪▐█▐█▌.▐▌▪▐█·█▌ //  ·▀▀▀▀  ▀▀▀ ▀▀ █▪ ▀▀▀  ▀█▄▀▪·▀▀▀▀  ▀█▄▀▪•▀▀ ▀▀ // This contract stores funds, handles their transfers, supports flash loans and strategies. // Copyright (c) 2021 BoringCrypto - All rights reserved // Twitter: @Boring_Crypto // Special thanks to Keno for all his hard work and support // Version 22-Mar-2021 pragma solidity 0.6.12; pragma experimental ABIEncoderV2; // solhint-disable avoid-low-level-calls // solhint-disable not-rely-on-time // solhint-disable no-inline-assembly // File @boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol@v1.2.0 // License-Identifier: MIT interface IERC20 {     function totalSupply() external view returns (uint256); function balanceOf(address account) external view returns (uint256);  function allowance(address owner, address spender) external view returns (uint256);  function approve(address spender, uint256 amount) external returns (bool);  event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value);  /// @notice EIP 2612 function permit(     address owner,     address spender,     uint256 value,     uint256 deadline,     uint8 v,     bytes32 r,     bytes32 s ) external;  } // File contracts/interfaces/IFlashLoan.sol // License-Identifier: MIT interface IFlashBorrower {     /// @notice The flashloan callback. amount + fee needs to repayed to msg.sender before this call returns.     /// @param sender The address of the invoker of this flashloan.     /// @param token The address of the token that is loaned.     /// @param amount of the token that is loaned.     /// @param fee The fee that needs to be paid on top for this loan. Needs to be the same as token.     /// @param data Additional data that was passed to the flashloan function.     function onFlashLoan(         address sender,         IERC20 token,         uint256 amount,         uint256 fee,         bytes calldata data     ) external; } interface IBatchFlashBorrower {     /// @notice The callback for batched flashloans. Every amount + fee needs to repayed to msg.sender before this call returns.     /// @param sender The address of the invoker of this flashloan.     /// @param tokens Array of addresses for ERC-20 tokens that is loaned.     /// @param amounts A one-to-one map to tokens that is loaned.     /// @param fees A one-to-one map to tokens that needs to be paid on top for each loan. Needs to be the same token.     /// @param data Additional data that was passed to the flashloan function.     function onBatchFlashLoan(         address sender,         IERC20[] calldata tokens,         uint256[] calldata amounts,         uint256[] calldata fees,         bytes calldata data     ) external; } // File contracts/interfaces/IWETH.sol // License-Identifier: MIT interface IWETH {     function deposit() external payable; function withdraw(uint256) external;  } // File contracts/interfaces/IStrategy.sol // License-Identifier: MIT interface IStrategy {     /// @notice Send the assets to the Strategy and call skim to invest them.     /// @param amount The amount of tokens to invest.     function skim(uint256 amount) external; /// @notice Harvest any profits made converted to the asset and pass them to the caller. /// @param balance The amount of tokens the caller thinks it has invested. /// @param sender The address of the initiator of this transaction. Can be used for reimbursements, etc. /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`. function harvest(uint256 balance, address sender) external returns (int256 amountAdded);  /// @notice Withdraw assets. The returned amount can differ from the requested amount due to rounding. /// @dev The `actualAmount` should be very close to the amount. /// The difference should NOT be used to report a loss. That's what harvest is for. /// @param amount The requested amount the caller wants to withdraw. /// @return actualAmount The real amount that is withdrawn. function withdraw(uint256 amount) external returns (uint256 actualAmount);  /// @notice Withdraw all assets in the safest way possible. This shouldn't fail. /// @param balance The amount of tokens the caller thinks it has invested. /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`. function exit(uint256 balance) external returns (int256 amountAdded);  } // File @boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol@v1.2.0 // License-Identifier: MIT library BoringERC20 {     bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()     bytes4 private constant SIG_NAME = 0x06fdde03; // name()     bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()     bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)     bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256) /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations. /// Reverts on a failed transfer. /// @param token The address of the ERC-20 token. /// @param to Transfer tokens to. /// @param amount The token amount. function safeTransfer(     IERC20 token,     address to,     uint256 amount ) internal {     (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));     require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), ""BoringERC20: Transfer failed""); }  /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations. /// Reverts on a failed transfer. /// @param token The address of the ERC-20 token. /// @param from Transfer tokens from. /// @param to Transfer tokens to. /// @param amount The token amount. function safeTransferFrom(     IERC20 token,     address from,     address to,     uint256 amount ) internal {     (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));     require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), ""BoringERC20: TransferFrom failed""); }  } // File @boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol@v1.2.0 // License-Identifier: MIT /// @notice A library for performing overflow-/underflow-safe math, /// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math). library BoringMath {     function add(uint256 a, uint256 b) internal pure returns (uint256 c) {         require((c = a + b) &gt;= b, ""BoringMath: Add Overflow"");     } function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {     require((c = a - b) &lt;= a, ""BoringMath: Underflow""); }  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {     require(b == 0 || (c = a * b) / b == a, ""BoringMath: Mul Overflow""); }  function to128(uint256 a) internal pure returns (uint128 c) {     require(a &lt;= uint128(-1), ""BoringMath: uint128 Overflow"");     c = uint128(a); }  function to64(uint256 a) internal pure returns (uint64 c) {     require(a &lt;= uint64(-1), ""BoringMath: uint64 Overflow"");     c = uint64(a); }  function to32(uint256 a) internal pure returns (uint32 c) {     require(a &lt;= uint32(-1), ""BoringMath: uint32 Overflow"");     c = uint32(a); }  } /// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint128. library BoringMath128 {     function add(uint128 a, uint128 b) internal pure returns (uint128 c) {         require((c = a + b) &gt;= b, ""BoringMath: Add Overflow"");     } function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {     require((c = a - b) &lt;= a, ""BoringMath: Underflow""); }  } /// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint64. library BoringMath64 {     function add(uint64 a, uint64 b) internal pure returns (uint64 c) {         require((c = a + b) &gt;= b, ""BoringMath: Add Overflow"");     } function sub(uint64 a, uint64 b) internal pure returns (uint64 c) {     require((c = a - b) &lt;= a, ""BoringMath: Underflow""); }  } /// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint32. library BoringMath32 {     function add(uint32 a, uint32 b) internal pure returns (uint32 c) {         require((c = a + b) &gt;= b, ""BoringMath: Add Overflow"");     } function sub(uint32 a, uint32 b) internal pure returns (uint32 c) {     require((c = a - b) &lt;= a, ""BoringMath: Underflow""); }  } // File @boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol@v1.2.0 // License-Identifier: MIT struct Rebase {     uint128 elastic;     uint128 base; } /// @notice A rebasing library using overflow-/underflow-safe math. library RebaseLibrary {     using BoringMath for uint256;     using BoringMath128 for uint128; /// @notice Calculates the base value in relationship to `elastic` and `total`. function toBase(     Rebase memory total,     uint256 elastic,     bool roundUp ) internal pure returns (uint256 base) {     if (total.elastic == 0) {         base = elastic;     } else {         base = elastic.mul(total.base) / total.elastic;         if (roundUp &amp;&amp; base.mul(total.elastic) / total.base &lt; elastic) {             base = base.add(1);         }     } }  /// @notice Calculates the elastic value in relationship to `base` and `total`. function toElastic(     Rebase memory total,     uint256 base,     bool roundUp ) internal pure returns (uint256 elastic) {     if (total.base == 0) {         elastic = base;     } else {         elastic = base.mul(total.elastic) / total.base;         if (roundUp &amp;&amp; elastic.mul(total.base) / total.elastic &lt; base) {             elastic = elastic.add(1);         }     } }  /// @notice Add `elastic` to `total` and doubles `total.base`. /// @return (Rebase) The new total. /// @return base in relationship to `elastic`. function add(     Rebase memory total,     uint256 elastic,     bool roundUp ) internal pure returns (Rebase memory, uint256 base) {     base = toBase(total, elastic, roundUp);     total.elastic = total.elastic.add(elastic.to128());     total.base = total.base.add(base.to128());     return (total, base); }  /// @notice Sub `base` from `total` and update `total.elastic`. /// @return (Rebase) The new total. /// @return elastic in relationship to `base`. function sub(     Rebase memory total,     uint256 base,     bool roundUp ) internal pure returns (Rebase memory, uint256 elastic) {     elastic = toElastic(total, base, roundUp);     total.elastic = total.elastic.sub(elastic.to128());     total.base = total.base.sub(base.to128());     return (total, elastic); }  /// @notice Add `elastic` and `base` to `total`. function add(     Rebase memory total,     uint256 elastic,     uint256 base ) internal pure returns (Rebase memory) {     total.elastic = total.elastic.add(elastic.to128());     total.base = total.base.add(base.to128());     return total; }  /// @notice Subtract `elastic` and `base` to `total`. function sub(     Rebase memory total,     uint256 elastic,     uint256 base ) internal pure returns (Rebase memory) {     total.elastic = total.elastic.sub(elastic.to128());     total.base = total.base.sub(base.to128());     return total; }  /// @notice Add `elastic` to `total` and update storage. /// @return newElastic Returns updated `elastic`. function addElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {     newElastic = total.elastic = total.elastic.add(elastic.to128()); }  /// @notice Subtract `elastic` from `total` and update storage. /// @return newElastic Returns updated `elastic`. function subElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {     newElastic = total.elastic = total.elastic.sub(elastic.to128()); }  } // File @boringcrypto/boring-solidity/contracts/BoringOwnable.sol@v1.2.0 // License-Identifier: MIT // Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol // Edited by BoringCrypto contract BoringOwnableData {     address public owner;     address public pendingOwner; } contract BoringOwnable is BoringOwnableData {     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /// @notice `owner` defaults to msg.sender on construction. constructor() public {     owner = msg.sender;     emit OwnershipTransferred(address(0), msg.sender); }  /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner. /// Can only be invoked by the current `owner`. /// @param newOwner Address of the new owner. /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`. /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise. function transferOwnership(     address newOwner,     bool direct,     bool renounce ) public onlyOwner {     if (direct) {         // Checks         require(newOwner != address(0) || renounce, ""Ownable: zero address"");          // Effects         emit OwnershipTransferred(owner, newOwner);         owner = newOwner;         pendingOwner = address(0);     } else {         // Effects         pendingOwner = newOwner;     } }  /// @notice Needs to be called by `pendingOwner` to claim ownership. function claimOwnership() public {     address _pendingOwner = pendingOwner;      // Checks     require(msg.sender == _pendingOwner, ""Ownable: caller != pending owner"");      // Effects     emit OwnershipTransferred(owner, _pendingOwner);     owner = _pendingOwner;     pendingOwner = address(0); }  /// @notice Only allows the `owner` to execute the function. modifier onlyOwner() {     require(msg.sender == owner, ""Ownable: caller is not the owner"");     _; }  } // File @boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol@v1.2.0 // License-Identifier: MIT interface IMasterContract {     /// @notice Init function that gets called from BoringFactory.deploy.     /// Also kown as the constructor for cloned contracts.     /// Any ETH send to BoringFactory.deploy ends up here.     /// @param data Can be abi encoded arguments or anything else.     function init(bytes calldata data) external payable; } // File @boringcrypto/boring-solidity/contracts/BoringFactory.sol@v1.2.0 // License-Identifier: MIT contract BoringFactory {     event LogDeploy(address indexed masterContract, bytes data, address indexed cloneAddress); /// @notice Mapping from clone contracts to their masterContract. mapping(address =&gt; address) public masterContractOf;  /// @notice Deploys a given master Contract as a clone. /// Any ETH transferred with this call is forwarded to the new clone. /// Emits `LogDeploy`. /// @param masterContract The address of the contract to clone. /// @param data Additional abi encoded calldata that is passed to the new clone via `IMasterContract.init`. /// @param useCreate2 Creates the clone by using the CREATE2 opcode, in this case `data` will be used as salt. /// @return cloneAddress Address of the created clone contract. function deploy(     address masterContract,     bytes calldata data,     bool useCreate2 ) public payable returns (address cloneAddress) {     require(masterContract != address(0), ""BoringFactory: No masterContract"");     bytes20 targetBytes = bytes20(masterContract); // Takes the first 20 bytes of the masterContract's address      if (useCreate2) {         // each masterContract has different code already. So clones are distinguished by their data only.         bytes32 salt = keccak256(data);          // Creates clone, more info here: https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/         assembly {             let clone := mload(0x40)             mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)             mstore(add(clone, 0x14), targetBytes)             mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)             cloneAddress := create2(0, clone, 0x37, salt)         }     } else {         assembly {             let clone := mload(0x40)             mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)             mstore(add(clone, 0x14), targetBytes)             mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)             cloneAddress := create(0, clone, 0x37)         }     }     masterContractOf[cloneAddress] = masterContract;      IMasterContract(cloneAddress).init{value: msg.value}(data);      emit LogDeploy(masterContract, data, cloneAddress); }  } // File contracts/MasterContractManager.sol // License-Identifier: UNLICENSED contract MasterContractManager is BoringOwnable, BoringFactory {     event LogWhiteListMasterContract(address indexed masterContract, bool approved);     event LogSetMasterContractApproval(address indexed masterContract, address indexed user, bool approved);     event LogRegisterProtocol(address indexed protocol); /// @notice masterContract to user to approval state mapping(address =&gt; mapping(address =&gt; bool)) public masterContractApproved; /// @notice masterContract to whitelisted state for approval without signed message mapping(address =&gt; bool) public whitelistedMasterContracts; /// @notice user nonces for masterContract approvals mapping(address =&gt; uint256) public nonces;  bytes32 private constant DOMAIN_SEPARATOR_SIGNATURE_HASH = keccak256(""EIP712Domain(string name,uint256 chainId,address verifyingContract)""); // See https://eips.ethereum.org/EIPS/eip-191 string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = ""\x19\x01""; bytes32 private constant APPROVAL_SIGNATURE_HASH =     keccak256(""SetMasterContractApproval(string warning,address user,address masterContract,bool approved,uint256 nonce)"");  // solhint-disable-next-line var-name-mixedcase bytes32 private immutable _DOMAIN_SEPARATOR; // solhint-disable-next-line var-name-mixedcase uint256 private immutable DOMAIN_SEPARATOR_CHAIN_ID;  constructor() public {     uint256 chainId;     assembly {         chainId := chainid()     }     _DOMAIN_SEPARATOR = _calculateDomainSeparator(DOMAIN_SEPARATOR_CHAIN_ID = chainId); }  function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {     return keccak256(abi.encode(DOMAIN_SEPARATOR_SIGNATURE_HASH, keccak256(""BentoBox V1""), chainId, address(this))); }  // solhint-disable-next-line func-name-mixedcase function DOMAIN_SEPARATOR() public view returns (bytes32) {     uint256 chainId;     assembly {         chainId := chainid()     }     return chainId == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId); }  /// @notice Other contracts need to register with this master contract so that users can approve them for the BentoBox. function registerProtocol() public {     masterContractOf[msg.sender] = msg.sender;     emit LogRegisterProtocol(msg.sender); }  /// @notice Enables or disables a contract for approval without signed message. function whitelistMasterContract(address masterContract, bool approved) public onlyOwner {     // Checks     require(masterContract != address(0), ""MasterCMgr: Cannot approve 0"");      // Effects     whitelistedMasterContracts[masterContract] = approved;     emit LogWhiteListMasterContract(masterContract, approved); }  /// @notice Approves or revokes a `masterContract` access to `user` funds. /// @param user The address of the user that approves or revokes access. /// @param masterContract The address who gains or loses access. /// @param approved If True approves access. If False revokes access. /// @param v Part of the signature. (See EIP-191) /// @param r Part of the signature. (See EIP-191) /// @param s Part of the signature. (See EIP-191) // F4 - Check behaviour for all function arguments when wrong or extreme // F4: Don't allow masterContract 0 to be approved. Unknown contracts will have a masterContract of 0. // F4: User can't be 0 for signed approvals because the recoveredAddress will be 0 if ecrecover fails function setMasterContractApproval(     address user,     address masterContract,     bool approved,     uint8 v,     bytes32 r,     bytes32 s ) public {     // Checks     require(masterContract != address(0), ""MasterCMgr: masterC not set""); // Important for security      // If no signature is provided, the fallback is executed     if (r == 0 &amp;&amp; s == 0 &amp;&amp; v == 0) {         require(user == msg.sender, ""MasterCMgr: user not sender"");         require(masterContractOf[user] == address(0), ""MasterCMgr: user is clone"");         require(whitelistedMasterContracts[masterContract], ""MasterCMgr: not whitelisted"");     } else {         // Important for security - any address without masterContract has address(0) as masterContract         // So approving address(0) would approve every address, leading to full loss of funds         // Also, ecrecover returns address(0) on failure. So we check this:         require(user != address(0), ""MasterCMgr: User cannot be 0"");          // C10 - Protect signatures against replay, use nonce and chainId (SWC-121)         // C10: nonce + chainId are used to prevent replays         // C11 - All signatures strictly EIP-712 (SWC-117 SWC-122)         // C11: signature is EIP-712 compliant         // C12 - abi.encodePacked can't contain variable length user input (SWC-133)         // C12: abi.encodePacked has fixed length parameters         bytes32 digest =             keccak256(                 abi.encodePacked(                     EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA,                     DOMAIN_SEPARATOR(),                     keccak256(                         abi.encode(                             APPROVAL_SIGNATURE_HASH,                             approved                                 ? keccak256(""Give FULL access to funds in (and approved to) BentoBox?"")                                 : keccak256(""Revoke access to BentoBox?""),                             user,                             masterContract,                             approved,                             nonces[user]++                         )                     )                 )             );         address recoveredAddress = ecrecover(digest, v, r, s);         require(recoveredAddress == user, ""MasterCMgr: Invalid Signature"");     }      // Effects     masterContractApproved[masterContract][user] = approved;     emit LogSetMasterContractApproval(masterContract, user, approved); }  } // File @boringcrypto/boring-solidity/contracts/BoringBatchable.sol@v1.2.0 // License-Identifier: MIT contract BaseBoringBatchable {     /// @dev Helper function to extract a useful revert message from a failed call.     /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.     function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {         // If the _res length is less than 68, then the transaction failed silently (without a revert message)         if (_returnData.length &lt; 68) return ""Transaction reverted silently"";     assembly {         // Slice the sighash.         _returnData := add(_returnData, 0x04)     }     return abi.decode(_returnData, (string)); // All that remains is the revert string }  /// @notice Allows batched call to self (this contract). /// @param calls An array of inputs for each call. /// @param revertOnFail If True then reverts after a failed call and stops doing further calls. /// @return successes An array indicating the success of a call, mapped one-to-one to `calls`. /// @return results An array with the returned data of each function call, mapped one-to-one to `calls`. // F1: External is ok here because this is the batch function, adding it to a batch makes no sense // F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value // C3: The length of the loop is fully under user control, so can't be exploited // C7: Delegatecall is only used on the same contract, so it's safe function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results) {     successes = new bool[](calls.length);     results = new bytes[](calls.length);     for (uint256 i = 0; i &lt; calls.length; i++) {         (bool success, bytes memory result) = address(this).delegatecall(calls[i]);         require(success || !revertOnFail, _getRevertMsg(result));         successes[i] = success;         results[i] = result;     } }  } contract BoringBatchable is BaseBoringBatchable {     /// @notice Call wrapper that performs ERC20.permit on token.     /// Lookup IERC20.permit.     // F6: Parameters can be used front-run the permit and the user's permit will fail (due to nonce or other revert)     //     if part of a batch this could be used to grief once as the second call would not need the permit     function permitToken(         IERC20 token,         address from,         address to,         uint256 amount,         uint256 deadline,         uint8 v,         bytes32 r,         bytes32 s     ) public {         token.permit(from, to, amount, deadline, v, r, s);     } } // File contracts/BentoBox.sol // License-Identifier: UNLICENSED /// @title BentoBox /// @author BoringCrypto, Keno /// @notice The BentoBox is a vault for tokens. The stored tokens can be flash loaned and used in strategies. /// Yield from this will go to the token depositors. /// Rebasing tokens ARE NOT supported and WILL cause loss of funds. /// Any funds transfered directly onto the BentoBox will be lost, use the deposit function instead. contract BentoBoxV1 is MasterContractManager, BoringBatchable {     using BoringMath for uint256;     using BoringMath128 for uint128;     using BoringERC20 for IERC20;     using RebaseLibrary for Rebase; // ************** // // *** EVENTS *** // // ************** //  event LogDeposit(IERC20 indexed token, address indexed from, address indexed to, uint256 amount, uint256 share); event LogWithdraw(IERC20 indexed token, address indexed from, address indexed to, uint256 amount, uint256 share); event LogTransfer(IERC20 indexed token, address indexed from, address indexed to, uint256 share);  event LogFlashLoan(address indexed borrower, IERC20 indexed token, uint256 amount, uint256 feeAmount, address indexed receiver);  event LogStrategyTargetPercentage(IERC20 indexed token, uint256 targetPercentage); event LogStrategyQueued(IERC20 indexed token, IStrategy indexed strategy); event LogStrategySet(IERC20 indexed token, IStrategy indexed strategy); event LogStrategyInvest(IERC20 indexed token, uint256 amount); event LogStrategyDivest(IERC20 indexed token, uint256 amount); event LogStrategyProfit(IERC20 indexed token, uint256 amount); event LogStrategyLoss(IERC20 indexed token, uint256 amount);  // *************** // // *** STRUCTS *** // // *************** //  struct StrategyData {     uint64 strategyStartDate;     uint64 targetPercentage;     uint128 balance; // the balance of the strategy that BentoBox thinks is in there }  // ******************************** // // *** CONSTANTS AND IMMUTABLES *** // // ******************************** //  // V2 - Can they be private? // V2: Private to save gas, to verify it's correct, check the constructor arguments IERC20 private immutable wethToken;  IERC20 private constant USE_ETHEREUM = IERC20(0); uint256 private constant FLASH_LOAN_FEE = 50; // 0.05% uint256 private constant FLASH_LOAN_FEE_PRECISION = 1e5; uint256 private constant STRATEGY_DELAY = 2 weeks; uint256 private constant MAX_TARGET_PERCENTAGE = 95; // 95% uint256 private constant MINIMUM_SHARE_BALANCE = 1000; // To prevent the ratio going off  // ***************** // // *** VARIABLES *** // // ***************** //  // Balance per token per address/contract in shares mapping(IERC20 =&gt; mapping(address =&gt; uint256)) public balanceOf;  // Rebase from amount to share mapping(IERC20 =&gt; Rebase) public totals;  mapping(IERC20 =&gt; IStrategy) public strategy; mapping(IERC20 =&gt; IStrategy) public pendingStrategy; mapping(IERC20 =&gt; StrategyData) public strategyData;  // ******************* // // *** CONSTRUCTOR *** // // ******************* //  constructor(IERC20 wethToken_) public {     wethToken = wethToken_; }  // ***************** // // *** MODIFIERS *** // // ***************** //  /// Modifier to check if the msg.sender is allowed to use funds belonging to the 'from' address. /// If 'from' is msg.sender, it's allowed. /// If 'from' is the BentoBox itself, it's allowed. Any ETH, token balances (above the known balances) or BentoBox balances /// can be taken by anyone. /// This is to enable skimming, not just for deposits, but also for withdrawals or transfers, enabling better composability. /// If 'from' is a clone of a masterContract AND the 'from' address has approved that masterContract, it's allowed. modifier allowed(address from) {     if (from != msg.sender &amp;&amp; from != address(this)) {         // From is sender or you are skimming         address masterContract = masterContractOf[msg.sender];         require(masterContract != address(0), ""BentoBox: no masterContract"");         require(masterContractApproved[masterContract][from], ""BentoBox: Transfer not approved"");     }     _; }  // ************************** // // *** INTERNAL FUNCTIONS *** // // ************************** //  /// @dev Returns the total balance of `token` this contracts holds, /// plus the total amount this contract thinks the strategy holds. function _tokenBalanceOf(IERC20 token) internal view returns (uint256 amount) {     amount = token.balanceOf(address(this)).add(strategyData[token].balance); }  // ************************ // // *** PUBLIC FUNCTIONS *** // // ************************ //  /// @dev Helper function to represent an `amount` of `token` in shares. /// @param token The ERC-20 token. /// @param amount The `token` amount. /// @param roundUp If the result `share` should be rounded up. /// @return share The token amount represented in shares. function toShare(     IERC20 token,     uint256 amount,     bool roundUp ) external view returns (uint256 share) {     share = totals[token].toBase(amount, roundUp); }  /// @dev Helper function represent shares back into the `token` amount. /// @param token The ERC-20 token. /// @param share The amount of shares. /// @param roundUp If the result should be rounded up. /// @return amount The share amount back into native representation. function toAmount(     IERC20 token,     uint256 share,     bool roundUp ) external view returns (uint256 amount) {     amount = totals[token].toElastic(share, roundUp); }  /// @notice Deposit an amount of `token` represented in either `amount` or `share`. /// @param token_ The ERC-20 token to deposit. /// @param from which account to pull the tokens. /// @param to which account to push the tokens. /// @param amount Token amount in native representation to deposit. /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`. /// @return amountOut The amount deposited. /// @return shareOut The deposited amount repesented in shares. function deposit(     IERC20 token_,     address from,     address to,     uint256 amount,     uint256 share ) public payable allowed(from) returns (uint256 amountOut, uint256 shareOut) {     // Checks     require(to != address(0), ""BentoBox: to not set""); // To avoid a bad UI from burning funds      // Effects     IERC20 token = token_ == USE_ETHEREUM ? wethToken : token_;     Rebase memory total = totals[token];      // If a new token gets added, the tokenSupply call checks that this is a deployed contract. Needed for security.     require(total.elastic != 0 || token.totalSupply() &gt; 0, ""BentoBox: No tokens"");     if (share == 0) {         // value of the share may be lower than the amount due to rounding, that's ok         share = total.toBase(amount, false);         // Any deposit should lead to at least the minimum share balance, otherwise it's ignored (no amount taken)         if (total.base.add(share.to128()) &lt; MINIMUM_SHARE_BALANCE) {             return (0, 0);         }     } else {         // amount may be lower than the value of share due to rounding, in that case, add 1 to amount (Always round up)         amount = total.toElastic(share, true);     }      // In case of skimming, check that only the skimmable amount is taken.     // For ETH, the full balance is available, so no need to check.     // During flashloans the _tokenBalanceOf is lower than 'reality', so skimming deposits will mostly fail during a flashloan.     require(         from != address(this) || token_ == USE_ETHEREUM || amount &lt;= _tokenBalanceOf(token).sub(total.elastic),         ""BentoBox: Skim too much""     );      balanceOf[token][to] = balanceOf[token][to].add(share);     total.base = total.base.add(share.to128());     total.elastic = total.elastic.add(amount.to128());     totals[token] = total;      // Interactions     // During the first deposit, we check that this token is 'real'     if (token_ == USE_ETHEREUM) {         // X2 - If there is an error, could it cause a DoS. Like balanceOf causing revert. (SWC-113)         // X2: If the WETH implementation is faulty or malicious, it will block adding ETH (but we know the WETH implementation)         IWETH(address(wethToken)).deposit{value: amount}();     } else if (from != address(this)) {         // X2 - If there is an error, could it cause a DoS. Like balanceOf causing revert. (SWC-113)         // X2: If the token implementation is faulty or malicious, it may block adding tokens. Good.         token.safeTransferFrom(from, address(this), amount);     }     emit LogDeposit(token, from, to, amount, share);     amountOut = amount;     shareOut = share; }  /// @notice Withdraws an amount of `token` from a user account. /// @param token_ The ERC-20 token to withdraw. /// @param from which user to pull the tokens. /// @param to which user to push the tokens. /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied. /// @param share Like above, but `share` takes precedence over `amount`. function withdraw(     IERC20 token_,     address from,     address to,     uint256 amount,     uint256 share ) public allowed(from) returns (uint256 amountOut, uint256 shareOut) {     // Checks     require(to != address(0), ""BentoBox: to not set""); // To avoid a bad UI from burning funds      // Effects     IERC20 token = token_ == USE_ETHEREUM ? wethToken : token_;     Rebase memory total = totals[token];     if (share == 0) {         // value of the share paid could be lower than the amount paid due to rounding, in that case, add a share (Always round up)         share = total.toBase(amount, true);     } else {         // amount may be lower than the value of share due to rounding, that's ok         amount = total.toElastic(share, false);     }      balanceOf[token][from] = balanceOf[token][from].sub(share);     total.elastic = total.elastic.sub(amount.to128());     total.base = total.base.sub(share.to128());     // There have to be at least 1000 shares left to prevent reseting the share/amount ratio (unless it's fully emptied)     require(total.base &gt;= MINIMUM_SHARE_BALANCE || total.base == 0, ""BentoBox: cannot empty"");     totals[token] = total;      // Interactions     if (token_ == USE_ETHEREUM) {         // X2, X3: A revert or big gas usage in the WETH contract could block withdrawals, but WETH9 is fine.         IWETH(address(wethToken)).withdraw(amount);         // X2, X3: A revert or big gas usage could block, however, the to address is under control of the caller.         (bool success, ) = to.call{value: amount}("""");         require(success, ""BentoBox: ETH transfer failed"");     } else {         // X2, X3: A malicious token could block withdrawal of just THAT token.         //         masterContracts may want to take care not to rely on withdraw always succeeding.         token.safeTransfer(to, amount);     }     emit LogWithdraw(token, from, to, amount, share);     amountOut = amount;     shareOut = share; }  /// @notice Transfer shares from a user account to another one. /// @param token The ERC-20 token to transfer. /// @param from which user to pull the tokens. /// @param to which user to push the tokens. /// @param share The amount of `token` in shares. // Clones of master contracts can transfer from any account that has approved them // F3 - Can it be combined with another similar function? // F3: This isn't combined with transferMultiple for gas optimization function transfer(     IERC20 token,     address from,     address to,     uint256 share ) public allowed(from) {     // Checks     require(to != address(0), ""BentoBox: to not set""); // To avoid a bad UI from burning funds      // Effects     balanceOf[token][from] = balanceOf[token][from].sub(share);     balanceOf[token][to] = balanceOf[token][to].add(share);      emit LogTransfer(token, from, to, share); }  /// @notice Transfer shares from a user account to multiple other ones. /// @param token The ERC-20 token to transfer. /// @param from which user to pull the tokens. /// @param tos The receivers of the tokens. /// @param shares The amount of `token` in shares for each receiver in `tos`. // F3 - Can it be combined with another similar function? // F3: This isn't combined with transfer for gas optimization function transferMultiple(     IERC20 token,     address from,     address[] calldata tos,     uint256[] calldata shares ) public allowed(from) {     // Checks     require(tos[0] != address(0), ""BentoBox: to[0] not set""); // To avoid a bad UI from burning funds      // Effects     uint256 totalAmount;     uint256 len = tos.length;     for (uint256 i = 0; i &lt; len; i++) {         address to = tos[i];         balanceOf[token][to] = balanceOf[token][to].add(shares[i]);         totalAmount = totalAmount.add(shares[i]);         emit LogTransfer(token, from, to, shares[i]);     }     balanceOf[token][from] = balanceOf[token][from].sub(totalAmount); }  /// @notice Flashloan ability. /// @param borrower The address of the contract that implements and conforms to `IFlashBorrower` and handles the flashloan. /// @param receiver Address of the token receiver. /// @param token The address of the token to receive. /// @param amount of the tokens to receive. /// @param data The calldata to pass to the `borrower` contract. // F5 - Checks-Effects-Interactions pattern followed? (SWC-107) // F5: Not possible to follow this here, reentrancy has been reviewed // F6 - Check for front-running possibilities, such as the approve function (SWC-114) // F6: Slight grieving possible by withdrawing an amount before someone tries to flashloan close to the full amount. function flashLoan(     IFlashBorrower borrower,     address receiver,     IERC20 token,     uint256 amount,     bytes calldata data ) public {     uint256 fee = amount.mul(FLASH_LOAN_FEE) / FLASH_LOAN_FEE_PRECISION;     token.safeTransfer(receiver, amount);      borrower.onFlashLoan(msg.sender, token, amount, fee, data);      require(_tokenBalanceOf(token) &gt;= totals[token].addElastic(fee.to128()), ""BentoBox: Wrong amount"");     emit LogFlashLoan(address(borrower), token, amount, fee, receiver); }  /// @notice Support for batched flashloans. Useful to request multiple different `tokens` in a single transaction. /// @param borrower The address of the contract that implements and conforms to `IBatchFlashBorrower` and handles the flashloan. /// @param receivers An array of the token receivers. A one-to-one mapping with `tokens` and `amounts`. /// @param tokens The addresses of the tokens. /// @param amounts of the tokens for each receiver. /// @param data The calldata to pass to the `borrower` contract. // F5 - Checks-Effects-Interactions pattern followed? (SWC-107) // F5: Not possible to follow this here, reentrancy has been reviewed // F6 - Check for front-running possibilities, such as the approve function (SWC-114) // F6: Slight grieving possible by withdrawing an amount before someone tries to flashloan close to the full amount. function batchFlashLoan(     IBatchFlashBorrower borrower,     address[] calldata receivers,     IERC20[] calldata tokens,     uint256[] calldata amounts,     bytes calldata data ) public {     uint256[] memory fees = new uint256[](tokens.length);      uint256 len = tokens.length;     for (uint256 i = 0; i &lt; len; i++) {         uint256 amount = amounts[i];         fees[i] = amount.mul(FLASH_LOAN_FEE) / FLASH_LOAN_FEE_PRECISION;          tokens[i].safeTransfer(receivers[i], amounts[i]);     }      borrower.onBatchFlashLoan(msg.sender, tokens, amounts, fees, data);      for (uint256 i = 0; i &lt; len; i++) {         IERC20 token = tokens[i];         require(_tokenBalanceOf(token) &gt;= totals[token].addElastic(fees[i].to128()), ""BentoBox: Wrong amount"");         emit LogFlashLoan(address(borrower), token, amounts[i], fees[i], receivers[i]);     } }  /// @notice Sets the target percentage of the strategy for `token`. /// @dev Only the owner of this contract is allowed to change this. /// @param token The address of the token that maps to a strategy to change. /// @param targetPercentage_ The new target in percent. Must be lesser or equal to `MAX_TARGET_PERCENTAGE`. function setStrategyTargetPercentage(IERC20 token, uint64 targetPercentage_) public onlyOwner {     // Checks     require(targetPercentage_ &lt;= MAX_TARGET_PERCENTAGE, ""StrategyManager: Target too high"");      // Effects     strategyData[token].targetPercentage = targetPercentage_;     emit LogStrategyTargetPercentage(token, targetPercentage_); }  /// @notice Sets the contract address of a new strategy that conforms to `IStrategy` for `token`. /// Must be called twice with the same arguments. /// A new strategy becomes pending first and can be activated once `STRATEGY_DELAY` is over. /// @dev Only the owner of this contract is allowed to change this. /// @param token The address of the token that maps to a strategy to change. /// @param newStrategy The address of the contract that conforms to `IStrategy`. // F5 - Checks-Effects-Interactions pattern followed? (SWC-107) // F5: Total amount is updated AFTER interaction. But strategy is under our control. // C4 - Use block.timestamp only for long intervals (SWC-116) // C4: block.timestamp is used for a period of 2 weeks, which is long enough function setStrategy(IERC20 token, IStrategy newStrategy) public onlyOwner {     StrategyData memory data = strategyData[token];     IStrategy pending = pendingStrategy[token];     if (data.strategyStartDate == 0 || pending != newStrategy) {         pendingStrategy[token] = newStrategy;         // C1 - All math done through BoringMath (SWC-101)         // C1: Our sun will swallow the earth well before this overflows         data.strategyStartDate = (block.timestamp + STRATEGY_DELAY).to64();         emit LogStrategyQueued(token, newStrategy);     } else {         require(data.strategyStartDate != 0 &amp;&amp; block.timestamp &gt;= data.strategyStartDate, ""StrategyManager: Too early"");         if (address(strategy[token]) != address(0)) {             int256 balanceChange = strategy[token].exit(data.balance);             // Effects             if (balanceChange &gt; 0) {                 uint256 add = uint256(balanceChange);                 totals[token].addElastic(add);                 emit LogStrategyProfit(token, add);             } else if (balanceChange &lt; 0) {                 uint256 sub = uint256(-balanceChange);                 totals[token].subElastic(sub);                 emit LogStrategyLoss(token, sub);             }              emit LogStrategyDivest(token, data.balance);         }         strategy[token] = pending;         data.strategyStartDate = 0;         data.balance = 0;         pendingStrategy[token] = IStrategy(0);         emit LogStrategySet(token, newStrategy);     }     strategyData[token] = data; }  /// @notice The actual process of yield farming. Executes the strategy of `token`. /// Optionally does housekeeping if `balance` is true. /// `maxChangeAmount` is relevant for skimming or withdrawing if `balance` is true. /// @param token The address of the token for which a strategy is deployed. /// @param balance True if housekeeping should be done. /// @param maxChangeAmount The maximum amount for either pulling or pushing from/to the `IStrategy` contract. // F5 - Checks-Effects-Interactions pattern followed? (SWC-107) // F5: Total amount is updated AFTER interaction. But strategy is under our control. // F5: Not followed to prevent reentrancy issues with flashloans and BentoBox skims? function harvest(     IERC20 token,     bool balance,     uint256 maxChangeAmount ) public {     StrategyData memory data = strategyData[token];     IStrategy _strategy = strategy[token];     int256 balanceChange = _strategy.harvest(data.balance, msg.sender);     if (balanceChange == 0 &amp;&amp; !balance) {         return;     }      uint256 totalElastic = totals[token].elastic;      if (balanceChange &gt; 0) {         uint256 add = uint256(balanceChange);         totalElastic = totalElastic.add(add);         totals[token].elastic = totalElastic.to128();         emit LogStrategyProfit(token, add);     } else if (balanceChange &lt; 0) {         // C1 - All math done through BoringMath (SWC-101)         // C1: balanceChange could overflow if it's max negative int128.         // But tokens with balances that large are not supported by the BentoBox.         uint256 sub = uint256(-balanceChange);         totalElastic = totalElastic.sub(sub);         totals[token].elastic = totalElastic.to128();         data.balance = data.balance.sub(sub.to128());         emit LogStrategyLoss(token, sub);     }      if (balance) {         uint256 targetBalance = totalElastic.mul(data.targetPercentage) / 100;         // if data.balance == targetBalance there is nothing to update         if (data.balance &lt; targetBalance) {             uint256 amountOut = targetBalance.sub(data.balance);             if (maxChangeAmount != 0 &amp;&amp; amountOut &gt; maxChangeAmount) {                 amountOut = maxChangeAmount;             }             token.safeTransfer(address(_strategy), amountOut);             data.balance = data.balance.add(amountOut.to128());             _strategy.skim(amountOut);             emit LogStrategyInvest(token, amountOut);         } else if (data.balance &gt; targetBalance) {             uint256 amountIn = data.balance.sub(targetBalance.to128());             if (maxChangeAmount != 0 &amp;&amp; amountIn &gt; maxChangeAmount) {                 amountIn = maxChangeAmount;             }              uint256 actualAmountIn = _strategy.withdraw(amountIn);              data.balance = data.balance.sub(actualAmountIn.to128());             emit LogStrategyDivest(token, actualAmountIn);         }     }      strategyData[token] = data; }  // Contract should be able to receive ETH deposits to support deposit &amp; skim // solhint-disable-next-line no-empty-blocks receive() external payable {}  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-15-08 17:06:30 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED
// The BentoBox

//  ▄▄▄▄· ▄▄▄ . ▐ ▄ ▄▄▄▄▄      ▄▄▄▄·       ▐▄• ▄
//  ▐█ ▀█▪▀▄.▀·█▌▐█•██  ▪     ▐█ ▀█▪▪      █▌█▌▪
//  ▐█▀▀█▄▐▀▀▪▄▐█▐▐▌ ▐█.▪ ▄█▀▄ ▐█▀▀█▄ ▄█▀▄  ·██·
//  ██▄▪▐█▐█▄▄▌██▐█▌ ▐█▌·▐█▌.▐▌██▄▪▐█▐█▌.▐▌▪▐█·█▌
//  ·▀▀▀▀  ▀▀▀ ▀▀ █▪ ▀▀▀  ▀█▄▀▪·▀▀▀▀  ▀█▄▀▪•▀▀ ▀▀

// This contract stores funds, handles their transfers, supports flash loans and strategies.

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to Keno for all his hard work and support

// Version 22-Mar-2021

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

// solhint-disable avoid-low-level-calls
// solhint-disable not-rely-on-time
// solhint-disable no-inline-assembly

// File @boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol@v1.2.0
// License-Identifier: MIT

interface IERC20 {
    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /// @notice EIP 2612
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}

// File contracts/interfaces/IFlashLoan.sol
// License-Identifier: MIT

interface IFlashBorrower {
    /// @notice The flashloan callback. `amount` + `fee` needs to repayed to msg.sender before this call returns.
    /// @param sender The address of the invoker of this flashloan.
    /// @param token The address of the token that is loaned.
    /// @param amount of the `token` that is loaned.
    /// @param fee The fee that needs to be paid on top for this loan. Needs to be the same as `token`.
    /// @param data Additional data that was passed to the flashloan function.
    function onFlashLoan(
        address sender,
        IERC20 token,
        uint256 amount,
        uint256 fee,
        bytes calldata data
    ) external;
}

interface IBatchFlashBorrower {
    /// @notice The callback for batched flashloans. Every amount + fee needs to repayed to msg.sender before this call returns.
    /// @param sender The address of the invoker of this flashloan.
    /// @param tokens Array of addresses for ERC-20 tokens that is loaned.
    /// @param amounts A one-to-one map to `tokens` that is loaned.
    /// @param fees A one-to-one map to `tokens` that needs to be paid on top for each loan. Needs to be the same token.
    /// @param data Additional data that was passed to the flashloan function.
    function onBatchFlashLoan(
        address sender,
        IERC20[] calldata tokens,
        uint256[] calldata amounts,
        uint256[] calldata fees,
        bytes calldata data
    ) external;
}

// File contracts/interfaces/IWETH.sol
// License-Identifier: MIT

interface IWETH {
    function deposit() external payable;

    function withdraw(uint256) external;
}

// File contracts/interfaces/IStrategy.sol
// License-Identifier: MIT

interface IStrategy {
    /// @notice Send the assets to the Strategy and call skim to invest them.
    /// @param amount The amount of tokens to invest.
    function skim(uint256 amount) external;

    /// @notice Harvest any profits made converted to the asset and pass them to the caller.
    /// @param balance The amount of tokens the caller thinks it has invested.
    /// @param sender The address of the initiator of this transaction. Can be used for reimbursements, etc.
    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.
    function harvest(uint256 balance, address sender) external returns (int256 amountAdded);

    /// @notice Withdraw assets. The returned amount can differ from the requested amount due to rounding.
    /// @dev The `actualAmount` should be very close to the amount.
    /// The difference should NOT be used to report a loss. That's what harvest is for.
    /// @param amount The requested amount the caller wants to withdraw.
    /// @return actualAmount The real amount that is withdrawn.
    function withdraw(uint256 amount) external returns (uint256 actualAmount);

    /// @notice Withdraw all assets in the safest way possible. This shouldn't fail.
    /// @param balance The amount of tokens the caller thinks it has invested.
    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.
    function exit(uint256 balance) external returns (int256 amountAdded);
}

// File @boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol@v1.2.0
// License-Identifier: MIT

library BoringERC20 {
    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()
    bytes4 private constant SIG_NAME = 0x06fdde03; // name()
    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()
    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)
    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)

    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.
    /// Reverts on a failed transfer.
    /// @param token The address of the ERC-20 token.
    /// @param to Transfer tokens to.
    /// @param amount The token amount.
    function safeTransfer(
        IERC20 token,
        address to,
        uint256 amount
    ) internal {
        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));
        require(success && (data.length == 0 || abi.decode(data, (bool))), ""BoringERC20: Transfer failed"");
    }

    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.
    /// Reverts on a failed transfer.
    /// @param token The address of the ERC-20 token.
    /// @param from Transfer tokens from.
    /// @param to Transfer tokens to.
    /// @param amount The token amount.
    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 amount
    ) internal {
        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));
        require(success && (data.length == 0 || abi.decode(data, (bool))), ""BoringERC20: TransferFrom failed"");
    }
}

// File @boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol@v1.2.0
// License-Identifier: MIT

/// @notice A library for performing overflow-/underflow-safe math,
/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).
library BoringMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require(b == 0 || (c = a * b) / b == a, ""BoringMath: Mul Overflow"");
    }

    function to128(uint256 a) internal pure returns (uint128 c) {
        require(a <= uint128(-1), ""BoringMath: uint128 Overflow"");
        c = uint128(a);
    }

    function to64(uint256 a) internal pure returns (uint64 c) {
        require(a <= uint64(-1), ""BoringMath: uint64 Overflow"");
        c = uint64(a);
    }

    function to32(uint256 a) internal pure returns (uint32 c) {
        require(a <= uint32(-1), ""BoringMath: uint32 Overflow"");
        c = uint32(a);
    }
}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint128.
library BoringMath128 {
    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }
}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint64.
library BoringMath64 {
    function add(uint64 a, uint64 b) internal pure returns (uint64 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint64 a, uint64 b) internal pure returns (uint64 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }
}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint32.
library BoringMath32 {
    function add(uint32 a, uint32 b) internal pure returns (uint32 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint32 a, uint32 b) internal pure returns (uint32 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }
}

// File @boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol@v1.2.0
// License-Identifier: MIT

struct Rebase {
    uint128 elastic;
    uint128 base;
}

/// @notice A rebasing library using overflow-/underflow-safe math.
library RebaseLibrary {
    using BoringMath for uint256;
    using BoringMath128 for uint128;

    /// @notice Calculates the base value in relationship to `elastic` and `total`.
    function toBase(
        Rebase memory total,
        uint256 elastic,
        bool roundUp
    ) internal pure returns (uint256 base) {
        if (total.elastic == 0) {
            base = elastic;
        } else {
            base = elastic.mul(total.base) / total.elastic;
            if (roundUp && base.mul(total.elastic) / total.base < elastic) {
                base = base.add(1);
            }
        }
    }

    /// @notice Calculates the elastic value in relationship to `base` and `total`.
    function toElastic(
        Rebase memory total,
        uint256 base,
        bool roundUp
    ) internal pure returns (uint256 elastic) {
        if (total.base == 0) {
            elastic = base;
        } else {
            elastic = base.mul(total.elastic) / total.base;
            if (roundUp && elastic.mul(total.base) / total.elastic < base) {
                elastic = elastic.add(1);
            }
        }
    }

    /// @notice Add `elastic` to `total` and doubles `total.base`.
    /// @return (Rebase) The new total.
    /// @return base in relationship to `elastic`.
    function add(
        Rebase memory total,
        uint256 elastic,
        bool roundUp
    ) internal pure returns (Rebase memory, uint256 base) {
        base = toBase(total, elastic, roundUp);
        total.elastic = total.elastic.add(elastic.to128());
        total.base = total.base.add(base.to128());
        return (total, base);
    }

    /// @notice Sub `base` from `total` and update `total.elastic`.
    /// @return (Rebase) The new total.
    /// @return elastic in relationship to `base`.
    function sub(
        Rebase memory total,
        uint256 base,
        bool roundUp
    ) internal pure returns (Rebase memory, uint256 elastic) {
        elastic = toElastic(total, base, roundUp);
        total.elastic = total.elastic.sub(elastic.to128());
        total.base = total.base.sub(base.to128());
        return (total, elastic);
    }

    /// @notice Add `elastic` and `base` to `total`.
    function add(
        Rebase memory total,
        uint256 elastic,
        uint256 base
    ) internal pure returns (Rebase memory) {
        total.elastic = total.elastic.add(elastic.to128());
        total.base = total.base.add(base.to128());
        return total;
    }

    /// @notice Subtract `elastic` and `base` to `total`.
    function sub(
        Rebase memory total,
        uint256 elastic,
        uint256 base
    ) internal pure returns (Rebase memory) {
        total.elastic = total.elastic.sub(elastic.to128());
        total.base = total.base.sub(base.to128());
        return total;
    }

    /// @notice Add `elastic` to `total` and update storage.
    /// @return newElastic Returns updated `elastic`.
    function addElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {
        newElastic = total.elastic = total.elastic.add(elastic.to128());
    }

    /// @notice Subtract `elastic` from `total` and update storage.
    /// @return newElastic Returns updated `elastic`.
    function subElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {
        newElastic = total.elastic = total.elastic.sub(elastic.to128());
    }
}

// File @boringcrypto/boring-solidity/contracts/BoringOwnable.sol@v1.2.0
// License-Identifier: MIT

// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol
// Edited by BoringCrypto

contract BoringOwnableData {
    address public owner;
    address public pendingOwner;
}

contract BoringOwnable is BoringOwnableData {
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /// @notice `owner` defaults to msg.sender on construction.
    constructor() public {
        owner = msg.sender;
        emit OwnershipTransferred(address(0), msg.sender);
    }

    /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.
    /// Can only be invoked by the current `owner`.
    /// @param newOwner Address of the new owner.
    /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.
    /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.
    function transferOwnership(
        address newOwner,
        bool direct,
        bool renounce
    ) public onlyOwner {
        if (direct) {
            // Checks
            require(newOwner != address(0) || renounce, ""Ownable: zero address"");

            // Effects
            emit OwnershipTransferred(owner, newOwner);
            owner = newOwner;
            pendingOwner = address(0);
        } else {
            // Effects
            pendingOwner = newOwner;
        }
    }

    /// @notice Needs to be called by `pendingOwner` to claim ownership.
    function claimOwnership() public {
        address _pendingOwner = pendingOwner;

        // Checks
        require(msg.sender == _pendingOwner, ""Ownable: caller != pending owner"");

        // Effects
        emit OwnershipTransferred(owner, _pendingOwner);
        owner = _pendingOwner;
        pendingOwner = address(0);
    }

    /// @notice Only allows the `owner` to execute the function.
    modifier onlyOwner() {
        require(msg.sender == owner, ""Ownable: caller is not the owner"");
        _;
    }
}

// File @boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol@v1.2.0
// License-Identifier: MIT

interface IMasterContract {
    /// @notice Init function that gets called from `BoringFactory.deploy`.
    /// Also kown as the constructor for cloned contracts.
    /// Any ETH send to `BoringFactory.deploy` ends up here.
    /// @param data Can be abi encoded arguments or anything else.
    function init(bytes calldata data) external payable;
}

// File @boringcrypto/boring-solidity/contracts/BoringFactory.sol@v1.2.0
// License-Identifier: MIT

contract BoringFactory {
    event LogDeploy(address indexed masterContract, bytes data, address indexed cloneAddress);

    /// @notice Mapping from clone contracts to their masterContract.
    mapping(address => address) public masterContractOf;

    /// @notice Deploys a given master Contract as a clone.
    /// Any ETH transferred with this call is forwarded to the new clone.
    /// Emits `LogDeploy`.
    /// @param masterContract The address of the contract to clone.
    /// @param data Additional abi encoded calldata that is passed to the new clone via `IMasterContract.init`.
    /// @param useCreate2 Creates the clone by using the CREATE2 opcode, in this case `data` will be used as salt.
    /// @return cloneAddress Address of the created clone contract.
    function deploy(
        address masterContract,
        bytes calldata data,
        bool useCreate2
    ) public payable returns (address cloneAddress) {
        require(masterContract != address(0), ""BoringFactory: No masterContract"");
        bytes20 targetBytes = bytes20(masterContract); // Takes the first 20 bytes of the masterContract's address

        if (useCreate2) {
            // each masterContract has different code already. So clones are distinguished by their data only.
            bytes32 salt = keccak256(data);

            // Creates clone, more info here: https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/
            assembly {
                let clone := mload(0x40)
                mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)
                mstore(add(clone, 0x14), targetBytes)
                mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)
                cloneAddress := create2(0, clone, 0x37, salt)
            }
        } else {
            assembly {
                let clone := mload(0x40)
                mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)
                mstore(add(clone, 0x14), targetBytes)
                mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)
                cloneAddress := create(0, clone, 0x37)
            }
        }
        masterContractOf[cloneAddress] = masterContract;

        IMasterContract(cloneAddress).init{value: msg.value}(data);

        emit LogDeploy(masterContract, data, cloneAddress);
    }
}

// File contracts/MasterContractManager.sol
// License-Identifier: UNLICENSED

contract MasterContractManager is BoringOwnable, BoringFactory {
    event LogWhiteListMasterContract(address indexed masterContract, bool approved);
    event LogSetMasterContractApproval(address indexed masterContract, address indexed user, bool approved);
    event LogRegisterProtocol(address indexed protocol);

    /// @notice masterContract to user to approval state
    mapping(address => mapping(address => bool)) public masterContractApproved;
    /// @notice masterContract to whitelisted state for approval without signed message
    mapping(address => bool) public whitelistedMasterContracts;
    /// @notice user nonces for masterContract approvals
    mapping(address => uint256) public nonces;

    bytes32 private constant DOMAIN_SEPARATOR_SIGNATURE_HASH = keccak256(""EIP712Domain(string name,uint256 chainId,address verifyingContract)"");
    // See https://eips.ethereum.org/EIPS/eip-191
    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = ""\x19\x01"";
    bytes32 private constant APPROVAL_SIGNATURE_HASH =
        keccak256(""SetMasterContractApproval(string warning,address user,address masterContract,bool approved,uint256 nonce)"");

    // solhint-disable-next-line var-name-mixedcase
    bytes32 private immutable _DOMAIN_SEPARATOR;
    // solhint-disable-next-line var-name-mixedcase
    uint256 private immutable DOMAIN_SEPARATOR_CHAIN_ID;

    constructor() public {
        uint256 chainId;
        assembly {
            chainId := chainid()
        }
        _DOMAIN_SEPARATOR = _calculateDomainSeparator(DOMAIN_SEPARATOR_CHAIN_ID = chainId);
    }

    function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {
        return keccak256(abi.encode(DOMAIN_SEPARATOR_SIGNATURE_HASH, keccak256(""BentoBox V1""), chainId, address(this)));
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() public view returns (bytes32) {
        uint256 chainId;
        assembly {
            chainId := chainid()
        }
        return chainId == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId);
    }

    /// @notice Other contracts need to register with this master contract so that users can approve them for the BentoBox.
    function registerProtocol() public {
        masterContractOf[msg.sender] = msg.sender;
        emit LogRegisterProtocol(msg.sender);
    }

    /// @notice Enables or disables a contract for approval without signed message.
    function whitelistMasterContract(address masterContract, bool approved) public onlyOwner {
        // Checks
        require(masterContract != address(0), ""MasterCMgr: Cannot approve 0"");

        // Effects
        whitelistedMasterContracts[masterContract] = approved;
        emit LogWhiteListMasterContract(masterContract, approved);
    }

    /// @notice Approves or revokes a `masterContract` access to `user` funds.
    /// @param user The address of the user that approves or revokes access.
    /// @param masterContract The address who gains or loses access.
    /// @param approved If True approves access. If False revokes access.
    /// @param v Part of the signature. (See EIP-191)
    /// @param r Part of the signature. (See EIP-191)
    /// @param s Part of the signature. (See EIP-191)
    // F4 - Check behaviour for all function arguments when wrong or extreme
    // F4: Don't allow masterContract 0 to be approved. Unknown contracts will have a masterContract of 0.
    // F4: User can't be 0 for signed approvals because the recoveredAddress will be 0 if ecrecover fails
    function setMasterContractApproval(
        address user,
        address masterContract,
        bool approved,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public {
        // Checks
        require(masterContract != address(0), ""MasterCMgr: masterC not set""); // Important for security

        // If no signature is provided, the fallback is executed
        if (r == 0 && s == 0 && v == 0) {
            require(user == msg.sender, ""MasterCMgr: user not sender"");
            require(masterContractOf[user] == address(0), ""MasterCMgr: user is clone"");
            require(whitelistedMasterContracts[masterContract], ""MasterCMgr: not whitelisted"");
        } else {
            // Important for security - any address without masterContract has address(0) as masterContract
            // So approving address(0) would approve every address, leading to full loss of funds
            // Also, ecrecover returns address(0) on failure. So we check this:
            require(user != address(0), ""MasterCMgr: User cannot be 0"");

            // C10 - Protect signatures against replay, use nonce and chainId (SWC-121)
            // C10: nonce + chainId are used to prevent replays
            // C11 - All signatures strictly EIP-712 (SWC-117 SWC-122)
            // C11: signature is EIP-712 compliant
            // C12 - abi.encodePacked can't contain variable length user input (SWC-133)
            // C12: abi.encodePacked has fixed length parameters
            bytes32 digest =
                keccak256(
                    abi.encodePacked(
                        EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA,
                        DOMAIN_SEPARATOR(),
                        keccak256(
                            abi.encode(
                                APPROVAL_SIGNATURE_HASH,
                                approved
                                    ? keccak256(""Give FULL access to funds in (and approved to) BentoBox?"")
                                    : keccak256(""Revoke access to BentoBox?""),
                                user,
                                masterContract,
                                approved,
                                nonces[user]++
                            )
                        )
                    )
                );
            address recoveredAddress = ecrecover(digest, v, r, s);
            require(recoveredAddress == user, ""MasterCMgr: Invalid Signature"");
        }

        // Effects
        masterContractApproved[masterContract][user] = approved;
        emit LogSetMasterContractApproval(masterContract, user, approved);
    }
}

// File @boringcrypto/boring-solidity/contracts/BoringBatchable.sol@v1.2.0
// License-Identifier: MIT

contract BaseBoringBatchable {
    /// @dev Helper function to extract a useful revert message from a failed call.
    /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.
    function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {
        // If the _res length is less than 68, then the transaction failed silently (without a revert message)
        if (_returnData.length < 68) return ""Transaction reverted silently"";

        assembly {
            // Slice the sighash.
            _returnData := add(_returnData, 0x04)
        }
        return abi.decode(_returnData, (string)); // All that remains is the revert string
    }

    /// @notice Allows batched call to self (this contract).
    /// @param calls An array of inputs for each call.
    /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.
    /// @return successes An array indicating the success of a call, mapped one-to-one to `calls`.
    /// @return results An array with the returned data of each function call, mapped one-to-one to `calls`.
    // F1: External is ok here because this is the batch function, adding it to a batch makes no sense
    // F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value
    // C3: The length of the loop is fully under user control, so can't be exploited
    // C7: Delegatecall is only used on the same contract, so it's safe
    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results) {
        successes = new bool[](calls.length);
        results = new bytes[](calls.length);
        for (uint256 i = 0; i < calls.length; i++) {
            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);
            require(success || !revertOnFail, _getRevertMsg(result));
            successes[i] = success;
            results[i] = result;
        }
    }
}

contract BoringBatchable is BaseBoringBatchable {
    /// @notice Call wrapper that performs `ERC20.permit` on `token`.
    /// Lookup `IERC20.permit`.
    // F6: Parameters can be used front-run the permit and the user's permit will fail (due to nonce or other revert)
    //     if part of a batch this could be used to grief once as the second call would not need the permit
    function permitToken(
        IERC20 token,
        address from,
        address to,
        uint256 amount,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public {
        token.permit(from, to, amount, deadline, v, r, s);
    }
}

// File contracts/BentoBox.sol
// License-Identifier: UNLICENSED

/// @title BentoBox
/// @author BoringCrypto, Keno
/// @notice The BentoBox is a vault for tokens. The stored tokens can be flash loaned and used in strategies.
/// Yield from this will go to the token depositors.
/// Rebasing tokens ARE NOT supported and WILL cause loss of funds.
/// Any funds transfered directly onto the BentoBox will be lost, use the deposit function instead.
contract BentoBoxV1 is MasterContractManager, BoringBatchable {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using BoringERC20 for IERC20;
    using RebaseLibrary for Rebase;

    // ************** //
    // *** EVENTS *** //
    // ************** //

    event LogDeposit(IERC20 indexed token, address indexed from, address indexed to, uint256 amount, uint256 share);
    event LogWithdraw(IERC20 indexed token, address indexed from, address indexed to, uint256 amount, uint256 share);
    event LogTransfer(IERC20 indexed token, address indexed from, address indexed to, uint256 share);

    event LogFlashLoan(address indexed borrower, IERC20 indexed token, uint256 amount, uint256 feeAmount, address indexed receiver);

    event LogStrategyTargetPercentage(IERC20 indexed token, uint256 targetPercentage);
    event LogStrategyQueued(IERC20 indexed token, IStrategy indexed strategy);
    event LogStrategySet(IERC20 indexed token, IStrategy indexed strategy);
    event LogStrategyInvest(IERC20 indexed token, uint256 amount);
    event LogStrategyDivest(IERC20 indexed token, uint256 amount);
    event LogStrategyProfit(IERC20 indexed token, uint256 amount);
    event LogStrategyLoss(IERC20 indexed token, uint256 amount);

    // *************** //
    // *** STRUCTS *** //
    // *************** //

    struct StrategyData {
        uint64 strategyStartDate;
        uint64 targetPercentage;
        uint128 balance; // the balance of the strategy that BentoBox thinks is in there
    }

    // ******************************** //
    // *** CONSTANTS AND IMMUTABLES *** //
    // ******************************** //

    // V2 - Can they be private?
    // V2: Private to save gas, to verify it's correct, check the constructor arguments
    IERC20 private immutable wethToken;

    IERC20 private constant USE_ETHEREUM = IERC20(0);
    uint256 private constant FLASH_LOAN_FEE = 50; // 0.05%
    uint256 private constant FLASH_LOAN_FEE_PRECISION = 1e5;
    uint256 private constant STRATEGY_DELAY = 2 weeks;
    uint256 private constant MAX_TARGET_PERCENTAGE = 95; // 95%
    uint256 private constant MINIMUM_SHARE_BALANCE = 1000; // To prevent the ratio going off

    // ***************** //
    // *** VARIABLES *** //
    // ***************** //

    // Balance per token per address/contract in shares
    mapping(IERC20 => mapping(address => uint256)) public balanceOf;

    // Rebase from amount to share
    mapping(IERC20 => Rebase) public totals;

    mapping(IERC20 => IStrategy) public strategy;
    mapping(IERC20 => IStrategy) public pendingStrategy;
    mapping(IERC20 => StrategyData) public strategyData;

    // ******************* //
    // *** CONSTRUCTOR *** //
    // ******************* //

    constructor(IERC20 wethToken_) public {
        wethToken = wethToken_;
    }

    // ***************** //
    // *** MODIFIERS *** //
    // ***************** //

    /// Modifier to check if the msg.sender is allowed to use funds belonging to the 'from' address.
    /// If 'from' is msg.sender, it's allowed.
    /// If 'from' is the BentoBox itself, it's allowed. Any ETH, token balances (above the known balances) or BentoBox balances
    /// can be taken by anyone.
    /// This is to enable skimming, not just for deposits, but also for withdrawals or transfers, enabling better composability.
    /// If 'from' is a clone of a masterContract AND the 'from' address has approved that masterContract, it's allowed.
    modifier allowed(address from) {
        if (from != msg.sender && from != address(this)) {
            // From is sender or you are skimming
            address masterContract = masterContractOf[msg.sender];
            require(masterContract != address(0), ""BentoBox: no masterContract"");
            require(masterContractApproved[masterContract][from], ""BentoBox: Transfer not approved"");
        }
        _;
    }

    // ************************** //
    // *** INTERNAL FUNCTIONS *** //
    // ************************** //

    /// @dev Returns the total balance of `token` this contracts holds,
    /// plus the total amount this contract thinks the strategy holds.
    function _tokenBalanceOf(IERC20 token) internal view returns (uint256 amount) {
        amount = token.balanceOf(address(this)).add(strategyData[token].balance);
    }

    // ************************ //
    // *** PUBLIC FUNCTIONS *** //
    // ************************ //

    /// @dev Helper function to represent an `amount` of `token` in shares.
    /// @param token The ERC-20 token.
    /// @param amount The `token` amount.
    /// @param roundUp If the result `share` should be rounded up.
    /// @return share The token amount represented in shares.
    function toShare(
        IERC20 token,
        uint256 amount,
        bool roundUp
    ) external view returns (uint256 share) {
        share = totals[token].toBase(amount, roundUp);
    }

    /// @dev Helper function represent shares back into the `token` amount.
    /// @param token The ERC-20 token.
    /// @param share The amount of shares.
    /// @param roundUp If the result should be rounded up.
    /// @return amount The share amount back into native representation.
    function toAmount(
        IERC20 token,
        uint256 share,
        bool roundUp
    ) external view returns (uint256 amount) {
        amount = totals[token].toElastic(share, roundUp);
    }

    /// @notice Deposit an amount of `token` represented in either `amount` or `share`.
    /// @param token_ The ERC-20 token to deposit.
    /// @param from which account to pull the tokens.
    /// @param to which account to push the tokens.
    /// @param amount Token amount in native representation to deposit.
    /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.
    /// @return amountOut The amount deposited.
    /// @return shareOut The deposited amount repesented in shares.
    function deposit(
        IERC20 token_,
        address from,
        address to,
        uint256 amount,
        uint256 share
    ) public payable allowed(from) returns (uint256 amountOut, uint256 shareOut) {
        // Checks
        require(to != address(0), ""BentoBox: to not set""); // To avoid a bad UI from burning funds

        // Effects
        IERC20 token = token_ == USE_ETHEREUM ? wethToken : token_;
        Rebase memory total = totals[token];

        // If a new token gets added, the tokenSupply call checks that this is a deployed contract. Needed for security.
        require(total.elastic != 0 || token.totalSupply() > 0, ""BentoBox: No tokens"");
        if (share == 0) {
            // value of the share may be lower than the amount due to rounding, that's ok
            share = total.toBase(amount, false);
            // Any deposit should lead to at least the minimum share balance, otherwise it's ignored (no amount taken)
            if (total.base.add(share.to128()) < MINIMUM_SHARE_BALANCE) {
                return (0, 0);
            }
        } else {
            // amount may be lower than the value of share due to rounding, in that case, add 1 to amount (Always round up)
            amount = total.toElastic(share, true);
        }

        // In case of skimming, check that only the skimmable amount is taken.
        // For ETH, the full balance is available, so no need to check.
        // During flashloans the _tokenBalanceOf is lower than 'reality', so skimming deposits will mostly fail during a flashloan.
        require(
            from != address(this) || token_ == USE_ETHEREUM || amount <= _tokenBalanceOf(token).sub(total.elastic),
            ""BentoBox: Skim too much""
        );

        balanceOf[token][to] = balanceOf[token][to].add(share);
        total.base = total.base.add(share.to128());
        total.elastic = total.elastic.add(amount.to128());
        totals[token] = total;

        // Interactions
        // During the first deposit, we check that this token is 'real'
        if (token_ == USE_ETHEREUM) {
            // X2 - If there is an error, could it cause a DoS. Like balanceOf causing revert. (SWC-113)
            // X2: If the WETH implementation is faulty or malicious, it will block adding ETH (but we know the WETH implementation)
            IWETH(address(wethToken)).deposit{value: amount}();
        } else if (from != address(this)) {
            // X2 - If there is an error, could it cause a DoS. Like balanceOf causing revert. (SWC-113)
            // X2: If the token implementation is faulty or malicious, it may block adding tokens. Good.
            token.safeTransferFrom(from, address(this), amount);
        }
        emit LogDeposit(token, from, to, amount, share);
        amountOut = amount;
        shareOut = share;
    }

    /// @notice Withdraws an amount of `token` from a user account.
    /// @param token_ The ERC-20 token to withdraw.
    /// @param from which user to pull the tokens.
    /// @param to which user to push the tokens.
    /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.
    /// @param share Like above, but `share` takes precedence over `amount`.
    function withdraw(
        IERC20 token_,
        address from,
        address to,
        uint256 amount,
        uint256 share
    ) public allowed(from) returns (uint256 amountOut, uint256 shareOut) {
        // Checks
        require(to != address(0), ""BentoBox: to not set""); // To avoid a bad UI from burning funds

        // Effects
        IERC20 token = token_ == USE_ETHEREUM ? wethToken : token_;
        Rebase memory total = totals[token];
        if (share == 0) {
            // value of the share paid could be lower than the amount paid due to rounding, in that case, add a share (Always round up)
            share = total.toBase(amount, true);
        } else {
            // amount may be lower than the value of share due to rounding, that's ok
            amount = total.toElastic(share, false);
        }

        balanceOf[token][from] = balanceOf[token][from].sub(share);
        total.elastic = total.elastic.sub(amount.to128());
        total.base = total.base.sub(share.to128());
        // There have to be at least 1000 shares left to prevent reseting the share/amount ratio (unless it's fully emptied)
        require(total.base >= MINIMUM_SHARE_BALANCE || total.base == 0, ""BentoBox: cannot empty"");
        totals[token] = total;

        // Interactions
        if (token_ == USE_ETHEREUM) {
            // X2, X3: A revert or big gas usage in the WETH contract could block withdrawals, but WETH9 is fine.
            IWETH(address(wethToken)).withdraw(amount);
            // X2, X3: A revert or big gas usage could block, however, the to address is under control of the caller.
            (bool success, ) = to.call{value: amount}("""");
            require(success, ""BentoBox: ETH transfer failed"");
        } else {
            // X2, X3: A malicious token could block withdrawal of just THAT token.
            //         masterContracts may want to take care not to rely on withdraw always succeeding.
            token.safeTransfer(to, amount);
        }
        emit LogWithdraw(token, from, to, amount, share);
        amountOut = amount;
        shareOut = share;
    }

    /// @notice Transfer shares from a user account to another one.
    /// @param token The ERC-20 token to transfer.
    /// @param from which user to pull the tokens.
    /// @param to which user to push the tokens.
    /// @param share The amount of `token` in shares.
    // Clones of master contracts can transfer from any account that has approved them
    // F3 - Can it be combined with another similar function?
    // F3: This isn't combined with transferMultiple for gas optimization
    function transfer(
        IERC20 token,
        address from,
        address to,
        uint256 share
    ) public allowed(from) {
        // Checks
        require(to != address(0), ""BentoBox: to not set""); // To avoid a bad UI from burning funds

        // Effects
        balanceOf[token][from] = balanceOf[token][from].sub(share);
        balanceOf[token][to] = balanceOf[token][to].add(share);

        emit LogTransfer(token, from, to, share);
    }

    /// @notice Transfer shares from a user account to multiple other ones.
    /// @param token The ERC-20 token to transfer.
    /// @param from which user to pull the tokens.
    /// @param tos The receivers of the tokens.
    /// @param shares The amount of `token` in shares for each receiver in `tos`.
    // F3 - Can it be combined with another similar function?
    // F3: This isn't combined with transfer for gas optimization
    function transferMultiple(
        IERC20 token,
        address from,
        address[] calldata tos,
        uint256[] calldata shares
    ) public allowed(from) {
        // Checks
        require(tos[0] != address(0), ""BentoBox: to[0] not set""); // To avoid a bad UI from burning funds

        // Effects
        uint256 totalAmount;
        uint256 len = tos.length;
        for (uint256 i = 0; i < len; i++) {
            address to = tos[i];
            balanceOf[token][to] = balanceOf[token][to].add(shares[i]);
            totalAmount = totalAmount.add(shares[i]);
            emit LogTransfer(token, from, to, shares[i]);
        }
        balanceOf[token][from] = balanceOf[token][from].sub(totalAmount);
    }

    /// @notice Flashloan ability.
    /// @param borrower The address of the contract that implements and conforms to `IFlashBorrower` and handles the flashloan.
    /// @param receiver Address of the token receiver.
    /// @param token The address of the token to receive.
    /// @param amount of the tokens to receive.
    /// @param data The calldata to pass to the `borrower` contract.
    // F5 - Checks-Effects-Interactions pattern followed? (SWC-107)
    // F5: Not possible to follow this here, reentrancy has been reviewed
    // F6 - Check for front-running possibilities, such as the approve function (SWC-114)
    // F6: Slight grieving possible by withdrawing an amount before someone tries to flashloan close to the full amount.
    function flashLoan(
        IFlashBorrower borrower,
        address receiver,
        IERC20 token,
        uint256 amount,
        bytes calldata data
    ) public {
        uint256 fee = amount.mul(FLASH_LOAN_FEE) / FLASH_LOAN_FEE_PRECISION;
        token.safeTransfer(receiver, amount);

        borrower.onFlashLoan(msg.sender, token, amount, fee, data);

        require(_tokenBalanceOf(token) >= totals[token].addElastic(fee.to128()), ""BentoBox: Wrong amount"");
        emit LogFlashLoan(address(borrower), token, amount, fee, receiver);
    }

    /// @notice Support for batched flashloans. Useful to request multiple different `tokens` in a single transaction.
    /// @param borrower The address of the contract that implements and conforms to `IBatchFlashBorrower` and handles the flashloan.
    /// @param receivers An array of the token receivers. A one-to-one mapping with `tokens` and `amounts`.
    /// @param tokens The addresses of the tokens.
    /// @param amounts of the tokens for each receiver.
    /// @param data The calldata to pass to the `borrower` contract.
    // F5 - Checks-Effects-Interactions pattern followed? (SWC-107)
    // F5: Not possible to follow this here, reentrancy has been reviewed
    // F6 - Check for front-running possibilities, such as the approve function (SWC-114)
    // F6: Slight grieving possible by withdrawing an amount before someone tries to flashloan close to the full amount.
    function batchFlashLoan(
        IBatchFlashBorrower borrower,
        address[] calldata receivers,
        IERC20[] calldata tokens,
        uint256[] calldata amounts,
        bytes calldata data
    ) public {
        uint256[] memory fees = new uint256[](tokens.length);

        uint256 len = tokens.length;
        for (uint256 i = 0; i < len; i++) {
            uint256 amount = amounts[i];
            fees[i] = amount.mul(FLASH_LOAN_FEE) / FLASH_LOAN_FEE_PRECISION;

            tokens[i].safeTransfer(receivers[i], amounts[i]);
        }

        borrower.onBatchFlashLoan(msg.sender, tokens, amounts, fees, data);

        for (uint256 i = 0; i < len; i++) {
            IERC20 token = tokens[i];
            require(_tokenBalanceOf(token) >= totals[token].addElastic(fees[i].to128()), ""BentoBox: Wrong amount"");
            emit LogFlashLoan(address(borrower), token, amounts[i], fees[i], receivers[i]);
        }
    }

    /// @notice Sets the target percentage of the strategy for `token`.
    /// @dev Only the owner of this contract is allowed to change this.
    /// @param token The address of the token that maps to a strategy to change.
    /// @param targetPercentage_ The new target in percent. Must be lesser or equal to `MAX_TARGET_PERCENTAGE`.
    function setStrategyTargetPercentage(IERC20 token, uint64 targetPercentage_) public onlyOwner {
        // Checks
        require(targetPercentage_ <= MAX_TARGET_PERCENTAGE, ""StrategyManager: Target too high"");

        // Effects
        strategyData[token].targetPercentage = targetPercentage_;
        emit LogStrategyTargetPercentage(token, targetPercentage_);
    }

    /// @notice Sets the contract address of a new strategy that conforms to `IStrategy` for `token`.
    /// Must be called twice with the same arguments.
    /// A new strategy becomes pending first and can be activated once `STRATEGY_DELAY` is over.
    /// @dev Only the owner of this contract is allowed to change this.
    /// @param token The address of the token that maps to a strategy to change.
    /// @param newStrategy The address of the contract that conforms to `IStrategy`.
    // F5 - Checks-Effects-Interactions pattern followed? (SWC-107)
    // F5: Total amount is updated AFTER interaction. But strategy is under our control.
    // C4 - Use block.timestamp only for long intervals (SWC-116)
    // C4: block.timestamp is used for a period of 2 weeks, which is long enough
    function setStrategy(IERC20 token, IStrategy newStrategy) public onlyOwner {
        StrategyData memory data = strategyData[token];
        IStrategy pending = pendingStrategy[token];
        if (data.strategyStartDate == 0 || pending != newStrategy) {
            pendingStrategy[token] = newStrategy;
            // C1 - All math done through BoringMath (SWC-101)
            // C1: Our sun will swallow the earth well before this overflows
            data.strategyStartDate = (block.timestamp + STRATEGY_DELAY).to64();
            emit LogStrategyQueued(token, newStrategy);
        } else {
            require(data.strategyStartDate != 0 && block.timestamp >= data.strategyStartDate, ""StrategyManager: Too early"");
            if (address(strategy[token]) != address(0)) {
                int256 balanceChange = strategy[token].exit(data.balance);
                // Effects
                if (balanceChange > 0) {
                    uint256 add = uint256(balanceChange);
                    totals[token].addElastic(add);
                    emit LogStrategyProfit(token, add);
                } else if (balanceChange < 0) {
                    uint256 sub = uint256(-balanceChange);
                    totals[token].subElastic(sub);
                    emit LogStrategyLoss(token, sub);
                }

                emit LogStrategyDivest(token, data.balance);
            }
            strategy[token] = pending;
            data.strategyStartDate = 0;
            data.balance = 0;
            pendingStrategy[token] = IStrategy(0);
            emit LogStrategySet(token, newStrategy);
        }
        strategyData[token] = data;
    }

    /// @notice The actual process of yield farming. Executes the strategy of `token`.
    /// Optionally does housekeeping if `balance` is true.
    /// `maxChangeAmount` is relevant for skimming or withdrawing if `balance` is true.
    /// @param token The address of the token for which a strategy is deployed.
    /// @param balance True if housekeeping should be done.
    /// @param maxChangeAmount The maximum amount for either pulling or pushing from/to the `IStrategy` contract.
    // F5 - Checks-Effects-Interactions pattern followed? (SWC-107)
    // F5: Total amount is updated AFTER interaction. But strategy is under our control.
    // F5: Not followed to prevent reentrancy issues with flashloans and BentoBox skims?
    function harvest(
        IERC20 token,
        bool balance,
        uint256 maxChangeAmount
    ) public {
        StrategyData memory data = strategyData[token];
        IStrategy _strategy = strategy[token];
        int256 balanceChange = _strategy.harvest(data.balance, msg.sender);
        if (balanceChange == 0 && !balance) {
            return;
        }

        uint256 totalElastic = totals[token].elastic;

        if (balanceChange > 0) {
            uint256 add = uint256(balanceChange);
            totalElastic = totalElastic.add(add);
            totals[token].elastic = totalElastic.to128();
            emit LogStrategyProfit(token, add);
        } else if (balanceChange < 0) {
            // C1 - All math done through BoringMath (SWC-101)
            // C1: balanceChange could overflow if it's max negative int128.
            // But tokens with balances that large are not supported by the BentoBox.
            uint256 sub = uint256(-balanceChange);
            totalElastic = totalElastic.sub(sub);
            totals[token].elastic = totalElastic.to128();
            data.balance = data.balance.sub(sub.to128());
            emit LogStrategyLoss(token, sub);
        }

        if (balance) {
            uint256 targetBalance = totalElastic.mul(data.targetPercentage) / 100;
            // if data.balance == targetBalance there is nothing to update
            if (data.balance < targetBalance) {
                uint256 amountOut = targetBalance.sub(data.balance);
                if (maxChangeAmount != 0 && amountOut > maxChangeAmount) {
                    amountOut = maxChangeAmount;
                }
                token.safeTransfer(address(_strategy), amountOut);
                data.balance = data.balance.add(amountOut.to128());
                _strategy.skim(amountOut);
                emit LogStrategyInvest(token, amountOut);
            } else if (data.balance > targetBalance) {
                uint256 amountIn = data.balance.sub(targetBalance.to128());
                if (maxChangeAmount != 0 && amountIn > maxChangeAmount) {
                    amountIn = maxChangeAmount;
                }

                uint256 actualAmountIn = _strategy.withdraw(amountIn);

                data.balance = data.balance.sub(actualAmountIn.to128());
                emit LogStrategyDivest(token, actualAmountIn);
            }
        }

        strategyData[token] = data;
    }

    // Contract should be able to receive ETH deposits to support deposit & skim
    // solhint-disable-next-line no-empty-blocks
    receive() external payable {}
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: UNLICENSED
// The BentoBox

//  ▄▄▄▄· ▄▄▄ . ▐ ▄ ▄▄▄▄▄      ▄▄▄▄·       ▐▄• ▄
//  ▐█ ▀█▪▀▄.▀·█▌▐█•██  ▪     ▐█ ▀█▪▪      █▌█▌▪
//  ▐█▀▀█▄▐▀▀▪▄▐█▐▐▌ ▐█.▪ ▄█▀▄ ▐█▀▀█▄ ▄█▀▄  ·██·
//  ██▄▪▐█▐█▄▄▌██▐█▌ ▐█▌·▐█▌.▐▌██▄▪▐█▐█▌.▐▌▪▐█·█▌
//  ·▀▀▀▀  ▀▀▀ ▀▀ █▪ ▀▀▀  ▀█▄▀▪·▀▀▀▀  ▀█▄▀▪•▀▀ ▀▀

// This contract stores funds, handles their transfers, supports flash loans and strategies.

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to Keno for all his hard work and support

// Version 22-Mar-2021

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

// solhint-disable avoid-low-level-calls
// solhint-disable not-rely-on-time
// solhint-disable no-inline-assembly

// File @boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol@v1.2.0
// License-Identifier: MIT

interface IERC20 {
    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /// @notice EIP 2612
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}

// File contracts/interfaces/IFlashLoan.sol
// License-Identifier: MIT

interface IFlashBorrower {
    /// @notice The flashloan callback. `amount` + `fee` needs to repayed to msg.sender before this call returns.
    /// @param sender The address of the invoker of this flashloan.
    /// @param token The address of the token that is loaned.
    /// @param amount of the `token` that is loaned.
    /// @param fee The fee that needs to be paid on top for this loan. Needs to be the same as `token`.
    /// @param data Additional data that was passed to the flashloan function.
    function onFlashLoan(
        address sender,
        IERC20 token,
        uint256 amount,
        uint256 fee,
        bytes calldata data
    ) external;
}

interface IBatchFlashBorrower {
    /// @notice The callback for batched flashloans. Every amount + fee needs to repayed to msg.sender before this call returns.
    /// @param sender The address of the invoker of this flashloan.
    /// @param tokens Array of addresses for ERC-20 tokens that is loaned.
    /// @param amounts A one-to-one map to `tokens` that is loaned.
    /// @param fees A one-to-one map to `tokens` that needs to be paid on top for each loan. Needs to be the same token.
    /// @param data Additional data that was passed to the flashloan function.
    function onBatchFlashLoan(
        address sender,
        IERC20[] calldata tokens,
        uint256[] calldata amounts,
        uint256[] calldata fees,
        bytes calldata data
    ) external;
}

// File contracts/interfaces/IWETH.sol
// License-Identifier: MIT

interface IWETH {
    function deposit() external payable;

    function withdraw(uint256) external;
}

// File contracts/interfaces/IStrategy.sol
// License-Identifier: MIT

interface IStrategy {
    /// @notice Send the assets to the Strategy and call skim to invest them.
    /// @param amount The amount of tokens to invest.
    function skim(uint256 amount) external;

    /// @notice Harvest any profits made converted to the asset and pass them to the caller.
    /// @param balance The amount of tokens the caller thinks it has invested.
    /// @param sender The address of the initiator of this transaction. Can be used for reimbursements, etc.
    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.
    function harvest(uint256 balance, address sender) external returns (int256 amountAdded);

    /// @notice Withdraw assets. The returned amount can differ from the requested amount due to rounding.
    /// @dev The `actualAmount` should be very close to the amount.
    /// The difference should NOT be used to report a loss. That's what harvest is for.
    /// @param amount The requested amount the caller wants to withdraw.
    /// @return actualAmount The real amount that is withdrawn.
    function withdraw(uint256 amount) external returns (uint256 actualAmount);

    /// @notice Withdraw all assets in the safest way possible. This shouldn't fail.
    /// @param balance The amount of tokens the caller thinks it has invested.
    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.
    function exit(uint256 balance) external returns (int256 amountAdded);
}

// File @boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol@v1.2.0
// License-Identifier: MIT

library BoringERC20 {
    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()
    bytes4 private constant SIG_NAME = 0x06fdde03; // name()
    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()
    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)
    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)

    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.
    /// Reverts on a failed transfer.
    /// @param token The address of the ERC-20 token.
    /// @param to Transfer tokens to.
    /// @param amount The token amount.
    function safeTransfer(
        IERC20 token,
        address to,
        uint256 amount
    ) internal {
        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));
        require(success && (data.length == 0 || abi.decode(data, (bool))), ""BoringERC20: Transfer failed"");
    }

    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.
    /// Reverts on a failed transfer.
    /// @param token The address of the ERC-20 token.
    /// @param from Transfer tokens from.
    /// @param to Transfer tokens to.
    /// @param amount The token amount.
    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 amount
    ) internal {
        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));
        require(success && (data.length == 0 || abi.decode(data, (bool))), ""BoringERC20: TransferFrom failed"");
    }
}

// File @boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol@v1.2.0
// License-Identifier: MIT

/// @notice A library for performing overflow-/underflow-safe math,
/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).
library BoringMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require(b == 0 || (c = a * b) / b == a, ""BoringMath: Mul Overflow"");
    }

    function to128(uint256 a) internal pure returns (uint128 c) {
        require(a <= uint128(-1), ""BoringMath: uint128 Overflow"");
        c = uint128(a);
    }

    function to64(uint256 a) internal pure returns (uint64 c) {
        require(a <= uint64(-1), ""BoringMath: uint64 Overflow"");
        c = uint64(a);
    }

    function to32(uint256 a) internal pure returns (uint32 c) {
        require(a <= uint32(-1), ""BoringMath: uint32 Overflow"");
        c = uint32(a);
    }
}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint128.
library BoringMath128 {
    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }
}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint64.
library BoringMath64 {
    function add(uint64 a, uint64 b) internal pure returns (uint64 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint64 a, uint64 b) internal pure returns (uint64 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }
}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint32.
library BoringMath32 {
    function add(uint32 a, uint32 b) internal pure returns (uint32 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint32 a, uint32 b) internal pure returns (uint32 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }
}

// File @boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol@v1.2.0
// License-Identifier: MIT

struct Rebase {
    uint128 elastic;
    uint128 base;
}

/// @notice A rebasing library using overflow-/underflow-safe math.
library RebaseLibrary {
    using BoringMath for uint256;
    using BoringMath128 for uint128;

    /// @notice Calculates the base value in relationship to `elastic` and `total`.
    function toBase(
        Rebase memory total,
        uint256 elastic,
        bool roundUp
    ) internal pure returns (uint256 base) {
        if (total.elastic == 0) {
            base = elastic;
        } else {
            base = elastic.mul(total.base) / total.elastic;
            if (roundUp && base.mul(total.elastic) / total.base < elastic) {
                base = base.add(1);
            }
        }
    }

    /// @notice Calculates the elastic value in relationship to `base` and `total`.
    function toElastic(
        Rebase memory total,
        uint256 base,
        bool roundUp
    ) internal pure returns (uint256 elastic) {
        if (total.base == 0) {
            elastic = base;
        } else {
            elastic = base.mul(total.elastic) / total.base;
            if (roundUp && elastic.mul(total.base) / total.elastic < base) {
                elastic = elastic.add(1);
            }
        }
    }

    /// @notice Add `elastic` to `total` and doubles `total.base`.
    /// @return (Rebase) The new total.
    /// @return base in relationship to `elastic`.
    function add(
        Rebase memory total,
        uint256 elastic,
        bool roundUp
    ) internal pure returns (Rebase memory, uint256 base) {
        base = toBase(total, elastic, roundUp);
        total.elastic = total.elastic.add(elastic.to128());
        total.base = total.base.add(base.to128());
        return (total, base);
    }

    /// @notice Sub `base` from `total` and update `total.elastic`.
    /// @return (Rebase) The new total.
    /// @return elastic in relationship to `base`.
    function sub(
        Rebase memory total,
        uint256 base,
        bool roundUp
    ) internal pure returns (Rebase memory, uint256 elastic) {
        elastic = toElastic(total, base, roundUp);
        total.elastic = total.elastic.sub(elastic.to128());
        total.base = total.base.sub(base.to128());
        return (total, elastic);
    }

    /// @notice Add `elastic` and `base` to `total`.
    function add(
        Rebase memory total,
        uint256 elastic,
        uint256 base
    ) internal pure returns (Rebase memory) {
        total.elastic = total.elastic.add(elastic.to128());
        total.base = total.base.add(base.to128());
        return total;
    }

    /// @notice Subtract `elastic` and `base` to `total`.
    function sub(
        Rebase memory total,
        uint256 elastic,
        uint256 base
    ) internal pure returns (Rebase memory) {
        total.elastic = total.elastic.sub(elastic.to128());
        total.base = total.base.sub(base.to128());
        return total;
    }

    /// @notice Add `elastic` to `total` and update storage.
    /// @return newElastic Returns updated `elastic`.
    function addElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {
        newElastic = total.elastic = total.elastic.add(elastic.to128());
    }

    /// @notice Subtract `elastic` from `total` and update storage.
    /// @return newElastic Returns updated `elastic`.
    function subElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {
        newElastic = total.elastic = total.elastic.sub(elastic.to128());
    }
}

// File @boringcrypto/boring-solidity/contracts/BoringOwnable.sol@v1.2.0
// License-Identifier: MIT

// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol
// Edited by BoringCrypto

contract BoringOwnableData {
    address public owner;
    address public pendingOwner;
}

contract BoringOwnable is BoringOwnableData {
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /// @notice `owner` defaults to msg.sender on construction.
    constructor() public {
        owner = msg.sender;
        emit OwnershipTransferred(address(0), msg.sender);
    }

    /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.
    /// Can only be invoked by the current `owner`.
    /// @param newOwner Address of the new owner.
    /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.
    /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.
    function transferOwnership(
        address newOwner,
        bool direct,
        bool renounce
    ) public onlyOwner {
        if (direct) {
            // Checks
            require(newOwner != address(0) || renounce, ""Ownable: zero address"");

            // Effects
            emit OwnershipTransferred(owner, newOwner);
            owner = newOwner;
            pendingOwner = address(0);
        } else {
            // Effects
            pendingOwner = newOwner;
        }
    }

    /// @notice Needs to be called by `pendingOwner` to claim ownership.
    function claimOwnership() public {
        address _pendingOwner = pendingOwner;

        // Checks
        require(msg.sender == _pendingOwner, ""Ownable: caller != pending owner"");

        // Effects
        emit OwnershipTransferred(owner, _pendingOwner);
        owner = _pendingOwner;
        pendingOwner = address(0);
    }

    /// @notice Only allows the `owner` to execute the function.
    modifier onlyOwner() {
        require(msg.sender == owner, ""Ownable: caller is not the owner"");
        _;
    }
}

// File @boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol@v1.2.0
// License-Identifier: MIT

interface IMasterContract {
    /// @notice Init function that gets called from `BoringFactory.deploy`.
    /// Also kown as the constructor for cloned contracts.
    /// Any ETH send to `BoringFactory.deploy` ends up here.
    /// @param data Can be abi encoded arguments or anything else.
    function init(bytes calldata data) external payable;
}

// File @boringcrypto/boring-solidity/contracts/BoringFactory.sol@v1.2.0
// License-Identifier: MIT

contract BoringFactory {
    event LogDeploy(address indexed masterContract, bytes data, address indexed cloneAddress);

    /// @notice Mapping from clone contracts to their masterContract.
    mapping(address => address) public masterContractOf;

    /// @notice Deploys a given master Contract as a clone.
    /// Any ETH transferred with this call is forwarded to the new clone.
    /// Emits `LogDeploy`.
    /// @param masterContract The address of the contract to clone.
    /// @param data Additional abi encoded calldata that is passed to the new clone via `IMasterContract.init`.
    /// @param useCreate2 Creates the clone by using the CREATE2 opcode, in this case `data` will be used as salt.
    /// @return cloneAddress Address of the created clone contract.
    function deploy(
        address masterContract,
        bytes calldata data,
        bool useCreate2
    ) public payable returns (address cloneAddress) {
        require(masterContract != address(0), ""BoringFactory: No masterContract"");
        bytes20 targetBytes = bytes20(masterContract); // Takes the first 20 bytes of the masterContract's address

        if (useCreate2) {
            // each masterContract has different code already. So clones are distinguished by their data only.
            bytes32 salt = keccak256(data);

            // Creates clone, more info here: https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/
            assembly {
                let clone := mload(0x40)
                mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)
                mstore(add(clone, 0x14), targetBytes)
                mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)
                cloneAddress := create2(0, clone, 0x37, salt)
            }
        } else {
            assembly {
                let clone := mload(0x40)
                mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)
                mstore(add(clone, 0x14), targetBytes)
                mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)
                cloneAddress := create(0, clone, 0x37)
            }
        }
        masterContractOf[cloneAddress] = masterContract;

        IMasterContract(cloneAddress).init{value: msg.value}(data);

        emit LogDeploy(masterContract, data, cloneAddress);
    }
}

// File contracts/MasterContractManager.sol
// License-Identifier: UNLICENSED

contract MasterContractManager is BoringOwnable, BoringFactory {
    event LogWhiteListMasterContract(address indexed masterContract, bool approved);
    event LogSetMasterContractApproval(address indexed masterContract, address indexed user, bool approved);
    event LogRegisterProtocol(address indexed protocol);

    /// @notice masterContract to user to approval state
    mapping(address => mapping(address => bool)) public masterContractApproved;
    /// @notice masterContract to whitelisted state for approval without signed message
    mapping(address => bool) public whitelistedMasterContracts;
    /// @notice user nonces for masterContract approvals
    mapping(address => uint256) public nonces;

    bytes32 private constant DOMAIN_SEPARATOR_SIGNATURE_HASH = keccak256(""EIP712Domain(string name,uint256 chainId,address verifyingContract)"");
    // See https://eips.ethereum.org/EIPS/eip-191
    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = ""\x19\x01"";
    bytes32 private constant APPROVAL_SIGNATURE_HASH =
        keccak256(""SetMasterContractApproval(string warning,address user,address masterContract,bool approved,uint256 nonce)"");

    // solhint-disable-next-line var-name-mixedcase
    bytes32 private immutable _DOMAIN_SEPARATOR;
    // solhint-disable-next-line var-name-mixedcase
    uint256 private immutable DOMAIN_SEPARATOR_CHAIN_ID;

    constructor() public {
        uint256 chainId;
        assembly {
            chainId := chainid()
        }
        _DOMAIN_SEPARATOR = _calculateDomainSeparator(DOMAIN_SEPARATOR_CHAIN_ID = chainId);
    }

    function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {
        return keccak256(abi.encode(DOMAIN_SEPARATOR_SIGNATURE_HASH, keccak256(""BentoBox V1""), chainId, address(this)));
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() public view returns (bytes32) {
        uint256 chainId;
        assembly {
            chainId := chainid()
        }
        return chainId == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId);
    }

    /// @notice Other contracts need to register with this master contract so that users can approve them for the BentoBox.
    function registerProtocol() public {
        masterContractOf[msg.sender] = msg.sender;
        emit LogRegisterProtocol(msg.sender);
    }

    /// @notice Enables or disables a contract for approval without signed message.
    function whitelistMasterContract(address masterContract, bool approved) public onlyOwner {
        // Checks
        require(masterContract != address(0), ""MasterCMgr: Cannot approve 0"");

        // Effects
        whitelistedMasterContracts[masterContract] = approved;
        emit LogWhiteListMasterContract(masterContract, approved);
    }

    /// @notice Approves or revokes a `masterContract` access to `user` funds.
    /// @param user The address of the user that approves or revokes access.
    /// @param masterContract The address who gains or loses access.
    /// @param approved If True approves access. If False revokes access.
    /// @param v Part of the signature. (See EIP-191)
    /// @param r Part of the signature. (See EIP-191)
    /// @param s Part of the signature. (See EIP-191)
    // F4 - Check behaviour for all function arguments when wrong or extreme
    // F4: Don't allow masterContract 0 to be approved. Unknown contracts will have a masterContract of 0.
    // F4: User can't be 0 for signed approvals because the recoveredAddress will be 0 if ecrecover fails
    function setMasterContractApproval(
        address user,
        address masterContract,
        bool approved,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public {
        // Checks
        require(masterContract != address(0), ""MasterCMgr: masterC not set""); // Important for security

        // If no signature is provided, the fallback is executed
        if (r == 0 && s == 0 && v == 0) {
            require(user == msg.sender, ""MasterCMgr: user not sender"");
            require(masterContractOf[user] == address(0), ""MasterCMgr: user is clone"");
            require(whitelistedMasterContracts[masterContract], ""MasterCMgr: not whitelisted"");
        } else {
            // Important for security - any address without masterContract has address(0) as masterContract
            // So approving address(0) would approve every address, leading to full loss of funds
            // Also, ecrecover returns address(0) on failure. So we check this:
            require(user != address(0), ""MasterCMgr: User cannot be 0"");

            // C10 - Protect signatures against replay, use nonce and chainId (SWC-121)
            // C10: nonce + chainId are used to prevent replays
            // C11 - All signatures strictly EIP-712 (SWC-117 SWC-122)
            // C11: signature is EIP-712 compliant
            // C12 - abi.encodePacked can't contain variable length user input (SWC-133)
            // C12: abi.encodePacked has fixed length parameters
            bytes32 digest =
                keccak256(
                    abi.encodePacked(
                        EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA,
                        DOMAIN_SEPARATOR(),
                        keccak256(
                            abi.encode(
                                APPROVAL_SIGNATURE_HASH,
                                approved
                                    ? keccak256(""Give FULL access to funds in (and approved to) BentoBox?"")
                                    : keccak256(""Revoke access to BentoBox?""),
                                user,
                                masterContract,
                                approved,
                                nonces[user]++
                            )
                        )
                    )
                );
            address recoveredAddress = ecrecover(digest, v, r, s);
            require(recoveredAddress == user, ""MasterCMgr: Invalid Signature"");
        }

        // Effects
        masterContractApproved[masterContract][user] = approved;
        emit LogSetMasterContractApproval(masterContract, user, approved);
    }
}

// File @boringcrypto/boring-solidity/contracts/BoringBatchable.sol@v1.2.0
// License-Identifier: MIT

contract BaseBoringBatchable {
    /// @dev Helper function to extract a useful revert message from a failed call.
    /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.
    function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {
        // If the _res length is less than 68, then the transaction failed silently (without a revert message)
        if (_returnData.length < 68) return ""Transaction reverted silently"";

        assembly {
            // Slice the sighash.
            _returnData := add(_returnData, 0x04)
        }
        return abi.decode(_returnData, (string)); // All that remains is the revert string
    }

    /// @notice Allows batched call to self (this contract).
    /// @param calls An array of inputs for each call.
    /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.
    /// @return successes An array indicating the success of a call, mapped one-to-one to `calls`.
    /// @return results An array with the returned data of each function call, mapped one-to-one to `calls`.
    // F1: External is ok here because this is the batch function, adding it to a batch makes no sense
    // F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value
    // C3: The length of the loop is fully under user control, so can't be exploited
    // C7: Delegatecall is only used on the same contract, so it's safe
    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results) {
        successes = new bool[](calls.length);
        results = new bytes[](calls.length);
        for (uint256 i = 0; i < calls.length; i++) {
            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);
            require(success || !revertOnFail, _getRevertMsg(result));
            successes[i] = success;
            results[i] = result;
        }
    }
}

contract BoringBatchable is BaseBoringBatchable {
    /// @notice Call wrapper that performs `ERC20.permit` on `token`.
    /// Lookup `IERC20.permit`.
    // F6: Parameters can be used front-run the permit and the user's permit will fail (due to nonce or other revert)
    //     if part of a batch this could be used to grief once as the second call would not need the permit
    function permitToken(
        IERC20 token,
        address from,
        address to,
        uint256 amount,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public {
        token.permit(from, to, amount, deadline, v, r, s);
    }
}

// File contracts/BentoBox.sol
// License-Identifier: UNLICENSED

/// @title BentoBox
/// @author BoringCrypto, Keno
/// @notice The BentoBox is a vault for tokens. The stored tokens can be flash loaned and used in strategies.
/// Yield from this will go to the token depositors.
/// Rebasing tokens ARE NOT supported and WILL cause loss of funds.
/// Any funds transfered directly onto the BentoBox will be lost, use the deposit function instead.
contract BentoBoxV1 is MasterContractManager, BoringBatchable {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using BoringERC20 for IERC20;
    using RebaseLibrary for Rebase;

    // ************** //
    // *** EVENTS *** //
    // ************** //

    event LogDeposit(IERC20 indexed token, address indexed from, address indexed to, uint256 amount, uint256 share);
    event LogWithdraw(IERC20 indexed token, address indexed from, address indexed to, uint256 amount, uint256 share);
    event LogTransfer(IERC20 indexed token, address indexed from, address indexed to, uint256 share);

    event LogFlashLoan(address indexed borrower, IERC20 indexed token, uint256 amount, uint256 feeAmount, address indexed receiver);

    event LogStrategyTargetPercentage(IERC20 indexed token, uint256 targetPercentage);
    event LogStrategyQueued(IERC20 indexed token, IStrategy indexed strategy);
    event LogStrategySet(IERC20 indexed token, IStrategy indexed strategy);
    event LogStrategyInvest(IERC20 indexed token, uint256 amount);
    event LogStrategyDivest(IERC20 indexed token, uint256 amount);
    event LogStrategyProfit(IERC20 indexed token, uint256 amount);
    event LogStrategyLoss(IERC20 indexed token, uint256 amount);

    // *************** //
    // *** STRUCTS *** //
    // *************** //

    struct StrategyData {
        uint64 strategyStartDate;
        uint64 targetPercentage;
        uint128 balance; // the balance of the strategy that BentoBox thinks is in there
    }

    // ******************************** //
    // *** CONSTANTS AND IMMUTABLES *** //
    // ******************************** //

    // V2 - Can they be private?
    // V2: Private to save gas, to verify it's correct, check the constructor arguments
    IERC20 private immutable wethToken;

    IERC20 private constant USE_ETHEREUM = IERC20(0);
    uint256 private constant FLASH_LOAN_FEE = 50; // 0.05%
    uint256 private constant FLASH_LOAN_FEE_PRECISION = 1e5;
    uint256 private constant STRATEGY_DELAY = 2 weeks;
    uint256 private constant MAX_TARGET_PERCENTAGE = 95; // 95%
    uint256 private constant MINIMUM_SHARE_BALANCE = 1000; // To prevent the ratio going off

    // ***************** //
    // *** VARIABLES *** //
    // ***************** //

    // Balance per token per address/contract in shares
    mapping(IERC20 => mapping(address => uint256)) public balanceOf;

    // Rebase from amount to share
    mapping(IERC20 => Rebase) public totals;

    mapping(IERC20 => IStrategy) public strategy;
    mapping(IERC20 => IStrategy) public pendingStrategy;
    mapping(IERC20 => StrategyData) public strategyData;

    // ******************* //
    // *** CONSTRUCTOR *** //
    // ******************* //

    constructor(IERC20 wethToken_) public {
        wethToken = wethToken_;
    }

    // ***************** //
    // *** MODIFIERS *** //
    // ***************** //

    /// Modifier to check if the msg.sender is allowed to use funds belonging to the 'from' address.
    /// If 'from' is msg.sender, it's allowed.
    /// If 'from' is the BentoBox itself, it's allowed. Any ETH, token balances (above the known balances) or BentoBox balances
    /// can be taken by anyone.
    /// This is to enable skimming, not just for deposits, but also for withdrawals or transfers, enabling better composability.
    /// If 'from' is a clone of a masterContract AND the 'from' address has approved that masterContract, it's allowed.
    modifier allowed(address from) {
        if (from != msg.sender && from != address(this)) {
            // From is sender or you are skimming
            address masterContract = masterContractOf[msg.sender];
            require(masterContract != address(0), ""BentoBox: no masterContract"");
            require(masterContractApproved[masterContract][from], ""BentoBox: Transfer not approved"");
        }
        _;
    }

    // ************************** //
    // *** INTERNAL FUNCTIONS *** //
    // ************************** //

    /// @dev Returns the total balance of `token` this contracts holds,
    /// plus the total amount this contract thinks the strategy holds.
    function _tokenBalanceOf(IERC20 token) internal view returns (uint256 amount) {
        amount = token.balanceOf(address(this)).add(strategyData[token].balance);
    }

    // ************************ //
    // *** PUBLIC FUNCTIONS *** //
    // ************************ //

    /// @dev Helper function to represent an `amount` of `token` in shares.
    /// @param token The ERC-20 token.
    /// @param amount The `token` amount.
    /// @param roundUp If the result `share` should be rounded up.
    /// @return share The token amount represented in shares.
    function toShare(
        IERC20 token,
        uint256 amount,
        bool roundUp
    ) external view returns (uint256 share) {
        share = totals[token].toBase(amount, roundUp);
    }

    /// @dev Helper function represent shares back into the `token` amount.
    /// @param token The ERC-20 token.
    /// @param share The amount of shares.
    /// @param roundUp If the result should be rounded up.
    /// @return amount The share amount back into native representation.
    function toAmount(
        IERC20 token,
        uint256 share,
        bool roundUp
    ) external view returns (uint256 amount) {
        amount = totals[token].toElastic(share, roundUp);
    }

    /// @notice Deposit an amount of `token` represented in either `amount` or `share`.
    /// @param token_ The ERC-20 token to deposit.
    /// @param from which account to pull the tokens.
    /// @param to which account to push the tokens.
    /// @param amount Token amount in native representation to deposit.
    /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.
    /// @return amountOut The amount deposited.
    /// @return shareOut The deposited amount repesented in shares.
    function deposit(
        IERC20 token_,
        address from,
        address to,
        uint256 amount,
        uint256 share
    ) public payable allowed(from) returns (uint256 amountOut, uint256 shareOut) {
        // Checks
        require(to != address(0), ""BentoBox: to not set""); // To avoid a bad UI from burning funds

        // Effects
        IERC20 token = token_ == USE_ETHEREUM ? wethToken : token_;
        Rebase memory total = totals[token];

        // If a new token gets added, the tokenSupply call checks that this is a deployed contract. Needed for security.
        require(total.elastic != 0 || token.totalSupply() > 0, ""BentoBox: No tokens"");
        if (share == 0) {
            // value of the share may be lower than the amount due to rounding, that's ok
            share = total.toBase(amount, false);
            // Any deposit should lead to at least the minimum share balance, otherwise it's ignored (no amount taken)
            if (total.base.add(share.to128()) < MINIMUM_SHARE_BALANCE) {
                return (0, 0);
            }
        } else {
            // amount may be lower than the value of share due to rounding, in that case, add 1 to amount (Always round up)
            amount = total.toElastic(share, true);
        }

        // In case of skimming, check that only the skimmable amount is taken.
        // For ETH, the full balance is available, so no need to check.
        // During flashloans the _tokenBalanceOf is lower than 'reality', so skimming deposits will mostly fail during a flashloan.
        require(
            from != address(this) || token_ == USE_ETHEREUM || amount <= _tokenBalanceOf(token).sub(total.elastic),
            ""BentoBox: Skim too much""
        );

        balanceOf[token][to] = balanceOf[token][to].add(share);
        total.base = total.base.add(share.to128());
        total.elastic = total.elastic.add(amount.to128());
        totals[token] = total;

        // Interactions
        // During the first deposit, we check that this token is 'real'
        if (token_ == USE_ETHEREUM) {
            // X2 - If there is an error, could it cause a DoS. Like balanceOf causing revert. (SWC-113)
            // X2: If the WETH implementation is faulty or malicious, it will block adding ETH (but we know the WETH implementation)
            IWETH(address(wethToken)).deposit{value: amount}();
        } else if (from != address(this)) {
            // X2 - If there is an error, could it cause a DoS. Like balanceOf causing revert. (SWC-113)
            // X2: If the token implementation is faulty or malicious, it may block adding tokens. Good.
            token.safeTransferFrom(from, address(this), amount);
        }
        emit LogDeposit(token, from, to, amount, share);
        amountOut = amount;
        shareOut = share;
    }

    /// @notice Withdraws an amount of `token` from a user account.
    /// @param token_ The ERC-20 token to withdraw.
    /// @param from which user to pull the tokens.
    /// @param to which user to push the tokens.
    /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.
    /// @param share Like above, but `share` takes precedence over `amount`.
    function withdraw(
        IERC20 token_,
        address from,
        address to,
        uint256 amount,
        uint256 share
    ) public allowed(from) returns (uint256 amountOut, uint256 shareOut) {
        // Checks
        require(to != address(0), ""BentoBox: to not set""); // To avoid a bad UI from burning funds

        // Effects
        IERC20 token = token_ == USE_ETHEREUM ? wethToken : token_;
        Rebase memory total = totals[token];
        if (share == 0) {
            // value of the share paid could be lower than the amount paid due to rounding, in that case, add a share (Always round up)
            share = total.toBase(amount, true);
        } else {
            // amount may be lower than the value of share due to rounding, that's ok
            amount = total.toElastic(share, false);
        }

        balanceOf[token][from] = balanceOf[token][from].sub(share);
        total.elastic = total.elastic.sub(amount.to128());
        total.base = total.base.sub(share.to128());
        // There have to be at least 1000 shares left to prevent reseting the share/amount ratio (unless it's fully emptied)
        require(total.base >= MINIMUM_SHARE_BALANCE || total.base == 0, ""BentoBox: cannot empty"");
        totals[token] = total;

        // Interactions
        if (token_ == USE_ETHEREUM) {
            // X2, X3: A revert or big gas usage in the WETH contract could block withdrawals, but WETH9 is fine.
            IWETH(address(wethToken)).withdraw(amount);
            // X2, X3: A revert or big gas usage could block, however, the to address is under control of the caller.
            (bool success, ) = to.call{value: amount}("""");
            require(success, ""BentoBox: ETH transfer failed"");
        } else {
            // X2, X3: A malicious token could block withdrawal of just THAT token.
            //         masterContracts may want to take care not to rely on withdraw always succeeding.
            token.safeTransfer(to, amount);
        }
        emit LogWithdraw(token, from, to, amount, share);
        amountOut = amount;
        shareOut = share;
    }

    /// @notice Transfer shares from a user account to another one.
    /// @param token The ERC-20 token to transfer.
    /// @param from which user to pull the tokens.
    /// @param to which user to push the tokens.
    /// @param share The amount of `token` in shares.
    // Clones of master contracts can transfer from any account that has approved them
    // F3 - Can it be combined with another similar function?
    // F3: This isn't combined with transferMultiple for gas optimization
    function transfer(
        IERC20 token,
        address from,
        address to,
        uint256 share
    ) public allowed(from) {
        // Checks
        require(to != address(0), ""BentoBox: to not set""); // To avoid a bad UI from burning funds

        // Effects
        balanceOf[token][from] = balanceOf[token][from].sub(share);
        balanceOf[token][to] = balanceOf[token][to].add(share);

        emit LogTransfer(token, from, to, share);
    }

    /// @notice Transfer shares from a user account to multiple other ones.
    /// @param token The ERC-20 token to transfer.
    /// @param from which user to pull the tokens.
    /// @param tos The receivers of the tokens.
    /// @param shares The amount of `token` in shares for each receiver in `tos`.
    // F3 - Can it be combined with another similar function?
    // F3: This isn't combined with transfer for gas optimization
    function transferMultiple(
        IERC20 token,
        address from,
        address[] calldata tos,
        uint256[] calldata shares
    ) public allowed(from) {
        // Checks
        require(tos[0] != address(0), ""BentoBox: to[0] not set""); // To avoid a bad UI from burning funds

        // Effects
        uint256 totalAmount;
        uint256 len = tos.length;
        for (uint256 i = 0; i < len; i++) {
            address to = tos[i];
            balanceOf[token][to] = balanceOf[token][to].add(shares[i]);
            totalAmount = totalAmount.add(shares[i]);
            emit LogTransfer(token, from, to, shares[i]);
        }
        balanceOf[token][from] = balanceOf[token][from].sub(totalAmount);
    }

    /// @notice Flashloan ability.
    /// @param borrower The address of the contract that implements and conforms to `IFlashBorrower` and handles the flashloan.
    /// @param receiver Address of the token receiver.
    /// @param token The address of the token to receive.
    /// @param amount of the tokens to receive.
    /// @param data The calldata to pass to the `borrower` contract.
    // F5 - Checks-Effects-Interactions pattern followed? (SWC-107)
    // F5: Not possible to follow this here, reentrancy has been reviewed
    // F6 - Check for front-running possibilities, such as the approve function (SWC-114)
    // F6: Slight grieving possible by withdrawing an amount before someone tries to flashloan close to the full amount.
    function flashLoan(
        IFlashBorrower borrower,
        address receiver,
        IERC20 token,
        uint256 amount,
        bytes calldata data
    ) public {
        uint256 fee = amount.mul(FLASH_LOAN_FEE) / FLASH_LOAN_FEE_PRECISION;
        token.safeTransfer(receiver, amount);

        borrower.onFlashLoan(msg.sender, token, amount, fee, data);

        require(_tokenBalanceOf(token) >= totals[token].addElastic(fee.to128()), ""BentoBox: Wrong amount"");
        emit LogFlashLoan(address(borrower), token, amount, fee, receiver);
    }

    /// @notice Support for batched flashloans. Useful to request multiple different `tokens` in a single transaction.
    /// @param borrower The address of the contract that implements and conforms to `IBatchFlashBorrower` and handles the flashloan.
    /// @param receivers An array of the token receivers. A one-to-one mapping with `tokens` and `amounts`.
    /// @param tokens The addresses of the tokens.
    /// @param amounts of the tokens for each receiver.
    /// @param data The calldata to pass to the `borrower` contract.
    // F5 - Checks-Effects-Interactions pattern followed? (SWC-107)
    // F5: Not possible to follow this here, reentrancy has been reviewed
    // F6 - Check for front-running possibilities, such as the approve function (SWC-114)
    // F6: Slight grieving possible by withdrawing an amount before someone tries to flashloan close to the full amount.
    function batchFlashLoan(
        IBatchFlashBorrower borrower,
        address[] calldata receivers,
        IERC20[] calldata tokens,
        uint256[] calldata amounts,
        bytes calldata data
    ) public {
        uint256[] memory fees = new uint256[](tokens.length);

        uint256 len = tokens.length;
        for (uint256 i = 0; i < len; i++) {
            uint256 amount = amounts[i];
            fees[i] = amount.mul(FLASH_LOAN_FEE) / FLASH_LOAN_FEE_PRECISION;

            tokens[i].safeTransfer(receivers[i], amounts[i]);
        }

        borrower.onBatchFlashLoan(msg.sender, tokens, amounts, fees, data);

        for (uint256 i = 0; i < len; i++) {
            IERC20 token = tokens[i];
            require(_tokenBalanceOf(token) >= totals[token].addElastic(fees[i].to128()), ""BentoBox: Wrong amount"");
            emit LogFlashLoan(address(borrower), token, amounts[i], fees[i], receivers[i]);
        }
    }

    /// @notice Sets the target percentage of the strategy for `token`.
    /// @dev Only the owner of this contract is allowed to change this.
    /// @param token The address of the token that maps to a strategy to change.
    /// @param targetPercentage_ The new target in percent. Must be lesser or equal to `MAX_TARGET_PERCENTAGE`.
    function setStrategyTargetPercentage(IERC20 token, uint64 targetPercentage_) public onlyOwner {
        // Checks
        require(targetPercentage_ <= MAX_TARGET_PERCENTAGE, ""StrategyManager: Target too high"");

        // Effects
        strategyData[token].targetPercentage = targetPercentage_;
        emit LogStrategyTargetPercentage(token, targetPercentage_);
    }

    /// @notice Sets the contract address of a new strategy that conforms to `IStrategy` for `token`.
    /// Must be called twice with the same arguments.
    /// A new strategy becomes pending first and can be activated once `STRATEGY_DELAY` is over.
    /// @dev Only the owner of this contract is allowed to change this.
    /// @param token The address of the token that maps to a strategy to change.
    /// @param newStrategy The address of the contract that conforms to `IStrategy`.
    // F5 - Checks-Effects-Interactions pattern followed? (SWC-107)
    // F5: Total amount is updated AFTER interaction. But strategy is under our control.
    // C4 - Use block.timestamp only for long intervals (SWC-116)
    // C4: block.timestamp is used for a period of 2 weeks, which is long enough
    function setStrategy(IERC20 token, IStrategy newStrategy) public onlyOwner {
        StrategyData memory data = strategyData[token];
        IStrategy pending = pendingStrategy[token];
        if (data.strategyStartDate == 0 || pending != newStrategy) {
            pendingStrategy[token] = newStrategy;
            // C1 - All math done through BoringMath (SWC-101)
            // C1: Our sun will swallow the earth well before this overflows
            data.strategyStartDate = (block.timestamp + STRATEGY_DELAY).to64();
            emit LogStrategyQueued(token, newStrategy);
        } else {
            require(data.strategyStartDate != 0 && block.timestamp >= data.strategyStartDate, ""StrategyManager: Too early"");
            if (address(strategy[token]) != address(0)) {
                int256 balanceChange = strategy[token].exit(data.balance);
                // Effects
                if (balanceChange > 0) {
                    uint256 add = uint256(balanceChange);
                    totals[token].addElastic(add);
                    emit LogStrategyProfit(token, add);
                } else if (balanceChange < 0) {
                    uint256 sub = uint256(-balanceChange);
                    totals[token].subElastic(sub);
                    emit LogStrategyLoss(token, sub);
                }

                emit LogStrategyDivest(token, data.balance);
            }
            strategy[token] = pending;
            data.strategyStartDate = 0;
            data.balance = 0;
            pendingStrategy[token] = IStrategy(0);
            emit LogStrategySet(token, newStrategy);
        }
        strategyData[token] = data;
    }

    /// @notice The actual process of yield farming. Executes the strategy of `token`.
    /// Optionally does housekeeping if `balance` is true.
    /// `maxChangeAmount` is relevant for skimming or withdrawing if `balance` is true.
    /// @param token The address of the token for which a strategy is deployed.
    /// @param balance True if housekeeping should be done.
    /// @param maxChangeAmount The maximum amount for either pulling or pushing from/to the `IStrategy` contract.
    // F5 - Checks-Effects-Interactions pattern followed? (SWC-107)
    // F5: Total amount is updated AFTER interaction. But strategy is under our control.
    // F5: Not followed to prevent reentrancy issues with flashloans and BentoBox skims?
    function harvest(
        IERC20 token,
        bool balance,
        uint256 maxChangeAmount
    ) public {
        StrategyData memory data = strategyData[token];
        IStrategy _strategy = strategy[token];
        int256 balanceChange = _strategy.harvest(data.balance, msg.sender);
        if (balanceChange == 0 && !balance) {
            return;
        }

        uint256 totalElastic = totals[token].elastic;

        if (balanceChange > 0) {
            uint256 add = uint256(balanceChange);
            totalElastic = totalElastic.add(add);
            totals[token].elastic = totalElastic.to128();
            emit LogStrategyProfit(token, add);
        } else if (balanceChange < 0) {
            // C1 - All math done through BoringMath (SWC-101)
            // C1: balanceChange could overflow if it's max negative int128.
            // But tokens with balances that large are not supported by the BentoBox.
            uint256 sub = uint256(-balanceChange);
            totalElastic = totalElastic.sub(sub);
            totals[token].elastic = totalElastic.to128();
            data.balance = data.balance.sub(sub.to128());
            emit LogStrategyLoss(token, sub);
        }

        if (balance) {
            uint256 targetBalance = totalElastic.mul(data.targetPercentage) / 100;
            // if data.balance == targetBalance there is nothing to update
            if (data.balance < targetBalance) {
                uint256 amountOut = targetBalance.sub(data.balance);
                if (maxChangeAmount != 0 && amountOut > maxChangeAmount) {
                    amountOut = maxChangeAmount;
                }
                token.safeTransfer(address(_strategy), amountOut);
                data.balance = data.balance.add(amountOut.to128());
                _strategy.skim(amountOut);
                emit LogStrategyInvest(token, amountOut);
            } else if (data.balance > targetBalance) {
                uint256 amountIn = data.balance.sub(targetBalance.to128());
                if (maxChangeAmount != 0 && amountIn > maxChangeAmount) {
                    amountIn = maxChangeAmount;
                }

                uint256 actualAmountIn = _strategy.withdraw(amountIn);

                data.balance = data.balance.sub(actualAmountIn.to128());
                emit LogStrategyDivest(token, actualAmountIn);
            }
        }

        strategyData[token] = data;
    }

    // Contract should be able to receive ETH deposits to support deposit & skim
    // solhint-disable-next-line no-empty-blocks
    receive() external payable {}
}
"".
Ideas: "" Unchecked Low-level Calls Identified.

```
UNCHECKED LOW-LEVEL CALL
'''
In the `withdraw` function of the `BentoBoxV1` contract, there is a low-level call made to transfer ETH to the `to` address after withdrawing from the WETH contract. The line:
(bool success, ) = to.call{value: amount}("""");
This call does not check if the transfer was successful. If the transfer fails (for example, if the `to` address is a contract that does not accept ETH), the transaction will not revert, and the contract will not handle the failure properly. This could lead to a loss of funds as the user may not receive their withdrawn amount.

Recommended Mitigation:
Replace the low-level call with a safer alternative that checks for success, such as using `require` to ensure the transfer was successful:
require(success, ""BentoBox: ETH transfer failed"");
'''
```

```
UNCHECKED LOW-LEVEL CALL
'''
In the `flashLoan` function, the contract calls the `onFlashLoan` method on the borrower without checking if the call succeeds. The line:
borrower.onFlashLoan(msg.sender, token, amount, fee, data);
If the `onFlashLoan` function in the borrower contract fails, the transaction will not revert, and the contract will not handle the failure properly. This could lead to a situation where the loan is not repaid correctly, potentially resulting in a loss of funds.

Recommended Mitigation:
Wrap the call in a require statement to ensure that the call succeeds:
require(borrower.onFlashLoan(msg.sender, token, amount, fee, data), ""BentoBox: Flash loan callback failed"");
'''
```

```
UNCHECKED LOW-LEVEL CALL
'''
In the `batchFlashLoan` function, similar to the `flashLoan` function, the contract calls the `onBatchFlashLoan` method on the borrower without checking if the call succeeds. The line:
borrower.onBatchFlashLoan(msg.sender, tokens, amounts, fees, data);
Again, if the `onBatchFlashLoan` function in the borrower contract fails, the transaction will not revert, and the contract will not handle the failure properly, leading to potential loss of funds.

Recommended Mitigation:
Wrap the call in a require statement to ensure that the call succeeds:
require(borrower.onBatchFlashLoan(msg.sender, tokens, amounts, fees, data), ""BentoBox: Batch flash loan callback failed"");
'''
```"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Transactions Order Dependence. Transactions Order Dependence vulnerabilities can result in unintended consequences and create opportunities for malicious actors to exploit transaction sequencing.
Please conduct a thorough analysis, considering the following information:
1. Review the contract's code logic to identify any potential areas where the order of transaction execution might have an impact on the contract's behavior.

2. Examine critical functions, particularly those involving fund transfers or resource allocation, to ensure they are not susceptible to Transactions Order Dependence.

3. Investigate scenarios in which gas prices can be manipulated to change the order of transaction execution.

If you identify Transactions Order Dependence, respond with: """,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
